Disassembly Listing for sampler_0.49.2
Generated From:
C:/Users/ryan/Documents/seniorproject/ps-040/dist/default/production/ps-040.production.elf
Jan 30, 2018 3:48:45 PM

---  C:/Users/ryan/Documents/seniorproject/ps-040/utilitites.c  -----------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <libpic30.h>
4:                 #include <dsp.h>
5:                 #include <stdio.h>
6:                 #include <stdlib.h>
7:                 #include <math.h>
8:                 #include "common.h"
9:                 #include "sounds.h"
10:                #include "audio.h"
11:                #include "flash.h"
12:                #include "screens.h"
13:                #include "utilities.h"
14:                #include "devInits.h"
15:                
16:                
17:                //CONTROL VARIABLES//
18:                extern unsigned char pad[BUTTONS];
19:                extern fractional pots[POTS];
20:                extern fractional pots_percent[POTS];
21:                extern unsigned char UART_ON; 
22:                extern enum screen state;
23:                
24:                //STATUS VARIABLES//
25:                extern unsigned char hard_clipped;
26:                extern unsigned char UART_EN;
27:                extern unsigned char TEST_SIN;
28:                extern fractional sampin;
29:                extern fractional sampout;
30:                
31:                //FX FLAGS & VARS
32:                extern unsigned char tremelo, looper, lpf;
33:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
34:                extern unsigned int loop_lim;
35:                extern fractional lpf_alpha, lpf_inv_alpha;
36:                extern fractional tremelo_depth;
37:                extern unsigned char kick_playing, snare_playing;   
38:                
39:                void scanButtons(void){
40:                    
41:                    static unsigned char pad_last[BUTTONS]={1};
42:                    int portrdG, portrdD, portrdF;
43:                
44:                    portrdG = PORTG;
008452  807313     MOV PORTG, W3
45:                    portrdD = PORTD;
008454  807191     MOV PORTD, W1
46:                    portrdF = PORTF;
008456  807292     MOV PORTF, W2
47:                    
48:                    pad[34]=(portrdF>>7)&1;     // Special function button
008458  DE9247     ASR W2, #7, W4
00845A  624261     AND.B W4, #0x1, W4
00845C  268BE5     MOV #0x68BE, W5
00845E  784A84     MOV.B W4, [W5]
49:                    
50:                    if(pad[34]){
008460  320033     BRA Z, 0x84C8
51:                        pad[6]=(portrdF>>6)&1;
008462  DE92C6     ASR W2, #6, W5
008464  268A24     MOV #0x68A2, W4
008466  62CA61     AND.B W5, #0x1, [W4]
52:                        pad[5]=(portrdF>>5)&1;
008468  DE92C5     ASR W2, #5, W5
00846A  E90204     DEC W4, W4
00846C  62CA61     AND.B W5, #0x1, [W4]
53:                        pad[4]=(portrdF>>4)&1;
00846E  DE9144     ASR W2, #4, W2
008470  E90204     DEC W4, W4
008472  614A61     AND.B W2, #0x1, [W4]
54:                        pad[0]=(portrdG)&1;
008474  520164     SUB W4, #0x4, W2
008476  61C961     AND.B W3, #0x1, [W2]
55:                        pad[1]=(portrdG>>1)&1;
008478  D18203     ASR W3, W4
00847A  E80102     INC W2, W2
00847C  624961     AND.B W4, #0x1, [W2]
56:                        pad[2]=(portrdG>>2)&1;
00847E  DE9A42     ASR W3, #2, W4
008480  E80102     INC W2, W2
008482  624961     AND.B W4, #0x1, [W2]
57:                        pad[3]=(portrdG>>3)&1;
008484  DE9A43     ASR W3, #3, W4
008486  E80102     INC W2, W2
008488  624961     AND.B W4, #0x1, [W2]
58:                        pad[16]=(portrdG>>10)&1;    // Encoder button
00848A  DE9A4A     ASR W3, #10, W4
00848C  41016D     ADD W2, #0xD, W2
00848E  624961     AND.B W4, #0x1, [W2]
59:                        pad[11]=(portrdG>>11)&1;
008490  DE9A4B     ASR W3, #11, W4
008492  510165     SUB W2, #0x5, W2
008494  624961     AND.B W4, #0x1, [W2]
60:                        pad[12]=(portrdG>>12)&1;
008496  DE9A4C     ASR W3, #12, W4
008498  E80102     INC W2, W2
00849A  624961     AND.B W4, #0x1, [W2]
61:                        pad[13]=(portrdG>>13)&1;
00849C  DE9A4D     ASR W3, #13, W4
00849E  E80102     INC W2, W2
0084A0  624961     AND.B W4, #0x1, [W2]
62:                        pad[14]=(portrdG>>14)&1;
0084A2  DE984E     ASR W3, #14, W0
0084A4  E80102     INC W2, W2
0084A6  604961     AND.B W0, #0x1, [W2]
63:                        pad[15]=(portrdG>>15)&1;
0084A8  DE19CF     LSR W3, #15, W3
0084AA  E80002     INC W2, W0
0084AC  784803     MOV.B W3, [W0]
64:                        pad[7]=(portrdD>>1)&1;
0084AE  D18101     ASR W1, W2
0084B0  500068     SUB W0, #0x8, W0
0084B2  614861     AND.B W2, #0x1, [W0]
65:                        pad[8]=(portrdD>>2)&1;
0084B4  DE8942     ASR W1, #2, W2
0084B6  E80000     INC W0, W0
0084B8  614861     AND.B W2, #0x1, [W0]
66:                        pad[9]=(portrdD>>3)&1;
0084BA  DE8943     ASR W1, #3, W2
0084BC  E80000     INC W0, W0
0084BE  614861     AND.B W2, #0x1, [W0]
67:                        pad[10]=(portrdD>>4)&1;
0084C0  DE88C4     ASR W1, #4, W1
0084C2  E80000     INC W0, W0
0084C4  60C861     AND.B W1, #0x1, [W0]
0084C6  370032     BRA 0x852C
68:                    } else {
69:                        pad[23]=(portrdF>>6)&1;
0084C8  DE92C6     ASR W2, #6, W5
0084CA  268B34     MOV #0x68B3, W4
0084CC  62CA61     AND.B W5, #0x1, [W4]
70:                        pad[22]=(portrdF>>5)&1;
0084CE  DE92C5     ASR W2, #5, W5
0084D0  E90204     DEC W4, W4
0084D2  62CA61     AND.B W5, #0x1, [W4]
71:                        pad[21]=(portrdF>>4)&1;
0084D4  DE9144     ASR W2, #4, W2
0084D6  E90204     DEC W4, W4
0084D8  614A61     AND.B W2, #0x1, [W4]
72:                        pad[17]=(portrdG)&1;
0084DA  520164     SUB W4, #0x4, W2
0084DC  61C961     AND.B W3, #0x1, [W2]
73:                        pad[18]=(portrdG>>1)&1;
0084DE  D18203     ASR W3, W4
0084E0  E80102     INC W2, W2
0084E2  624961     AND.B W4, #0x1, [W2]
74:                        pad[19]=(portrdG>>2)&1;
0084E4  DE9A42     ASR W3, #2, W4
0084E6  E80102     INC W2, W2
0084E8  624961     AND.B W4, #0x1, [W2]
75:                        pad[20]=(portrdG>>3)&1;
0084EA  DE9A43     ASR W3, #3, W4
0084EC  E80102     INC W2, W2
0084EE  624961     AND.B W4, #0x1, [W2]
76:                        pad[33]=(portrdG>>10)&1;    // Encoder button
0084F0  DE9A4A     ASR W3, #10, W4
0084F2  41016D     ADD W2, #0xD, W2
0084F4  624961     AND.B W4, #0x1, [W2]
77:                        pad[28]=(portrdG>>11)&1;
0084F6  DE9A4B     ASR W3, #11, W4
0084F8  510165     SUB W2, #0x5, W2
0084FA  624961     AND.B W4, #0x1, [W2]
78:                        pad[29]=(portrdG>>12)&1;
0084FC  DE9A4C     ASR W3, #12, W4
0084FE  E80102     INC W2, W2
008500  624961     AND.B W4, #0x1, [W2]
79:                        pad[30]=(portrdG>>13)&1;
008502  DE9A4D     ASR W3, #13, W4
008504  E80102     INC W2, W2
008506  624961     AND.B W4, #0x1, [W2]
80:                        pad[31]=(portrdG>>14)&1;
008508  DE984E     ASR W3, #14, W0
00850A  E80102     INC W2, W2
00850C  604961     AND.B W0, #0x1, [W2]
81:                        pad[32]=(portrdG>>15)&1;
00850E  DE19CF     LSR W3, #15, W3
008510  E80002     INC W2, W0
008512  784803     MOV.B W3, [W0]
82:                        pad[24]=(portrdD>>1)&1;
008514  D18101     ASR W1, W2
008516  500068     SUB W0, #0x8, W0
008518  614861     AND.B W2, #0x1, [W0]
83:                        pad[25]=(portrdD>>2)&1;
00851A  DE8942     ASR W1, #2, W2
00851C  E80000     INC W0, W0
00851E  614861     AND.B W2, #0x1, [W0]
84:                        pad[26]=(portrdD>>3)&1;
008520  DE8943     ASR W1, #3, W2
008522  E80000     INC W0, W0
008524  614861     AND.B W2, #0x1, [W0]
85:                        pad[27]=(portrdD>>4)&1;
008526  DE88C4     ASR W1, #4, W1
008528  E80000     INC W0, W0
00852A  60C861     AND.B W1, #0x1, [W0]
86:                    }
87:                
88:                   
89:                    
90:                    if(pad[13]==0&&pad_last[13]==1){                                              //TREMELO CONTROL
00852C  268A90     MOV #0x68A9, W0
00852E  784010     MOV.B [W0], W0
008530  E00400     CP0.B W0
008532  3A000C     BRA NZ, 0x854C
008534  26D571     MOV #0x6D57, W1
008536  B3C012     MOV.B #0x1, W2
008538  114F91     SUBR.B W2, [W1], [W15]
00853A  3A0008     BRA NZ, 0x854C
91:                        pad_last[13]=0;
00853C  780001     MOV W1, W0
00853E  EB4800     CLR.B [W0]
92:                        if(tremelo==FALSE)
008540  E2501B     CP0.B tremelo
008542  3A0002     BRA NZ, 0x8548
93:                            tremelo=TRUE;
008544  EFF01B     SETM.B tremelo
008546  370004     BRA 0x8550
94:                        else tremelo=FALSE;
008548  EF701B     CLR.B tremelo
00854A  370002     BRA 0x8550
95:                    }
96:                    else{
97:                        pad_last[13]=pad[13];
00854C  26D571     MOV #0x6D57, W1
00854E  784880     MOV.B W0, [W1]
98:                    }
99:                    
100:                   if(pad[14]==0) looper=TRUE;
008550  268AA0     MOV #0x68AA, W0
008552  E00410     CP0.B [W0]
008554  3A0002     BRA NZ, 0x855A
008556  EFF01C     SETM.B looper
008558  370001     BRA 0x855C
101:                   else looper=FALSE;
00855A  EF701C     CLR.B looper
102:                  
103:                   if(pad[15]==0&&pad_last[15]==1){                                              //LPF CONTROL
00855C  268AB0     MOV #0x68AB, W0
00855E  784010     MOV.B [W0], W0
008560  E00400     CP0.B W0
008562  3A000C     BRA NZ, 0x857C
008564  26D591     MOV #0x6D59, W1
008566  B3C012     MOV.B #0x1, W2
008568  114F91     SUBR.B W2, [W1], [W15]
00856A  3A0008     BRA NZ, 0x857C
104:                       pad_last[15]=0;
00856C  780001     MOV W1, W0
00856E  EB4800     CLR.B [W0]
105:                       if(lpf==FALSE)
008570  E2501D     CP0.B lpf
008572  3A0002     BRA NZ, 0x8578
106:                           lpf=TRUE;
008574  EFF01D     SETM.B lpf
008576  370004     BRA 0x8580
107:                       else lpf=FALSE;
008578  EF701D     CLR.B lpf
00857A  370002     BRA 0x8580
108:                   }
109:                   else{
110:                       pad_last[15]=pad[15];
00857C  26D591     MOV #0x6D59, W1
00857E  784880     MOV.B W0, [W1]
111:                   }
112:                   
113:                   
114:                   // SAMPLE TRIGGERS 
115:                   if(pad[0]==0&&kick_playing==FALSE){                                         //kick
008580  2689C0     MOV #0x689C, W0
008582  E00410     CP0.B [W0]
008584  3A0003     BRA NZ, 0x858C
008586  E2502E     CP0.B kick_playing
008588  3A0001     BRA NZ, 0x858C
116:                       kick_playing=TRUE;
00858A  EFF02E     SETM.B kick_playing
117:                   }
118:                   /*
119:                   if(pad[2]==0&&hat_playing==FALSE){                                          //hat
120:                       hat_playing=TRUE;
121:                   }
122:                   */
123:                   if(pad[1]==0&&snare_playing==FALSE){                                        //snare
00858C  2689D0     MOV #0x689D, W0
00858E  E00410     CP0.B [W0]
008590  3A0003     BRA NZ, 0x8598
008592  E25032     CP0.B snare_playing
008594  3A0001     BRA NZ, 0x8598
124:                       snare_playing=TRUE;
008596  EFF032     SETM.B snare_playing
125:                   }
126:               }
008598  060000     RETURN
127:               
128:               void readPots(void){
00859A  F80022     PUSH ACCA
00859C  F80024     PUSH ACCAH
00859E  F80026     PUSH ACCAU
00860C  408166     ADD W1, #0x6, W2
00860E  410102     ADD W2, W2, W2
008610  26DAA0     MOV #0x6DAA, W0
008612  410100     ADD W2, W0, W2
008616  408081     ADD W1, W1, W1
008618  2606C0     MOV #0x606C, W0
00861A  408080     ADD W1, W0, W1
129:                   volatile register int result asm("A");
130:                   static fractional pots_buf[POTS/2];
131:                   const fractional pot_alpha = 0x0F00;    //larger = rougher, lower = more latency
132:                   const fractional pot_alpha_inv = 32767-pot_alpha;
133:                   int i;
134:                   _AD1IF = 0; // Clear conversion done status bit
0085A0  A9A801     BCLR 0x801, #5
135:                   if(pad[34])i=0;
0085A4  268BE0     MOV #0x68BE, W0
0085A6  E00410     CP0.B [W0]
0085A8  320001     BRA Z, 0x85AC
0085AA  EB0080     CLR W1
136:                   else i=POTS/2;
0085A2  200061     MOV #0x6, W1
137:                   pots_buf[i++]=(ADC1BUF5>>1)|0x7;
0085AC  26DAA0     MOV #0x6DAA, W0
0085AE  408101     ADD W1, W1, W2
0085B0  400102     ADD W0, W2, W2
0085B2  801853     MOV ADC1BUF5, W3
0085B4  D10183     LSR W3, W3
0085B6  718967     IOR W3, #0x7, [W2]
0085B8  E80101     INC W1, W2
138:                   pots_buf[i++]=(ADC1BUF2>>1)|0x7;
0085BA  410182     ADD W2, W2, W3
0085BC  400183     ADD W0, W3, W3
0085BE  801824     MOV ADC1BUF2, W4
0085C0  D10204     LSR W4, W4
0085C2  7209E7     IOR W4, #0x7, [W3]
0085C4  E80102     INC W2, W2
139:                   pots_buf[i++]=(ADC1BUF4>>1)|0x7;
0085C6  410182     ADD W2, W2, W3
0085C8  400183     ADD W0, W3, W3
0085CA  801844     MOV ADC1BUF4, W4
0085CC  D10204     LSR W4, W4
0085CE  7209E7     IOR W4, #0x7, [W3]
0085D0  E80102     INC W2, W2
140:                   pots_buf[i++]=(ADC1BUF1>>1)|0x7;
0085D2  410182     ADD W2, W2, W3
0085D4  400183     ADD W0, W3, W3
0085D6  801814     MOV ADC1BUF1, W4
0085D8  D10204     LSR W4, W4
0085DA  7209E7     IOR W4, #0x7, [W3]
0085DC  E80102     INC W2, W2
141:                   pots_buf[i++]=(ADC1BUF3>>1)|0x7;
0085DE  410182     ADD W2, W2, W3
0085E0  400183     ADD W0, W3, W3
0085E2  801834     MOV ADC1BUF3, W4
0085E4  D10204     LSR W4, W4
0085E6  7209E7     IOR W4, #0x7, [W3]
142:                   pots_buf[i]=(ADC1BUF0>>1)|0x7;
0085E8  E80102     INC W2, W2
0085EA  410102     ADD W2, W2, W2
0085EC  400002     ADD W0, W2, W0
0085EE  801802     MOV ADC1BUF0, W2
0085F0  D10102     LSR W2, W2
0085F2  710867     IOR W2, #0x7, [W0]
143:               
144:                   
145:                   loop_lim=pots[5];               //LOOPER CONTROL
0085F4  8303B0     MOV 0x6076, W0
0085F6  888010     MOV W0, loop_lim
146:                   if(pots[0]>=310){                      //LPF CONTROL
0085F8  830360     MOV pots, W0
0085FA  201352     MOV #0x135, W2
0085FC  500F82     SUB W0, W2, [W15]
0085FE  340004     BRA LE, 0x8608
147:                       lpf_alpha=pots[0];
008600  888200     MOV W0, ___divsi3
148:                       lpf_inv_alpha=(32767-lpf_alpha); 
008602  27FFF2     MOV #0x7FFF, W2
008604  510000     SUB W2, W0, W0
008606  888210     MOV W0, 0x1042
149:                   }
150:                   tremelo_depth=pots[1];
008608  830370     MOV 0x606E, W0
00860A  888220     MOV W0, 0x1044
151:                   
152:                       
153:                  
154:                   int j=6;
155:                   while(j-->0){
00861C  200050     MOV #0x5, W0
00862C  E90000     DEC W0, W0
00862E  400FE1     ADD W0, #0x1, [W15]
008630  3AFFF8     BRA NZ, 0x8622
156:                        result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
00861E  20F006     MOV #0xF00, W6
008622  780242     MOV [--W2], W4
008624  C10113     MPY W4*W6, A
157:                       result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008614  4080E5     ADD W1, #0x5, W1
008620  270FF5     MOV #0x70FF, W5
008626  780211     MOV [W1], W4
008628  C00112     MAC W4*W5, A
158:                       pots[i--]=__builtin_sac(result, 0);
00862A  CC0021     SAC A, [W1--]
159:                   }
160:               
161:                   
162:               }
008632  F90026     POP ACCAU
008634  F90024     POP ACCAH
008636  F90022     POP ACCA
008638  060000     RETURN
163:               
164:               void scalePotsPercent(void){
00863A  F80022     PUSH ACCA
00863C  F80024     PUSH ACCAH
00863E  F80026     PUSH ACCAU
165:                   /* Potentiometer scaling for fx or lcd display */
166:                   volatile register int scaled asm("A");
167:                   scaled=__builtin_mpy(pots[0],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008640  232644     MOV #0x3264, W4
008642  830365     MOV pots, W5
008644  C00113     MPY W4*W5, A
168:                   pots_percent[0]=__builtin_sac(scaled, 7);
008646  260840     MOV #0x6084, W0
008648  CC0390     SAC A, #7, [W0]
169:                   scaled=__builtin_mpy(pots[1],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
00864A  830375     MOV 0x606E, W5
00864C  C00113     MPY W4*W5, A
170:                   pots_percent[1]=__builtin_sac(scaled, 7);
00864E  E88000     INC2 W0, W0
008650  CC0390     SAC A, #7, [W0]
171:                   scaled=__builtin_mpy(pots[2],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008652  830385     MOV 0x6070, W5
008654  C00113     MPY W4*W5, A
172:                   pots_percent[2]=__builtin_sac(scaled, 7);
008656  E88000     INC2 W0, W0
008658  CC0390     SAC A, #7, [W0]
173:                   scaled=__builtin_mpy(pots[3],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
00865A  830395     MOV 0x6072, W5
00865C  C00113     MPY W4*W5, A
174:                   pots_percent[3]=__builtin_sac(scaled, 7);
00865E  E88000     INC2 W0, W0
008660  CC0390     SAC A, #7, [W0]
175:                   scaled=__builtin_mpy(pots[4],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008662  8303A5     MOV 0x6074, W5
008664  C00113     MPY W4*W5, A
176:                   pots_percent[4]=__builtin_sac(scaled, 7);
008666  E88000     INC2 W0, W0
008668  CC0390     SAC A, #7, [W0]
177:                   scaled=__builtin_mpy(pots[5],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
00866A  8303B5     MOV 0x6076, W5
00866C  C00113     MPY W4*W5, A
178:                   pots_percent[5]=__builtin_sac(scaled, 7);
00866E  E88000     INC2 W0, W0
008670  CC0390     SAC A, #7, [W0]
179:               }
008672  F90026     POP ACCAU
008674  F90024     POP ACCAH
008676  F90022     POP ACCA
008678  060000     RETURN
180:               
181:               void display(void){
182:                   scalePotsPercent();
00867A  07FFDF     RCALL scalePotsPercent
183:                   
184:                   // Update ui state logic here
185:                   state = (ENCODERCNTL/4)+1;
00867C  800E30     MOV POS1CNTL, W0
00867E  DE0042     LSR W0, #2, W0
008680  E80000     INC W0, W0
008682  8881F0     MOV W0, 0x103E
186:                   
187:                   // Update screen here
188:                   screenUpdate();
008684  07FECC     RCALL screenUpdate
189:                  
190:                  if(UART_ON==TRUE){
008686  BFD019     MOV.B UART_ON, WREG
008688  404FE1     ADD.B W0, #0x1, [W15]
00868A  3A0007     BRA NZ, 0x869A
191:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
192:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
193:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
194:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
00868C  F86070     PUSH 0x6070
00868E  F8606E     PUSH 0x606E
008690  F8606C     PUSH pots
008692  2F74C0     MOV #0xF74C, W0
008694  781F80     MOV W0, [W15++]
008696  07BF14     RCALL __printf_cdnopuxX
008698  5787E8     SUB W15, #0x8, W15
195:                       //printf("%d\r\n", sample);  //check input ADC
196:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
197:                   }
198:                  
199:                  SLED=~SLED;
00869A  8072A0     MOV LATF, W0
00869C  EA8000     COM W0, W0
00869E  600061     AND W0, #0x1, W0
0086A0  8072A1     MOV LATF, W1
0086A2  A10001     BCLR W1, #0
0086A4  700081     IOR W0, W1, W1
0086A6  8872A1     MOV W1, LATF
200:               }
0086A8  060000     RETURN
201:               
202:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
203:                   /* This procedure loops back the received data to the*/
204:                   /* the codec output. The user application could process*/
205:                   /* this data as per application requirements.*/
206:                   int index;
207:                   for(index = 0;index < STREAMBUF;index ++)
0086AA  EB0100     CLR W2
0086AC  201003     MOV #0x100, W3
0086B0  E80102     INC W2, W2
0086B2  510F83     SUB W2, W3, [W15]
0086B4  3AFFFC     BRA NZ, 0x86AE
208:                   {
209:                       targetBuffer[index] = sourceBuffer[index];
0086AE  7818B0     MOV [W0++], [W1++]
210:                   }
211:               }
0086B6  060000     RETURN
212:               
213:               //A blocking delay function. Not very accurate but good enough.
214:               void Delay_us(unsigned int delay)
215:               {
216:                   int i;
217:                   for (i = 0; i < delay; i++)
0086B8  E00000     CP0 W0
0086BA  320006     BRA Z, 0x86C8
0086BC  EB0080     CLR W1
0086C2  E80081     INC W1, W1
0086C4  500F81     SUB W0, W1, [W15]
0086C6  3EFFFB     BRA GTU, 0x86BE
218:                   {
219:                       __asm__ volatile ("repeat #50");
0086BE  090032     REPEAT #0x32
220:                       __asm__ volatile ("nop");
0086C0  000000     NOP
221:                   }
222:               }
0086C8  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/screens.c  --------------------------------------------
1:                 /*
2:                  * File:   screens.c
3:                  * Author: ryan
4:                  *
5:                  * Created on January 28, 2018, 11:17 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "common.h"
11:                #include "plcd.h"
12:                #include "dsp.h"
13:                #include "flash.h"
14:                
15:                extern unsigned char TEST_SIN;
16:                extern fractional pots[POTS];
17:                extern fractional pots_percent[POTS];
18:                extern unsigned char pad[BUTTONS];
19:                extern enum screen state, laststate;
20:                extern char flash_readback[512];
21:                extern unsigned int process_time;
22:                
23:                
24:                void screenDebugAudio(){
25:                
26:                }
008184  060000     RETURN
27:                
28:                void screenDebugBuffers(){
29:                    if(state!=laststate){
008186  8080F0     MOV laststate, W0
008188  E3103E     CP 0x103E
00818A  32001B     BRA Z, 0x81C2
30:                        //setup here
31:                        lcdClearQ();
00818C  07FB01     RCALL lcdClearQ
32:                        lcdSetCursorQ(0,0);
00818E  EB4080     CLR.B W1
008190  784001     MOV.B W1, W0
008192  07FB09     RCALL lcdSetCursorQ
33:                        lcdWriteStringQ("Buffer Debug");
008194  2F6D20     MOV #0xF6D2, W0
008196  07FB1B     RCALL lcdWriteStringQ
34:                        lcdSetCursorQ(0,1);
008198  B3C011     MOV.B #0x1, W1
00819A  EB4000     CLR.B W0
00819C  07FB04     RCALL lcdSetCursorQ
35:                        lcdWriteStringQ("FX time:");
00819E  2F6DF0     MOV #0xF6DF, W0
0081A0  07FB16     RCALL lcdWriteStringQ
36:                        lcdSetCursorQ(11,1);
0081A2  B3C011     MOV.B #0x1, W1
0081A4  B3C0B0     MOV.B #0xB, W0
0081A6  07FAFF     RCALL lcdSetCursorQ
37:                        lcdWriteStringQ("/256");
0081A8  2F6E80     MOV #0xF6E8, W0
0081AA  07FB11     RCALL lcdWriteStringQ
38:                        lcdSetCursorQ(0,2);
0081AC  B3C021     MOV.B #0x2, W1
0081AE  EB4000     CLR.B W0
0081B0  07FAFA     RCALL lcdSetCursorQ
39:                        lcdWriteStringQ("LCD:");
0081B2  2F6ED0     MOV #0xF6ED, W0
0081B4  07FB0C     RCALL lcdWriteStringQ
40:                        lcdSetCursorQ(0,3);
0081B6  B3C031     MOV.B #0x3, W1
0081B8  EB4000     CLR.B W0
0081BA  07FAF5     RCALL lcdSetCursorQ
41:                        lcdWriteStringQ("Flash:");
0081BC  2F6F20     MOV #0xF6F2, W0
0081BE  07FB07     RCALL lcdWriteStringQ
0081C0  370006     BRA 0x81CE
42:                    } else {
43:                        //update here
44:                        lcdSetCursorQ(8,1);
0081C2  B3C011     MOV.B #0x1, W1
0081C4  B3C080     MOV.B #0x8, W0
0081C6  07FAEF     RCALL lcdSetCursorQ
45:                        lcdWriteDecimalQ(process_time,3);
0081C8  200031     MOV #0x3, W1
0081CA  BFD016     MOV.B process_time, WREG
0081CC  07FBE6     RCALL lcdWriteDecimalQ
46:                        //lcdSetCursorQ(4,2);
47:                        //lcdWriteDecimalQ();
48:                        //lcdSetCursorQ(6,3);
49:                        //lcdWriteDecimalQ();
50:                        
51:                    }
52:                }
0081CE  060000     RETURN
53:                
54:                void screenDebugPots(void){
0081D0  BE9F88     MOV.D W8, [W15++]
0081D2  BE9F8A     MOV.D W10, [W15++]
55:                    int bank=0;
00820E  EB0480     CLR W9
56:                    
57:                    if(state!=laststate){
0081D4  8080F0     MOV laststate, W0
0081D6  E3103E     CP 0x103E
0081D8  320016     BRA Z, 0x8206
58:                        // Setup here
59:                        lcdClearQ();
0081DA  07FADA     RCALL lcdClearQ
60:                        lcdSetCursorQ(0,0);
0081DC  EB4080     CLR.B W1
0081DE  784001     MOV.B W1, W0
0081E0  07FAE2     RCALL lcdSetCursorQ
61:                        lcdWriteStringQ("Potentiometer Debug");
0081E2  2F6F90     MOV #0xF6F9, W0
0081E4  07FAF4     RCALL lcdWriteStringQ
62:                        lcdSetCursorQ(9,1);
0081E6  B3C011     MOV.B #0x1, W1
0081E8  B3C090     MOV.B #0x9, W0
0081EA  07FADD     RCALL lcdSetCursorQ
63:                        lcdWriteStringQ("|");
0081EC  2F70D0     MOV #0xF70D, W0
0081EE  07FAEF     RCALL lcdWriteStringQ
64:                         lcdSetCursorQ(9,2);
0081F0  B3C021     MOV.B #0x2, W1
0081F2  B3C090     MOV.B #0x9, W0
0081F4  07FAD8     RCALL lcdSetCursorQ
65:                        lcdWriteStringQ("|");
0081F6  2F70D0     MOV #0xF70D, W0
0081F8  07FAEA     RCALL lcdWriteStringQ
66:                         lcdSetCursorQ(9,3);
0081FA  B3C031     MOV.B #0x3, W1
0081FC  B3C090     MOV.B #0x9, W0
0081FE  07FAD3     RCALL lcdSetCursorQ
67:                        lcdWriteStringQ("|");
008200  2F70D0     MOV #0xF70D, W0
008202  07FAE5     RCALL lcdWriteStringQ
008204  37005A     BRA 0x82BA
68:                    } else {
69:                        // Update here
70:                        if(!pad[34])bank=POTS/2;
008206  200069     MOV #0x6, W9
008208  268BE0     MOV #0x68BE, W0
00820A  E00410     CP0.B [W0]
00820C  320001     BRA Z, 0x8210
71:                        lcdSetCursorQ(0,1);
008210  B3C011     MOV.B #0x1, W1
008212  EB4000     CLR.B W0
008214  07FAC8     RCALL lcdSetCursorQ
72:                        lcdWriteDecimalQ(pots_percent[bank], 3);
008216  448589     ADD W9, W9, W11
008218  260848     MOV #0x6084, W8
00821A  44000B     ADD W8, W11, W0
00821C  780010     MOV [W0], W0
00821E  200031     MOV #0x3, W1
008220  07FBBC     RCALL lcdWriteDecimalQ
73:                        lcdWriteQ(',');
008222  B3C2C0     MOV.B #0x2C, W0
008224  07FAA0     RCALL lcdWriteQ
74:                        lcdWriteWordUnsignedQ(pots[bank++]);
008226  E80509     INC W9, W10
008228  2606C9     MOV #0x606C, W9
00822A  44858B     ADD W9, W11, W11
00822C  78001B     MOV [W11], W0
00822E  07FB5D     RCALL lcdWriteWordUnsignedQ
75:                        lcdSetCursorQ(11,1);
008230  B3C011     MOV.B #0x1, W1
008232  B3C0B0     MOV.B #0xB, W0
008234  07FAB8     RCALL lcdSetCursorQ
76:                        lcdWriteDecimalQ(pots_percent[bank], 3);
008236  45058A     ADD W10, W10, W11
008238  44000B     ADD W8, W11, W0
00823A  780010     MOV [W0], W0
00823C  200031     MOV #0x3, W1
00823E  07FBAD     RCALL lcdWriteDecimalQ
77:                        lcdWriteQ(',');
008240  B3C2C0     MOV.B #0x2C, W0
008242  07FA91     RCALL lcdWriteQ
78:                        lcdWriteWordUnsignedQ(pots[bank++]);
008244  E8050A     INC W10, W10
008246  44858B     ADD W9, W11, W11
008248  78001B     MOV [W11], W0
00824A  07FB4F     RCALL lcdWriteWordUnsignedQ
79:                        lcdSetCursorQ(0,2);
00824C  B3C021     MOV.B #0x2, W1
00824E  EB4000     CLR.B W0
008250  07FAAA     RCALL lcdSetCursorQ
80:                        lcdWriteDecimalQ(pots_percent[bank], 3);
008252  45058A     ADD W10, W10, W11
008254  44000B     ADD W8, W11, W0
008256  780010     MOV [W0], W0
008258  200031     MOV #0x3, W1
00825A  07FB9F     RCALL lcdWriteDecimalQ
81:                        lcdWriteQ(',');
00825C  B3C2C0     MOV.B #0x2C, W0
00825E  07FA83     RCALL lcdWriteQ
82:                        lcdWriteWordUnsignedQ(pots[bank++]);
008260  E8050A     INC W10, W10
008262  44858B     ADD W9, W11, W11
008264  78001B     MOV [W11], W0
008266  07FB41     RCALL lcdWriteWordUnsignedQ
83:                        lcdSetCursorQ(11,2);
008268  B3C021     MOV.B #0x2, W1
00826A  B3C0B0     MOV.B #0xB, W0
00826C  07FA9C     RCALL lcdSetCursorQ
84:                        lcdWriteDecimalQ(pots_percent[bank], 3);
00826E  45058A     ADD W10, W10, W11
008270  44000B     ADD W8, W11, W0
008272  780010     MOV [W0], W0
008274  200031     MOV #0x3, W1
008276  07FB91     RCALL lcdWriteDecimalQ
85:                        lcdWriteQ(',');
008278  B3C2C0     MOV.B #0x2C, W0
00827A  07FA75     RCALL lcdWriteQ
86:                        lcdWriteWordUnsignedQ(pots[bank++]);
00827C  E8050A     INC W10, W10
00827E  44858B     ADD W9, W11, W11
008280  78001B     MOV [W11], W0
008282  07FB33     RCALL lcdWriteWordUnsignedQ
87:                        lcdSetCursorQ(0,3);
008284  B3C031     MOV.B #0x3, W1
008286  EB4000     CLR.B W0
008288  07FA8E     RCALL lcdSetCursorQ
88:                        lcdWriteDecimalQ(pots_percent[bank], 3);
00828A  45058A     ADD W10, W10, W11
00828C  44000B     ADD W8, W11, W0
00828E  780010     MOV [W0], W0
008290  200031     MOV #0x3, W1
008292  07FB83     RCALL lcdWriteDecimalQ
89:                        lcdWriteQ(',');
008294  B3C2C0     MOV.B #0x2C, W0
008296  07FA67     RCALL lcdWriteQ
90:                        lcdWriteWordUnsignedQ(pots[bank++]);
008298  E8050A     INC W10, W10
00829A  44858B     ADD W9, W11, W11
00829C  78001B     MOV [W11], W0
00829E  07FB25     RCALL lcdWriteWordUnsignedQ
91:                        lcdSetCursorQ(11,3);
0082A0  B3C031     MOV.B #0x3, W1
0082A2  B3C0B0     MOV.B #0xB, W0
0082A4  07FA80     RCALL lcdSetCursorQ
92:                        lcdWriteDecimalQ(pots_percent[bank], 3);
0082A6  45050A     ADD W10, W10, W10
0082A8  44040A     ADD W8, W10, W8
0082AA  780018     MOV [W8], W0
0082AC  200031     MOV #0x3, W1
0082AE  07FB75     RCALL lcdWriteDecimalQ
93:                        lcdWriteQ(',');
0082B0  B3C2C0     MOV.B #0x2C, W0
0082B2  07FA59     RCALL lcdWriteQ
94:                        lcdWriteWordUnsignedQ(pots[bank++]);
0082B4  44850A     ADD W9, W10, W10
0082B6  78001A     MOV [W10], W0
0082B8  07FB18     RCALL lcdWriteWordUnsignedQ
95:                    }
96:                }
0082BA  BE054F     MOV.D [--W15], W10
0082BC  BE044F     MOV.D [--W15], W8
0082BE  060000     RETURN
97:                
98:                void screenFX(void){
99:                    if(state!=laststate){
0082C0  8080F0     MOV laststate, W0
0082C2  E3103E     CP 0x103E
0082C4  32002A     BRA Z, 0x831A
100:                       //setup here
101:                       lcdClearQ();
0082C6  07FA64     RCALL lcdClearQ
102:                       lcdSetCursorQ(0,0);
0082C8  EB4080     CLR.B W1
0082CA  784001     MOV.B W1, W0
0082CC  07FA6C     RCALL lcdSetCursorQ
103:                       lcdWriteStringQ("FX1:");
0082CE  2F70F0     MOV #0xF70F, W0
0082D0  07FA7E     RCALL lcdWriteStringQ
104:                       lcdSetCursorQ(10,0);
0082D2  EB4080     CLR.B W1
0082D4  B3C0A0     MOV.B #0xA, W0
0082D6  07FA67     RCALL lcdSetCursorQ
105:                       lcdWriteStringQ("FX2:");
0082D8  2F7140     MOV #0xF714, W0
0082DA  07FA79     RCALL lcdWriteStringQ
106:                       
107:                       lcdSetCursorQ(0,1);
0082DC  B3C011     MOV.B #0x1, W1
0082DE  EB4000     CLR.B W0
0082E0  07FA62     RCALL lcdSetCursorQ
108:                       lcdWriteStringQ("1:");
0082E2  2F7190     MOV #0xF719, W0
0082E4  07FA74     RCALL lcdWriteStringQ
109:                       lcdSetCursorQ(10,1);
0082E6  B3C011     MOV.B #0x1, W1
0082E8  B3C0A0     MOV.B #0xA, W0
0082EA  07FA5D     RCALL lcdSetCursorQ
110:                       lcdWriteStringQ("4:");
0082EC  2F71C0     MOV #0xF71C, W0
0082EE  07FA6F     RCALL lcdWriteStringQ
111:                       lcdSetCursorQ(0,2);
0082F0  B3C021     MOV.B #0x2, W1
0082F2  EB4000     CLR.B W0
0082F4  07FA58     RCALL lcdSetCursorQ
112:                       lcdWriteStringQ("2:");
0082F6  2F71F0     MOV #0xF71F, W0
0082F8  07FA6A     RCALL lcdWriteStringQ
113:                       lcdSetCursorQ(10,2);
0082FA  B3C021     MOV.B #0x2, W1
0082FC  B3C0A0     MOV.B #0xA, W0
0082FE  07FA53     RCALL lcdSetCursorQ
114:                       lcdWriteStringQ("5:");
008300  2F7220     MOV #0xF722, W0
008302  07FA65     RCALL lcdWriteStringQ
115:                       lcdSetCursorQ(0,3);
008304  B3C031     MOV.B #0x3, W1
008306  EB4000     CLR.B W0
008308  07FA4E     RCALL lcdSetCursorQ
116:                       lcdWriteStringQ("3:");
00830A  2F7250     MOV #0xF725, W0
00830C  07FA60     RCALL lcdWriteStringQ
117:                       lcdSetCursorQ(10,3);
00830E  B3C031     MOV.B #0x3, W1
008310  B3C0A0     MOV.B #0xA, W0
008312  07FA49     RCALL lcdSetCursorQ
118:                       lcdWriteStringQ("6:");
008314  2F7280     MOV #0xF728, W0
008316  07FA5B     RCALL lcdWriteStringQ
008318  370024     BRA 0x8362
119:                   } else {
120:                       //update here
121:                       lcdSetCursorQ(2,1);
00831A  B3C011     MOV.B #0x1, W1
00831C  B3C020     MOV.B #0x2, W0
00831E  07FA43     RCALL lcdSetCursorQ
122:                       lcdWriteDecimalQ(pots_percent[0], 3);
008320  200031     MOV #0x3, W1
008322  830420     MOV pots_percent, W0
008324  07FB3A     RCALL lcdWriteDecimalQ
123:                       lcdSetCursorQ(12,1);
008326  B3C011     MOV.B #0x1, W1
008328  B3C0C0     MOV.B #0xC, W0
00832A  07FA3D     RCALL lcdSetCursorQ
124:                       lcdWriteDecimalQ(pots_percent[1], 3);
00832C  200031     MOV #0x3, W1
00832E  830430     MOV 0x6086, W0
008330  07FB34     RCALL lcdWriteDecimalQ
125:                       lcdSetCursorQ(2,2);
008332  B3C021     MOV.B #0x2, W1
008334  784001     MOV.B W1, W0
008336  07FA37     RCALL lcdSetCursorQ
126:                       lcdWriteDecimalQ(pots_percent[2], 3);
008338  200031     MOV #0x3, W1
00833A  830440     MOV 0x6088, W0
00833C  07FB2E     RCALL lcdWriteDecimalQ
127:                       lcdSetCursorQ(12,2);
00833E  B3C021     MOV.B #0x2, W1
008340  B3C0C0     MOV.B #0xC, W0
008342  07FA31     RCALL lcdSetCursorQ
128:                       lcdWriteDecimalQ(pots_percent[3], 3);
008344  200031     MOV #0x3, W1
008346  830450     MOV 0x608A, W0
008348  07FB28     RCALL lcdWriteDecimalQ
129:                       lcdSetCursorQ(2,3);
00834A  B3C031     MOV.B #0x3, W1
00834C  B3C020     MOV.B #0x2, W0
00834E  07FA2B     RCALL lcdSetCursorQ
130:                       lcdWriteDecimalQ(pots_percent[4], 3);
008350  200031     MOV #0x3, W1
008352  830460     MOV 0x608C, W0
008354  07FB22     RCALL lcdWriteDecimalQ
131:                       lcdSetCursorQ(12,3);
008356  B3C031     MOV.B #0x3, W1
008358  B3C0C0     MOV.B #0xC, W0
00835A  07FA25     RCALL lcdSetCursorQ
132:                       lcdWriteDecimalQ(pots_percent[5], 3);
00835C  200031     MOV #0x3, W1
00835E  830470     MOV 0x608E, W0
008360  07FB1C     RCALL lcdWriteDecimalQ
133:               
134:                   }
135:               }
008362  060000     RETURN
136:               
137:               void screenDebugFlash(void){
008364  781F88     MOV W8, [W15++]
138:                       if(state!=laststate){
008366  8080F0     MOV laststate, W0
008368  E3103E     CP 0x103E
00836A  32003D     BRA Z, 0x83E6
139:                       //setup here
140:                       lcdClearQ();
00836C  07FA11     RCALL lcdClearQ
141:                       lcdSetCursorQ(0,0);
00836E  EB4080     CLR.B W1
008370  784001     MOV.B W1, W0
008372  07FA19     RCALL lcdSetCursorQ
142:                       lcdWriteWordQ(flash_readback[2]);
008374  25E6E0     MOV #0x5E6E, W0
008376  FB0010     SE [W0], W0
008378  07FA48     RCALL lcdWriteWordQ
143:                        lcdSetCursorQ(6,0);
00837A  EB4080     CLR.B W1
00837C  B3C060     MOV.B #0x6, W0
00837E  07FA13     RCALL lcdSetCursorQ
144:                       lcdWriteWordQ(flash_readback[3]);
008380  25E6F0     MOV #0x5E6F, W0
008382  FB0010     SE [W0], W0
008384  07FA42     RCALL lcdWriteWordQ
145:                        lcdSetCursorQ(12,0);
008386  EB4080     CLR.B W1
008388  B3C0C0     MOV.B #0xC, W0
00838A  07FA0D     RCALL lcdSetCursorQ
146:                       lcdWriteWordQ(flash_readback[4]);
00838C  25E700     MOV #0x5E70, W0
00838E  FB0010     SE [W0], W0
008390  07FA3C     RCALL lcdWriteWordQ
147:                        lcdSetCursorQ(0,1);
008392  B3C011     MOV.B #0x1, W1
008394  EB4000     CLR.B W0
008396  07FA07     RCALL lcdSetCursorQ
148:                       lcdWriteWordQ(flash_readback[5]);
008398  25E710     MOV #0x5E71, W0
00839A  FB0010     SE [W0], W0
00839C  07FA36     RCALL lcdWriteWordQ
149:                       lcdSetCursorQ(6,1);
00839E  B3C011     MOV.B #0x1, W1
0083A0  B3C060     MOV.B #0x6, W0
0083A2  07FA01     RCALL lcdSetCursorQ
150:                       lcdWriteWordQ(flash_readback[6]);
0083A4  25E720     MOV #0x5E72, W0
0083A6  FB0010     SE [W0], W0
0083A8  07FA30     RCALL lcdWriteWordQ
151:                        lcdSetCursorQ(12,1);
0083AA  B3C011     MOV.B #0x1, W1
0083AC  B3C0C0     MOV.B #0xC, W0
0083AE  07F9FB     RCALL lcdSetCursorQ
152:                       lcdWriteWordQ(flash_readback[7]);
0083B0  25E730     MOV #0x5E73, W0
0083B2  FB0010     SE [W0], W0
0083B4  07FA2A     RCALL lcdWriteWordQ
153:                       lcdSetCursorQ(0,2);
0083B6  B3C021     MOV.B #0x2, W1
0083B8  EB4000     CLR.B W0
0083BA  07F9F5     RCALL lcdSetCursorQ
154:                       lcdWriteWordQ(flash_readback[8]);
0083BC  25E748     MOV #0x5E74, W8
0083BE  FB0018     SE [W8], W0
0083C0  07FA24     RCALL lcdWriteWordQ
155:                       lcdSetCursorQ(6,2);
0083C2  B3C021     MOV.B #0x2, W1
0083C4  B3C060     MOV.B #0x6, W0
0083C6  07F9EF     RCALL lcdSetCursorQ
156:                       lcdWriteWordQ(flash_readback[9]);
0083C8  E80008     INC W8, W0
0083CA  FB0010     SE [W0], W0
0083CC  07FA1E     RCALL lcdWriteWordQ
157:                        lcdSetCursorQ(12,2);
0083CE  B3C021     MOV.B #0x2, W1
0083D0  B3C0C0     MOV.B #0xC, W0
0083D2  07F9E9     RCALL lcdSetCursorQ
158:                       lcdWriteWordQ(flash_readback[10]);
0083D4  E88008     INC2 W8, W0
0083D6  FB0010     SE [W0], W0
0083D8  07FA18     RCALL lcdWriteWordQ
159:                       lcdSetCursorQ(0,3);
0083DA  B3C031     MOV.B #0x3, W1
0083DC  EB4000     CLR.B W0
0083DE  07F9E3     RCALL lcdSetCursorQ
160:                       lcdWriteWordQ(flash_readback[8]);
0083E0  FB0018     SE [W8], W0
0083E2  07FA13     RCALL lcdWriteWordQ
0083E4  370008     BRA 0x83F6
161:                   } else {
162:                       //update here
163:                       lcdSetCursorQ(9,3);
0083E6  B3C031     MOV.B #0x3, W1
0083E8  B3C090     MOV.B #0x9, W0
0083EA  07F9DD     RCALL lcdSetCursorQ
164:                       lcdWriteStringQ("Stat:");
0083EC  2F72B0     MOV #0xF72B, W0
0083EE  07F9EF     RCALL lcdWriteStringQ
165:                       lcdWriteWordQ(flashStatusCheck());
0083F0  070330     RCALL flashStatusCheck
0083F2  FB0000     SE W0, W0
0083F4  07FA0A     RCALL lcdWriteWordQ
166:                   }
167:               }
0083F6  78044F     MOV [--W15], W8
0083F8  060000     RETURN
168:               
169:               void screenDebugInput(void){
170:                   if(state!=laststate){
0083FA  8080F0     MOV laststate, W0
0083FC  E3103E     CP 0x103E
0083FE  32000C     BRA Z, 0x8418
171:                       //setup here
172:                       lcdClearQ();
008400  07F9C7     RCALL lcdClearQ
173:                       lcdSetCursorQ(0,0);
008402  EB4080     CLR.B W1
008404  784001     MOV.B W1, W0
008406  07F9CF     RCALL lcdSetCursorQ
174:                       lcdWriteStringQ("Input Debug");
008408  2F7310     MOV #0xF731, W0
00840A  07F9E1     RCALL lcdWriteStringQ
175:                       lcdSetCursorQ(0,1);
00840C  B3C011     MOV.B #0x1, W1
00840E  EB4000     CLR.B W0
008410  07F9CA     RCALL lcdSetCursorQ
176:                       lcdWriteStringQ("ADC variance: ");
008412  2F73D0     MOV #0xF73D, W0
008414  07F9DC     RCALL lcdWriteStringQ
008416  370002     BRA 0x841C
177:                   } else {
178:                       //update here
179:                       lcdDrawPads(16);
008418  B3C100     MOV.B #0x10, W0
00841A  07FAF1     RCALL lcdDrawPads
180:                   }
181:               }
00841C  060000     RETURN
182:               
183:               void screenUpdate(void){
184:                   switch(state){
00841E  8081F0     MOV 0x103E, W0
008420  500FE3     SUB W0, #0x3, [W15]
008422  32000F     BRA Z, 0x8442
008424  3E0005     BRA GTU, 0x8430
008426  500FE1     SUB W0, #0x1, [W15]
008428  320008     BRA Z, 0x843A
00842A  500FE2     SUB W0, #0x2, [W15]
00842C  3A000F     BRA NZ, 0x844C
00842E  370007     BRA 0x843E
008430  500FE4     SUB W0, #0x4, [W15]
008432  320009     BRA Z, 0x8446
008434  500FE5     SUB W0, #0x5, [W15]
008436  3A000A     BRA NZ, 0x844C
008438  370008     BRA 0x844A
185:                       case start: break;
186:                       case scrnFX:            screenFX(); 
00843A  07FF42     RCALL screenFX
187:                       break;
00843C  370007     BRA 0x844C
188:                       case debugscrnPOTS:     screenDebugPots();
00843E  07FEC8     RCALL screenDebugPots
189:                       break;
008440  370005     BRA 0x844C
190:                       case debugscrnFLASH:    screenDebugFlash();
008442  07FF90     RCALL screenDebugFlash
191:                       break;
008444  370003     BRA 0x844C
192:                       case debugscrnBUFFERS:  screenDebugBuffers();
008446  07FE9F     RCALL screenDebugBuffers
193:                       break;
008448  370001     BRA 0x844C
194:                       case debugscrnINPUT:    screenDebugInput();
00844A  07FFD7     RCALL screenDebugInput
195:                       break;
196:                                       
197:                       default: break;
198:                   }
199:                   
200:                   laststate=state;
00844C  F8103E     PUSH 0x103E
00844E  F9101E     POP laststate
201:               }
008450  060000     RETURN
202:               
203:                   /*
204:                   lcdSetCursorQ(0,3);
205:                   if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
206:                       lcdWriteStringQ("CLIP");
207:                       hard_clipped=FALSE;  
208:                   }
209:                   else if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
210:                   else lcdWriteStringQ("THRU");
211:                    * 
212:                    *    lcdSetCursorQ(10,3);
213:                  lcdWriteWordQ(ENCODERCNTL);
214:                   */
215:               
216:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/routines.c  -------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
10:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
11:                extern unsigned int write_ptr, rw, frameReady;
12:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
13:                
14:                //misc.
15:                volatile fractional sampinA=0, sampinB=0;
16:                
17:                volatile int rxBufferIndicator = 0;
18:                fractional *ping, *pong;
19:                
20:                //Description: This interrupt triggers at the completion of DCI output
21:                //Dependancies: initSPI2(); 
22:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
000306  BE9F80     MOV.D W0, [W15++]
000308  BE9F82     MOV.D W2, [W15++]
00030A  781F84     MOV W4, [W15++]
00030C  F80032     PUSH DSRPAG
00030E  F80034     PUSH DSWPAG
000310  200010     MOV #0x1, W0
000312  8801A0     MOV W0, DSWPAG
000314  202000     MOV #0x200, W0
000316  880190     MOV W0, DSRPAG
000318  000000     NOP
23:                    static fractional sampoutA=0, sampoutB=0;
24:                    
25:                    int trashA=RXBUF0;
00031A  801480     MOV RXBUF0, W0
26:                    sampinA=RXBUF1;
00031C  F80292     PUSH RXBUF1
00031E  F91020     POP sampinA
27:                    int trashB=RXBUF2;
000320  8014A0     MOV RXBUF2, W0
28:                    sampinB=RXBUF3;
000322  F80296     PUSH RXBUF3
000324  F91022     POP sampinB
29:                    TXBUF0=TXBUF1=sampoutA;                                    //output buffered sample to DAC
000326  F8102C     PUSH sampoutA
000328  F9029A     POP TXBUF1
00032A  F8029A     PUSH TXBUF1
00032C  F90298     POP TXBUF0
30:                    TXBUF2=TXBUF3=sampoutB;
00032E  F8102A     PUSH sampoutB
000330  F9029E     POP TXBUF3
000332  F8029E     PUSH TXBUF3
000334  F9029C     POP TXBUF2
31:                
32:                
33:                    
34:                    __builtin_btg(&sampinA, 15);                             //convert to Q1.15 compatible format
000336  210200     MOV #0x1020, W0
000338  A2F010     BTG [W0], #15
35:                    __builtin_btg(&sampinB, 15);                             //convert to Q1.15 compatible format
00033A  210220     MOV #0x1022, W0
00033C  A2F010     BTG [W0], #15
36:                    
37:                
38:                      
39:                    
40:                    if(write_ptr--==0){                       //reset pointer when out of bounds
00033E  8081D0     MOV 0x103A, W0
000340  E90080     DEC W0, W1
000342  8881D1     MOV W1, 0x103A
000344  E00000     CP0 W0
000346  3A0005     BRA NZ, 0x352
41:                        write_ptr=STREAMBUF-1;
000348  200FF0     MOV #0xFF, W0
00034A  8881D0     MOV W0, 0x103A
42:                        __builtin_btg(&rw,0);
00034C  AA1012     BTG rw, #0
43:                        frameReady=1;
00034E  200010     MOV #0x1, W0
000350  8880A0     MOV W0, frameReady
44:                    }
45:                   
46:                    if(rw){
000352  E21012     CP0 rw
000354  320014     BRA Z, 0x37E
47:                        streamB[write_ptr]=sampinA;
000356  8081D0     MOV 0x103A, W0
000358  2669C2     MOV #0x669C, W2
00035A  400180     ADD W0, W0, W3
00035C  410083     ADD W2, W3, W1
00035E  808104     MOV sampinA, W4
000360  780884     MOV W4, [W1]
48:                        sampoutA=outputA[write_ptr--]; 
000362  2609C1     MOV #0x609C, W1
000364  408183     ADD W1, W3, W3
000366  780193     MOV [W3], W3
000368  888163     MOV W3, sampoutA
00036A  E90000     DEC W0, W0
00036C  8881D0     MOV W0, 0x103A
49:                        streamB[write_ptr]=sampinB;
00036E  400000     ADD W0, W0, W0
000370  410100     ADD W2, W0, W2
000372  808113     MOV sampinB, W3
000374  780903     MOV W3, [W2]
50:                        sampoutB=outputA[write_ptr];
000376  408000     ADD W1, W0, W0
000378  780010     MOV [W0], W0
00037A  888150     MOV W0, sampoutB
00037C  370013     BRA 0x3A4
51:                        
52:                    }
53:                    else {
54:                        streamA[write_ptr]=sampinA; 
00037E  8081D0     MOV 0x103A, W0
000380  2649C2     MOV #0x649C, W2
000382  400180     ADD W0, W0, W3
000384  410083     ADD W2, W3, W1
000386  808104     MOV sampinA, W4
000388  780884     MOV W4, [W1]
55:                        sampoutA=outputB[write_ptr--];  
00038A  2629C1     MOV #0x629C, W1
00038C  408183     ADD W1, W3, W3
00038E  780193     MOV [W3], W3
000390  888163     MOV W3, sampoutA
000392  E90000     DEC W0, W0
000394  8881D0     MOV W0, 0x103A
56:                        streamA[write_ptr]=sampinB; 
000396  400000     ADD W0, W0, W0
000398  410100     ADD W2, W0, W2
00039A  808113     MOV sampinB, W3
00039C  780903     MOV W3, [W2]
57:                        sampoutB=outputB[write_ptr];  
00039E  408000     ADD W1, W0, W0
0003A0  780010     MOV [W0], W0
0003A2  888150     MOV W0, sampoutB
58:                    } 
59:                    
60:                    _DCIIF=0;
0003A4  A98807     BCLR 0x807, #4
61:                }
0003A6  F90034     POP DSWPAG
0003A8  F90032     POP DSRPAG
0003AA  78024F     MOV [--W15], W4
0003AC  BE014F     MOV.D [--W15], W2
0003AE  BE004F     MOV.D [--W15], W0
0003B0  064000     RETFIE
62:                
63:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003B2  F80036     PUSH RCOUNT
0003B4  BE9F80     MOV.D W0, [W15++]
0003B6  BE9F82     MOV.D W2, [W15++]
0003B8  BE9F84     MOV.D W4, [W15++]
0003BA  BE9F86     MOV.D W6, [W15++]
64:                    _DMA2IF = 0; /* Received one frame of data*/    
0003BC  A90803     BCLR 0x803, #0
65:                    
66:                    if(rxBufferIndicator == 0)
0003BE  E21024     CP0 rxBufferIndicator
0003C0  3A0004     BRA NZ, 0x3CA
67:                    {
68:                         processRxData((int *)rxBufferA, (int*)txBufferA);
0003C2  2CE001     MOV #0xCE00, W1
0003C4  2CA000     MOV #0xCA00, W0
0003C6  074171     RCALL processRxData
0003C8  370003     BRA 0x3D0
69:                    }
70:                    else
71:                    {
72:                         processRxData((int *)rxBufferB, (int*)txBufferB);
0003CA  2CC001     MOV #0xCC00, W1
0003CC  2C8000     MOV #0xC800, W0
0003CE  07416D     RCALL processRxData
73:                    }
74:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
0003D0  AA1024     BTG rxBufferIndicator, #0
75:                }
0003D2  BE034F     MOV.D [--W15], W6
0003D4  BE024F     MOV.D [--W15], W4
0003D6  BE014F     MOV.D [--W15], W2
0003D8  BE004F     MOV.D [--W15], W0
0003DA  F90036     POP RCOUNT
0003DC  064000     RETFIE
76:                
77:                /*
78:                //Description: This interrupt handles UART reception
79:                //Dependencies: initUART1();
80:                void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
81:                    unsigned char trash;
82:                    trash=U1RXREG;
83:                    printf("RECIEVED: %d\r\n", trash);
84:                    IFS0bits.U1RXIF = 0;            //clear flag, restart
85:                }
86:                
87:                //Description: This interrupt handles UART transmission
88:                //Dependencies: initUART1();
89:                void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
90:                    YLED=~YLED;
91:                    IFS0bits.U1TXIF = 0;            //clear flag, restart
92:                } 
93:                  
94:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
95:                    //SEG_SEL=1;
96:                    int trash=SPI3BUF;
97:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
98:                    IFS5bits.SPI3IF=0;
99:                    
100:               }
101:                */
---  C:/Users/ryan/Documents/seniorproject/ps-040/plcd.c  -----------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                #include "screens.h"
14:                
15:                extern unsigned char pad[BUTTONS];
16:                int lcdBuf[LCDBUF+1]={0};
17:                int *lcdWritePtr=lcdBuf;
18:                int *lcdReadPtr=lcdBuf;
19:                
20:                // There are write and command macros in the header, make sure these match.
21:                void lcdWriteQ(unsigned char data){
22:                    *lcdWritePtr++=data|0x0000;
007766  FB8000     ZE W0, W0
007768  808231     MOV 0x1046, W1
00776A  781880     MOV W0, [W1++]
00776C  888231     MOV W1, 0x1046
23:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
00776E  26AC00     MOV #0x6AC0, W0
007770  508F80     SUB W1, W0, [W15]
007772  3A0002     BRA NZ, 0x7778
24:                        lcdWritePtr=lcdBuf;
007774  B12000     SUB #0x200, W0
007776  888230     MOV W0, 0x1046
25:                }
007778  060000     RETURN
26:                
27:                // There are write and command macros in the header, make sure these match.
28:                void lcdCommandQ(unsigned char data){
29:                    *lcdWritePtr++=data|0x0100;     //flag for rs=1
00777A  FB8000     ZE W0, W0
00777C  808231     MOV 0x1046, W1
00777E  A08000     BSET W0, #8
007780  781880     MOV W0, [W1++]
007782  888231     MOV W1, 0x1046
30:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007784  26AC00     MOV #0x6AC0, W0
007786  508F80     SUB W1, W0, [W15]
007788  3A0002     BRA NZ, 0x778E
31:                        lcdWritePtr=lcdBuf;
00778A  B12000     SUB #0x200, W0
00778C  888230     MOV W0, 0x1046
32:                }
00778E  060000     RETURN
33:                
34:                void lcdClearQ(void){
35:                    *lcdWritePtr++=LCD_CLEARDISPLAY|0x0300;     //flag for rs=1 & long delay
007790  808230     MOV 0x1046, W0
007792  203011     MOV #0x301, W1
007794  781801     MOV W1, [W0++]
007796  888230     MOV W0, 0x1046
36:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007798  26AC01     MOV #0x6AC0, W1
00779A  500F81     SUB W0, W1, [W15]
00779C  3A0003     BRA NZ, 0x77A4
37:                        lcdWritePtr=lcdBuf;
00779E  2FE000     MOV #0xFE00, W0
0077A0  400001     ADD W0, W1, W0
0077A2  888230     MOV W0, 0x1046
38:                }
0077A4  060000     RETURN
39:                
40:                void lcdSetCursorQ(unsigned char col, unsigned char row) {
0077A6  784101     MOV.B W1, W2
41:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
42:                  if (row > 3) {
43:                    row = 3;
44:                  }
45:                  *lcdWritePtr++=(LCD_SETDDRAMADDR | (col + offsets[row]))|0x0100;  //flag for rs=0 
0077A8  808231     MOV 0x1046, W1
0077AA  514FE3     SUB.B W2, #0x3, [W15]
0077AC  360001     BRA LEU, 0x77B0
0077AE  B3C032     MOV.B #0x3, W2
0077B0  FB8102     ZE W2, W2
0077B2  2F7623     MOV #0xF762, W3
0077B4  418102     ADD W3, W2, W2
0077B6  FB8112     ZE [W2], W2
0077B8  FB8000     ZE W0, W0
0077BA  410000     ADD W2, W0, W0
0077BC  201802     MOV #0x180, W2
0077BE  701882     IOR W0, W2, [W1++]
0077C0  888231     MOV W1, 0x1046
46:                    if(lcdWritePtr==&lcdBuf[LCDBUF]) 
0077C2  26AC00     MOV #0x6AC0, W0
0077C4  508F80     SUB W1, W0, [W15]
0077C6  3A0002     BRA NZ, 0x77CC
47:                        lcdWritePtr=lcdBuf; 
0077C8  B12000     SUB #0x200, W0
0077CA  888230     MOV W0, 0x1046
48:                }
0077CC  060000     RETURN
49:                
50:                void lcdWriteStringQ(char *string) {
51:                    char *it = string;
52:                    for (; *it; it++) {
0077CE  784090     MOV.B [W0], W1
0077D0  E00401     CP0.B W1
0077D2  32000D     BRA Z, 0x77EE
0077E8  7840D0     MOV.B [++W0], W1
0077EA  E00401     CP0.B W1
0077EC  3AFFF6     BRA NZ, 0x77DA
53:                        lcdWriteQMac(*it);
0077D4  26AC03     MOV #0x6AC0, W3
0077D6  2FE004     MOV #0xFE00, W4
0077D8  420203     ADD W4, W3, W4
0077DA  FB0101     SE W1, W2
0077DC  808231     MOV 0x1046, W1
0077DE  781882     MOV W2, [W1++]
0077E0  888231     MOV W1, 0x1046
0077E2  508F83     SUB W1, W3, [W15]
0077E4  3A0001     BRA NZ, 0x77E8
0077E6  888234     MOV W4, 0x1046
54:                  }
55:                }
0077EE  060000     RETURN
56:                
57:                void lcdCustomSymbols(void){
58:                    int i=0;
59:                    lcdCommandQMac(0x40);
0077F0  808230     MOV 0x1046, W0
0077F2  201401     MOV #0x140, W1
0077F4  781801     MOV W1, [W0++]
0077F6  888230     MOV W0, 0x1046
0077F8  26AC01     MOV #0x6AC0, W1
0077FA  500F81     SUB W0, W1, [W15]
0077FC  3A0003     BRA NZ, 0x7804
0077FE  2FE000     MOV #0xFE00, W0
007800  400001     ADD W0, W1, W0
007802  888230     MOV W0, 0x1046
60:                    Delay_us(200);
007804  200C80     MOV #0xC8, W0
007806  070758     RCALL Delay_us
61:                   // for(; i<8; i++)lcdWriteString(loadingOne[i]);
62:                    //lcdWriteString(loadingTwo);
63:                    //lcdWriteString(loadingThree);
64:                    //lcdWriteString(loadingFour);
65:                }
007808  060000     RETURN
66:                
67:                void lcdWriteWordQ(int word){
00780A  4787E6     ADD W15, #0x6, W15
00780C  781F8E     MOV W14, [W15++]
007850  200041     MOV #0x4, W1
68:                    int i;
69:                    char inchar[4];
70:                    
71:                    if(word<0) {
00780E  E00000     CP0 W0
007810  3D000C     BRA GE, 0x782A
72:                        lcdWriteQMac('-');
007812  808231     MOV 0x1046, W1
007814  2002D2     MOV #0x2D, W2
007816  781882     MOV W2, [W1++]
007818  888231     MOV W1, 0x1046
00781A  26AC02     MOV #0x6AC0, W2
00781C  508F82     SUB W1, W2, [W15]
00781E  3A0003     BRA NZ, 0x7826
007820  2FE001     MOV #0xFE00, W1
007822  408082     ADD W1, W2, W1
007824  888231     MOV W1, 0x1046
73:                        word=~word+1;
007826  EA0000     NEG W0, W0
007828  37000A     BRA 0x783E
74:                    }else lcdWriteQMac(' ');
00782A  808231     MOV 0x1046, W1
00782C  200202     MOV #0x20, W2
00782E  781882     MOV W2, [W1++]
007830  888231     MOV W1, 0x1046
007832  26AC02     MOV #0x6AC0, W2
007834  508F82     SUB W1, W2, [W15]
007836  3A0003     BRA NZ, 0x783E
007838  2FE001     MOV #0xFE00, W1
00783A  408082     ADD W1, W2, W1
00783C  888231     MOV W1, 0x1046
75:                   
76:                   inchar[0] = word&0x000F; 
00783E  6040EF     AND.B W0, #0xF, W1
77:                   if (inchar[0] > 9) 
007840  50CFE9     SUB.B W1, #0x9, [W15]
007842  340003     BRA LE, 0x784A
78:                       inchar[0]+=55;
007844  B04371     ADD.B #0x37, W1
007846  9FFFA1     MOV.B W1, [W15-6]
007848  370002     BRA 0x784E
79:                   else inchar[0]+=48;
00784A  B04301     ADD.B #0x30, W1
00784C  9FFFA1     MOV.B W1, [W15-6]
00784E  578766     SUB W15, #0x6, W14
80:                   
81:                   for(i=1; i<4; i++){ 
00786A  508FF0     SUB W1, #0x10, [W15]
00786C  3AFFF2     BRA NZ, 0x7852
82:                      inchar[i] = ((word>>(i*4))&0x0000F); 
007852  DE8101     ASR W0, W1, W2
007854  61416F     AND.B W2, #0xF, W2
007856  E8070E     INC W14, W14
007858  784F02     MOV.B W2, [W14]
83:                      if (inchar[i] > 9) 
00785A  514FE9     SUB.B W2, #0x9, [W15]
00785C  340003     BRA LE, 0x7864
84:                          inchar[i]+=55;
00785E  B3C374     MOV.B #0x37, W4
007860  414F04     ADD.B W2, W4, [W14]
007862  370002     BRA 0x7868
85:                      else inchar[i]+=48;
007864  B3C304     MOV.B #0x30, W4
007866  414F04     ADD.B W2, W4, [W14]
007868  4080E4     ADD W1, #0x4, W1
86:                   } 
87:                   lcdWriteQMac(inchar[3]);
00786E  97F8DF     MOV.B [W15-3], W1
007870  FB0081     SE W1, W1
007872  808230     MOV 0x1046, W0
007874  781801     MOV W1, [W0++]
007876  26AC01     MOV #0x6AC0, W1
007878  500F81     SUB W0, W1, [W15]
00787A  3A000A     BRA NZ, 0x7890
88:                   lcdWriteQMac(inchar[2]);
00787C  97F84F     MOV.B [W15-4], W0
00787E  FB0000     SE W0, W0
007880  8B4600     MOV W0, lcdBuf
007890  97F8CF     MOV.B [W15-4], W1
007892  FB0081     SE W1, W1
007894  781801     MOV W1, [W0++]
007896  888230     MOV W0, 0x1046
007898  26AC01     MOV #0x6AC0, W1
00789A  500F81     SUB W0, W1, [W15]
00789C  3A0009     BRA NZ, 0x78B0
89:                   lcdWriteQMac(inchar[1]);
007882  97F83F     MOV.B [W15-5], W0
007884  FB0000     SE W0, W0
007886  8B4610     MOV W0, 0x68C2
007888  2FE040     MOV #0xFE04, W0
00788A  400001     ADD W0, W1, W0
00788C  888230     MOV W0, 0x1046
00788E  37001F     BRA 0x78CE
00789E  97F83F     MOV.B [W15-5], W0
0078A0  FB0000     SE W0, W0
0078A2  8B4600     MOV W0, lcdBuf
0078B0  97F8BF     MOV.B [W15-5], W1
0078B2  FB0081     SE W1, W1
0078B4  808230     MOV 0x1046, W0
0078B6  781801     MOV W1, [W0++]
0078B8  888230     MOV W0, 0x1046
0078BA  26AC01     MOV #0x6AC0, W1
0078BC  500F81     SUB W0, W1, [W15]
0078BE  3A0007     BRA NZ, 0x78CE
90:                   lcdWriteQMac(inchar[0]);
0078A4  97F8AF     MOV.B [W15-6], W1
0078A6  FB0001     SE W1, W0
0078A8  8B4610     MOV W0, 0x68C2
0078AA  268C40     MOV #0x68C4, W0
0078AC  888230     MOV W0, 0x1046
0078AE  37001A     BRA 0x78E4
0078C0  97FA2F     MOV.B [W15-6], W4
0078C2  FB0004     SE W4, W0
0078C4  8B4600     MOV W0, lcdBuf
0078C6  2FE020     MOV #0xFE02, W0
0078C8  400001     ADD W0, W1, W0
0078CA  888230     MOV W0, 0x1046
0078CC  37000B     BRA 0x78E4
0078CE  97F82F     MOV.B [W15-6], W0
0078D0  FB0080     SE W0, W1
0078D2  808230     MOV 0x1046, W0
0078D4  781801     MOV W1, [W0++]
0078D6  888230     MOV W0, 0x1046
0078D8  26AC01     MOV #0x6AC0, W1
0078DA  500F81     SUB W0, W1, [W15]
0078DC  3A0003     BRA NZ, 0x78E4
0078DE  2FE000     MOV #0xFE00, W0
0078E0  400001     ADD W0, W1, W0
0078E2  888230     MOV W0, 0x1046
91:                }
0078E4  78074F     MOV [--W15], W14
0078E6  B1006F     SUB #0x6, W15
0078E8  060000     RETURN
92:                
93:                void lcdWriteWordUnsignedQ(unsigned int word){
0078EA  4787E6     ADD W15, #0x6, W15
0078EC  781F8E     MOV W14, [W15++]
007900  200041     MOV #0x4, W1
94:                    int i;
95:                    char inchar[4];
96:                    
97:                   inchar[0] = word&0x000F; 
0078EE  6040EF     AND.B W0, #0xF, W1
98:                   if (inchar[0] > 9) 
0078F0  50CFE9     SUB.B W1, #0x9, [W15]
0078F2  340003     BRA LE, 0x78FA
99:                       inchar[0]+=55;
0078F4  B04371     ADD.B #0x37, W1
0078F6  9FFFA1     MOV.B W1, [W15-6]
0078F8  370002     BRA 0x78FE
100:                  else inchar[0]+=48;
0078FA  B04301     ADD.B #0x30, W1
0078FC  9FFFA1     MOV.B W1, [W15-6]
0078FE  578766     SUB W15, #0x6, W14
101:                  
102:                  for(i=1; i<4; i++){ 
00791A  508FF0     SUB W1, #0x10, [W15]
00791C  3AFFF2     BRA NZ, 0x7902
103:                     inchar[i] = ((word>>(i*4))&0x0000F); 
007902  DE0101     LSR W0, W1, W2
007904  61416F     AND.B W2, #0xF, W2
007906  E8070E     INC W14, W14
007908  784F02     MOV.B W2, [W14]
104:                     if (inchar[i] > 9) 
00790A  514FE9     SUB.B W2, #0x9, [W15]
00790C  340003     BRA LE, 0x7914
105:                         inchar[i]+=55;
00790E  B3C374     MOV.B #0x37, W4
007910  414F04     ADD.B W2, W4, [W14]
007912  370002     BRA 0x7918
106:                     else inchar[i]+=48;
007914  B3C304     MOV.B #0x30, W4
007916  414F04     ADD.B W2, W4, [W14]
007918  4080E4     ADD W1, #0x4, W1
107:                  } 
108:                  lcdWriteQMac(inchar[3]);
00791E  97F8DF     MOV.B [W15-3], W1
007920  FB0081     SE W1, W1
007922  808230     MOV 0x1046, W0
007924  781801     MOV W1, [W0++]
007926  26AC01     MOV #0x6AC0, W1
007928  500F81     SUB W0, W1, [W15]
00792A  3A000A     BRA NZ, 0x7940
109:                  lcdWriteQMac(inchar[2]);
00792C  97F84F     MOV.B [W15-4], W0
00792E  FB0000     SE W0, W0
007930  8B4600     MOV W0, lcdBuf
007940  97F8CF     MOV.B [W15-4], W1
007942  FB0081     SE W1, W1
007944  781801     MOV W1, [W0++]
007946  888230     MOV W0, 0x1046
007948  26AC01     MOV #0x6AC0, W1
00794A  500F81     SUB W0, W1, [W15]
00794C  3A0009     BRA NZ, 0x7960
110:                  lcdWriteQMac(inchar[1]);
007932  97F83F     MOV.B [W15-5], W0
007934  FB0000     SE W0, W0
007936  8B4610     MOV W0, 0x68C2
007938  2FE040     MOV #0xFE04, W0
00793A  400001     ADD W0, W1, W0
00793C  888230     MOV W0, 0x1046
00793E  37001F     BRA 0x797E
00794E  97F83F     MOV.B [W15-5], W0
007950  FB0000     SE W0, W0
007952  8B4600     MOV W0, lcdBuf
007960  97F8BF     MOV.B [W15-5], W1
007962  FB0081     SE W1, W1
007964  808230     MOV 0x1046, W0
007966  781801     MOV W1, [W0++]
007968  888230     MOV W0, 0x1046
00796A  26AC01     MOV #0x6AC0, W1
00796C  500F81     SUB W0, W1, [W15]
00796E  3A0007     BRA NZ, 0x797E
111:                  lcdWriteQMac(inchar[0]);
007954  97F8AF     MOV.B [W15-6], W1
007956  FB0001     SE W1, W0
007958  8B4610     MOV W0, 0x68C2
00795A  268C40     MOV #0x68C4, W0
00795C  888230     MOV W0, 0x1046
00795E  37001A     BRA 0x7994
007970  97FA2F     MOV.B [W15-6], W4
007972  FB0004     SE W4, W0
007974  8B4600     MOV W0, lcdBuf
007976  2FE020     MOV #0xFE02, W0
007978  400001     ADD W0, W1, W0
00797A  888230     MOV W0, 0x1046
00797C  37000B     BRA 0x7994
00797E  97F82F     MOV.B [W15-6], W0
007980  FB0080     SE W0, W1
007982  808230     MOV 0x1046, W0
007984  781801     MOV W1, [W0++]
007986  888230     MOV W0, 0x1046
007988  26AC01     MOV #0x6AC0, W1
00798A  500F81     SUB W0, W1, [W15]
00798C  3A0003     BRA NZ, 0x7994
00798E  2FE000     MOV #0xFE00, W0
007990  400001     ADD W0, W1, W0
007992  888230     MOV W0, 0x1046
112:               }
007994  78074F     MOV [--W15], W14
007996  B1006F     SUB #0x6, W15
007998  060000     RETURN
113:               
114:               void lcdWriteDecimalQ(char word, int digits){
00799A  FA0000     LNK #0x0
00799C  781F88     MOV W8, [W15++]
00799E  780381     MOV W1, W7
115:                   const char maxdigits = 4;
116:                   char result[maxdigits];
0079A2  4787E6     ADD W15, #0x6, W15
0079A4  780186     MOV W6, W3
117:                   char i = 3;
0079A6  B3C032     MOV.B #0x3, W2
118:                   do {
119:                       result[i] = '0' + word % 10;
0079A8  2000A4     MOV #0xA, W4
0079AA  FB0282     SE W2, W5
0079AC  418285     ADD W3, W5, W5
0079AE  FB0000     SE W0, W0
0079B0  090011     REPEAT #0x11
0079B2  D80004     DIV.SW W0, W4
0079B4  B3C308     MOV.B #0x30, W8
0079B6  40CA88     ADD.B W1, W8, [W5]
120:                       word /= 10;
121:                       i--;
0079B8  E94102     DEC.B W2, W2
122:                   }
123:                   while (word > 0);
0079BA  E00400     CP0.B W0
0079BC  3CFFF6     BRA GT, 0x79AA
124:                   while (i>=0) result[i--] = ' '; 
0079BE  E00402     CP0.B W2
0079C0  350007     BRA LT, 0x79D0
0079C2  B3C204     MOV.B #0x20, W4
0079C4  FB0002     SE W2, W0
0079C6  418000     ADD W3, W0, W0
0079C8  784804     MOV.B W4, [W0]
0079CA  E94102     DEC.B W2, W2
0079CC  414FE1     ADD.B W2, #0x1, [W15]
0079CE  3AFFFA     BRA NZ, 0x79C4
125:                 
126:                   for (i=maxdigits-digits; i<maxdigits; i++) {
0079D0  B3C041     MOV.B #0x4, W1
0079D2  50C087     SUB.B W1, W7, W1
0079D4  50CFE3     SUB.B W1, #0x3, [W15]
0079D6  3C000F     BRA GT, 0x79F6
0079F0  E84081     INC.B W1, W1
0079F2  50CFE4     SUB.B W1, #0x4, [W15]
0079F4  3AFFF4     BRA NZ, 0x79DE
127:                       lcdWriteQMac(result[i]);
0079D8  26AC04     MOV #0x6AC0, W4
0079DA  2FE005     MOV #0xFE00, W5
0079DC  428284     ADD W5, W4, W5
0079DE  FB0001     SE W1, W0
0079E0  418000     ADD W3, W0, W0
0079E2  FB0110     SE [W0], W2
0079E4  808230     MOV 0x1046, W0
0079E6  781802     MOV W2, [W0++]
0079E8  888230     MOV W0, 0x1046
0079EA  500F84     SUB W0, W4, [W15]
0079EC  3A0001     BRA NZ, 0x79F0
0079EE  888235     MOV W5, 0x1046
128:                   }
129:               }
0079A0  78030F     MOV W15, W6
0079F6  780786     MOV W6, W15
0079F8  78044F     MOV [--W15], W8
0079FA  FA8000     ULNK
0079FC  060000     RETURN
130:               
131:               //4x4 pad debug
132:               void lcdDrawPads(unsigned char col){
0079FE  BE9F88     MOV.D W8, [W15++]
007A00  784480     MOV.B W0, W9
133:                   unsigned char block=0xFF;
007A10  EBC400     SETM.B W8
134:                   if(!pad[34]||!pad[16]) block='*';
007A02  B3C2A8     MOV.B #0x2A, W8
007A04  268BE0     MOV #0x68BE, W0
007A06  E00410     CP0.B [W0]
007A08  320004     BRA Z, 0x7A12
007A0A  500072     SUB W0, #0x12, W0
007A0C  E00410     CP0.B [W0]
007A0E  320001     BRA Z, 0x7A12
135:                   
136:                   lcdSetCursorQ(col, 0);
007A12  EB4080     CLR.B W1
007A14  784009     MOV.B W9, W0
007A16  07FEC7     RCALL lcdSetCursorQ
137:                   if(!pad[12]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007A18  268A80     MOV #0x68A8, W0
007A1A  E00410     CP0.B [W0]
007A1C  3A000B     BRA NZ, 0x7A34
007A1E  808230     MOV 0x1046, W0
007A20  200201     MOV #0x20, W1
007A22  781801     MOV W1, [W0++]
007A24  888230     MOV W0, 0x1046
007A26  26AC01     MOV #0x6AC0, W1
007A28  500F81     SUB W0, W1, [W15]
007A2A  3A000E     BRA NZ, 0x7A48
007A2C  2FE000     MOV #0xFE00, W0
007A2E  400001     ADD W0, W1, W0
007A30  888230     MOV W0, 0x1046
007A32  37000A     BRA 0x7A48
007A34  FB8088     ZE W8, W1
007A36  808230     MOV 0x1046, W0
007A38  781801     MOV W1, [W0++]
007A3A  888230     MOV W0, 0x1046
007A3C  26AC01     MOV #0x6AC0, W1
007A3E  500F81     SUB W0, W1, [W15]
007A40  3A0003     BRA NZ, 0x7A48
007A42  2FE000     MOV #0xFE00, W0
007A44  400001     ADD W0, W1, W0
007A46  888230     MOV W0, 0x1046
138:                   if(!pad[13]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007A48  268A90     MOV #0x68A9, W0
007A4A  E00410     CP0.B [W0]
007A4C  3A000B     BRA NZ, 0x7A64
007A4E  808230     MOV 0x1046, W0
007A50  200201     MOV #0x20, W1
007A52  781801     MOV W1, [W0++]
007A54  888230     MOV W0, 0x1046
007A56  26AC01     MOV #0x6AC0, W1
007A58  500F81     SUB W0, W1, [W15]
007A5A  3A000E     BRA NZ, 0x7A78
007A5C  2FE000     MOV #0xFE00, W0
007A5E  400001     ADD W0, W1, W0
007A60  888230     MOV W0, 0x1046
007A62  37000A     BRA 0x7A78
007A64  FB8088     ZE W8, W1
007A66  808230     MOV 0x1046, W0
007A68  781801     MOV W1, [W0++]
007A6A  888230     MOV W0, 0x1046
007A6C  26AC01     MOV #0x6AC0, W1
007A6E  500F81     SUB W0, W1, [W15]
007A70  3A0003     BRA NZ, 0x7A78
007A72  2FE000     MOV #0xFE00, W0
007A74  400001     ADD W0, W1, W0
007A76  888230     MOV W0, 0x1046
139:                   if(!pad[14]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007A78  268AA0     MOV #0x68AA, W0
007A7A  E00410     CP0.B [W0]
007A7C  3A000B     BRA NZ, 0x7A94
007A7E  808230     MOV 0x1046, W0
007A80  200201     MOV #0x20, W1
007A82  781801     MOV W1, [W0++]
007A84  888230     MOV W0, 0x1046
007A86  26AC01     MOV #0x6AC0, W1
007A88  500F81     SUB W0, W1, [W15]
007A8A  3A000E     BRA NZ, 0x7AA8
007A8C  2FE000     MOV #0xFE00, W0
007A8E  400001     ADD W0, W1, W0
007A90  888230     MOV W0, 0x1046
007A92  37000A     BRA 0x7AA8
007A94  FB8088     ZE W8, W1
007A96  808230     MOV 0x1046, W0
007A98  781801     MOV W1, [W0++]
007A9A  888230     MOV W0, 0x1046
007A9C  26AC01     MOV #0x6AC0, W1
007A9E  500F81     SUB W0, W1, [W15]
007AA0  3A0003     BRA NZ, 0x7AA8
007AA2  2FE000     MOV #0xFE00, W0
007AA4  400001     ADD W0, W1, W0
007AA6  888230     MOV W0, 0x1046
140:                   if(!pad[15]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007AA8  268AB0     MOV #0x68AB, W0
007AAA  E00410     CP0.B [W0]
007AAC  3A000B     BRA NZ, 0x7AC4
007AAE  808230     MOV 0x1046, W0
007AB0  200201     MOV #0x20, W1
007AB2  781801     MOV W1, [W0++]
007AB4  888230     MOV W0, 0x1046
007AB6  26AC01     MOV #0x6AC0, W1
007AB8  500F81     SUB W0, W1, [W15]
007ABA  3A000E     BRA NZ, 0x7AD8
007ABC  2FE000     MOV #0xFE00, W0
007ABE  400001     ADD W0, W1, W0
007AC0  888230     MOV W0, 0x1046
007AC2  37000A     BRA 0x7AD8
007AC4  FB8088     ZE W8, W1
007AC6  808230     MOV 0x1046, W0
007AC8  781801     MOV W1, [W0++]
007ACA  888230     MOV W0, 0x1046
007ACC  26AC01     MOV #0x6AC0, W1
007ACE  500F81     SUB W0, W1, [W15]
007AD0  3A0003     BRA NZ, 0x7AD8
007AD2  2FE000     MOV #0xFE00, W0
007AD4  400001     ADD W0, W1, W0
007AD6  888230     MOV W0, 0x1046
141:                   lcdSetCursorQ(col, 1);
007AD8  B3C011     MOV.B #0x1, W1
007ADA  784009     MOV.B W9, W0
007ADC  07FE64     RCALL lcdSetCursorQ
142:                   if(!pad[8]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007ADE  268A40     MOV #0x68A4, W0
007AE0  E00410     CP0.B [W0]
007AE2  3A000B     BRA NZ, 0x7AFA
007AE4  808230     MOV 0x1046, W0
007AE6  200201     MOV #0x20, W1
007AE8  781801     MOV W1, [W0++]
007AEA  888230     MOV W0, 0x1046
007AEC  26AC01     MOV #0x6AC0, W1
007AEE  500F81     SUB W0, W1, [W15]
007AF0  3A000E     BRA NZ, 0x7B0E
007AF2  2FE000     MOV #0xFE00, W0
007AF4  400001     ADD W0, W1, W0
007AF6  888230     MOV W0, 0x1046
007AF8  37000A     BRA 0x7B0E
007AFA  FB8088     ZE W8, W1
007AFC  808230     MOV 0x1046, W0
007AFE  781801     MOV W1, [W0++]
007B00  888230     MOV W0, 0x1046
007B02  26AC01     MOV #0x6AC0, W1
007B04  500F81     SUB W0, W1, [W15]
007B06  3A0003     BRA NZ, 0x7B0E
007B08  2FE000     MOV #0xFE00, W0
007B0A  400001     ADD W0, W1, W0
007B0C  888230     MOV W0, 0x1046
143:                   if(!pad[9]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007B0E  268A50     MOV #0x68A5, W0
007B10  E00410     CP0.B [W0]
007B12  3A000B     BRA NZ, 0x7B2A
007B14  808230     MOV 0x1046, W0
007B16  200201     MOV #0x20, W1
007B18  781801     MOV W1, [W0++]
007B1A  888230     MOV W0, 0x1046
007B1C  26AC01     MOV #0x6AC0, W1
007B1E  500F81     SUB W0, W1, [W15]
007B20  3A000E     BRA NZ, 0x7B3E
007B22  2FE000     MOV #0xFE00, W0
007B24  400001     ADD W0, W1, W0
007B26  888230     MOV W0, 0x1046
007B28  37000A     BRA 0x7B3E
007B2A  FB8088     ZE W8, W1
007B2C  808230     MOV 0x1046, W0
007B2E  781801     MOV W1, [W0++]
007B30  888230     MOV W0, 0x1046
007B32  26AC01     MOV #0x6AC0, W1
007B34  500F81     SUB W0, W1, [W15]
007B36  3A0003     BRA NZ, 0x7B3E
007B38  2FE000     MOV #0xFE00, W0
007B3A  400001     ADD W0, W1, W0
007B3C  888230     MOV W0, 0x1046
144:                   if(!pad[10]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007B3E  268A60     MOV #0x68A6, W0
007B40  E00410     CP0.B [W0]
007B42  3A000B     BRA NZ, 0x7B5A
007B44  808230     MOV 0x1046, W0
007B46  200201     MOV #0x20, W1
007B48  781801     MOV W1, [W0++]
007B4A  888230     MOV W0, 0x1046
007B4C  26AC01     MOV #0x6AC0, W1
007B4E  500F81     SUB W0, W1, [W15]
007B50  3A000E     BRA NZ, 0x7B6E
007B52  2FE000     MOV #0xFE00, W0
007B54  400001     ADD W0, W1, W0
007B56  888230     MOV W0, 0x1046
007B58  37000A     BRA 0x7B6E
007B5A  FB8088     ZE W8, W1
007B5C  808230     MOV 0x1046, W0
007B5E  781801     MOV W1, [W0++]
007B60  888230     MOV W0, 0x1046
007B62  26AC01     MOV #0x6AC0, W1
007B64  500F81     SUB W0, W1, [W15]
007B66  3A0003     BRA NZ, 0x7B6E
007B68  2FE000     MOV #0xFE00, W0
007B6A  400001     ADD W0, W1, W0
007B6C  888230     MOV W0, 0x1046
145:                   if(!pad[11]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007B6E  268A70     MOV #0x68A7, W0
007B70  E00410     CP0.B [W0]
007B72  3A000B     BRA NZ, 0x7B8A
007B74  808230     MOV 0x1046, W0
007B76  200201     MOV #0x20, W1
007B78  781801     MOV W1, [W0++]
007B7A  888230     MOV W0, 0x1046
007B7C  26AC01     MOV #0x6AC0, W1
007B7E  500F81     SUB W0, W1, [W15]
007B80  3A000E     BRA NZ, 0x7B9E
007B82  2FE000     MOV #0xFE00, W0
007B84  400001     ADD W0, W1, W0
007B86  888230     MOV W0, 0x1046
007B88  37000A     BRA 0x7B9E
007B8A  FB8088     ZE W8, W1
007B8C  808230     MOV 0x1046, W0
007B8E  781801     MOV W1, [W0++]
007B90  888230     MOV W0, 0x1046
007B92  26AC01     MOV #0x6AC0, W1
007B94  500F81     SUB W0, W1, [W15]
007B96  3A0003     BRA NZ, 0x7B9E
007B98  2FE000     MOV #0xFE00, W0
007B9A  400001     ADD W0, W1, W0
007B9C  888230     MOV W0, 0x1046
146:                   lcdSetCursorQ(col, 2);
007B9E  B3C021     MOV.B #0x2, W1
007BA0  784009     MOV.B W9, W0
007BA2  07FE01     RCALL lcdSetCursorQ
147:                   if(!pad[4]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007BA4  268A00     MOV #0x68A0, W0
007BA6  E00410     CP0.B [W0]
007BA8  3A000B     BRA NZ, 0x7BC0
007BAA  808230     MOV 0x1046, W0
007BAC  200201     MOV #0x20, W1
007BAE  781801     MOV W1, [W0++]
007BB0  888230     MOV W0, 0x1046
007BB2  26AC01     MOV #0x6AC0, W1
007BB4  500F81     SUB W0, W1, [W15]
007BB6  3A000E     BRA NZ, 0x7BD4
007BB8  2FE000     MOV #0xFE00, W0
007BBA  400001     ADD W0, W1, W0
007BBC  888230     MOV W0, 0x1046
007BBE  37000A     BRA 0x7BD4
007BC0  FB8088     ZE W8, W1
007BC2  808230     MOV 0x1046, W0
007BC4  781801     MOV W1, [W0++]
007BC6  888230     MOV W0, 0x1046
007BC8  26AC01     MOV #0x6AC0, W1
007BCA  500F81     SUB W0, W1, [W15]
007BCC  3A0003     BRA NZ, 0x7BD4
007BCE  2FE000     MOV #0xFE00, W0
007BD0  400001     ADD W0, W1, W0
007BD2  888230     MOV W0, 0x1046
148:                   if(!pad[5]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007BD4  268A10     MOV #0x68A1, W0
007BD6  E00410     CP0.B [W0]
007BD8  3A000B     BRA NZ, 0x7BF0
007BDA  808230     MOV 0x1046, W0
007BDC  200201     MOV #0x20, W1
007BDE  781801     MOV W1, [W0++]
007BE0  888230     MOV W0, 0x1046
007BE2  26AC01     MOV #0x6AC0, W1
007BE4  500F81     SUB W0, W1, [W15]
007BE6  3A000E     BRA NZ, 0x7C04
007BE8  2FE000     MOV #0xFE00, W0
007BEA  400001     ADD W0, W1, W0
007BEC  888230     MOV W0, 0x1046
007BEE  37000A     BRA 0x7C04
007BF0  FB8088     ZE W8, W1
007BF2  808230     MOV 0x1046, W0
007BF4  781801     MOV W1, [W0++]
007BF6  888230     MOV W0, 0x1046
007BF8  26AC01     MOV #0x6AC0, W1
007BFA  500F81     SUB W0, W1, [W15]
007BFC  3A0003     BRA NZ, 0x7C04
007BFE  2FE000     MOV #0xFE00, W0
007C00  400001     ADD W0, W1, W0
007C02  888230     MOV W0, 0x1046
149:                   if(!pad[6]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007C04  268A20     MOV #0x68A2, W0
007C06  E00410     CP0.B [W0]
007C08  3A000B     BRA NZ, 0x7C20
007C0A  808230     MOV 0x1046, W0
007C0C  200201     MOV #0x20, W1
007C0E  781801     MOV W1, [W0++]
007C10  888230     MOV W0, 0x1046
007C12  26AC01     MOV #0x6AC0, W1
007C14  500F81     SUB W0, W1, [W15]
007C16  3A000E     BRA NZ, 0x7C34
007C18  2FE000     MOV #0xFE00, W0
007C1A  400001     ADD W0, W1, W0
007C1C  888230     MOV W0, 0x1046
007C1E  37000A     BRA 0x7C34
007C20  FB8088     ZE W8, W1
007C22  808230     MOV 0x1046, W0
007C24  781801     MOV W1, [W0++]
007C26  888230     MOV W0, 0x1046
007C28  26AC01     MOV #0x6AC0, W1
007C2A  500F81     SUB W0, W1, [W15]
007C2C  3A0003     BRA NZ, 0x7C34
007C2E  2FE000     MOV #0xFE00, W0
007C30  400001     ADD W0, W1, W0
007C32  888230     MOV W0, 0x1046
150:                   if(!pad[7]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007C34  268A30     MOV #0x68A3, W0
007C36  E00410     CP0.B [W0]
007C38  3A000B     BRA NZ, 0x7C50
007C3A  808230     MOV 0x1046, W0
007C3C  200201     MOV #0x20, W1
007C3E  781801     MOV W1, [W0++]
007C40  888230     MOV W0, 0x1046
007C42  26AC01     MOV #0x6AC0, W1
007C44  500F81     SUB W0, W1, [W15]
007C46  3A000E     BRA NZ, 0x7C64
007C48  2FE000     MOV #0xFE00, W0
007C4A  400001     ADD W0, W1, W0
007C4C  888230     MOV W0, 0x1046
007C4E  37000A     BRA 0x7C64
007C50  FB8088     ZE W8, W1
007C52  808230     MOV 0x1046, W0
007C54  781801     MOV W1, [W0++]
007C56  888230     MOV W0, 0x1046
007C58  26AC01     MOV #0x6AC0, W1
007C5A  500F81     SUB W0, W1, [W15]
007C5C  3A0003     BRA NZ, 0x7C64
007C5E  2FE000     MOV #0xFE00, W0
007C60  400001     ADD W0, W1, W0
007C62  888230     MOV W0, 0x1046
151:                   lcdSetCursorQ(col, 3);
007C64  B3C031     MOV.B #0x3, W1
007C66  784009     MOV.B W9, W0
007C68  07FD9E     RCALL lcdSetCursorQ
152:                   if(!pad[0]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007C6A  2689C0     MOV #0x689C, W0
007C6C  E00410     CP0.B [W0]
007C6E  3A000B     BRA NZ, 0x7C86
007C70  808230     MOV 0x1046, W0
007C72  200201     MOV #0x20, W1
007C74  781801     MOV W1, [W0++]
007C76  888230     MOV W0, 0x1046
007C78  26AC01     MOV #0x6AC0, W1
007C7A  500F81     SUB W0, W1, [W15]
007C7C  3A000E     BRA NZ, 0x7C9A
007C7E  2FE000     MOV #0xFE00, W0
007C80  400001     ADD W0, W1, W0
007C82  888230     MOV W0, 0x1046
007C84  37000A     BRA 0x7C9A
007C86  FB8088     ZE W8, W1
007C88  808230     MOV 0x1046, W0
007C8A  781801     MOV W1, [W0++]
007C8C  888230     MOV W0, 0x1046
007C8E  26AC01     MOV #0x6AC0, W1
007C90  500F81     SUB W0, W1, [W15]
007C92  3A0003     BRA NZ, 0x7C9A
007C94  2FE000     MOV #0xFE00, W0
007C96  400001     ADD W0, W1, W0
007C98  888230     MOV W0, 0x1046
153:                   if(!pad[1]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007C9A  2689D0     MOV #0x689D, W0
007C9C  E00410     CP0.B [W0]
007C9E  3A000B     BRA NZ, 0x7CB6
007CA0  808230     MOV 0x1046, W0
007CA2  200201     MOV #0x20, W1
007CA4  781801     MOV W1, [W0++]
007CA6  888230     MOV W0, 0x1046
007CA8  26AC01     MOV #0x6AC0, W1
007CAA  500F81     SUB W0, W1, [W15]
007CAC  3A000E     BRA NZ, 0x7CCA
007CAE  2FE000     MOV #0xFE00, W0
007CB0  400001     ADD W0, W1, W0
007CB2  888230     MOV W0, 0x1046
007CB4  37000A     BRA 0x7CCA
007CB6  FB8088     ZE W8, W1
007CB8  808230     MOV 0x1046, W0
007CBA  781801     MOV W1, [W0++]
007CBC  888230     MOV W0, 0x1046
007CBE  26AC01     MOV #0x6AC0, W1
007CC0  500F81     SUB W0, W1, [W15]
007CC2  3A0003     BRA NZ, 0x7CCA
007CC4  2FE000     MOV #0xFE00, W0
007CC6  400001     ADD W0, W1, W0
007CC8  888230     MOV W0, 0x1046
154:                   if(!pad[2]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007CCA  2689E0     MOV #0x689E, W0
007CCC  E00410     CP0.B [W0]
007CCE  3A000B     BRA NZ, 0x7CE6
007CD0  808230     MOV 0x1046, W0
007CD2  200201     MOV #0x20, W1
007CD4  781801     MOV W1, [W0++]
007CD6  888230     MOV W0, 0x1046
007CD8  26AC01     MOV #0x6AC0, W1
007CDA  500F81     SUB W0, W1, [W15]
007CDC  3A000E     BRA NZ, 0x7CFA
007CDE  2FE000     MOV #0xFE00, W0
007CE0  400001     ADD W0, W1, W0
007CE2  888230     MOV W0, 0x1046
007CE4  37000A     BRA 0x7CFA
007CE6  FB8088     ZE W8, W1
007CE8  808230     MOV 0x1046, W0
007CEA  781801     MOV W1, [W0++]
007CEC  888230     MOV W0, 0x1046
007CEE  26AC01     MOV #0x6AC0, W1
007CF0  500F81     SUB W0, W1, [W15]
007CF2  3A0003     BRA NZ, 0x7CFA
007CF4  2FE000     MOV #0xFE00, W0
007CF6  400001     ADD W0, W1, W0
007CF8  888230     MOV W0, 0x1046
155:                   if(!pad[3]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007CFA  2689F0     MOV #0x689F, W0
007CFC  E00410     CP0.B [W0]
007CFE  3A000B     BRA NZ, 0x7D16
007D00  808230     MOV 0x1046, W0
007D02  200201     MOV #0x20, W1
007D04  781801     MOV W1, [W0++]
007D06  888230     MOV W0, 0x1046
007D08  26AC01     MOV #0x6AC0, W1
007D0A  500F81     SUB W0, W1, [W15]
007D0C  3A000E     BRA NZ, 0x7D2A
007D0E  2FE000     MOV #0xFE00, W0
007D10  400001     ADD W0, W1, W0
007D12  888230     MOV W0, 0x1046
007D14  37000A     BRA 0x7D2A
007D16  FB8408     ZE W8, W8
007D18  808230     MOV 0x1046, W0
007D1A  781808     MOV W8, [W0++]
007D1C  888230     MOV W0, 0x1046
007D1E  26AC01     MOV #0x6AC0, W1
007D20  500F81     SUB W0, W1, [W15]
007D22  3A0003     BRA NZ, 0x7D2A
007D24  2FE000     MOV #0xFE00, W0
007D26  400001     ADD W0, W1, W0
007D28  888230     MOV W0, 0x1046
156:               }
007D2A  BE044F     MOV.D [--W15], W8
007D2C  060000     RETURN
157:               
158:               void lcdPoll(void){  
159:                   if(lcdWritePtr!=lcdReadPtr){   
007D2E  808240     MOV 0x1048, W0
007D30  E31046     CP 0x1046
007D32  320018     BRA Z, 0x7D64
160:                       if((*lcdReadPtr>>8)&1) LCD_RS=0;
007D34  201001     MOV #0x100, W1
007D36  608090     AND W1, [W0], W1
007D38  320002     BRA Z, 0x7D3E
007D3A  A9EE45     BCLR 0xE45, #7
007D3C  370001     BRA 0x7D40
161:                       else LCD_RS=1;
007D3E  A8EE45     BSET 0xE45, #7
162:                       if((*lcdReadPtr>>9)&1) PR3=0x2DF0; //2DF0 for ~1.3mS
007D40  202001     MOV #0x200, W1
007D42  608090     AND W1, [W0], W1
007D44  320003     BRA Z, 0x7D4C
007D46  22DF01     MOV #0x2DF0, W1
007D48  880871     MOV W1, PR3
007D4A  370002     BRA 0x7D50
163:                       else PR3=0x0120; //120 for ~40uS
007D4C  201201     MOV #0x120, W1
007D4E  880871     MOV W1, PR3
164:                       PMDIN1=(*lcdReadPtr++)&0x00FF;
007D50  200FF1     MOV #0xFF, W1
007D52  6080B0     AND W1, [W0++], W1
007D54  883041     MOV W1, PMDIN1
007D56  888240     MOV W0, 0x1048
165:                       if(lcdReadPtr==&lcdBuf[LCDBUF]) lcdReadPtr=lcdBuf;
007D58  26AC01     MOV #0x6AC0, W1
007D5A  500F81     SUB W0, W1, [W15]
007D5C  3A0003     BRA NZ, 0x7D64
007D5E  2FE000     MOV #0xFE00, W0
007D60  400001     ADD W0, W1, W0
007D62  888240     MOV W0, 0x1048
166:                   } 
167:                   TMR3=0x0000; 
007D64  EF210A     CLR TMR3
168:               }
007D66  060000     RETURN
169:               
170:               //ALWAYS SENDS, blocks program
171:               void lcdBlockingSend(unsigned char data){
007D68  BE9F88     MOV.D W8, [W15++]
007D6A  781F8A     MOV W10, [W15++]
007D6C  784500     MOV.B W0, W10
172:                   while(PMMODEbits.BUSY)Delay_us(2);
007D6E  E20602     CP0 PMMODE
007D70  3D0007     BRA GE, 0x7D80
007D72  200028     MOV #0x2, W8
007D74  280009     MOV #0x8000, W9
007D76  780008     MOV W8, W0
007D78  07049F     RCALL Delay_us
007D7A  803011     MOV PMMODE, W1
007D7C  648001     AND W9, W1, W0
007D7E  3AFFFB     BRA NZ, 0x7D76
173:                   PMDIN1=data; 
007D80  FB850A     ZE W10, W10
007D82  88304A     MOV W10, PMDIN1
174:               }
007D84  78054F     MOV [--W15], W10
007D86  BE044F     MOV.D [--W15], W8
007D88  060000     RETURN
175:               //ALWAYS SENDS, blocks program
176:               void lcdBlockingClear(void){
007D8A  BE9F88     MOV.D W8, [W15++]
177:                   while(PMMODEbits.BUSY)Delay_us(2);
007D8C  E20602     CP0 PMMODE
007D8E  3D0007     BRA GE, 0x7D9E
007D90  200028     MOV #0x2, W8
007D92  280009     MOV #0x8000, W9
007D94  780008     MOV W8, W0
007D96  070490     RCALL Delay_us
007D98  803011     MOV PMMODE, W1
007D9A  648001     AND W9, W1, W0
007D9C  3AFFFB     BRA NZ, 0x7D94
178:                   PMDIN1=LCD_CLEARDISPLAY; 
007D9E  200010     MOV #0x1, W0
007DA0  883040     MOV W0, PMDIN1
179:               }
007DA2  BE044F     MOV.D [--W15], W8
007DA4  060000     RETURN
180:               
181:               //ALWAYS SENDS, blocks program
182:               void lcdBlockingReturn(void){
007DA6  BE9F88     MOV.D W8, [W15++]
183:                   while(PMMODEbits.BUSY)Delay_us(2);
007DA8  E20602     CP0 PMMODE
007DAA  3D0007     BRA GE, 0x7DBA
007DAC  200028     MOV #0x2, W8
007DAE  280009     MOV #0x8000, W9
007DB0  780008     MOV W8, W0
007DB2  070482     RCALL Delay_us
007DB4  803011     MOV PMMODE, W1
007DB6  648001     AND W9, W1, W0
007DB8  3AFFFB     BRA NZ, 0x7DB0
184:                   PMDIN1=LCD_RETURNHOME;
007DBA  200020     MOV #0x2, W0
007DBC  883040     MOV W0, PMDIN1
185:               }
007DBE  BE044F     MOV.D [--W15], W8
007DC0  060000     RETURN
186:               
187:               void lcdInit(void){
188:                   LCD_RS=0;
007DC2  A9EE45     BCLR 0xE45, #7
189:                   lcdBlockingSend(0x38);              //function set, 8 bits, 2 line disp, 5x8
007DC4  B3C380     MOV.B #0x38, W0
007DC6  07FFD0     RCALL lcdBlockingSend
190:                   Delay_us(4500);                //>4.1 mS required
007DC8  211940     MOV #0x1194, W0
007DCA  070476     RCALL Delay_us
191:                   lcdBlockingSend(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
007DCC  B3C0C0     MOV.B #0xC, W0
007DCE  07FFCC     RCALL lcdBlockingSend
192:                   Delay_us(4500);
007DD0  211940     MOV #0x1194, W0
007DD2  070472     RCALL Delay_us
193:                   lcdBlockingClear();                    //Display Clear  
007DD4  07FFDA     RCALL lcdBlockingClear
194:                   Delay_us(1800);                //>1.64mS required
007DD6  207080     MOV #0x708, W0
007DD8  07046F     RCALL Delay_us
195:                   lcdBlockingSend(0x06);               // entry Mode Set
007DDA  B3C060     MOV.B #0x6, W0
007DDC  07FFC5     RCALL lcdBlockingSend
196:                   Delay_us(200);
007DDE  200C80     MOV #0xC8, W0
007DE0  07046B     RCALL Delay_us
197:                   lcdBlockingReturn();
007DE2  07FFE1     RCALL lcdBlockingReturn
198:                   Delay_us(1500);
007DE4  205DC0     MOV #0x5DC, W0
007DE6  070468     RCALL Delay_us
199:                   
200:                   //lcdCustomSymbols();
201:                   Delay_us(200);
007DE8  200C80     MOV #0xC8, W0
007DEA  070466     RCALL Delay_us
202:                   lcdBlockingClear();                         //Display Clear  
007DEC  07FFCE     RCALL lcdBlockingClear
203:                   Delay_us(1500);
007DEE  205DC0     MOV #0x5DC, W0
007DF0  070463     RCALL Delay_us
204:                   lcdBlockingReturn();
007DF2  07FFD9     RCALL lcdBlockingReturn
205:                   Delay_us(200);
007DF4  200C80     MOV #0xC8, W0
007DF6  070460     RCALL Delay_us
206:               }
007DF8  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/main.c  -----------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 #include "plcd.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = OFF   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                /* Data Buffers & index variables */
22:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
23:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
24:                unsigned int write_ptr=STREAMBUF, rw=0, frameReady=0;
25:                
26:                /* DMA BUFFERS */
27:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
28:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
29:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
31:                
32:                
33:                /* Debug Variables */
34:                unsigned int process_time=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                              
37:                volatile unsigned char recording=TRUE;
38:                unsigned char UART_ON = FALSE;
39:                unsigned char TEST_SIN = FALSE;
40:                
41:                volatile unsigned char tremelo=FALSE;                                       
42:                volatile unsigned char looper=FALSE;
43:                volatile unsigned char lpf=FALSE;
44:                
45:                char flash_readback[512]={0};
46:                
47:                /* Screen state variables */
48:                enum screen state = scrnFX;
49:                enum screen laststate = invalid;
50:                
51:                /* Buttons & Potentiometers */
52:                unsigned char pad[BUTTONS];                                                            
53:                fractional pots[POTS]={0};
54:                fractional pots_percent[POTS]={0};
55:                
56:                void initBuffer(void){
008B60  2649A7     MOV #0x649A, W7
008B62  2669A6     MOV #0x669A, W6
008B64  2CDFE5     MOV #0xCDFE, W5
008B66  2CBFE4     MOV #0xCBFE, W4
008B68  2C9FE3     MOV #0xC9FE, W3
008B6A  2C7FE2     MOV #0xC7FE, W2
008B6C  201001     MOV #0x100, W1
008B82  200232     MOV #0x23, W2
008B84  410100     ADD W2, W0, W2
57:                    int i;
58:                    for(i=0; i<STREAMBUF; i++){
008B7E  3AFFF8     BRA NZ, 0x8B70
008B80  2689B0     MOV #0x689B, W0
59:                        streamA[i]=0;
008B6E  EB0000     CLR W0
008B70  782B80     MOV W0, [++W7]
60:                        streamB[i]=0;
008B72  782B00     MOV W0, [++W6]
61:                        txBufferA[i]=0;
008B74  782A80     MOV W0, [++W5]
62:                        txBufferB[i]=0;
008B76  782A00     MOV W0, [++W4]
63:                        rxBufferA[i]=0;
008B78  782980     MOV W0, [++W3]
64:                        rxBufferB[i]=0;
008B7A  782900     MOV W0, [++W2]
008B7C  E90081     DEC W1, W1
65:                    }
66:                    
67:                    for(i=0; i<BUTTONS; i++)
008B8A  500F82     SUB W0, W2, [W15]
008B8C  3AFFFD     BRA NZ, 0x8B88
68:                        pad[i]=1;
008B86  B3C011     MOV.B #0x1, W1
008B88  786801     MOV.B W1, [++W0]
69:                }
008B8E  060000     RETURN
70:                
71:                int main(void) {
008B90  BE9F88     MOV.D W8, [W15++]
008B92  BE9F8A     MOV.D W10, [W15++]
008B94  781F8C     MOV W12, [W15++]
72:                    initPorts();                    //configure io device & adc 
008B96  07F931     RCALL initPorts
73:                    //initUART1();                    //configure & enable UART
74:                    initBuffer();
008B98  07FFE3     RCALL initBuffer
75:                    initADC1();                     //configure & enable internal ADC
008B9A  07F9F6     RCALL initADC1
76:                    initPMP();
008B9C  07FA13     RCALL initPMP
77:                    //||||||||----
78:                    //initDMA0();
79:                    initDCI_DAC();                  //configure & enable DAC
008B9E  07FA51     RCALL initDCI_DAC
80:                    initT1();                       //configure & start T1 
008BA0  07FA25     RCALL initT1
81:                    initT2();                       //configure & start T2 
008BA2  07FA2D     RCALL initT2
82:                    initSPI3_MEM();                  //start segment display
008BA4  07FAC6     RCALL initSPI3_MEM
83:                    //initCAP_BPM();                  //configure bpm capture
84:                    initT3();                       //configure & start T3 for lcd
008BA6  07FA37     RCALL initT3
85:                    initQEI_ENC();
008BA8  07FAE6     RCALL initQEI_ENC
86:                    //initT5();
87:                    fractional temp;
88:                    fractional *ping, *pong;
89:                    
90:                    while(1){    
91:                        if(frameReady) {
008BB4  E21014     CP0 frameReady
008BB6  32000F     BRA Z, 0x8BD6
92:                            process_time=(STREAMBUF-1);             //DEBUG
008BB8  200FF0     MOV #0xFF, W0
008BBA  8880B0     MOV W0, process_time
93:                            if(rw){
008BBC  E21012     CP0 rw
008BBE  320003     BRA Z, 0x8BC6
94:                                ping = streamA+(STREAMBUF-1);
008BB0  2669AC     MOV #0x669A, W12
008BC2  78000C     MOV W12, W0
008BC4  370002     BRA 0x8BCA
95:                                pong = outputB+(STREAMBUF-1);
008BAE  2649AB     MOV #0x649A, W11
008BC0  78008B     MOV W11, W1
96:                            }else{
97:                                ping = streamB+(STREAMBUF-1);
008BAC  2689AA     MOV #0x689A, W10
008BC8  78000A     MOV W10, W0
98:                                pong = outputA+(STREAMBUF-1);
008BAA  2629A9     MOV #0x629A, W9
008BC6  780089     MOV W9, W1
99:                            }
100:                           
101:                           processAudio(ping, pong); 
008BCA  07FE12     RCALL processAudio
102:                           process_time=(STREAMBUF-1)-write_ptr;    //DEBUG
008BCC  8081D0     MOV 0x103A, W0
008BCE  200FF1     MOV #0xFF, W1
008BD0  508000     SUB W1, W0, W0
008BD2  8880B0     MOV W0, process_time
103:                           frameReady=0;
008BD4  EF3014     CLR frameReady
104:                           
105:                           
106:                       }
107:                       if(_T2IF){
008BD6  ABE800     BTST IFS0, #7
008BD8  320006     BRA Z, 0x8BE6
108:                           scanButtons();                   //read button matrix
008BDA  07FC3B     RCALL scanButtons
109:                           if(_AD1IF) readPots();
008BB2  220008     MOV #0x2000, W8
008BDC  804001     MOV IFS0, W1
008BDE  640001     AND W8, W1, W0
008BE0  320001     BRA Z, 0x8BE4
008BE2  07FCDB     RCALL readPots
110:                           _T2IF=0;
008BE4  A9E800     BCLR IFS0, #7
111:                       }
112:                       if(_T1IF){
008BE6  AB6800     BTST IFS0, #3
008BE8  320002     BRA Z, 0x8BEE
113:                           display();
008BEA  07FD47     RCALL display
114:                           _T1IF=0;
008BEC  A96800     BCLR IFS0, #3
115:                       }
116:                       if(_T3IF) {
008BEE  AB0801     BTST 0x801, #0
008BF0  32FFE1     BRA Z, 0x8BB4
117:                           lcdPoll();
008BF2  07F89D     RCALL lcdPoll
118:                           _T3IF=0;
008BF4  A90801     BCLR 0x801, #0
008BF6  37FFDE     BRA 0x8BB4
119:                       }
120:                   }
121:                   return 0;
122:               }
123:               // example test 
---  C:/Users/ryan/Documents/seniorproject/ps-040/flash.c  ----------------------------------------------
1:                 /*
2:                  * File:   flash.c
3:                  * Author: root
4:                  *
5:                  * Created on January 28, 2018, 5:00 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "flash.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                char flashBuf[STREAMBUF*2];
15:                char receive;
16:                
17:                void flashWriteReg(char command) {
18:                    SS3=0;
008A3A  A92E54     BCLR LATF, #1
19:                    SPI3BUF=command;               //WEL=1 for write enable
008A3C  FB0000     SE W0, W0
008A3E  881540     MOV W0, SPI3BUF
20:                    while(!_SPI3IF); _SPI3IF=0;
008A40  208001     MOV #0x800, W1
008A42  804052     MOV IFS5, W2
008A44  608002     AND W1, W2, W0
008A46  32FFFD     BRA Z, 0x8A42
008A48  A9680B     BCLR 0x80B, #3
21:                    receive=SPI3BUF;
008A4A  801540     MOV SPI3BUF, W0
008A4C  B7F04A     MOV.B WREG, receive
22:                    SS3=1;
008A4E  A82E54     BSET LATF, #1
23:                }
008A50  060000     RETURN
24:                
25:                char flashStatusCheck(void){
26:                    SS3=0;
008A52  A92E54     BCLR LATF, #1
27:                    SPI3BUF=FLASH_RDSR1;               //WEL=1 for write enable
008A54  200050     MOV #0x5, W0
008A56  881540     MOV W0, SPI3BUF
28:                    while(!_SPI3IF); _SPI3IF=0;
008A58  208001     MOV #0x800, W1
008A5A  804052     MOV IFS5, W2
008A5C  608002     AND W1, W2, W0
008A5E  32FFFD     BRA Z, 0x8A5A
008A60  A9680B     BCLR 0x80B, #3
29:                    receive=SPI3BUF;
008A62  801540     MOV SPI3BUF, W0
30:                    SPI3BUF=0x00;               //WEL=1 for write enable
008A64  EF22A8     CLR SPI3BUF
31:                    while(!_SPI3IF); _SPI3IF=0;
008A66  208001     MOV #0x800, W1
008A68  804052     MOV IFS5, W2
008A6A  608002     AND W1, W2, W0
008A6C  32FFFD     BRA Z, 0x8A68
008A6E  A9680B     BCLR 0x80B, #3
32:                    receive=SPI3BUF;
008A70  801540     MOV SPI3BUF, W0
008A72  B7F04A     MOV.B WREG, receive
33:                    SS3=1;
008A74  A82E54     BSET LATF, #1
34:                    
35:                    return receive;
36:                }
008A76  060000     RETURN
37:                
38:                void flashWritePage(int addressH, int addressL){
39:                    int i;
40:                    SS3=0;
008A78  A92E54     BCLR LATF, #1
41:                    SPI3BUF=FLASH_PP;
008A7A  200022     MOV #0x2, W2
008A7C  881542     MOV W2, SPI3BUF
42:                    while(!_SPI3IF); _SPI3IF=0;
008A7E  208003     MOV #0x800, W3
008A80  804054     MOV IFS5, W4
008A82  618104     AND W3, W4, W2
008A84  32FFFD     BRA Z, 0x8A80
008A86  A9680B     BCLR 0x80B, #3
43:                    receive=SPI3BUF;
008A88  801542     MOV SPI3BUF, W2
44:                    SPI3BUF=addressH&&0xFF;
008A8A  A7F000     BTSC W0, #15
008A8C  EA0000     NEG W0, W0
008A8E  EA0000     NEG W0, W0
008A90  DE004F     LSR W0, #15, W0
008A92  881540     MOV W0, SPI3BUF
45:                    while(!_SPI3IF); _SPI3IF=0;
008A94  208002     MOV #0x800, W2
008A96  804053     MOV IFS5, W3
008A98  610003     AND W2, W3, W0
008A9A  32FFFD     BRA Z, 0x8A96
008A9C  A9680B     BCLR 0x80B, #3
46:                    receive=SPI3BUF;
008A9E  801540     MOV SPI3BUF, W0
47:                    SPI3BUF=(addressL&&0xFF00)>>8;
008AA0  EF22A8     CLR SPI3BUF
48:                    while(!_SPI3IF); _SPI3IF=0;
008AA2  208002     MOV #0x800, W2
008AA4  804054     MOV IFS5, W4
008AA6  610004     AND W2, W4, W0
008AA8  32FFFD     BRA Z, 0x8AA4
008AAA  A9680B     BCLR 0x80B, #3
49:                    receive=SPI3BUF;
008AAC  801540     MOV SPI3BUF, W0
50:                    SPI3BUF=addressL&&0xFF;
008AAE  780001     MOV W1, W0
008AB0  A7F000     BTSC W0, #15
008AB2  EA0000     NEG W0, W0
008AB4  EA0000     NEG W0, W0
008AB6  DE004F     LSR W0, #15, W0
008AB8  881540     MOV W0, SPI3BUF
51:                    while(!_SPI3IF); _SPI3IF=0;
008ABA  208001     MOV #0x800, W1
008ABC  804052     MOV IFS5, W2
008ABE  608002     AND W1, W2, W0
008AC0  32FFFD     BRA Z, 0x8ABC
008AC2  A9680B     BCLR 0x80B, #3
52:                    receive=SPI3BUF;
008AC4  801540     MOV SPI3BUF, W0
008AC6  202002     MOV #0x200, W2
53:                    
54:                    for(i=0; i<512;i++){    //write 512 bytes
008ADA  3AFFF8     BRA NZ, 0x8ACC
008ADC  B7F04A     MOV.B WREG, receive
55:                        //send byte
56:                        SPI3BUF=0xAA;
008AC8  200AA3     MOV #0xAA, W3
008ACC  881543     MOV W3, SPI3BUF
57:                        while(!_SPI3IF); _SPI3IF=0;
008ACA  208001     MOV #0x800, W1
008ACE  804054     MOV IFS5, W4
008AD0  608004     AND W1, W4, W0
008AD2  32FFFD     BRA Z, 0x8ACE
008AD4  A9680B     BCLR 0x80B, #3
58:                        receive=SPI3BUF;
008AD6  801540     MOV SPI3BUF, W0
008AD8  E90102     DEC W2, W2
59:                    }
60:                    SS3=1;
008ADE  A82E54     BSET LATF, #1
61:                }
008AE0  060000     RETURN
62:                
63:                void flashRead(char *array, int bytes){
008AE2  BE9F88     MOV.D W8, [W15++]
008AE4  BE9F8A     MOV.D W10, [W15++]
008AE6  781F8C     MOV W12, [W15++]
008AE8  780581     MOV W1, W11
64:                    int i;
65:                    
66:                    SS3=0;
008AEA  A92E54     BCLR LATF, #1
67:                    SPI3BUF=FLASH_READ;
008AEC  200031     MOV #0x3, W1
008AEE  881541     MOV W1, SPI3BUF
68:                    while(!_SPI3IF); _SPI3IF=0;
008AF0  208002     MOV #0x800, W2
008AF2  804053     MOV IFS5, W3
008AF4  610083     AND W2, W3, W1
008AF6  32FFFD     BRA Z, 0x8AF2
008AF8  A9680B     BCLR 0x80B, #3
69:                    receive=SPI3BUF;
008AFA  801541     MOV SPI3BUF, W1
70:                    SPI3BUF=0x00;
008AFC  EF22A8     CLR SPI3BUF
71:                    while(!_SPI3IF); _SPI3IF=0;
008AFE  208002     MOV #0x800, W2
008B00  804053     MOV IFS5, W3
008B02  610083     AND W2, W3, W1
008B04  32FFFD     BRA Z, 0x8B00
008B06  A9680B     BCLR 0x80B, #3
72:                    receive=SPI3BUF;
008B08  801541     MOV SPI3BUF, W1
73:                    SPI3BUF=0x00;
008B0A  EF22A8     CLR SPI3BUF
74:                    while(!_SPI3IF); _SPI3IF=0;
008B0C  208002     MOV #0x800, W2
008B0E  804053     MOV IFS5, W3
008B10  610083     AND W2, W3, W1
008B12  32FFFD     BRA Z, 0x8B0E
008B14  A9680B     BCLR 0x80B, #3
75:                    receive=SPI3BUF;
008B16  801541     MOV SPI3BUF, W1
76:                    SPI3BUF=0x00;
008B18  EF22A8     CLR SPI3BUF
77:                    while(!_SPI3IF); _SPI3IF=0;
008B1A  208002     MOV #0x800, W2
008B1C  804053     MOV IFS5, W3
008B1E  610083     AND W2, W3, W1
008B20  32FFFD     BRA Z, 0x8B1C
008B22  A9680B     BCLR 0x80B, #3
78:                    receive=SPI3BUF;
008B24  801541     MOV SPI3BUF, W1
008B26  784181     MOV.B W1, W3
008B28  2104A2     MOV #0x104A, W2
008B2A  784903     MOV.B W3, [W2]
79:                    
80:                    for(i=0; i<bytes;i++){    //read 512 bytes
008B2C  E0000B     CP0 W11
008B2E  340010     BRA LE, 0x8B50
008B30  780500     MOV W0, W10
008B32  EB0480     CLR W9
008B4A  E80489     INC W9, W9
008B4C  558F89     SUB W11, W9, [W15]
008B4E  3CFFF4     BRA GT, 0x8B38
81:                        //receive byte
82:                        SPI3BUF=0x00;
008B34  EB0600     CLR W12
008B38  88154C     MOV W12, SPI3BUF
83:                        while(!_SPI3IF); _SPI3IF=0;
008B36  208008     MOV #0x800, W8
008B3A  804051     MOV IFS5, W1
008B3C  640001     AND W8, W1, W0
008B3E  32FFFD     BRA Z, 0x8B3A
008B40  A9680B     BCLR 0x80B, #3
84:                        Delay_us(1);
008B42  200010     MOV #0x1, W0
008B44  07FDB9     RCALL Delay_us
85:                        array[i]=SPI3BUF;
008B46  801540     MOV SPI3BUF, W0
008B48  785D00     MOV.B W0, [W10++]
86:                    }
87:                    SS3=1;
008B50  A82E54     BSET LATF, #1
88:                }
008B52  78064F     MOV [--W15], W12
008B54  BE054F     MOV.D [--W15], W10
008B56  BE044F     MOV.D [--W15], W8
008B58  060000     RETURN
89:                
90:                void flashBulkErase(void) {
91:                    flashWriteReg(FLASH_FRMT);
008B5A  B3C600     MOV.B #0x60, W0
008B5C  07FF6E     RCALL flashWriteReg
92:                }
008B5E  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/devInits.c  -------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 #include <xc.h>
5:                 #include <p33EP512GM310.h>
6:                 #include <libpic30.h>
7:                 #include "common.h"
8:                 #include "devInits.h"
9:                 #include "utilities.h"
10:                #include "plcd.h"
11:                #include "screens.h"
12:                #include "flash.h"
13:                #include "dsp.h"
14:                
15:                extern unsigned char UART_ON;
16:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
17:                
18:                extern char flash_readback[512];
19:                
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
007DFA  2FF3F0     MOV #0xFF3F, W0
007DFC  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
007DFE  2FFE00     MOV #0xFFE0, W0
007E00  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
007E02  2FE000     MOV #0xFE00, W0
007E04  B60746     AND PLLFBD, WREG
007E06  B30490     IOR #0x49, W0
007E08  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
007E0A  200201     MOV #0x20, W1
007E0C  803A12     MOV OSCCON, W2
007E0E  608002     AND W1, W2, W0
007E10  32FFFD     BRA Z, 0x7E0C
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
007E12  803A10     MOV OSCCON, W0
007E14  A16000     BCLR W0, #6
007E16  200462     MOV #0x46, W2
007E18  200573     MOV #0x57, W3
007E1A  207421     MOV #0x742, W1
007E1C  784882     MOV.B W2, [W1]
007E1E  784883     MOV.B W3, [W1]
007E20  784880     MOV.B W0, [W1]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
007E22  2FFC00     MOV #0xFFC0, W0
007E24  803424     MOV RPOR2, W4
007E26  600084     AND W0, W4, W1
007E28  A00001     BSET W1, #0
007E2A  883421     MOV W1, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
007E2C  2FF801     MOV #0xFF80, W1
007E2E  803685     MOV RPINR24, W5
007E30  608205     AND W1, W5, W4
007E32  B303D4     IOR #0x3D, W4
007E34  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
007E36  B60686     AND RPOR3, WREG
007E38  B300C0     IOR #0xC, W0
007E3A  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
007E3C  2C0FF0     MOV #0xC0FF, W0
007E3E  803426     MOV RPOR2, W6
007E40  600286     AND W0, W6, W5
007E42  20D004     MOV #0xD00, W4
007E44  720205     IOR W4, W5, W4
007E46  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
007E48  803434     MOV RPOR3, W4
007E4A  600284     AND W0, W4, W5
007E4C  20B004     MOV #0xB00, W4
007E4E  720205     IOR W4, W5, W4
007E50  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
007E52  803575     MOV RPINR7, W5
007E54  608205     AND W1, W5, W4
007E56  B305F4     IOR #0x5F, W4
007E58  883574     MOV W4, RPINR7
36:                    RPINR29bits.SCK3R=0x39;     //SCK3 input on pin 84
007E5A  280FF4     MOV #0x80FF, W4
007E5C  8036D5     MOV RPINR29, W5
007E5E  620305     AND W4, W5, W6
007E60  239005     MOV #0x3900, W5
007E62  728286     IOR W5, W6, W5
007E64  8836D5     MOV W5, RPINR29
37:                    RPOR7bits.RP57R=0x20;       //SCK3 output on pin 84
007E66  803476     MOV RPOR7, W6
007E68  600286     AND W0, W6, W5
007E6A  A0D005     BSET W5, #13
007E6C  883475     MOV W5, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
007E6E  803485     MOV RPOR8, W5
007E70  600305     AND W0, W5, W6
007E72  21F005     MOV #0x1F00, W5
007E74  728286     IOR W5, W6, W5
007E76  883485     MOV W5, RPOR8
39:                    RPOR9bits.RP97R=0x21;       //SS3 on pin 88
007E78  B60692     AND RPOR9, WREG
007E7A  221005     MOV #0x2100, W5
007E7C  728280     IOR W5, W0, W5
007E7E  883495     MOV W5, RPOR9
40:                    RPINR29bits.SDI3R=0x4C;     //SDI on pin 79, RPI76
007E80  8036D6     MOV RPINR29, W6
007E82  608006     AND W1, W6, W0
007E84  B304C0     IOR #0x4C, W0
007E86  8836D0     MOV W0, RPINR29
41:                    RPINR14bits.QEA1R=0x10;     //QEA on pin 22, RPI16
007E88  8035E0     MOV RPINR14, W0
007E8A  608080     AND W1, W0, W1
007E8C  A04001     BSET W1, #4
007E8E  8835E1     MOV W1, RPINR14
42:                    RPINR14bits.QEB1R=0x1B;     //QEB on pin 21, RPI27
007E90  8035E5     MOV RPINR14, W5
007E92  620205     AND W4, W5, W4
007E94  21B000     MOV #0x1B00, W0
007E96  700004     IOR W0, W4, W0
007E98  8835E0     MOV W0, RPINR14
43:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
007E9A  803A10     MOV OSCCON, W0
007E9C  A06000     BSET W0, #6
007E9E  207421     MOV #0x742, W1
007EA0  784882     MOV.B W2, [W1]
007EA2  784883     MOV.B W3, [W1]
007EA4  784880     MOV.B W0, [W1]
44:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
45:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
007EA6  EB8000     SETM W0
007EA8  883B60     MOV W0, PMD7
007EAA  F8076C     PUSH PMD7
007EAC  F9076A     POP PMD6
007EAE  F8076A     PUSH PMD6
007EB0  F90766     POP PMD4
007EB2  F80766     PUSH PMD4
007EB4  F90764     POP PMD3
007EB6  F80764     PUSH PMD3
007EB8  F90762     POP PMD2
007EBA  F80762     PUSH PMD2
007EBC  F90760     POP PMD1
46:                    PMD1bits.AD1MD=0;
007EBE  A90760     BCLR PMD1, #0
47:                    PMD1bits.SPI1MD=0;
007EC0  A96760     BCLR PMD1, #3
48:                    PMD1bits.SPI2MD=0;
007EC2  A98760     BCLR PMD1, #4
49:                    PMD1bits.U1MD=0;
007EC4  A9A760     BCLR PMD1, #5
50:                    PMD1bits.U2MD=0;
007EC6  A9C760     BCLR PMD1, #6
51:                    PMD1bits.DCIMD=0;
007EC8  A90761     BCLR 0x761, #0
52:                    PMD1bits.T1MD=0;
007ECA  A96761     BCLR 0x761, #3
53:                    PMD1bits.T2MD=0;
007ECC  A98761     BCLR 0x761, #4
54:                    PMD1bits.T3MD=0;
007ECE  A9A761     BCLR 0x761, #5
55:                    PMD1bits.T4MD=0;
007ED0  A9C761     BCLR 0x761, #6
56:                    PMD1bits.T5MD=0;
007ED2  A9E761     BCLR 0x761, #7
57:                    PMD3bits.PMPMD=0;
007ED4  A90765     BCLR 0x765, #0
58:                    PMD3bits.CMPMD=0;
007ED6  A94765     BCLR 0x765, #2
59:                    PMD6bits.SPI3MD=0;
007ED8  A9076A     BCLR PMD6, #0
60:                    PMD7bits.DMA0MD=0;
007EDA  A9876C     BCLR PMD7, #4
61:                    
62:                    /* Digital IO DIRECTION (1 = input) */
63:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
007EDC  EF2E60     CLR TRISG
007EDE  F80E60     PUSH TRISG
007EE0  F90E50     POP TRISF
007EE2  F80E50     PUSH TRISF
007EE4  F90E40     POP TRISE
007EE6  F80E40     PUSH TRISE
007EE8  F90E30     POP TRISD
007EEA  F80E30     PUSH TRISD
007EEC  F90E20     POP TRISC
007EEE  F80E20     PUSH TRISC
007EF0  F90E10     POP TRISB
007EF2  F80E10     PUSH TRISB
007EF4  F90E00     POP TRISA
64:                    TRISA=0x1E01; CNPUA=0x0801;
007EF6  21E011     MOV #0x1E01, W1
007EF8  887001     MOV W1, TRISA
007EFA  208011     MOV #0x801, W1
007EFC  887051     MOV W1, CNPUA
65:                    TRISB=0x0000; CNPUB=0x0000;
007EFE  EF2E10     CLR TRISB
007F00  EF2E1A     CLR CNPUB
66:                    TRISC=0x2087;
007F02  220871     MOV #0x2087, W1
007F04  887101     MOV W1, TRISC
67:                    TRISD=0x011E; CNPUD=0x001E;
007F06  2011E1     MOV #0x11E, W1
007F08  887181     MOV W1, TRISD
007F0A  2001E1     MOV #0x1E, W1
007F0C  8871D1     MOV W1, CNPUD
68:                    TRISE=0x7300;
007F0E  273001     MOV #0x7300, W1
007F10  887201     MOV W1, TRISE
69:                    TRISF=0x00F0; CNPUF=0x00F1;
007F12  200F01     MOV #0xF0, W1
007F14  887281     MOV W1, TRISF
007F16  E80081     INC W1, W1
007F18  8872D1     MOV W1, CNPUF
70:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
007F1A  887350     MOV W0, CNPUG
007F1C  F80E6A     PUSH CNPUG
007F1E  F90E60     POP TRISG
71:                    
72:                    /* DIGITAL OUTPUT LATCH */
73:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
007F20  EF2E64     CLR LATG
007F22  F80E64     PUSH LATG
007F24  F90E54     POP LATF
007F26  F80E54     PUSH LATF
007F28  F90E44     POP LATE
007F2A  F80E44     PUSH LATE
007F2C  F90E34     POP LATD
007F2E  F80E34     PUSH LATD
007F30  F90E24     POP LATC
007F32  F80E24     PUSH LATC
007F34  F90E14     POP LATB
007F36  F80E14     PUSH LATB
007F38  F90E04     POP LATA
74:                    LATA=0x0040;
007F3A  200400     MOV #0x40, W0
007F3C  887020     MOV W0, LATA
75:                    
76:                    /* ANALOG PINS (1 = analog) */
77:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
007F3E  EF2E6E     CLR ANSELG
007F40  F80E6E     PUSH ANSELG
007F42  F90E5E     POP ANSELF
007F44  F80E5E     PUSH ANSELF
007F46  F90E4E     POP ANSELE
007F48  F80E4E     PUSH ANSELE
007F4A  F90E3E     POP ANSELD
007F4C  F80E3E     PUSH ANSELD
007F4E  F90E2E     POP ANSELC
007F50  F80E2E     PUSH ANSELC
007F52  F90E1E     POP ANSELB
007F54  F80E1E     PUSH ANSELB
007F56  F90E0E     POP ANSELA
78:                    ANSELCbits.ANSC0=1;     //AN6
007F58  A80E2E     BSET ANSELC, #0
79:                    ANSELCbits.ANSC1=1;     //AN7
007F5A  A82E2E     BSET ANSELC, #1
80:                    ANSELCbits.ANSC2=1;     //AN8
007F5C  A84E2E     BSET ANSELC, #2
81:                    ANSELAbits.ANSA12=1;    //AN10 
007F5E  A88E0F     BSET 0xE0F, #4
82:                    ANSELEbits.ANSE8=1;     //AN21
007F60  A80E4F     BSET 0xE4F, #0
83:                    ANSELEbits.ANSE9=1;     //AN20
007F62  A82E4F     BSET 0xE4F, #1
84:                    
85:                    
86:                    
87:                }
007F64  060000     RETURN
88:                
89:                void initUART1(void){
90:                    IFS0bits.U1TXIF = 0;        //clear flag
007F66  A98801     BCLR 0x801, #4
91:                    IFS0bits.U1RXIF = 0;        //clear flag
007F68  A96801     BCLR 0x801, #3
92:                    U1STA=0x1510;               //enable tx & rx
007F6A  215100     MOV #0x1510, W0
007F6C  881110     MOV W0, U1STA
93:                    U1BRG=BRGVAL;               //baud rate
007F6E  2004A0     MOV #0x4A, W0
007F70  881140     MOV W0, U1BRG
94:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
007F72  2FFF90     MOV #0xFFF9, W0
007F74  B60220     AND U1MODE, WREG
007F76  A01000     BSET W0, #1
007F78  881100     MOV W0, U1MODE
95:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
007F7A  270000     MOV #0x7000, W0
007F7C  B72844     IOR IPC2
96:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
007F7E  200070     MOV #0x7, W0
007F80  B72846     IOR IPC3
97:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
98:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
99:                    U1MODEbits.UARTEN = 1;      //start uart
007F82  A8E221     BSET 0x221, #7
100:                   UART_ON = TRUE;
007F84  EFF019     SETM.B UART_ON
101:                   
102:               }
007F86  060000     RETURN
103:               
104:               void initADC1(void){ 
105:               
106:                   /* Assign MUXA inputs */
107:                   AD1CON1 = 0x04E4; // Enable 12-bit mode, auto-sample and auto-conversion
007F88  204E40     MOV #0x4E4, W0
007F8A  881900     MOV W0, AD1CON1
108:                   AD1CON2 = 0x0408; // Sample alternately using channel scanning
007F8C  B10DC0     SUB #0xDC, W0
007F8E  881910     MOV W0, AD1CON2
109:                   AD1CON2bits.SMPI=(POTS/2)-1; // Sample 6 channels
007F90  2FF830     MOV #0xFF83, W0
007F92  B60322     AND AD1CON2, WREG
007F94  B30140     IOR #0x14, W0
007F96  881910     MOV W0, AD1CON2
110:                   AD1CON3 = 0x0F0F; // Sample for 15*TAD before converting
007F98  20F0F0     MOV #0xF0F, W0
007F9A  881920     MOV W0, AD1CON3
111:                   AD1CON1bits.FORM=2;         //signed fractional format 
007F9C  2FCFF0     MOV #0xFCFF, W0
007F9E  B60320     AND AD1CON1, WREG
007FA0  A09000     BSET W0, #9
007FA2  881900     MOV W0, AD1CON1
112:                   AD1CON3bits.ADCS=0x07;
007FA4  B3C070     MOV.B #0x7, W0
007FA6  B7E324     MOV.B WREG, AD1CON3
113:                   AD1CON3bits.SAMC=0x03;
007FA8  2E0FF0     MOV #0xE0FF, W0
007FAA  B60324     AND AD1CON3, WREG
007FAC  B33000     IOR #0x300, W0
007FAE  881920     MOV W0, AD1CON3
114:                   //select  AN6,7,8
115:                   AD1CSSLbits.CSS6=1; //AN6
007FB0  A8C330     BSET AD1CSSL, #6
116:                   AD1CSSLbits.CSS7=1; //AN7
007FB2  A8E330     BSET AD1CSSL, #7
117:                   AD1CSSLbits.CSS8=1; //AN8
007FB4  A80331     BSET 0x331, #0
118:                   AD1CSSLbits.CSS10=1;//AN10
007FB6  A84331     BSET 0x331, #2
119:                   AD1CSSHbits.CSS20=1;//AN20
007FB8  A8832E     BSET AD1CSSH, #4
120:                   AD1CSSHbits.CSS21=1;//AN21
007FBA  A8A32E     BSET AD1CSSH, #5
121:                   //AD1CSSLbits.CSS9=1; //AN9
122:                   /* Enable ADC module and provide ADC stabilization delay */
123:                   AD1CON1bits.ADON = 1;
007FBC  A8E321     BSET 0x321, #7
124:                   Delay_us(30);
007FBE  2001E0     MOV #0x1E, W0
007FC0  07037B     RCALL Delay_us
125:               }
007FC2  060000     RETURN
126:               
127:               void initPMP(void){
128:                   /*
129:                    Data is clocked on falling edge of E
130:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
131:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
132:                    */
133:                   PMMODEbits.MODE=3;  //master mode 1 
007FC4  203000     MOV #0x300, W0
007FC6  B72602     IOR PMMODE
134:                   PMCONbits.PTWREN = 1;
007FC8  A82601     BSET 0x601, #1
135:                   PMCONbits.PTRDEN = 1;
007FCA  A80601     BSET 0x601, #0
136:                   PMCONbits.WRSP=1;   //write strobe active high
007FCC  A82600     BSET PMCON, #1
137:                   PMCONbits.RDSP=1;   //read strobe active high
007FCE  A80600     BSET PMCON, #0
138:               
139:                   PMMODEbits.WAITB = 0;
007FD0  2FF3F0     MOV #0xFF3F, W0
007FD2  B62602     AND PMMODE
140:                   PMMODEbits.WAITM = 0xC;
007FD4  2FFC30     MOV #0xFFC3, W0
007FD6  B60602     AND PMMODE, WREG
007FD8  B30300     IOR #0x30, W0
007FDA  883010     MOV W0, PMMODE
141:                   PMMODEbits.WAITE = 0;
007FDC  2FFFC0     MOV #0xFFFC, W0
007FDE  B62602     AND PMMODE
142:                   LCD_RS=0;
007FE0  A9EE45     BCLR 0xE45, #7
143:                   PMCONbits.PMPEN = 1;
007FE2  A8E601     BSET 0x601, #7
144:                   
145:                   /* INIT DEVICE */
146:                   Delay_us(40000);
007FE4  29C400     MOV #0x9C40, W0
007FE6  070368     RCALL Delay_us
147:                   lcdInit();
007FE8  07FEEC     RCALL lcdInit
148:                   
149:                   /* SETUP SCREEN */
150:                   //lcdSetupPots();
151:               }
007FEA  060000     RETURN
152:               
153:               
154:               //Description: Initializes timer for LED's UART and display
155:               //Prereq: initUART1()
156:               //Dependencies: _T1Interrupt(void)
157:               //Frequency: 15Hz
158:               void initT1(void){          //16 bit timer
159:                   TMR1 = 0x0000;          //clear timer 4
007FEC  EF2100     CLR TMR1
160:                   T1CONbits.TCKPS = 3;    //prescale 1:256
007FEE  200300     MOV #0x30, W0
007FF0  B72104     IOR T1CON
161:                   T1CONbits.TCS = 0;      //use internal clock
007FF2  A92104     BCLR T1CON, #1
162:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
007FF4  A9C104     BCLR T1CON, #6
163:                   PR1 = Fcy/(256*Fdisp);    //period register
007FF6  246500     MOV #0x4650, W0
007FF8  880810     MOV W0, PR1
164:                   //PR1=0x7FFF;
165:               
166:                   T1CONbits.TON = 1;      //start timer
007FFA  A8E105     BSET 0x105, #7
167:               }
007FFC  060000     RETURN
168:               
169:               //Description:  Initializes timer handles polling button input
170:               //Prereq: initADC1() 
171:               //Dependencies: _T2Interrupt(void)
172:               //Frequency: 512Hz
173:               void initT2(void){          //16/32 bit timer
174:                   TMR2 = 0x0000;          //clear timer 4
007FFE  EF2106     CLR TMR2
175:                   T2CONbits.T32 = 0;      //16 bit mode
008000  A96110     BCLR T2CON, #3
176:                   T2CONbits.TCKPS = 1;    //prescale 1:8
008002  2FFCF0     MOV #0xFFCF, W0
008004  B60110     AND T2CON, WREG
008006  A04000     BSET W0, #4
008008  880880     MOV W0, T2CON
177:                   T2CONbits.TCS = 0;      //use internal clock
00800A  A92110     BCLR T2CON, #1
178:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
00800C  A9C110     BCLR T2CON, #6
179:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
00800E  283D60     MOV #0x83D6, W0
008010  880860     MOV W0, PR2
180:               
181:                   T2CONbits.TON = 1;      //start timer
008012  A8E111     BSET 0x111, #7
182:               }
008014  060000     RETURN
183:               
184:               //Description: Initialize timer handling LCD sending
185:               //Dependencies: _T3Interrupt(void)
186:               //Frequency: 44.1kHz
187:               void initT3(void){          //16/32 bit timer
188:                   TMR3 = 0x0000;          //clear timer 3
008016  EF210A     CLR TMR3
189:                   T3CONbits.TCKPS = 1;    //prescale 8:1
008018  2FFCF0     MOV #0xFFCF, W0
00801A  B60112     AND T3CON, WREG
00801C  A04000     BSET W0, #4
00801E  880890     MOV W0, T3CON
190:                   T3CONbits.TCS = 0;      //use internal clock
008020  A92112     BCLR T3CON, #1
191:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
008022  A9C112     BCLR T3CON, #6
192:                   //PR3 = Fcy/(256*T3freq);           //period register
193:                   PR3 = 0x01D0;           //45uS initial delay
008024  201D00     MOV #0x1D0, W0
008026  880870     MOV W0, PR3
194:                   
195:                   T3CONbits.TON = 1;
008028  A8E113     BSET 0x113, #7
196:                   
197:               }
00802A  060000     RETURN
198:               
199:               /*=============================================================================  
200:               Timer 5 is setup to time-out every 125 microseconds (8Khz Rate). As a result, the module 
201:               will stop sampling and trigger a conversion on every Timer3 time-out, i.e., Ts=125us. 
202:               =============================================================================*/
203:               void initT5() 
204:               {
205:                       TMR5 = 0x0000;
00802C  EF2118     CLR TMR5
206:                       PR5 = 4999;
00802E  213870     MOV #0x1387, W0
008030  8808E0     MOV W0, PR5
207:                       T5CONbits.TCKPS = 2;    //prescale 8:1
008032  2FFCF0     MOV #0xFFCF, W0
008034  B60120     AND T5CON, WREG
008036  A05000     BSET W0, #5
008038  880900     MOV W0, T5CON
208:                       IFS1bits.T5IF = 0;
00803A  A98803     BCLR 0x803, #4
209:                       IEC1bits.T5IE = 0;
00803C  A98823     BCLR 0x823, #4
210:               
211:                       //Start Timer 3
212:                       T5CONbits.TON = 1;
00803E  A8E121     BSET 0x121, #7
213:               
214:               }
008040  060000     RETURN
215:               
216:               //Description: Initializes & starts 16 bit DCI I2S DAC
217:               //Prereq: initSPI_ADC(void)
218:               //Dependencies: readDAC(void)
219:               void initDCI_DAC(void){
220:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
008042  2F0000     MOV #0xF000, W0
008044  B60284     AND DCICON3, WREG
008046  B30170     IOR #0x17, W0
008048  881420     MOV W0, DCICON3
221:                   DCICON1bits.COFSM=1;                //i2s mode
00804A  2FFFC0     MOV #0xFFFC, W0
00804C  B60280     AND DCICON1, WREG
00804E  A00000     BSET W0, #0
008050  881400     MOV W0, DCICON1
222:                   DCICON1bits.CSCKE=1;                //sample on rising edge
008052  A82281     BSET 0x281, #1
223:                   DCICON2bits.WS=0xF;                 //16 bit data word
008054  2000F0     MOV #0xF, W0
008056  B72282     IOR DCICON2
224:                   DCICON2bits.COFSG=0;    //data frame has 1 word (per frame)
008058  2FE1F0     MOV #0xFE1F, W0
00805A  B62282     AND DCICON2
225:                   DCICON1bits.DJST=0;     //align data
00805C  A9A280     BCLR DCICON1, #5
226:                   DCICON2bits.BLEN=3;     //4 words buffer btwn interrupts
00805E  20C000     MOV #0xC00, W0
008060  B72282     IOR DCICON2
227:                   
228:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
008062  A80288     BSET TSCON, #0
229:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
008064  A82288     BSET TSCON, #1
230:                   TSCONbits.TSE2 = 1;     // Transmit on Time Slot 2     
008066  A84288     BSET TSCON, #2
231:                   TSCONbits.TSE3 = 1;     // Transmit on Time Slot 3   
008068  A86288     BSET TSCON, #3
232:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
00806A  A8028C     BSET RSCON, #0
233:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
00806C  A8228C     BSET RSCON, #1
234:                   RSCONbits.RSE2 = 1;     // rcv on Time Slot 2     
00806E  A8428C     BSET RSCON, #2
235:                   RSCONbits.RSE3 = 1;     // rcv on Time Slot 3 
008070  A8628C     BSET RSCON, #3
236:                   
237:               
238:                   
239:                   IPC15bits.DCIIP = 6;    // Interrput priority
008072  2FFF80     MOV #0xFFF8, W0
008074  B6085E     AND IPC15, WREG
008076  B30060     IOR #0x6, W0
008078  8842F0     MOV W0, IPC15
240:                   IFS3bits.DCIIF=0;
00807A  A98807     BCLR 0x807, #4
241:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
00807C  A88827     BSET 0x827, #4
242:                   
243:                   // Pre-load send registers.
244:                   TXBUF0=0;
00807E  EF2298     CLR TXBUF0
245:                   TXBUF1=0;   
008080  EF229A     CLR TXBUF1
246:                   TXBUF2=0;
008082  EF229C     CLR TXBUF2
247:                   TXBUF3=0;
008084  EF229E     CLR TXBUF3
248:                   DCICON1bits.DCIEN=1;    //ENABLE
008086  A8E281     BSET 0x281, #7
249:                   // Stabilization delay
250:                   Delay_us(20);
008088  200140     MOV #0x14, W0
00808A  070316     RCALL Delay_us
251:               }
00808C  060000     RETURN
252:               
253:               void initDMA0(void){
254:                   unsigned long address;
255:                   
256:                   /*
257:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
258:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
259:                   DMA0PAD =  0X0608; // Point DMA to PMP
260:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
261:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
262:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
263:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
264:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
265:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
266:                   DMA0CONbits.CHEN=1; // Enable DMA
267:                   */
268:                   
269:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
00808E  A9CB01     BCLR 0xB01, #6
270:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
008090  A8AB01     BSET 0xB01, #5
271:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
008092  2FFCF4     MOV #0xFFCF, W4
008094  20B000     MOV #0xB00, W0
008096  620810     AND W4, [W0], [W0]
272:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
008098  2FFFC3     MOV #0xFFFC, W3
00809A  805801     MOV DMA0CON, W1
00809C  618001     AND W3, W1, W0
00809E  A01000     BSET W0, #1
0080A0  885800     MOV W0, DMA0CON
273:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
0080A2  A98B01     BCLR 0xB01, #4
274:                   DMA0CONbits.NULLW = 0;
0080A4  A96B01     BCLR 0xB01, #3
275:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
0080A6  A9EB03     BCLR 0xB03, #7
276:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
0080A8  B3C3C2     MOV.B #0x3C, W2
0080AA  20B025     MOV #0xB02, W5
0080AC  784A82     MOV.B W2, [W5]
277:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
0080AE  27FFF0     MOV #0x7FFF, W0
0080B0  2CE001     MOV #0xCE00, W1
0080B2  608080     AND W1, W0, W1
278:                   address +=__builtin_edspage(txBufferA) << 15;
0080B4  200016     MOV #0x1, W6
0080B6  DD334F     SL W6, #15, W6
0080B8  EB0380     CLR W7
0080BA  408306     ADD W1, W6, W6
0080BC  4B83E0     ADDC W7, #0x0, W7
279:                   DMA0STAL = address & 0xFFFF;
0080BE  885826     MOV W6, DMA0STAL
280:                   DMA0STAH = address >>16;
0080C0  885837     MOV W7, DMA0STAH
281:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
0080C2  2CC001     MOV #0xCC00, W1
0080C4  608080     AND W1, W0, W1
282:                   address +=__builtin_edspage(txBufferB) << 15;
0080C6  200016     MOV #0x1, W6
0080C8  DD334F     SL W6, #15, W6
0080CA  EB0380     CLR W7
0080CC  408306     ADD W1, W6, W6
0080CE  4B83E0     ADDC W7, #0x0, W7
283:                   DMA0STBL = address & 0xFFFF;
0080D0  885846     MOV W6, DMA0STBL
284:                   DMA0STBH = address >>16;
0080D2  885857     MOV W7, DMA0STBH
285:                   DMA0PAD = (int)&TXBUF0;
0080D4  202981     MOV #0x298, W1
0080D6  885861     MOV W1, DMA0PAD
286:                   DMA0CNT = STREAMBUF-1;
0080D8  200FF1     MOV #0xFF, W1
0080DA  885871     MOV W1, DMA0CNT
287:                   /* DMA 2 - DCI to DPSRAM*/
288:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
0080DC  A9CB21     BCLR 0xB21, #6
289:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
0080DE  A9AB21     BCLR 0xB21, #5
290:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
0080E0  A98B21     BCLR 0xB21, #4
291:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
0080E2  A96B21     BCLR 0xB21, #3
292:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
0080E4  20B205     MOV #0xB20, W5
0080E6  620A95     AND W4, [W5], [W5]
293:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
0080E8  805904     MOV DMA2CON, W4
0080EA  618184     AND W3, W4, W3
0080EC  A01003     BSET W3, #1
0080EE  885903     MOV W3, DMA2CON
294:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
0080F0  A9EB23     BCLR 0xB23, #7
295:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
0080F2  784182     MOV.B W2, W3
0080F4  20B225     MOV #0xB22, W5
0080F6  784A83     MOV.B W3, [W5]
296:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
0080F8  2CA004     MOV #0xCA00, W4
0080FA  620200     AND W4, W0, W4
297:                   address +=__builtin_edspage(rxBufferA) << 15;
0080FC  200012     MOV #0x1, W2
0080FE  DD114F     SL W2, #15, W2
008100  EB0180     CLR W3
008102  420102     ADD W4, W2, W2
008104  4981E0     ADDC W3, #0x0, W3
298:                   DMA2STAL = address & 0xFFFF;
008106  885922     MOV W2, DMA2STAL
299:                   DMA2STAH = address >>16;
008108  885933     MOV W3, DMA2STAH
300:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
00810A  2C8002     MOV #0xC800, W2
00810C  610000     AND W2, W0, W0
301:                   address +=__builtin_edspage(rxBufferB) << 15;
00810E  200012     MOV #0x1, W2
008110  DD114F     SL W2, #15, W2
008112  EB0180     CLR W3
008114  400102     ADD W0, W2, W2
008116  4981E0     ADDC W3, #0x0, W3
302:                   DMA2STBL = address & 0xFFFF;
008118  885942     MOV W2, DMA2STBL
303:                   DMA2STBH = address >>16;
00811A  885953     MOV W3, DMA2STBH
304:                   DMA2PAD = (int)&RXBUF0;
00811C  202900     MOV #0x290, W0
00811E  885960     MOV W0, DMA2PAD
305:                   DMA2CNT = STREAMBUF-1;
008120  885971     MOV W1, DMA2CNT
306:                   _DMA2IP = 5;
008122  2FFF80     MOV #0xFFF8, W0
008124  B6084C     AND IPC6, WREG
008126  B30050     IOR #0x5, W0
008128  884260     MOV W0, IPC6
307:                   _DMA2IE = 1;
00812A  A80823     BSET 0x823, #0
308:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
00812C  A8EB01     BSET 0xB01, #7
309:                   DMA2CONbits.CHEN = 1;
00812E  A8EB21     BSET 0xB21, #7
310:               }
008130  060000     RETURN
311:               
312:               void initSPI3_MEM(void){
313:                   SS3=1;                     // Assert chip select (active low)
008132  A82E54     BSET LATF, #1
314:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
008134  A9680B     BCLR 0x80B, #3
315:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
008136  A9682B     BCLR 0x82B, #3
316:                   SPI3CON1bits.MSTEN=1;       //master mode
008138  A8A2A2     BSET SPI3CON1, #5
317:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
00813A  A982A3     BCLR 0x2A3, #4
318:                   SPI3CON1bits.MODE16=0;      //8 bit
00813C  A942A3     BCLR 0x2A3, #2
319:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
00813E  A962A3     BCLR 0x2A3, #3
320:                   SPI3CON1bits.SSEN=1;        //use SS
008140  A8E2A2     BSET SPI3CON1, #7
321:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
008142  A9E2A5     BCLR 0x2A5, #7
322:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
008144  A902A4     BCLR SPI3CON2, #0
323:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
008146  2FFE33     MOV #0xFFE3, W3
008148  801300     MOV SPI2STAT, W0
00814A  618080     AND W3, W0, W1
00814C  B30141     IOR #0x14, W1
00814E  881301     MOV W1, SPI2STAT
324:                   
325:                   SPI3CON1bits.SMP=1;         //data sampled at end of output time
008150  A822A3     BSET 0x2A3, #1
326:                   SPI3CON1bits.CKP=0;         //idle clock is low
008152  A9C2A2     BCLR SPI3CON1, #6
327:                   SPI3CON1bits.CKE=1;         //data changes from H to L
008154  A802A3     BSET 0x2A3, #0
328:                   
329:                   SPI3CON1bits.PPRE=3;        //1:1 primary prescale
008156  200030     MOV #0x3, W0
008158  B722A2     IOR SPI3CON1
330:                   SPI3CON1bits.SPRE=6;        //2:1 secondary
00815A  801511     MOV SPI3CON1, W1
00815C  618001     AND W3, W1, W0
00815E  B30180     IOR #0x18, W0
008160  881510     MOV W0, SPI3CON1
331:                   
332:                   SPI3STATbits.SPIROV = 0;        // Clear SPI1 receive overflow flag if set
008162  A9C2A0     BCLR SPI3STAT, #6
333:                   //IPC22bits.SPI3IP = 3;         // Interrupt priority
334:                   //IFS5bits.SPI3IF = 0;          // Clear the Interrupt flag
335:                   //IEC5bits.SPI3IE = 0;          // Enable the interrupt
336:                   SPI3STATbits.SPIEN = 1;         //start SPI module
008164  A8E2A1     BSET 0x2A1, #7
337:                  
338:                   Delay_us(20);                       // Stabilization Delay
008166  200140     MOV #0x14, W0
008168  0702A7     RCALL Delay_us
339:                   
340:                   flashWriteReg(FLASH_WREN);
00816A  B3C060     MOV.B #0x6, W0
00816C  070466     RCALL flashWriteReg
341:                   /*
342:                   flashBulkErase();
343:                   while(flashStatusCheck()&1);
344:               
345:                   flashWritePage
346:                   while(flashStatusCheck()&1);
347:                   */
348:                   
349:                   flashRead(flash_readback, 256);     // READBACK
00816E  201001     MOV #0x100, W1
008170  25E6C0     MOV #0x5E6C, W0
008172  0704B7     RCALL flashRead
350:                   
351:               }
008174  060000     RETURN
352:               
353:               void initQEI_ENC(void){
354:                   QEI1CONbits.INTDIV=6;       // 1:64 prescaler
008176  2FF8F0     MOV #0xFF8F, W0
008178  B601C0     AND QEI1CON, WREG
00817A  B30600     IOR #0x60, W0
00817C  880E00     MOV W0, QEI1CON
355:                   QEI1IOCbits.FLTREN=1;       // Enable input filter
00817E  A8C1C3     BSET 0x1C3, #6
356:                   QEI1CONbits.QEIEN=1;        // Enable Quad encoder inteface
008180  A8E1C1     BSET 0x1C1, #7
357:               }
008182  060000     RETURN
358:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/audio.c  ----------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[BUTTONS];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[POTS];
7:                 extern fractional pots_percent[POTS];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                void processAudio(fractional *source, fractional *destination){
0087F0  4787E4     ADD W15, #0x4, W15
0087F2  BE9F88     MOV.D W8, [W15++]
0087F4  BE9F8A     MOV.D W10, [W15++]
0087F6  BE9F8C     MOV.D W12, [W15++]
0087F8  781F8E     MOV W14, [W15++]
0087FA  F80022     PUSH ACCA
0087FC  F80024     PUSH ACCAH
0087FE  F80026     PUSH ACCAU
008800  BE0400     MOV.D W0, W8
008808  2FE002     MOV #0xFE00, W2
00880A  410108     ADD W2, W8, W2
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    volatile fractional sample;
38:                    int counter=(STREAMBUF-1);
39:                    
40:                    runFX(source, source);
008802  780088     MOV W8, W1
008804  780008     MOV W8, W0
008806  07FF61     RCALL runFX
41:                    
42:                
43:                    for(; counter>=0; counter--){
0088D2  540F82     SUB W8, W2, [W15]
0088D4  3AFFA3     BRA NZ, 0x881C
44:                        sample=*source--; //!rw
00881C  780028     MOV [W8--], W0
00881E  9FB7D0     MOV W0, [W15-22]
45:                
46:                        if(kick_playing==TRUE&&kick_ptr<kick_max){
008820  BFD02E     MOV.B kick_playing, WREG
008822  404FE1     ADD.B W0, #0x1, [W15]
008824  3A0011     BRA NZ, 0x8848
008826  877664     MOV 0xEECC, W4
008828  808187     MOV kick_ptr, W7
00882A  538F84     SUB W7, W4, [W15]
00882C  31000D     BRA C, 0x8848
47:                            result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
00880E  27332E     MOV #0x7332, W14
00882E  97B3DF     MOV [W15-22], W7
008830  78020E     MOV W14, W4
008832  C20113     MPY W4*W7, A
48:                            result1 = __builtin_add(result1,kick[kick_ptr++],0);
008810  2C36CD     MOV #0xC36C, W13
008834  808180     MOV kick_ptr, W0
008836  400200     ADD W0, W0, W4
008838  468204     ADD W13, W4, W4
00883A  780214     MOV [W4], W4
00883C  E80000     INC W0, W0
00883E  888180     MOV W0, kick_ptr
008840  C90004     ADD W4, A
49:                            sample=__builtin_sac(result1, 0);
008842  CC0007     SAC A, W7
008844  9FB7D7     MOV W7, [W15-22]
008846  37000A     BRA 0x885C
50:                        }
51:                        else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
00880C  2689C5     MOV #0x689C, W5
008848  B3C01B     MOV.B #0x1, W11
00884A  15CF95     SUBR.B W11, [W5], [W15]
00884C  3A0007     BRA NZ, 0x885C
00884E  404FE1     ADD.B W0, #0x1, [W15]
008850  3A0005     BRA NZ, 0x885C
008852  877660     MOV 0xEECC, W0
008854  E31030     CP kick_ptr
008856  3A0002     BRA NZ, 0x885C
52:                            kick_playing=FALSE;
008858  EF702E     CLR.B kick_playing
53:                            kick_ptr=0;
00885A  EF3030     CLR kick_ptr
54:                        }
55:                        /*
56:                        if(hat_playing==TRUE&&hat_ptr<hat_max){
57:                            result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
58:                            result1 = __builtin_add(result1,hat[hat_ptr++],0);
59:                            sample=__builtin_sac(result1, 0);
60:                        }
61:                        else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
62:                            hat_playing=FALSE;
63:                            hat_ptr=0;
64:                        }
65:                         */
66:                
67:                        if(snare_playing==TRUE&&snare_ptr<snare_max){
00885C  BFD032     MOV.B snare_playing, WREG
00885E  404FE1     ADD.B W0, #0x1, [W15]
008860  3A0012     BRA NZ, 0x8886
008862  877674     MOV 0xEECE, W4
008864  8081A7     MOV snare_ptr, W7
008866  538F84     SUB W7, W4, [W15]
008868  31000E     BRA C, 0x8886
68:                            result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
008814  26CCCC     MOV #0x6CCC, W12
00886A  97B3DF     MOV [W15-22], W7
00886C  78020C     MOV W12, W4
00886E  C20113     MPY W4*W7, A
69:                            result1 = __builtin_add(result1,snare[snare_ptr++],0);
008870  8081A0     MOV snare_ptr, W0
008872  400200     ADD W0, W0, W4
008874  292947     MOV #0x9294, W7
008876  438204     ADD W7, W4, W4
008878  780214     MOV [W4], W4
00887A  E80000     INC W0, W0
00887C  8881A0     MOV W0, snare_ptr
00887E  C90004     ADD W4, A
70:                            sample=__builtin_sac(result1, 0);
008880  CC000B     SAC A, W11
008882  9FB7DB     MOV W11, [W15-22]
008884  37000A     BRA 0x889A
71:                        }
72:                        else if (pad[1]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
008812  E80185     INC W5, W3
008886  B3C014     MOV.B #0x1, W4
008888  124F93     SUBR.B W4, [W3], [W15]
00888A  3A0007     BRA NZ, 0x889A
00888C  404FE1     ADD.B W0, #0x1, [W15]
00888E  3A0005     BRA NZ, 0x889A
008890  877670     MOV 0xEECE, W0
008892  E31034     CP snare_ptr
008894  3A0002     BRA NZ, 0x889A
73:                            snare_playing=FALSE;
008896  EF7032     CLR.B snare_playing
74:                            snare_ptr=0;
008898  EF3034     CLR snare_ptr
75:                        }
76:                
77:                
78:                        if (TEST_SIN==TRUE){
00889A  BFD01A     MOV.B TEST_SIN, WREG
00889C  404FE1     ADD.B W0, #0x1, [W15]
00889E  3A000B     BRA NZ, 0x88B6
79:                            i++;
0088A0  EC1010     INC i, WREG
0088A2  888080     MOV W0, i
80:                            if(i==1024)
008816  20400A     MOV #0x400, W10
0088A4  500F8A     SUB W0, W10, [W15]
0088A6  3A0001     BRA NZ, 0x88AA
81:                                i=0;
0088A8  EF3010     CLR i
82:                            sample=sintab[i];
0088AA  808080     MOV i, W0
0088AC  400000     ADD W0, W0, W0
0088AE  2EED27     MOV #0xEED2, W7
0088B0  438000     ADD W7, W0, W0
0088B2  780010     MOV [W0], W0
0088B4  9FB7D0     MOV W0, [W15-22]
83:                        }
84:                
85:                        //VOLUME CONTROL
86:                        if(pots[POT_VOLUME]==0x0007)
008818  2607A1     MOV #0x607A, W1
0088B6  780211     MOV [W1], W4
0088B8  520FE7     SUB W4, #0x7, [W15]
0088BA  3A0003     BRA NZ, 0x88C2
87:                            sample=0;
0088BC  EB0580     CLR W11
0088BE  9FB7DB     MOV W11, [W15-22]
0088C0  370006     BRA 0x88CE
88:                        else if(pots[POT_VOLUME]>=0x7FF7);
00881A  27FF66     MOV #0x7FF6, W6
0088C2  520F86     SUB W4, W6, [W15]
0088C4  3C0004     BRA GT, 0x88CE
89:                        else{
90:                            result1 =__builtin_mpy(sample,pots[POT_VOLUME], NULL, NULL, 0, NULL, NULL, 0);
0088C6  97B3DF     MOV [W15-22], W7
0088C8  C20113     MPY W4*W7, A
91:                            sample=__builtin_sac(result1, 0);
0088CA  CC000B     SAC A, W11
0088CC  9FB7DB     MOV W11, [W15-22]
92:                        }
93:                        
94:                        //return sample;
95:                        *destination--=sample; //rw
0088CE  97B05F     MOV [W15-22], W0
0088D0  781480     MOV W0, [W9--]
96:                    }
97:                }
0088D6  F90026     POP ACCAU
0088D8  F90024     POP ACCAH
0088DA  F90022     POP ACCA
0088DC  78074F     MOV [--W15], W14
0088DE  BE064F     MOV.D [--W15], W12
0088E0  BE054F     MOV.D [--W15], W10
0088E2  BE044F     MOV.D [--W15], W8
0088E4  B1004F     SUB #0x4, W15
0088E6  060000     RETURN
98:                
99:                void runFX(fractional *source, fractional *destination){
0086CA  FA0002     LNK #0x2
0086CC  BE9F88     MOV.D W8, [W15++]
0086CE  BE9F8A     MOV.D W10, [W15++]
0086D0  BE9F8C     MOV.D W12, [W15++]
0086D2  F80022     PUSH ACCA
0086D4  F80024     PUSH ACCAH
0086D6  F80026     PUSH ACCAU
0086D8  F80028     PUSH ACCB
0086DA  F8002A     PUSH ACCBH
0086DC  F8002C     PUSH ACCBU
0086DE  2FE003     MOV #0xFE00, W3
0086E0  418180     ADD W3, W0, W3
100:                   volatile register int result1 asm("A");
101:                   volatile register int result2 asm("B");
102:                   static fractional delayed_sample;
103:                   static fractional trem_mod; 
104:                   volatile fractional sample;
105:                   
106:                   
107:                   int *readPTR=source;
108:                   int *rewritePTR=destination;
109:                   
110:                   
111:                   int counter=(STREAMBUF-1);
112:                   for(; counter>=0; counter--){
0087D6  500F83     SUB W0, W3, [W15]
0087D8  3AFF8B     BRA NZ, 0x86F0
113:                       sample=*readPTR--; //!rw
0086F0  780120     MOV [W0--], W2
0086F2  9FB7B2     MOV W2, [W15-26]
114:               
115:                       if(tremelo==TRUE){                                                          //TREMELO//
0086F4  2101B2     MOV #0x101B, W2
0086F6  784112     MOV.B [W2], W2
0086F8  414FE1     ADD.B W2, #0x1, [W15]
0086FA  3A002B     BRA NZ, 0x8752
116:                           if (trem_var<=pots[3]){
0086E2  26072D     MOV #0x6072, W13
0086FC  808042     MOV trem_var, W2
0086FE  110F9D     SUBR W2, [W13], [W15]
008700  390012     BRA NC, 0x8726
117:                               trem_var++;
008702  E80102     INC W2, W2
008704  888042     MOV W2, trem_var
118:                               result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
008706  808022     MOV tremelo_ptr, W2
008708  410102     ADD W2, W2, W2
00870A  440102     ADD W8, W2, W2
00870C  780592     MOV [W2], W11
00870E  808226     MOV 0x1044, W6
008710  78038B     MOV W11, W7
008712  C60113     MPY W6*W7, A
119:                               trem_mod=__builtin_sac(result1, 0);
008714  CC0002     SAC A, W2
008716  888062     MOV W2, trem_mod
120:                               result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008718  97B5BF     MOV [W15-26], W11
00871A  780302     MOV W2, W6
00871C  78038B     MOV W11, W7
00871E  C68113     MPY W6*W7, B
121:                               sample=__builtin_sac(result2, 0);
008720  CC8002     SAC B, W2
008722  9FB7B2     MOV W2, [W15-26]
008724  370016     BRA 0x8752
122:                           }
123:                           else{
124:                               trem_var=0;
0086E4  EB0600     CLR W12
008726  88804C     MOV W12, trem_var
125:                               if(tremelo_ptr==1024)
0086E6  204009     MOV #0x400, W9
008728  808026     MOV tremelo_ptr, W6
00872A  530F89     SUB W6, W9, [W15]
00872C  3A0001     BRA NZ, 0x8730
126:                                   tremelo_ptr=0;
00872E  88802C     MOV W12, tremelo_ptr
127:                               result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
0086E8  2EED28     MOV #0xEED2, W8
008730  808022     MOV tremelo_ptr, W2
008732  410582     ADD W2, W2, W11
008734  44058B     ADD W8, W11, W11
008736  78059B     MOV [W11], W11
008738  E80102     INC W2, W2
00873A  888022     MOV W2, tremelo_ptr
00873C  808227     MOV 0x1044, W7
00873E  78030B     MOV W11, W6
008740  C60113     MPY W6*W7, A
128:                               trem_mod=__builtin_sac(result1, 0);
008742  CC0002     SAC A, W2
008744  888062     MOV W2, trem_mod
129:                               result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008746  97B5BF     MOV [W15-26], W11
008748  780382     MOV W2, W7
00874A  78030B     MOV W11, W6
00874C  C68113     MPY W6*W7, B
130:                               sample=__builtin_sac(result2, 0);
00874E  CC8007     SAC B, W7
008750  9FB7B7     MOV W7, [W15-26]
131:                           }
132:                       }
133:                       if(looper==TRUE){                           //LOOPER// 
008752  2101C2     MOV #0x101C, W2
008754  784112     MOV.B [W2], W2
008756  414FE1     ADD.B W2, #0x1, [W15]
008758  3A0019     BRA NZ, 0x878C
134:                           if(loop_lim>=LOOP_BUF_SIZE)
00875A  808012     MOV loop_lim, W2
00875C  510F84     SUB W2, W4, [W15]
00875E  360001     BRA LEU, 0x8762
135:                               loop_lim=LOOP_BUF_SIZE;
0086EE  22710A     MOV #0x2710, W10
008760  88801A     MOV W10, loop_lim
136:                           if(loop_ptr<loop_lim){
008762  808012     MOV loop_lim, W2
008764  808006     MOV loop_ptr, W6
008766  530F82     SUB W6, W2, [W15]
008768  310008     BRA C, 0x877A
137:                               sample = (loop[loop_ptr++]);
00876A  808002     MOV loop_ptr, W2
00876C  410582     ADD W2, W2, W11
00876E  42858B     ADD W5, W11, W11
008770  78059B     MOV [W11], W11
008772  9FB7BB     MOV W11, [W15-26]
008774  E80102     INC W2, W2
008776  888002     MOV W2, loop_ptr
008778  37001C     BRA 0x87B2
138:                           }
139:                           else {
140:                               loop_ptr=0;
00877A  88800C     MOV W12, loop_ptr
141:                               sample = (loop[loop_ptr++]);
00877C  808002     MOV loop_ptr, W2
00877E  410582     ADD W2, W2, W11
008780  42858B     ADD W5, W11, W11
008782  78059B     MOV [W11], W11
008784  9FB7BB     MOV W11, [W15-26]
008786  E80102     INC W2, W2
008788  888002     MOV W2, loop_ptr
00878A  370013     BRA 0x87B2
142:                           }
143:                       }                                                                           
144:                       else {                                      //buffer
145:                           if(loop_ptr<LOOP_BUF_SIZE)
0086EA  2270F4     MOV #0x270F, W4
00878C  808007     MOV loop_ptr, W7
00878E  538F84     SUB W7, W4, [W15]
008790  3E0008     BRA GTU, 0x87A2
146:                               loop[loop_ptr++]=sample;
008792  808002     MOV loop_ptr, W2
008794  410582     ADD W2, W2, W11
008796  42858B     ADD W5, W11, W11
008798  97B33F     MOV [W15-26], W6
00879A  780D86     MOV W6, [W11]
00879C  E80102     INC W2, W2
00879E  888002     MOV W2, loop_ptr
0087A0  370008     BRA 0x87B2
147:                           else {
148:                               loop_ptr=0;
0087A2  88800C     MOV W12, loop_ptr
149:                               loop[loop_ptr++]=sample;
0086EC  2104C5     MOV #0x104C, W5
0087A4  808002     MOV loop_ptr, W2
0087A6  410582     ADD W2, W2, W11
0087A8  42858B     ADD W5, W11, W11
0087AA  97B3BF     MOV [W15-26], W7
0087AC  780D87     MOV W7, [W11]
0087AE  E80102     INC W2, W2
0087B0  888002     MOV W2, loop_ptr
150:                           }
151:                       }
152:               
153:                       //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
154:                       if(lpf==TRUE){
0087B2  2101D2     MOV #0x101D, W2
0087B4  784112     MOV.B [W2], W2
0087B6  414FE1     ADD.B W2, #0x1, [W15]
0087B8  3A000C     BRA NZ, 0x87D2
155:                           result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
0087BA  97B13F     MOV [W15-26], W2
0087BC  80820B     MOV ___divsi3, W11
0087BE  780302     MOV W2, W6
0087C0  78038B     MOV W11, W7
0087C2  C68113     MPY W6*W7, B
156:                           result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
0087C4  808212     MOV 0x1042, W2
0087C6  808076     MOV delayed_sample, W6
0087C8  780382     MOV W2, W7
0087CA  C68112     MAC W6*W7, B
157:                           delayed_sample=__builtin_sac(result2, 0);
0087CC  CC8002     SAC B, W2
0087CE  888072     MOV W2, delayed_sample
158:                           sample=delayed_sample;
0087D0  9FB7B2     MOV W2, [W15-26]
159:                       }
160:                       
161:                       *rewritePTR--=sample; //rw
0087D2  97B13F     MOV [W15-26], W2
0087D4  781082     MOV W2, [W1--]
162:                   }
163:               }
0087DA  F9002C     POP ACCBU
0087DC  F9002A     POP ACCBH
0087DE  F90028     POP ACCB
0087E0  F90026     POP ACCAU
0087E2  F90024     POP ACCAH
0087E4  F90022     POP ACCA
0087E6  BE064F     MOV.D [--W15], W12
0087E8  BE054F     MOV.D [--W15], W10
0087EA  BE044F     MOV.D [--W15], W8
0087EC  FA8000     ULNK
0087EE  060000     RETURN
164:               
165:               //test
