Disassembly Listing for sampler_0.49.2
Generated From:
C:/Users/ryan/Documents/seniorproject/ps-040/dist/default/production/ps-040.production.elf
Jan 30, 2018 11:54:05 AM

---  C:/Users/ryan/Documents/seniorproject/ps-040/utilitites.c  -----------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <libpic30.h>
4:                 #include <dsp.h>
5:                 #include <stdio.h>
6:                 #include <stdlib.h>
7:                 #include <math.h>
8:                 #include "common.h"
9:                 #include "sounds.h"
10:                #include "audio.h"
11:                #include "flash.h"
12:                #include "screens.h"
13:                #include "utilities.h"
14:                #include "devInits.h"
15:                
16:                
17:                //CONTROL VARIABLES//
18:                extern unsigned char pad[BUTTONS];
19:                extern fractional pots[POTS];
20:                extern fractional pots_percent[POTS];
21:                extern unsigned char UART_ON; 
22:                extern enum screen state;
23:                
24:                //STATUS VARIABLES//
25:                extern unsigned char hard_clipped;
26:                extern unsigned char UART_EN;
27:                extern unsigned char TEST_SIN;
28:                extern fractional sampin;
29:                extern fractional sampout;
30:                
31:                //FX FLAGS & VARS
32:                extern unsigned char tremelo, looper, lpf;
33:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
34:                extern unsigned int loop_lim;
35:                extern fractional lpf_alpha, lpf_inv_alpha;
36:                extern fractional tremelo_depth;
37:                extern unsigned char kick_playing, snare_playing;   
38:                extern unsigned char frame;
39:                
40:                void scanButtons(void){
41:                    
42:                    static unsigned char pad_last[BUTTONS]={1};
43:                    int portrdG, portrdD, portrdF;
44:                
45:                    portrdG = PORTG;
0082CC  807313     MOV PORTG, W3
46:                    portrdD = PORTD;
0082CE  807191     MOV PORTD, W1
47:                    portrdF = PORTF;
0082D0  807292     MOV PORTF, W2
48:                    
49:                    pad[34]=(portrdF>>7)&1;     // Special function button
0082D2  DE9247     ASR W2, #7, W4
0082D4  624261     AND.B W4, #0x1, W4
0082D6  270C25     MOV #0x70C2, W5
0082D8  784A84     MOV.B W4, [W5]
50:                    
51:                    if(pad[34]){
0082DA  320033     BRA Z, 0x8342
52:                        pad[6]=(portrdF>>6)&1;
0082DC  DE92C6     ASR W2, #6, W5
0082DE  270A64     MOV #0x70A6, W4
0082E0  62CA61     AND.B W5, #0x1, [W4]
53:                        pad[5]=(portrdF>>5)&1;
0082E2  DE92C5     ASR W2, #5, W5
0082E4  E90204     DEC W4, W4
0082E6  62CA61     AND.B W5, #0x1, [W4]
54:                        pad[4]=(portrdF>>4)&1;
0082E8  DE9144     ASR W2, #4, W2
0082EA  E90204     DEC W4, W4
0082EC  614A61     AND.B W2, #0x1, [W4]
55:                        pad[0]=(portrdG)&1;
0082EE  520164     SUB W4, #0x4, W2
0082F0  61C961     AND.B W3, #0x1, [W2]
56:                        pad[1]=(portrdG>>1)&1;
0082F2  D18203     ASR W3, W4
0082F4  E80102     INC W2, W2
0082F6  624961     AND.B W4, #0x1, [W2]
57:                        pad[2]=(portrdG>>2)&1;
0082F8  DE9A42     ASR W3, #2, W4
0082FA  E80102     INC W2, W2
0082FC  624961     AND.B W4, #0x1, [W2]
58:                        pad[3]=(portrdG>>3)&1;
0082FE  DE9A43     ASR W3, #3, W4
008300  E80102     INC W2, W2
008302  624961     AND.B W4, #0x1, [W2]
59:                        pad[16]=(portrdG>>10)&1;    // Encoder button
008304  DE9A4A     ASR W3, #10, W4
008306  41016D     ADD W2, #0xD, W2
008308  624961     AND.B W4, #0x1, [W2]
60:                        pad[11]=(portrdG>>11)&1;
00830A  DE9A4B     ASR W3, #11, W4
00830C  510165     SUB W2, #0x5, W2
00830E  624961     AND.B W4, #0x1, [W2]
61:                        pad[12]=(portrdG>>12)&1;
008310  DE9A4C     ASR W3, #12, W4
008312  E80102     INC W2, W2
008314  624961     AND.B W4, #0x1, [W2]
62:                        pad[13]=(portrdG>>13)&1;
008316  DE9A4D     ASR W3, #13, W4
008318  E80102     INC W2, W2
00831A  624961     AND.B W4, #0x1, [W2]
63:                        pad[14]=(portrdG>>14)&1;
00831C  DE984E     ASR W3, #14, W0
00831E  E80102     INC W2, W2
008320  604961     AND.B W0, #0x1, [W2]
64:                        pad[15]=(portrdG>>15)&1;
008322  DE19CF     LSR W3, #15, W3
008324  E80002     INC W2, W0
008326  784803     MOV.B W3, [W0]
65:                        pad[7]=(portrdD>>1)&1;
008328  D18101     ASR W1, W2
00832A  500068     SUB W0, #0x8, W0
00832C  614861     AND.B W2, #0x1, [W0]
66:                        pad[8]=(portrdD>>2)&1;
00832E  DE8942     ASR W1, #2, W2
008330  E80000     INC W0, W0
008332  614861     AND.B W2, #0x1, [W0]
67:                        pad[9]=(portrdD>>3)&1;
008334  DE8943     ASR W1, #3, W2
008336  E80000     INC W0, W0
008338  614861     AND.B W2, #0x1, [W0]
68:                        pad[10]=(portrdD>>4)&1;
00833A  DE88C4     ASR W1, #4, W1
00833C  E80000     INC W0, W0
00833E  60C861     AND.B W1, #0x1, [W0]
008340  370032     BRA 0x83A6
69:                    } else {
70:                        pad[23]=(portrdF>>6)&1;
008342  DE92C6     ASR W2, #6, W5
008344  270B74     MOV #0x70B7, W4
008346  62CA61     AND.B W5, #0x1, [W4]
71:                        pad[22]=(portrdF>>5)&1;
008348  DE92C5     ASR W2, #5, W5
00834A  E90204     DEC W4, W4
00834C  62CA61     AND.B W5, #0x1, [W4]
72:                        pad[21]=(portrdF>>4)&1;
00834E  DE9144     ASR W2, #4, W2
008350  E90204     DEC W4, W4
008352  614A61     AND.B W2, #0x1, [W4]
73:                        pad[17]=(portrdG)&1;
008354  520164     SUB W4, #0x4, W2
008356  61C961     AND.B W3, #0x1, [W2]
74:                        pad[18]=(portrdG>>1)&1;
008358  D18203     ASR W3, W4
00835A  E80102     INC W2, W2
00835C  624961     AND.B W4, #0x1, [W2]
75:                        pad[19]=(portrdG>>2)&1;
00835E  DE9A42     ASR W3, #2, W4
008360  E80102     INC W2, W2
008362  624961     AND.B W4, #0x1, [W2]
76:                        pad[20]=(portrdG>>3)&1;
008364  DE9A43     ASR W3, #3, W4
008366  E80102     INC W2, W2
008368  624961     AND.B W4, #0x1, [W2]
77:                        pad[33]=(portrdG>>10)&1;    // Encoder button
00836A  DE9A4A     ASR W3, #10, W4
00836C  41016D     ADD W2, #0xD, W2
00836E  624961     AND.B W4, #0x1, [W2]
78:                        pad[28]=(portrdG>>11)&1;
008370  DE9A4B     ASR W3, #11, W4
008372  510165     SUB W2, #0x5, W2
008374  624961     AND.B W4, #0x1, [W2]
79:                        pad[29]=(portrdG>>12)&1;
008376  DE9A4C     ASR W3, #12, W4
008378  E80102     INC W2, W2
00837A  624961     AND.B W4, #0x1, [W2]
80:                        pad[30]=(portrdG>>13)&1;
00837C  DE9A4D     ASR W3, #13, W4
00837E  E80102     INC W2, W2
008380  624961     AND.B W4, #0x1, [W2]
81:                        pad[31]=(portrdG>>14)&1;
008382  DE984E     ASR W3, #14, W0
008384  E80102     INC W2, W2
008386  604961     AND.B W0, #0x1, [W2]
82:                        pad[32]=(portrdG>>15)&1;
008388  DE19CF     LSR W3, #15, W3
00838A  E80002     INC W2, W0
00838C  784803     MOV.B W3, [W0]
83:                        pad[24]=(portrdD>>1)&1;
00838E  D18101     ASR W1, W2
008390  500068     SUB W0, #0x8, W0
008392  614861     AND.B W2, #0x1, [W0]
84:                        pad[25]=(portrdD>>2)&1;
008394  DE8942     ASR W1, #2, W2
008396  E80000     INC W0, W0
008398  614861     AND.B W2, #0x1, [W0]
85:                        pad[26]=(portrdD>>3)&1;
00839A  DE8943     ASR W1, #3, W2
00839C  E80000     INC W0, W0
00839E  614861     AND.B W2, #0x1, [W0]
86:                        pad[27]=(portrdD>>4)&1;
0083A0  DE88C4     ASR W1, #4, W1
0083A2  E80000     INC W0, W0
0083A4  60C861     AND.B W1, #0x1, [W0]
87:                    }
88:                
89:                   
90:                    
91:                    if(pad[13]==0&&pad_last[13]==1){                                              //TREMELO CONTROL
0083A6  270AD0     MOV #0x70AD, W0
0083A8  784010     MOV.B [W0], W0
0083AA  E00400     CP0.B W0
0083AC  3A000C     BRA NZ, 0x83C6
0083AE  2775B1     MOV #0x775B, W1
0083B0  B3C012     MOV.B #0x1, W2
0083B2  114F91     SUBR.B W2, [W1], [W15]
0083B4  3A0008     BRA NZ, 0x83C6
92:                        pad_last[13]=0;
0083B6  780001     MOV W1, W0
0083B8  EB4800     CLR.B [W0]
93:                        if(tremelo==FALSE)
0083BA  E2500D     CP0.B tremelo
0083BC  3A0002     BRA NZ, 0x83C2
94:                            tremelo=TRUE;
0083BE  EFF00D     SETM.B tremelo
0083C0  370004     BRA 0x83CA
95:                        else tremelo=FALSE;
0083C2  EF700D     CLR.B tremelo
0083C4  370002     BRA 0x83CA
96:                    }
97:                    else{
98:                        pad_last[13]=pad[13];
0083C6  2775B1     MOV #0x775B, W1
0083C8  784880     MOV.B W0, [W1]
99:                    }
100:                   
101:                   if(pad[14]==0) looper=TRUE;
0083CA  270AE0     MOV #0x70AE, W0
0083CC  E00410     CP0.B [W0]
0083CE  3A0002     BRA NZ, 0x83D4
0083D0  EFF00E     SETM.B looper
0083D2  370001     BRA 0x83D6
102:                   else looper=FALSE;
0083D4  EF700E     CLR.B looper
103:                  
104:                   if(pad[15]==0&&pad_last[15]==1){                                              //LPF CONTROL
0083D6  270AF0     MOV #0x70AF, W0
0083D8  784010     MOV.B [W0], W0
0083DA  E00400     CP0.B W0
0083DC  3A000C     BRA NZ, 0x83F6
0083DE  2775D1     MOV #0x775D, W1
0083E0  B3C012     MOV.B #0x1, W2
0083E2  114F91     SUBR.B W2, [W1], [W15]
0083E4  3A0008     BRA NZ, 0x83F6
105:                       pad_last[15]=0;
0083E6  780001     MOV W1, W0
0083E8  EB4800     CLR.B [W0]
106:                       if(lpf==FALSE)
0083EA  E2500F     CP0.B lpf
0083EC  3A0002     BRA NZ, 0x83F2
107:                           lpf=TRUE;
0083EE  EFF00F     SETM.B lpf
0083F0  370004     BRA 0x83FA
108:                       else lpf=FALSE;
0083F2  EF700F     CLR.B lpf
0083F4  370002     BRA 0x83FA
109:                   }
110:                   else{
111:                       pad_last[15]=pad[15];
0083F6  2775D1     MOV #0x775D, W1
0083F8  784880     MOV.B W0, [W1]
112:                   }
113:                   
114:                   
115:                   // SAMPLE TRIGGERS 
116:                   if(pad[0]==0&&kick_playing==FALSE){                                         //kick
0083FA  270A00     MOV #0x70A0, W0
0083FC  E00410     CP0.B [W0]
0083FE  3A0003     BRA NZ, 0x8406
008400  E25032     CP0.B kick_playing
008402  3A0001     BRA NZ, 0x8406
117:                       kick_playing=TRUE;
008404  EFF032     SETM.B kick_playing
118:                   }
119:                   /*
120:                   if(pad[2]==0&&hat_playing==FALSE){                                          //hat
121:                       hat_playing=TRUE;
122:                   }
123:                   */
124:                   if(pad[1]==0&&snare_playing==FALSE){                                        //snare
008406  270A10     MOV #0x70A1, W0
008408  E00410     CP0.B [W0]
00840A  3A0003     BRA NZ, 0x8412
00840C  E25036     CP0.B snare_playing
00840E  3A0001     BRA NZ, 0x8412
125:                       snare_playing=TRUE;
008410  EFF036     SETM.B snare_playing
126:                   }
127:               }
008412  060000     RETURN
128:               
129:               void readPots(void){
130:                   _AD1IF = 0; // Clear conversion done status bit
008414  A9A801     BCLR 0x801, #5
131:                   
132:                   if(pad[34]){
008416  270C20     MOV #0x70C2, W0
008418  E00410     CP0.B [W0]
00841A  320019     BRA Z, 0x844E
133:                       pots[5]=(ADC1BUF0>>1)|0x7;
00841C  801801     MOV ADC1BUF0, W1
00841E  D10081     LSR W1, W1
008420  2607A0     MOV #0x607A, W0
008422  708867     IOR W1, #0x7, [W0]
134:                       pots[3]=(ADC1BUF1>>1)|0x7;
008424  801811     MOV ADC1BUF1, W1
008426  D10081     LSR W1, W1
008428  500064     SUB W0, #0x4, W0
00842A  708867     IOR W1, #0x7, [W0]
135:                       pots[1]=(ADC1BUF2>>1)|0x7;
00842C  801821     MOV ADC1BUF2, W1
00842E  D10081     LSR W1, W1
008430  500064     SUB W0, #0x4, W0
008432  708867     IOR W1, #0x7, [W0]
136:                       pots[4]=(ADC1BUF3>>1)|0x7;
008434  801831     MOV ADC1BUF3, W1
008436  D10081     LSR W1, W1
008438  400066     ADD W0, #0x6, W0
00843A  708867     IOR W1, #0x7, [W0]
137:                       pots[2]=(ADC1BUF4>>1)|0x7;
00843C  801841     MOV ADC1BUF4, W1
00843E  D10081     LSR W1, W1
008440  500064     SUB W0, #0x4, W0
008442  708867     IOR W1, #0x7, [W0]
138:                       pots[0]=(ADC1BUF5>>1)|0x7;
008444  801851     MOV ADC1BUF5, W1
008446  D10081     LSR W1, W1
008448  500064     SUB W0, #0x4, W0
00844A  708867     IOR W1, #0x7, [W0]
00844C  370018     BRA 0x847E
139:                   } else {
140:                       pots[6]=(ADC1BUF0>>1)|0x7;
00844E  801801     MOV ADC1BUF0, W1
008450  D10081     LSR W1, W1
008452  2607C0     MOV #0x607C, W0
008454  708867     IOR W1, #0x7, [W0]
141:                       pots[7]=(ADC1BUF1>>1)|0x7;
008456  801811     MOV ADC1BUF1, W1
008458  D10081     LSR W1, W1
00845A  E88000     INC2 W0, W0
00845C  708867     IOR W1, #0x7, [W0]
142:                       pots[8]=(ADC1BUF2>>1)|0x7;
00845E  801821     MOV ADC1BUF2, W1
008460  D10081     LSR W1, W1
008462  E88000     INC2 W0, W0
008464  708867     IOR W1, #0x7, [W0]
143:                       pots[9]=(ADC1BUF3>>1)|0x7;
008466  801831     MOV ADC1BUF3, W1
008468  D10081     LSR W1, W1
00846A  E88000     INC2 W0, W0
00846C  708867     IOR W1, #0x7, [W0]
144:                       pots[10]=(ADC1BUF4>>1)|0x7;
00846E  801841     MOV ADC1BUF4, W1
008470  D10081     LSR W1, W1
008472  E88000     INC2 W0, W0
008474  708867     IOR W1, #0x7, [W0]
145:                       pots[11]=(ADC1BUF5>>1)|0x7;
008476  801851     MOV ADC1BUF5, W1
008478  D10081     LSR W1, W1
00847A  E88000     INC2 W0, W0
00847C  708867     IOR W1, #0x7, [W0]
146:                   }
147:                   
148:                   loop_lim=pots_percent[5];               //LOOPER CONTROL
00847E  830490     MOV 0x6092, W0
008480  8880A0     MOV W0, loop_lim
149:                   if(pots[0]>=310){                      //LPF CONTROL
008482  830380     MOV pots, W0
008484  201351     MOV #0x135, W1
008486  500F81     SUB W0, W1, [W15]
008488  340004     BRA LE, 0x8492
150:                       lpf_alpha=pots[0];
00848A  888220     MOV W0, 0x1044
151:                       lpf_inv_alpha=(32767-lpf_alpha); 
00848C  27FFF1     MOV #0x7FFF, W1
00848E  508000     SUB W1, W0, W0
008490  888230     MOV W0, 0x1046
152:                   }
153:                   tremelo_depth=pots[1];
008492  830390     MOV 0x6072, W0
008494  888240     MOV W0, 0x1048
154:                   
155:               }
008496  060000     RETURN
156:               
157:               void scalePots(void){
008498  F80022     PUSH ACCA
00849A  F80024     PUSH ACCAH
00849C  F80026     PUSH ACCAU
158:                   /* Potentiometer scaling for fx or lcd display */
159:                   volatile register int scaled asm("A");
160:                   
161:                   scaled=__builtin_mpy(pots[0],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
00849E  232644     MOV #0x3264, W4
0084A0  830385     MOV pots, W5
0084A2  C00113     MPY W4*W5, A
162:                   pots_percent[0]=__builtin_sac(scaled, 7);
0084A4  260880     MOV #0x6088, W0
0084A6  CC0390     SAC A, #7, [W0]
163:                   scaled=__builtin_mpy(pots[1],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
0084A8  830395     MOV 0x6072, W5
0084AA  C00113     MPY W4*W5, A
164:                   pots_percent[1]=__builtin_sac(scaled, 7);
0084AC  E88000     INC2 W0, W0
0084AE  CC0390     SAC A, #7, [W0]
165:                   scaled=__builtin_mpy(pots[2],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
0084B0  8303A5     MOV 0x6074, W5
0084B2  C00113     MPY W4*W5, A
166:                   pots_percent[2]=__builtin_sac(scaled, 7);
0084B4  E88000     INC2 W0, W0
0084B6  CC0390     SAC A, #7, [W0]
167:                   scaled=__builtin_mpy(pots[3],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
0084B8  8303B5     MOV 0x6076, W5
0084BA  C00113     MPY W4*W5, A
168:                   pots_percent[3]=__builtin_sac(scaled, 7);
0084BC  E88000     INC2 W0, W0
0084BE  CC0390     SAC A, #7, [W0]
169:                   scaled=__builtin_mpy(pots[4],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
0084C0  8303C5     MOV 0x6078, W5
0084C2  C00113     MPY W4*W5, A
170:                   pots_percent[4]=__builtin_sac(scaled, 7);
0084C4  E88000     INC2 W0, W0
0084C6  CC0390     SAC A, #7, [W0]
171:                   scaled=__builtin_mpy(pots[5],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
0084C8  8303D5     MOV 0x607A, W5
0084CA  C00113     MPY W4*W5, A
172:                   pots_percent[5]=__builtin_sac(scaled, 7);
0084CC  E88000     INC2 W0, W0
0084CE  CC0390     SAC A, #7, [W0]
173:                   
174:                   //scaled=__builtin_mpy(pots[5],Q15(0.33), NULL, NULL, 0, NULL, NULL, 0);
175:                   //pots_percent[5]=__builtin_sac(scaled, 0);
176:               }
0084D0  F90026     POP ACCAU
0084D2  F90024     POP ACCAH
0084D4  F90022     POP ACCA
0084D6  060000     RETURN
177:               
178:               void display(void){
179:                   IFS0bits.SPI1IF=0;
0084D8  A94801     BCLR 0x801, #2
180:                   SPI1STATbits.SPIROV = 0;
0084DA  A9C240     BCLR SPI1STAT, #6
181:                   scalePots();
0084DC  07FFDD     RCALL scalePots
182:                   
183:                   // Update ui state logic here
184:                   state = (ENCODERCNTL/4)+1;
0084DE  800E30     MOV POS1CNTL, W0
0084E0  DE0042     LSR W0, #2, W0
0084E2  E80000     INC W0, W0
0084E4  888210     MOV W0, 0x1042
185:                   
186:                   // Update screen here
187:                   screenUpdate();
0084E6  07FEDC     RCALL screenUpdate
188:                  
189:                  if(UART_ON==TRUE){
0084E8  BFD00B     MOV.B UART_ON, WREG
0084EA  404FE1     ADD.B W0, #0x1, [W15]
0084EC  3A0007     BRA NZ, 0x84FC
190:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
191:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
192:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
193:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
0084EE  F86074     PUSH 0x6074
0084F0  F86072     PUSH 0x6072
0084F2  F86070     PUSH pots
0084F4  2F72E0     MOV #0xF72E, W0
0084F6  781F80     MOV W0, [W15++]
0084F8  07BFE3     RCALL __printf_cdnopuxX
0084FA  5787E8     SUB W15, #0x8, W15
194:                       //printf("%d\r\n", sample);  //check input ADC
195:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
196:                   }
197:                  
198:                  SLED=~SLED;
0084FC  8072A0     MOV LATF, W0
0084FE  EA8000     COM W0, W0
008500  600061     AND W0, #0x1, W0
008502  8072A1     MOV LATF, W1
008504  A10001     BCLR W1, #0
008506  700081     IOR W0, W1, W1
008508  8872A1     MOV W1, LATF
199:               }
00850A  060000     RETURN
200:               
201:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
202:                   /* This procedure loops back the received data to the*/
203:                   /* the codec output. The user application could process*/
204:                   /* this data as per application requirements.*/
205:                   int index;
206:                   for(index = 0;index < STREAMBUF;index ++)
00850C  EB0100     CLR W2
00850E  202003     MOV #0x200, W3
008512  E80102     INC W2, W2
008514  510F83     SUB W2, W3, [W15]
008516  3AFFFC     BRA NZ, 0x8510
207:                   {
208:                       targetBuffer[index] = sourceBuffer[index];
008510  7818B0     MOV [W0++], [W1++]
209:                   }
210:               }
008518  060000     RETURN
211:               
212:               //A blocking delay function. Not very accurate but good enough.
213:               void Delay_us(unsigned int delay)
214:               {
215:                   int i;
216:                   for (i = 0; i < delay; i++)
00851A  E00000     CP0 W0
00851C  320006     BRA Z, 0x852A
00851E  EB0080     CLR W1
008524  E80081     INC W1, W1
008526  500F81     SUB W0, W1, [W15]
008528  3EFFFB     BRA GTU, 0x8520
217:                   {
218:                       __asm__ volatile ("repeat #50");
008520  090032     REPEAT #0x32
219:                       __asm__ volatile ("nop");
008522  000000     NOP
220:                   }
221:               }
00852A  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/screens.c  --------------------------------------------
1:                 /*
2:                  * File:   screens.c
3:                  * Author: ryan
4:                  *
5:                  * Created on January 28, 2018, 11:17 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "common.h"
11:                #include "plcd.h"
12:                #include "dsp.h"
13:                #include "flash.h"
14:                
15:                extern unsigned char TEST_SIN;
16:                extern fractional pots[POTS];
17:                extern fractional pots_percent[POTS];
18:                extern enum screen state, laststate;
19:                extern char flash_readback[512];
20:                extern unsigned int cycle, process_time;
21:                
22:                
23:                void screenDebugAudio(){
24:                
25:                }
008068  060000     RETURN
26:                
27:                void screenDebufBuffers(){
28:                    if(state!=laststate){
00806A  808080     MOV laststate, W0
00806C  E31042     CP 0x1042
00806E  32001E     BRA Z, 0x80AC
29:                        //setup here
30:                        lcdClearQ();
008070  07FB81     RCALL lcdClearQ
31:                        lcdSetCursorQ(0,0);
008072  EB4080     CLR.B W1
008074  784001     MOV.B W1, W0
008076  07FB89     RCALL lcdSetCursorQ
32:                        lcdWriteStringQ("Buffer Debug");
008078  2F6D20     MOV #0xF6D2, W0
00807A  07FB9B     RCALL lcdWriteStringQ
33:                        lcdSetCursorQ(0,1);
00807C  B3C011     MOV.B #0x1, W1
00807E  EB4000     CLR.B W0
008080  07FB84     RCALL lcdSetCursorQ
34:                        lcdWriteStringQ("FX time:");
008082  2F6DF0     MOV #0xF6DF, W0
008084  07FB96     RCALL lcdWriteStringQ
35:                        lcdSetCursorQ(11,1);
008086  B3C011     MOV.B #0x1, W1
008088  B3C0B0     MOV.B #0xB, W0
00808A  07FB7F     RCALL lcdSetCursorQ
36:                        lcdWriteStringQ("/");
00808C  2F6E80     MOV #0xF6E8, W0
00808E  07FB91     RCALL lcdWriteStringQ
37:                        lcdWriteDecimalQ((char)STREAMBUF,3);
008090  200031     MOV #0x3, W1
008092  EB4000     CLR.B W0
008094  07FC74     RCALL lcdWriteDecimalQ
38:                        lcdSetCursorQ(0,2);
008096  B3C021     MOV.B #0x2, W1
008098  EB4000     CLR.B W0
00809A  07FB77     RCALL lcdSetCursorQ
39:                        lcdWriteStringQ("LCD:");
00809C  2F6EA0     MOV #0xF6EA, W0
00809E  07FB89     RCALL lcdWriteStringQ
40:                        lcdSetCursorQ(0,3);
0080A0  B3C031     MOV.B #0x3, W1
0080A2  EB4000     CLR.B W0
0080A4  07FB72     RCALL lcdSetCursorQ
41:                        lcdWriteStringQ("Flash:");
0080A6  2F6EF0     MOV #0xF6EF, W0
0080A8  07FB84     RCALL lcdWriteStringQ
0080AA  370006     BRA 0x80B8
42:                    } else {
43:                        //update here
44:                        lcdSetCursorQ(8,1);
0080AC  B3C011     MOV.B #0x1, W1
0080AE  B3C080     MOV.B #0x8, W0
0080B0  07FB6C     RCALL lcdSetCursorQ
45:                        lcdWriteDecimalQ(process_time,3);
0080B2  200031     MOV #0x3, W1
0080B4  BFD008     MOV.B process_time, WREG
0080B6  07FC63     RCALL lcdWriteDecimalQ
46:                        //lcdSetCursorQ(4,2);
47:                        //lcdWriteDecimalQ();
48:                        //lcdSetCursorQ(6,3);
49:                        //lcdWriteDecimalQ();
50:                        
51:                    }
52:                }
0080B8  060000     RETURN
53:                
54:                void screenDebugPots(void){
55:                    if(state!=laststate){
0080BA  808080     MOV laststate, W0
0080BC  E31042     CP 0x1042
0080BE  320016     BRA Z, 0x80EC
56:                        // Setup here
57:                        lcdClearQ();
0080C0  07FB59     RCALL lcdClearQ
58:                        lcdSetCursorQ(0,0);
0080C2  EB4080     CLR.B W1
0080C4  784001     MOV.B W1, W0
0080C6  07FB61     RCALL lcdSetCursorQ
59:                        lcdWriteStringQ("Potentiometer Debug");
0080C8  2F6F60     MOV #0xF6F6, W0
0080CA  07FB73     RCALL lcdWriteStringQ
60:                        lcdSetCursorQ(9,1);
0080CC  B3C011     MOV.B #0x1, W1
0080CE  B3C090     MOV.B #0x9, W0
0080D0  07FB5C     RCALL lcdSetCursorQ
61:                        lcdWriteStringQ("|");
0080D2  2F70A0     MOV #0xF70A, W0
0080D4  07FB6E     RCALL lcdWriteStringQ
62:                         lcdSetCursorQ(9,2);
0080D6  B3C021     MOV.B #0x2, W1
0080D8  B3C090     MOV.B #0x9, W0
0080DA  07FB57     RCALL lcdSetCursorQ
63:                        lcdWriteStringQ("|");
0080DC  2F70A0     MOV #0xF70A, W0
0080DE  07FB69     RCALL lcdWriteStringQ
64:                         lcdSetCursorQ(9,3);
0080E0  B3C031     MOV.B #0x3, W1
0080E2  B3C090     MOV.B #0x9, W0
0080E4  07FB52     RCALL lcdSetCursorQ
65:                        lcdWriteStringQ("|");
0080E6  2F70A0     MOV #0xF70A, W0
0080E8  07FB64     RCALL lcdWriteStringQ
0080EA  37003C     BRA 0x8164
66:                    } else {
67:                        // Update here
68:                        lcdSetCursorQ(0,1);
0080EC  B3C011     MOV.B #0x1, W1
0080EE  EB4000     CLR.B W0
0080F0  07FB4C     RCALL lcdSetCursorQ
69:                        lcdWriteDecimalQ(pots_percent[0], 3);
0080F2  200031     MOV #0x3, W1
0080F4  830440     MOV pots_percent, W0
0080F6  07FC43     RCALL lcdWriteDecimalQ
70:                        lcdWriteQ(',');
0080F8  B3C2C0     MOV.B #0x2C, W0
0080FA  07FB27     RCALL lcdWriteQ
71:                        lcdWriteWordUnsignedQ(pots[0]);
0080FC  830380     MOV pots, W0
0080FE  07FBE7     RCALL lcdWriteWordUnsignedQ
72:                        lcdSetCursorQ(11,1);
008100  B3C011     MOV.B #0x1, W1
008102  B3C0B0     MOV.B #0xB, W0
008104  07FB42     RCALL lcdSetCursorQ
73:                        lcdWriteDecimalQ(pots_percent[1], 3);
008106  200031     MOV #0x3, W1
008108  830450     MOV 0x608A, W0
00810A  07FC39     RCALL lcdWriteDecimalQ
74:                        lcdWriteQ(',');
00810C  B3C2C0     MOV.B #0x2C, W0
00810E  07FB1D     RCALL lcdWriteQ
75:                        lcdWriteWordUnsignedQ(pots[1]);
008110  830390     MOV 0x6072, W0
008112  07FBDD     RCALL lcdWriteWordUnsignedQ
76:                        lcdSetCursorQ(0,2);
008114  B3C021     MOV.B #0x2, W1
008116  EB4000     CLR.B W0
008118  07FB38     RCALL lcdSetCursorQ
77:                        lcdWriteDecimalQ(pots_percent[2], 3);
00811A  200031     MOV #0x3, W1
00811C  830460     MOV 0x608C, W0
00811E  07FC2F     RCALL lcdWriteDecimalQ
78:                        lcdWriteQ(',');
008120  B3C2C0     MOV.B #0x2C, W0
008122  07FB13     RCALL lcdWriteQ
79:                        lcdWriteWordUnsignedQ(pots[2]);
008124  8303A0     MOV 0x6074, W0
008126  07FBD3     RCALL lcdWriteWordUnsignedQ
80:                        lcdSetCursorQ(11,2);
008128  B3C021     MOV.B #0x2, W1
00812A  B3C0B0     MOV.B #0xB, W0
00812C  07FB2E     RCALL lcdSetCursorQ
81:                        lcdWriteDecimalQ(pots_percent[3], 3);
00812E  200031     MOV #0x3, W1
008130  830470     MOV 0x608E, W0
008132  07FC25     RCALL lcdWriteDecimalQ
82:                        lcdWriteQ(',');
008134  B3C2C0     MOV.B #0x2C, W0
008136  07FB09     RCALL lcdWriteQ
83:                        lcdWriteWordUnsignedQ(pots[3]);
008138  8303B0     MOV 0x6076, W0
00813A  07FBC9     RCALL lcdWriteWordUnsignedQ
84:                        lcdSetCursorQ(0,3);
00813C  B3C031     MOV.B #0x3, W1
00813E  EB4000     CLR.B W0
008140  07FB24     RCALL lcdSetCursorQ
85:                        lcdWriteDecimalQ(pots_percent[4], 3);
008142  200031     MOV #0x3, W1
008144  830480     MOV 0x6090, W0
008146  07FC1B     RCALL lcdWriteDecimalQ
86:                        lcdWriteQ(',');
008148  B3C2C0     MOV.B #0x2C, W0
00814A  07FAFF     RCALL lcdWriteQ
87:                        lcdWriteWordUnsignedQ(pots[4]);
00814C  8303C0     MOV 0x6078, W0
00814E  07FBBF     RCALL lcdWriteWordUnsignedQ
88:                        lcdSetCursorQ(11,3);
008150  B3C031     MOV.B #0x3, W1
008152  B3C0B0     MOV.B #0xB, W0
008154  07FB1A     RCALL lcdSetCursorQ
89:                        lcdWriteDecimalQ(pots_percent[5], 3);
008156  200031     MOV #0x3, W1
008158  830490     MOV 0x6092, W0
00815A  07FC11     RCALL lcdWriteDecimalQ
90:                        lcdWriteQ(',');
00815C  B3C2C0     MOV.B #0x2C, W0
00815E  07FAF5     RCALL lcdWriteQ
91:                        lcdWriteWordUnsignedQ(pots[5]);
008160  8303D0     MOV 0x607A, W0
008162  07FBB5     RCALL lcdWriteWordUnsignedQ
92:                    }
93:                }
008164  060000     RETURN
94:                
95:                void screenFX(void){
96:                    if(state!=laststate){
008166  808080     MOV laststate, W0
008168  E31042     CP 0x1042
00816A  32002A     BRA Z, 0x81C0
97:                        //setup here
98:                        lcdClearQ();
00816C  07FB03     RCALL lcdClearQ
99:                        lcdSetCursorQ(0,0);
00816E  EB4080     CLR.B W1
008170  784001     MOV.B W1, W0
008172  07FB0B     RCALL lcdSetCursorQ
100:                       lcdWriteStringQ("FX1:");
008174  2F70C0     MOV #0xF70C, W0
008176  07FB1D     RCALL lcdWriteStringQ
101:                       lcdSetCursorQ(10,0);
008178  EB4080     CLR.B W1
00817A  B3C0A0     MOV.B #0xA, W0
00817C  07FB06     RCALL lcdSetCursorQ
102:                       lcdWriteStringQ("FX2:");
00817E  2F7110     MOV #0xF711, W0
008180  07FB18     RCALL lcdWriteStringQ
103:                       
104:                       lcdSetCursorQ(0,1);
008182  B3C011     MOV.B #0x1, W1
008184  EB4000     CLR.B W0
008186  07FB01     RCALL lcdSetCursorQ
105:                       lcdWriteStringQ("1:");
008188  2F7160     MOV #0xF716, W0
00818A  07FB13     RCALL lcdWriteStringQ
106:                       lcdSetCursorQ(10,1);
00818C  B3C011     MOV.B #0x1, W1
00818E  B3C0A0     MOV.B #0xA, W0
008190  07FAFC     RCALL lcdSetCursorQ
107:                       lcdWriteStringQ("4:");
008192  2F7190     MOV #0xF719, W0
008194  07FB0E     RCALL lcdWriteStringQ
108:                       lcdSetCursorQ(0,2);
008196  B3C021     MOV.B #0x2, W1
008198  EB4000     CLR.B W0
00819A  07FAF7     RCALL lcdSetCursorQ
109:                       lcdWriteStringQ("2:");
00819C  2F71C0     MOV #0xF71C, W0
00819E  07FB09     RCALL lcdWriteStringQ
110:                       lcdSetCursorQ(10,2);
0081A0  B3C021     MOV.B #0x2, W1
0081A2  B3C0A0     MOV.B #0xA, W0
0081A4  07FAF2     RCALL lcdSetCursorQ
111:                       lcdWriteStringQ("5:");
0081A6  2F71F0     MOV #0xF71F, W0
0081A8  07FB04     RCALL lcdWriteStringQ
112:                       lcdSetCursorQ(0,3);
0081AA  B3C031     MOV.B #0x3, W1
0081AC  EB4000     CLR.B W0
0081AE  07FAED     RCALL lcdSetCursorQ
113:                       lcdWriteStringQ("3:");
0081B0  2F7220     MOV #0xF722, W0
0081B2  07FAFF     RCALL lcdWriteStringQ
114:                       lcdSetCursorQ(10,3);
0081B4  B3C031     MOV.B #0x3, W1
0081B6  B3C0A0     MOV.B #0xA, W0
0081B8  07FAE8     RCALL lcdSetCursorQ
115:                       lcdWriteStringQ("6:");
0081BA  2F7250     MOV #0xF725, W0
0081BC  07FAFA     RCALL lcdWriteStringQ
0081BE  370024     BRA 0x8208
116:                   } else {
117:                       //update here
118:                       lcdSetCursorQ(2,1);
0081C0  B3C011     MOV.B #0x1, W1
0081C2  B3C020     MOV.B #0x2, W0
0081C4  07FAE2     RCALL lcdSetCursorQ
119:                       lcdWriteDecimalQ(pots_percent[0], 3);
0081C6  200031     MOV #0x3, W1
0081C8  830440     MOV pots_percent, W0
0081CA  07FBD9     RCALL lcdWriteDecimalQ
120:                       lcdSetCursorQ(12,1);
0081CC  B3C011     MOV.B #0x1, W1
0081CE  B3C0C0     MOV.B #0xC, W0
0081D0  07FADC     RCALL lcdSetCursorQ
121:                       lcdWriteDecimalQ(pots_percent[1], 3);
0081D2  200031     MOV #0x3, W1
0081D4  830450     MOV 0x608A, W0
0081D6  07FBD3     RCALL lcdWriteDecimalQ
122:                       lcdSetCursorQ(2,2);
0081D8  B3C021     MOV.B #0x2, W1
0081DA  784001     MOV.B W1, W0
0081DC  07FAD6     RCALL lcdSetCursorQ
123:                       lcdWriteDecimalQ(pots_percent[2], 3);
0081DE  200031     MOV #0x3, W1
0081E0  830460     MOV 0x608C, W0
0081E2  07FBCD     RCALL lcdWriteDecimalQ
124:                       lcdSetCursorQ(12,2);
0081E4  B3C021     MOV.B #0x2, W1
0081E6  B3C0C0     MOV.B #0xC, W0
0081E8  07FAD0     RCALL lcdSetCursorQ
125:                       lcdWriteDecimalQ(pots_percent[3], 3);
0081EA  200031     MOV #0x3, W1
0081EC  830470     MOV 0x608E, W0
0081EE  07FBC7     RCALL lcdWriteDecimalQ
126:                       lcdSetCursorQ(2,3);
0081F0  B3C031     MOV.B #0x3, W1
0081F2  B3C020     MOV.B #0x2, W0
0081F4  07FACA     RCALL lcdSetCursorQ
127:                       lcdWriteDecimalQ(pots_percent[4], 3);
0081F6  200031     MOV #0x3, W1
0081F8  830480     MOV 0x6090, W0
0081FA  07FBC1     RCALL lcdWriteDecimalQ
128:                       lcdSetCursorQ(12,3);
0081FC  B3C031     MOV.B #0x3, W1
0081FE  B3C0C0     MOV.B #0xC, W0
008200  07FAC4     RCALL lcdSetCursorQ
129:                       lcdWriteDecimalQ(pots_percent[5], 3);
008202  200031     MOV #0x3, W1
008204  830490     MOV 0x6092, W0
008206  07FBBB     RCALL lcdWriteDecimalQ
130:               
131:                   }
132:               }
008208  060000     RETURN
133:               
134:               void screenDebugFlash(void){
00820A  781F88     MOV W8, [W15++]
135:                       if(state!=laststate){
00820C  808080     MOV laststate, W0
00820E  E31042     CP 0x1042
008210  32003D     BRA Z, 0x828C
136:                       //setup here
137:                       lcdClearQ();
008212  07FAB0     RCALL lcdClearQ
138:                       lcdSetCursorQ(0,0);
008214  EB4080     CLR.B W1
008216  784001     MOV.B W1, W0
008218  07FAB8     RCALL lcdSetCursorQ
139:                       lcdWriteWordQ(flash_readback[2]);
00821A  25E720     MOV #0x5E72, W0
00821C  FB0010     SE [W0], W0
00821E  07FAE7     RCALL lcdWriteWordQ
140:                        lcdSetCursorQ(6,0);
008220  EB4080     CLR.B W1
008222  B3C060     MOV.B #0x6, W0
008224  07FAB2     RCALL lcdSetCursorQ
141:                       lcdWriteWordQ(flash_readback[3]);
008226  25E730     MOV #0x5E73, W0
008228  FB0010     SE [W0], W0
00822A  07FAE1     RCALL lcdWriteWordQ
142:                        lcdSetCursorQ(12,0);
00822C  EB4080     CLR.B W1
00822E  B3C0C0     MOV.B #0xC, W0
008230  07FAAC     RCALL lcdSetCursorQ
143:                       lcdWriteWordQ(flash_readback[4]);
008232  25E740     MOV #0x5E74, W0
008234  FB0010     SE [W0], W0
008236  07FADB     RCALL lcdWriteWordQ
144:                        lcdSetCursorQ(0,1);
008238  B3C011     MOV.B #0x1, W1
00823A  EB4000     CLR.B W0
00823C  07FAA6     RCALL lcdSetCursorQ
145:                       lcdWriteWordQ(flash_readback[5]);
00823E  25E750     MOV #0x5E75, W0
008240  FB0010     SE [W0], W0
008242  07FAD5     RCALL lcdWriteWordQ
146:                       lcdSetCursorQ(6,1);
008244  B3C011     MOV.B #0x1, W1
008246  B3C060     MOV.B #0x6, W0
008248  07FAA0     RCALL lcdSetCursorQ
147:                       lcdWriteWordQ(flash_readback[6]);
00824A  25E760     MOV #0x5E76, W0
00824C  FB0010     SE [W0], W0
00824E  07FACF     RCALL lcdWriteWordQ
148:                        lcdSetCursorQ(12,1);
008250  B3C011     MOV.B #0x1, W1
008252  B3C0C0     MOV.B #0xC, W0
008254  07FA9A     RCALL lcdSetCursorQ
149:                       lcdWriteWordQ(flash_readback[7]);
008256  25E770     MOV #0x5E77, W0
008258  FB0010     SE [W0], W0
00825A  07FAC9     RCALL lcdWriteWordQ
150:                       lcdSetCursorQ(0,2);
00825C  B3C021     MOV.B #0x2, W1
00825E  EB4000     CLR.B W0
008260  07FA94     RCALL lcdSetCursorQ
151:                       lcdWriteWordQ(flash_readback[8]);
008262  25E788     MOV #0x5E78, W8
008264  FB0018     SE [W8], W0
008266  07FAC3     RCALL lcdWriteWordQ
152:                       lcdSetCursorQ(6,2);
008268  B3C021     MOV.B #0x2, W1
00826A  B3C060     MOV.B #0x6, W0
00826C  07FA8E     RCALL lcdSetCursorQ
153:                       lcdWriteWordQ(flash_readback[9]);
00826E  E80008     INC W8, W0
008270  FB0010     SE [W0], W0
008272  07FABD     RCALL lcdWriteWordQ
154:                        lcdSetCursorQ(12,2);
008274  B3C021     MOV.B #0x2, W1
008276  B3C0C0     MOV.B #0xC, W0
008278  07FA88     RCALL lcdSetCursorQ
155:                       lcdWriteWordQ(flash_readback[10]);
00827A  E88008     INC2 W8, W0
00827C  FB0010     SE [W0], W0
00827E  07FAB7     RCALL lcdWriteWordQ
156:                       lcdSetCursorQ(0,3);
008280  B3C031     MOV.B #0x3, W1
008282  EB4000     CLR.B W0
008284  07FA82     RCALL lcdSetCursorQ
157:                       lcdWriteWordQ(flash_readback[8]);
008286  FB0018     SE [W8], W0
008288  07FAB2     RCALL lcdWriteWordQ
00828A  370008     BRA 0x829C
158:                   } else {
159:                       //update here
160:                       lcdSetCursorQ(9,3);
00828C  B3C031     MOV.B #0x3, W1
00828E  B3C090     MOV.B #0x9, W0
008290  07FA7C     RCALL lcdSetCursorQ
161:                       lcdWriteStringQ("Stat:");
008292  2F7280     MOV #0xF728, W0
008294  07FA8E     RCALL lcdWriteStringQ
162:                       lcdWriteWordQ(flashStatusCheck());
008296  0702D1     RCALL flashStatusCheck
008298  FB0000     SE W0, W0
00829A  07FAA9     RCALL lcdWriteWordQ
163:                   }
164:               }
00829C  78044F     MOV [--W15], W8
00829E  060000     RETURN
165:               
166:               void screenUpdate(void){
167:                   switch(state){
0082A0  808210     MOV 0x1042, W0
0082A2  500FE2     SUB W0, #0x2, [W15]
0082A4  32000B     BRA Z, 0x82BC
0082A6  3E0003     BRA GTU, 0x82AE
0082A8  500FE1     SUB W0, #0x1, [W15]
0082AA  3A000D     BRA NZ, 0x82C6
0082AC  370005     BRA 0x82B8
0082AE  500FE3     SUB W0, #0x3, [W15]
0082B0  320007     BRA Z, 0x82C0
0082B2  500FE4     SUB W0, #0x4, [W15]
0082B4  3A0008     BRA NZ, 0x82C6
0082B6  370006     BRA 0x82C4
168:                       case start: break;
169:                       case scrnFX:            screenFX(); 
0082B8  07FF56     RCALL screenFX
170:                       break;
0082BA  370005     BRA 0x82C6
171:                       case debugscrnPOTS:     screenDebugPots();
0082BC  07FEFE     RCALL screenDebugPots
172:                       break;
0082BE  370003     BRA 0x82C6
173:                       case debugscrnFLASH:    screenDebugFlash();
0082C0  07FFA4     RCALL screenDebugFlash
174:                       break;
0082C2  370001     BRA 0x82C6
175:                       case debugscrnBUFFERS:  screenDebufBuffers();
0082C4  07FED2     RCALL screenDebufBuffers
176:                       break;
177:                                       
178:                       default: break;
179:                   }
180:                   
181:                   laststate=state;
0082C6  F81042     PUSH 0x1042
0082C8  F91010     POP laststate
182:               }
0082CA  060000     RETURN
183:               
184:                   /*
185:                   lcdSetCursorQ(0,3);
186:                   if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
187:                       lcdWriteStringQ("CLIP");
188:                       hard_clipped=FALSE;  
189:                   }
190:                   else if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
191:                   else lcdWriteStringQ("THRU");
192:                    * 
193:                    *    lcdSetCursorQ(10,3);
194:                  lcdWriteWordQ(ENCODERCNTL);
195:                   */
196:               
197:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/routines.c  -------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
10:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
11:                extern unsigned int write_ptr, rw, frameReady;
12:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
13:                
14:                //misc.
15:                volatile fractional sampinA=0, sampinB=0;
16:                
17:                volatile int rxBufferIndicator = 0;
18:                fractional *ping, *pong;
19:                
20:                //Description: This interrupt triggers at the completion of DCI output
21:                //Dependancies: initSPI2(); 
22:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
000306  BE9F80     MOV.D W0, [W15++]
000308  BE9F82     MOV.D W2, [W15++]
00030A  781F84     MOV W4, [W15++]
00030C  F80032     PUSH DSRPAG
00030E  F80034     PUSH DSWPAG
000310  200010     MOV #0x1, W0
000312  8801A0     MOV W0, DSWPAG
000314  202000     MOV #0x200, W0
000316  880190     MOV W0, DSRPAG
000318  000000     NOP
23:                    static fractional sampoutA=0, sampoutB=0;
24:                    
25:                    int trashA=RXBUF0;
00031A  801480     MOV RXBUF0, W0
26:                    sampinA=RXBUF1;
00031C  F80292     PUSH RXBUF1
00031E  F91024     POP sampinA
27:                    int trashB=RXBUF2;
000320  8014A0     MOV RXBUF2, W0
28:                    sampinB=RXBUF3;
000322  F80296     PUSH RXBUF3
000324  F91026     POP sampinB
29:                    TXBUF0=TXBUF1=sampoutA;                                    //output buffered sample to DAC
000326  F81030     PUSH sampoutA
000328  F9029A     POP TXBUF1
00032A  F8029A     PUSH TXBUF1
00032C  F90298     POP TXBUF0
30:                    TXBUF2=TXBUF3=sampoutB;
00032E  F8102E     PUSH sampoutB
000330  F9029E     POP TXBUF3
000332  F8029E     PUSH TXBUF3
000334  F9029C     POP TXBUF2
31:                
32:                
33:                    
34:                    __builtin_btg(&sampinA, 15);                             //convert to Q1.15 compatible format
000336  210240     MOV #0x1024, W0
000338  A2F010     BTG [W0], #15
35:                    __builtin_btg(&sampinB, 15);                             //convert to Q1.15 compatible format
00033A  210260     MOV #0x1026, W0
00033C  A2F010     BTG [W0], #15
36:                    
37:                
38:                      
39:                    
40:                    if(write_ptr--==0){                       //reset pointer when out of bounds
00033E  8081F0     MOV 0x103E, W0
000340  E90080     DEC W0, W1
000342  8881F1     MOV W1, 0x103E
000344  E00000     CP0 W0
000346  3A0005     BRA NZ, 0x352
41:                        write_ptr=STREAMBUF-1;
000348  201FF0     MOV #0x1FF, W0
00034A  8881F0     MOV W0, 0x103E
42:                        __builtin_btg(&rw,0);
00034C  AA1000     BTG rw, #0
43:                        frameReady=1;
00034E  200010     MOV #0x1, W0
000350  888010     MOV W0, frameReady
44:                    }
45:                   
46:                    if(rw){
000352  E21000     CP0 rw
000354  320014     BRA Z, 0x37E
47:                        streamB[write_ptr]=sampinA;
000356  8081F0     MOV 0x103E, W0
000358  26CA02     MOV #0x6CA0, W2
00035A  400180     ADD W0, W0, W3
00035C  410083     ADD W2, W3, W1
00035E  808124     MOV sampinA, W4
000360  780884     MOV W4, [W1]
48:                        sampoutA=outputA[write_ptr--]; 
000362  260A01     MOV #0x60A0, W1
000364  408183     ADD W1, W3, W3
000366  780193     MOV [W3], W3
000368  888183     MOV W3, sampoutA
00036A  E90000     DEC W0, W0
00036C  8881F0     MOV W0, 0x103E
49:                        streamB[write_ptr]=sampinB;
00036E  400000     ADD W0, W0, W0
000370  410100     ADD W2, W0, W2
000372  808133     MOV sampinB, W3
000374  780903     MOV W3, [W2]
50:                        sampoutB=outputA[write_ptr];
000376  408000     ADD W1, W0, W0
000378  780010     MOV [W0], W0
00037A  888170     MOV W0, sampoutB
00037C  370013     BRA 0x3A4
51:                        
52:                    }
53:                    else {
54:                        streamA[write_ptr]=sampinA; 
00037E  8081F0     MOV 0x103E, W0
000380  268A02     MOV #0x68A0, W2
000382  400180     ADD W0, W0, W3
000384  410083     ADD W2, W3, W1
000386  808124     MOV sampinA, W4
000388  780884     MOV W4, [W1]
55:                        sampoutA=outputB[write_ptr--];  
00038A  264A01     MOV #0x64A0, W1
00038C  408183     ADD W1, W3, W3
00038E  780193     MOV [W3], W3
000390  888183     MOV W3, sampoutA
000392  E90000     DEC W0, W0
000394  8881F0     MOV W0, 0x103E
56:                        streamA[write_ptr]=sampinB; 
000396  400000     ADD W0, W0, W0
000398  410100     ADD W2, W0, W2
00039A  808133     MOV sampinB, W3
00039C  780903     MOV W3, [W2]
57:                        sampoutB=outputB[write_ptr];  
00039E  408000     ADD W1, W0, W0
0003A0  780010     MOV [W0], W0
0003A2  888170     MOV W0, sampoutB
58:                    } 
59:                    
60:                    _DCIIF=0;
0003A4  A98807     BCLR 0x807, #4
61:                }
0003A6  F90034     POP DSWPAG
0003A8  F90032     POP DSRPAG
0003AA  78024F     MOV [--W15], W4
0003AC  BE014F     MOV.D [--W15], W2
0003AE  BE004F     MOV.D [--W15], W0
0003B0  064000     RETFIE
62:                
63:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003B2  F80036     PUSH RCOUNT
0003B4  BE9F80     MOV.D W0, [W15++]
0003B6  BE9F82     MOV.D W2, [W15++]
0003B8  BE9F84     MOV.D W4, [W15++]
0003BA  BE9F86     MOV.D W6, [W15++]
64:                    _DMA2IF = 0; /* Received one frame of data*/    
0003BC  A90803     BCLR 0x803, #0
65:                    
66:                    if(rxBufferIndicator == 0)
0003BE  E21028     CP0 rxBufferIndicator
0003C0  3A0004     BRA NZ, 0x3CA
67:                    {
68:                         processRxData((int *)rxBufferA, (int*)txBufferA);
0003C2  2CC001     MOV #0xCC00, W1
0003C4  2C4000     MOV #0xC400, W0
0003C6  0740A2     RCALL processRxData
0003C8  370003     BRA 0x3D0
69:                    }
70:                    else
71:                    {
72:                         processRxData((int *)rxBufferB, (int*)txBufferB);
0003CA  2C8001     MOV #0xC800, W1
0003CC  2C0000     MOV #0xC000, W0
0003CE  07409E     RCALL processRxData
73:                    }
74:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
0003D0  AA1028     BTG rxBufferIndicator, #0
75:                }
0003D2  BE034F     MOV.D [--W15], W6
0003D4  BE024F     MOV.D [--W15], W4
0003D6  BE014F     MOV.D [--W15], W2
0003D8  BE004F     MOV.D [--W15], W0
0003DA  F90036     POP RCOUNT
0003DC  064000     RETFIE
76:                
77:                /*
78:                //Description: This interrupt handles UART reception
79:                //Dependencies: initUART1();
80:                void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
81:                    unsigned char trash;
82:                    trash=U1RXREG;
83:                    printf("RECIEVED: %d\r\n", trash);
84:                    IFS0bits.U1RXIF = 0;            //clear flag, restart
85:                }
86:                
87:                //Description: This interrupt handles UART transmission
88:                //Dependencies: initUART1();
89:                void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
90:                    YLED=~YLED;
91:                    IFS0bits.U1TXIF = 0;            //clear flag, restart
92:                } 
93:                  
94:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
95:                    //SEG_SEL=1;
96:                    int trash=SPI3BUF;
97:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
98:                    IFS5bits.SPI3IF=0;
99:                    
100:               }
101:                */
---  C:/Users/ryan/Documents/seniorproject/ps-040/plcd.c  -----------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                #include "screens.h"
14:                
15:                extern unsigned char pad[BUTTONS];
16:                int lcdBuf[LCDBUF+1]={0};
17:                int *lcdWritePtr=lcdBuf;
18:                int *lcdReadPtr=lcdBuf;
19:                
20:                // There are write and command macros in the header, make sure these match.
21:                void lcdWriteQ(unsigned char data){
22:                    *lcdWritePtr++=data|0x0000;
00774A  FB8000     ZE W0, W0
00774C  808251     MOV divtestb, W1
00774E  781880     MOV W0, [W1++]
007750  888251     MOV W1, divtestb
23:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007752  276C40     MOV #0x76C4, W0
007754  508F80     SUB W1, W0, [W15]
007756  3A0002     BRA NZ, 0x775C
24:                        lcdWritePtr=lcdBuf;
007758  B12000     SUB #0x200, W0
00775A  888250     MOV W0, divtestb
25:                }
00775C  060000     RETURN
26:                
27:                // There are write and command macros in the header, make sure these match.
28:                void lcdCommandQ(unsigned char data){
29:                    *lcdWritePtr++=data|0x0100;     //flag for rs=1
00775E  FB8000     ZE W0, W0
007760  808251     MOV divtestb, W1
007762  A08000     BSET W0, #8
007764  781880     MOV W0, [W1++]
007766  888251     MOV W1, divtestb
30:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007768  276C40     MOV #0x76C4, W0
00776A  508F80     SUB W1, W0, [W15]
00776C  3A0002     BRA NZ, 0x7772
31:                        lcdWritePtr=lcdBuf;
00776E  B12000     SUB #0x200, W0
007770  888250     MOV W0, divtestb
32:                }
007772  060000     RETURN
33:                
34:                void lcdClearQ(void){
35:                    *lcdWritePtr++=LCD_CLEARDISPLAY|0x0300;     //flag for rs=1 & long delay
007774  808250     MOV divtestb, W0
007776  203011     MOV #0x301, W1
007778  781801     MOV W1, [W0++]
00777A  888250     MOV W0, divtestb
36:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
00777C  276C41     MOV #0x76C4, W1
00777E  500F81     SUB W0, W1, [W15]
007780  3A0003     BRA NZ, 0x7788
37:                        lcdWritePtr=lcdBuf;
007782  2FE000     MOV #0xFE00, W0
007784  400001     ADD W0, W1, W0
007786  888250     MOV W0, divtestb
38:                }
007788  060000     RETURN
39:                
40:                void lcdSetCursorQ(unsigned char col, unsigned char row) {
00778A  784101     MOV.B W1, W2
41:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
42:                  if (row > 3) {
43:                    row = 3;
44:                  }
45:                  *lcdWritePtr++=(LCD_SETDDRAMADDR | (col + offsets[row]))|0x0100;  //flag for rs=0 
00778C  808251     MOV divtestb, W1
00778E  514FE3     SUB.B W2, #0x3, [W15]
007790  360001     BRA LEU, 0x7794
007792  B3C032     MOV.B #0x3, W2
007794  FB8102     ZE W2, W2
007796  2F7463     MOV #0xF746, W3
007798  418102     ADD W3, W2, W2
00779A  FB8112     ZE [W2], W2
00779C  FB8000     ZE W0, W0
00779E  410000     ADD W2, W0, W0
0077A0  201802     MOV #0x180, W2
0077A2  701882     IOR W0, W2, [W1++]
0077A4  888251     MOV W1, divtestb
46:                    if(lcdWritePtr==&lcdBuf[LCDBUF]) 
0077A6  276C40     MOV #0x76C4, W0
0077A8  508F80     SUB W1, W0, [W15]
0077AA  3A0002     BRA NZ, 0x77B0
47:                        lcdWritePtr=lcdBuf; 
0077AC  B12000     SUB #0x200, W0
0077AE  888250     MOV W0, divtestb
48:                }
0077B0  060000     RETURN
49:                
50:                void lcdWriteStringQ(char *string) {
51:                    char *it = string;
52:                    for (; *it; it++) {
0077B2  784090     MOV.B [W0], W1
0077B4  E00401     CP0.B W1
0077B6  32000D     BRA Z, 0x77D2
0077CC  7840D0     MOV.B [++W0], W1
0077CE  E00401     CP0.B W1
0077D0  3AFFF6     BRA NZ, 0x77BE
53:                        lcdWriteQMac(*it);
0077B8  276C43     MOV #0x76C4, W3
0077BA  2FE004     MOV #0xFE00, W4
0077BC  420203     ADD W4, W3, W4
0077BE  FB0101     SE W1, W2
0077C0  808251     MOV divtestb, W1
0077C2  781882     MOV W2, [W1++]
0077C4  888251     MOV W1, divtestb
0077C6  508F83     SUB W1, W3, [W15]
0077C8  3A0001     BRA NZ, 0x77CC
0077CA  888254     MOV W4, divtestb
54:                  }
55:                }
0077D2  060000     RETURN
56:                
57:                void lcdCustomSymbols(void){
58:                    int i=0;
59:                    lcdCommandQMac(0x40);
0077D4  808250     MOV divtestb, W0
0077D6  201401     MOV #0x140, W1
0077D8  781801     MOV W1, [W0++]
0077DA  888250     MOV W0, divtestb
0077DC  276C41     MOV #0x76C4, W1
0077DE  500F81     SUB W0, W1, [W15]
0077E0  3A0003     BRA NZ, 0x77E8
0077E2  2FE000     MOV #0xFE00, W0
0077E4  400001     ADD W0, W1, W0
0077E6  888250     MOV W0, divtestb
60:                    Delay_us(200);
0077E8  200C80     MOV #0xC8, W0
0077EA  070697     RCALL Delay_us
61:                   // for(; i<8; i++)lcdWriteString(loadingOne[i]);
62:                    //lcdWriteString(loadingTwo);
63:                    //lcdWriteString(loadingThree);
64:                    //lcdWriteString(loadingFour);
65:                }
0077EC  060000     RETURN
66:                
67:                void lcdWriteWordQ(int word){
0077EE  4787E6     ADD W15, #0x6, W15
0077F0  781F8E     MOV W14, [W15++]
007834  200041     MOV #0x4, W1
68:                    int i;
69:                    char inchar[4];
70:                    
71:                    if(word<0) {
0077F2  E00000     CP0 W0
0077F4  3D000C     BRA GE, 0x780E
72:                        lcdWriteQMac('-');
0077F6  808251     MOV divtestb, W1
0077F8  2002D2     MOV #0x2D, W2
0077FA  781882     MOV W2, [W1++]
0077FC  888251     MOV W1, divtestb
0077FE  276C42     MOV #0x76C4, W2
007800  508F82     SUB W1, W2, [W15]
007802  3A0003     BRA NZ, 0x780A
007804  2FE001     MOV #0xFE00, W1
007806  408082     ADD W1, W2, W1
007808  888251     MOV W1, divtestb
73:                        word=~word+1;
00780A  EA0000     NEG W0, W0
00780C  37000A     BRA 0x7822
74:                    }else lcdWriteQMac(' ');
00780E  808251     MOV divtestb, W1
007810  200202     MOV #0x20, W2
007812  781882     MOV W2, [W1++]
007814  888251     MOV W1, divtestb
007816  276C42     MOV #0x76C4, W2
007818  508F82     SUB W1, W2, [W15]
00781A  3A0003     BRA NZ, 0x7822
00781C  2FE001     MOV #0xFE00, W1
00781E  408082     ADD W1, W2, W1
007820  888251     MOV W1, divtestb
75:                   
76:                   inchar[0] = word&0x000F; 
007822  6040EF     AND.B W0, #0xF, W1
77:                   if (inchar[0] > 9) 
007824  50CFE9     SUB.B W1, #0x9, [W15]
007826  340003     BRA LE, 0x782E
78:                       inchar[0]+=55;
007828  B04371     ADD.B #0x37, W1
00782A  9FFFA1     MOV.B W1, [W15-6]
00782C  370002     BRA 0x7832
79:                   else inchar[0]+=48;
00782E  B04301     ADD.B #0x30, W1
007830  9FFFA1     MOV.B W1, [W15-6]
007832  578766     SUB W15, #0x6, W14
80:                   
81:                   for(i=1; i<4; i++){ 
00784E  508FF0     SUB W1, #0x10, [W15]
007850  3AFFF2     BRA NZ, 0x7836
82:                      inchar[i] = ((word>>(i*4))&0x0000F); 
007836  DE8101     ASR W0, W1, W2
007838  61416F     AND.B W2, #0xF, W2
00783A  E8070E     INC W14, W14
00783C  784F02     MOV.B W2, [W14]
83:                      if (inchar[i] > 9) 
00783E  514FE9     SUB.B W2, #0x9, [W15]
007840  340003     BRA LE, 0x7848
84:                          inchar[i]+=55;
007842  B3C374     MOV.B #0x37, W4
007844  414F04     ADD.B W2, W4, [W14]
007846  370002     BRA 0x784C
85:                      else inchar[i]+=48;
007848  B3C304     MOV.B #0x30, W4
00784A  414F04     ADD.B W2, W4, [W14]
00784C  4080E4     ADD W1, #0x4, W1
86:                   } 
87:                   lcdWriteQMac(inchar[3]);
007852  97F8DF     MOV.B [W15-3], W1
007854  FB0081     SE W1, W1
007856  808250     MOV divtestb, W0
007858  781801     MOV W1, [W0++]
00785A  276C41     MOV #0x76C4, W1
00785C  500F81     SUB W0, W1, [W15]
00785E  3A000A     BRA NZ, 0x7874
88:                   lcdWriteQMac(inchar[2]);
007860  97F84F     MOV.B [W15-4], W0
007862  FB0000     SE W0, W0
007864  8BA620     MOV W0, lcdBuf
007874  97F8CF     MOV.B [W15-4], W1
007876  FB0081     SE W1, W1
007878  781801     MOV W1, [W0++]
00787A  888250     MOV W0, divtestb
00787C  276C41     MOV #0x76C4, W1
00787E  500F81     SUB W0, W1, [W15]
007880  3A0009     BRA NZ, 0x7894
89:                   lcdWriteQMac(inchar[1]);
007866  97F83F     MOV.B [W15-5], W0
007868  FB0000     SE W0, W0
00786A  8BA630     MOV W0, 0x74C6
00786C  2FE040     MOV #0xFE04, W0
00786E  400001     ADD W0, W1, W0
007870  888250     MOV W0, divtestb
007872  37001F     BRA 0x78B2
007882  97F83F     MOV.B [W15-5], W0
007884  FB0000     SE W0, W0
007886  8BA620     MOV W0, lcdBuf
007894  97F8BF     MOV.B [W15-5], W1
007896  FB0081     SE W1, W1
007898  808250     MOV divtestb, W0
00789A  781801     MOV W1, [W0++]
00789C  888250     MOV W0, divtestb
00789E  276C41     MOV #0x76C4, W1
0078A0  500F81     SUB W0, W1, [W15]
0078A2  3A0007     BRA NZ, 0x78B2
90:                   lcdWriteQMac(inchar[0]);
007888  97F8AF     MOV.B [W15-6], W1
00788A  FB0001     SE W1, W0
00788C  8BA630     MOV W0, 0x74C6
00788E  274C80     MOV #0x74C8, W0
007890  888250     MOV W0, divtestb
007892  37001A     BRA 0x78C8
0078A4  97FA2F     MOV.B [W15-6], W4
0078A6  FB0004     SE W4, W0
0078A8  8BA620     MOV W0, lcdBuf
0078AA  2FE020     MOV #0xFE02, W0
0078AC  400001     ADD W0, W1, W0
0078AE  888250     MOV W0, divtestb
0078B0  37000B     BRA 0x78C8
0078B2  97F82F     MOV.B [W15-6], W0
0078B4  FB0080     SE W0, W1
0078B6  808250     MOV divtestb, W0
0078B8  781801     MOV W1, [W0++]
0078BA  888250     MOV W0, divtestb
0078BC  276C41     MOV #0x76C4, W1
0078BE  500F81     SUB W0, W1, [W15]
0078C0  3A0003     BRA NZ, 0x78C8
0078C2  2FE000     MOV #0xFE00, W0
0078C4  400001     ADD W0, W1, W0
0078C6  888250     MOV W0, divtestb
91:                }
0078C8  78074F     MOV [--W15], W14
0078CA  B1006F     SUB #0x6, W15
0078CC  060000     RETURN
92:                
93:                void lcdWriteWordUnsignedQ(unsigned int word){
0078CE  4787E6     ADD W15, #0x6, W15
0078D0  781F8E     MOV W14, [W15++]
0078E4  200041     MOV #0x4, W1
94:                    int i;
95:                    char inchar[4];
96:                    
97:                   inchar[0] = word&0x000F; 
0078D2  6040EF     AND.B W0, #0xF, W1
98:                   if (inchar[0] > 9) 
0078D4  50CFE9     SUB.B W1, #0x9, [W15]
0078D6  340003     BRA LE, 0x78DE
99:                       inchar[0]+=55;
0078D8  B04371     ADD.B #0x37, W1
0078DA  9FFFA1     MOV.B W1, [W15-6]
0078DC  370002     BRA 0x78E2
100:                  else inchar[0]+=48;
0078DE  B04301     ADD.B #0x30, W1
0078E0  9FFFA1     MOV.B W1, [W15-6]
0078E2  578766     SUB W15, #0x6, W14
101:                  
102:                  for(i=1; i<4; i++){ 
0078FE  508FF0     SUB W1, #0x10, [W15]
007900  3AFFF2     BRA NZ, 0x78E6
103:                     inchar[i] = ((word>>(i*4))&0x0000F); 
0078E6  DE0101     LSR W0, W1, W2
0078E8  61416F     AND.B W2, #0xF, W2
0078EA  E8070E     INC W14, W14
0078EC  784F02     MOV.B W2, [W14]
104:                     if (inchar[i] > 9) 
0078EE  514FE9     SUB.B W2, #0x9, [W15]
0078F0  340003     BRA LE, 0x78F8
105:                         inchar[i]+=55;
0078F2  B3C374     MOV.B #0x37, W4
0078F4  414F04     ADD.B W2, W4, [W14]
0078F6  370002     BRA 0x78FC
106:                     else inchar[i]+=48;
0078F8  B3C304     MOV.B #0x30, W4
0078FA  414F04     ADD.B W2, W4, [W14]
0078FC  4080E4     ADD W1, #0x4, W1
107:                  } 
108:                  lcdWriteQMac(inchar[3]);
007902  97F8DF     MOV.B [W15-3], W1
007904  FB0081     SE W1, W1
007906  808250     MOV divtestb, W0
007908  781801     MOV W1, [W0++]
00790A  276C41     MOV #0x76C4, W1
00790C  500F81     SUB W0, W1, [W15]
00790E  3A000A     BRA NZ, 0x7924
109:                  lcdWriteQMac(inchar[2]);
007910  97F84F     MOV.B [W15-4], W0
007912  FB0000     SE W0, W0
007914  8BA620     MOV W0, lcdBuf
007924  97F8CF     MOV.B [W15-4], W1
007926  FB0081     SE W1, W1
007928  781801     MOV W1, [W0++]
00792A  888250     MOV W0, divtestb
00792C  276C41     MOV #0x76C4, W1
00792E  500F81     SUB W0, W1, [W15]
007930  3A0009     BRA NZ, 0x7944
110:                  lcdWriteQMac(inchar[1]);
007916  97F83F     MOV.B [W15-5], W0
007918  FB0000     SE W0, W0
00791A  8BA630     MOV W0, 0x74C6
00791C  2FE040     MOV #0xFE04, W0
00791E  400001     ADD W0, W1, W0
007920  888250     MOV W0, divtestb
007922  37001F     BRA 0x7962
007932  97F83F     MOV.B [W15-5], W0
007934  FB0000     SE W0, W0
007936  8BA620     MOV W0, lcdBuf
007944  97F8BF     MOV.B [W15-5], W1
007946  FB0081     SE W1, W1
007948  808250     MOV divtestb, W0
00794A  781801     MOV W1, [W0++]
00794C  888250     MOV W0, divtestb
00794E  276C41     MOV #0x76C4, W1
007950  500F81     SUB W0, W1, [W15]
007952  3A0007     BRA NZ, 0x7962
111:                  lcdWriteQMac(inchar[0]);
007938  97F8AF     MOV.B [W15-6], W1
00793A  FB0001     SE W1, W0
00793C  8BA630     MOV W0, 0x74C6
00793E  274C80     MOV #0x74C8, W0
007940  888250     MOV W0, divtestb
007942  37001A     BRA 0x7978
007954  97FA2F     MOV.B [W15-6], W4
007956  FB0004     SE W4, W0
007958  8BA620     MOV W0, lcdBuf
00795A  2FE020     MOV #0xFE02, W0
00795C  400001     ADD W0, W1, W0
00795E  888250     MOV W0, divtestb
007960  37000B     BRA 0x7978
007962  97F82F     MOV.B [W15-6], W0
007964  FB0080     SE W0, W1
007966  808250     MOV divtestb, W0
007968  781801     MOV W1, [W0++]
00796A  888250     MOV W0, divtestb
00796C  276C41     MOV #0x76C4, W1
00796E  500F81     SUB W0, W1, [W15]
007970  3A0003     BRA NZ, 0x7978
007972  2FE000     MOV #0xFE00, W0
007974  400001     ADD W0, W1, W0
007976  888250     MOV W0, divtestb
112:               }
007978  78074F     MOV [--W15], W14
00797A  B1006F     SUB #0x6, W15
00797C  060000     RETURN
113:               
114:               void lcdWriteDecimalQ(char word, int digits){
00797E  FA0000     LNK #0x0
007980  781F88     MOV W8, [W15++]
007982  780381     MOV W1, W7
115:                   const char maxdigits = 4;
116:                   char result[maxdigits];
007986  4787E6     ADD W15, #0x6, W15
007988  780186     MOV W6, W3
117:                   char i = 3;
00798A  B3C032     MOV.B #0x3, W2
118:                   do {
119:                       result[i] = '0' + word % 10;
00798C  2000A4     MOV #0xA, W4
00798E  FB0282     SE W2, W5
007990  418285     ADD W3, W5, W5
007992  FB0000     SE W0, W0
007994  090011     REPEAT #0x11
007996  D80004     DIV.SW W0, W4
007998  B3C308     MOV.B #0x30, W8
00799A  40CA88     ADD.B W1, W8, [W5]
120:                       word /= 10;
121:                       i--;
00799C  E94102     DEC.B W2, W2
122:                   }
123:                   while (word > 0);
00799E  E00400     CP0.B W0
0079A0  3CFFF6     BRA GT, 0x798E
124:                   while (i>=0) result[i--] = ' '; 
0079A2  E00402     CP0.B W2
0079A4  350007     BRA LT, 0x79B4
0079A6  B3C204     MOV.B #0x20, W4
0079A8  FB0002     SE W2, W0
0079AA  418000     ADD W3, W0, W0
0079AC  784804     MOV.B W4, [W0]
0079AE  E94102     DEC.B W2, W2
0079B0  414FE1     ADD.B W2, #0x1, [W15]
0079B2  3AFFFA     BRA NZ, 0x79A8
125:                 
126:                   for (i=maxdigits-digits; i<maxdigits; i++) {
0079B4  B3C041     MOV.B #0x4, W1
0079B6  50C087     SUB.B W1, W7, W1
0079B8  50CFE3     SUB.B W1, #0x3, [W15]
0079BA  3C000F     BRA GT, 0x79DA
0079D4  E84081     INC.B W1, W1
0079D6  50CFE4     SUB.B W1, #0x4, [W15]
0079D8  3AFFF4     BRA NZ, 0x79C2
127:                       lcdWriteQMac(result[i]);
0079BC  276C44     MOV #0x76C4, W4
0079BE  2FE005     MOV #0xFE00, W5
0079C0  428284     ADD W5, W4, W5
0079C2  FB0001     SE W1, W0
0079C4  418000     ADD W3, W0, W0
0079C6  FB0110     SE [W0], W2
0079C8  808250     MOV divtestb, W0
0079CA  781802     MOV W2, [W0++]
0079CC  888250     MOV W0, divtestb
0079CE  500F84     SUB W0, W4, [W15]
0079D0  3A0001     BRA NZ, 0x79D4
0079D2  888255     MOV W5, divtestb
128:                   }
129:               }
007984  78030F     MOV W15, W6
0079DA  780786     MOV W6, W15
0079DC  78044F     MOV [--W15], W8
0079DE  FA8000     ULNK
0079E0  060000     RETURN
130:               
131:               //4x4 pad debug
132:               void lcdDrawPads(unsigned char col){
0079E2  BE9F88     MOV.D W8, [W15++]
0079E4  784480     MOV.B W0, W9
133:                   char block=0xFF;
0079F4  EBC400     SETM.B W8
134:                   if(!pad[34]||!pad[16]) block='*';
0079E6  B3C2A8     MOV.B #0x2A, W8
0079E8  270C20     MOV #0x70C2, W0
0079EA  E00410     CP0.B [W0]
0079EC  320004     BRA Z, 0x79F6
0079EE  500072     SUB W0, #0x12, W0
0079F0  E00410     CP0.B [W0]
0079F2  320001     BRA Z, 0x79F6
135:                   
136:                   lcdSetCursorQ(col, 0);
0079F6  EB4080     CLR.B W1
0079F8  784009     MOV.B W9, W0
0079FA  07FEC7     RCALL lcdSetCursorQ
137:                   if(!pad[12])lcdWriteStringQ(" "); else lcdWriteQMac(block);
0079FC  270AC0     MOV #0x70AC, W0
0079FE  E00410     CP0.B [W0]
007A00  3A0003     BRA NZ, 0x7A08
007A02  2F7440     MOV #0xF744, W0
007A04  07FED6     RCALL lcdWriteStringQ
007A06  37000A     BRA 0x7A1C
007A08  FB0088     SE W8, W1
007A0A  808250     MOV divtestb, W0
007A0C  781801     MOV W1, [W0++]
007A0E  888250     MOV W0, divtestb
007A10  276C41     MOV #0x76C4, W1
007A12  500F81     SUB W0, W1, [W15]
007A14  3A0003     BRA NZ, 0x7A1C
007A16  2FE000     MOV #0xFE00, W0
007A18  400001     ADD W0, W1, W0
007A1A  888250     MOV W0, divtestb
138:                   if(!pad[13])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007A1C  270AD0     MOV #0x70AD, W0
007A1E  E00410     CP0.B [W0]
007A20  3A0003     BRA NZ, 0x7A28
007A22  2F7440     MOV #0xF744, W0
007A24  07FEC6     RCALL lcdWriteStringQ
007A26  37000A     BRA 0x7A3C
007A28  FB0088     SE W8, W1
007A2A  808250     MOV divtestb, W0
007A2C  781801     MOV W1, [W0++]
007A2E  888250     MOV W0, divtestb
007A30  276C41     MOV #0x76C4, W1
007A32  500F81     SUB W0, W1, [W15]
007A34  3A0003     BRA NZ, 0x7A3C
007A36  2FE000     MOV #0xFE00, W0
007A38  400001     ADD W0, W1, W0
007A3A  888250     MOV W0, divtestb
139:                   if(!pad[14])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007A3C  270AE0     MOV #0x70AE, W0
007A3E  E00410     CP0.B [W0]
007A40  3A0003     BRA NZ, 0x7A48
007A42  2F7440     MOV #0xF744, W0
007A44  07FEB6     RCALL lcdWriteStringQ
007A46  37000A     BRA 0x7A5C
007A48  FB0088     SE W8, W1
007A4A  808250     MOV divtestb, W0
007A4C  781801     MOV W1, [W0++]
007A4E  888250     MOV W0, divtestb
007A50  276C41     MOV #0x76C4, W1
007A52  500F81     SUB W0, W1, [W15]
007A54  3A0003     BRA NZ, 0x7A5C
007A56  2FE000     MOV #0xFE00, W0
007A58  400001     ADD W0, W1, W0
007A5A  888250     MOV W0, divtestb
140:                   if(!pad[15])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007A5C  270AF0     MOV #0x70AF, W0
007A5E  E00410     CP0.B [W0]
007A60  3A0003     BRA NZ, 0x7A68
007A62  2F7440     MOV #0xF744, W0
007A64  07FEA6     RCALL lcdWriteStringQ
007A66  37000A     BRA 0x7A7C
007A68  FB0088     SE W8, W1
007A6A  808250     MOV divtestb, W0
007A6C  781801     MOV W1, [W0++]
007A6E  888250     MOV W0, divtestb
007A70  276C41     MOV #0x76C4, W1
007A72  500F81     SUB W0, W1, [W15]
007A74  3A0003     BRA NZ, 0x7A7C
007A76  2FE000     MOV #0xFE00, W0
007A78  400001     ADD W0, W1, W0
007A7A  888250     MOV W0, divtestb
141:                   lcdSetCursorQ(col, 1);
007A7C  B3C011     MOV.B #0x1, W1
007A7E  784009     MOV.B W9, W0
007A80  07FE84     RCALL lcdSetCursorQ
142:                   if(!pad[8])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007A82  270A80     MOV #0x70A8, W0
007A84  E00410     CP0.B [W0]
007A86  3A0003     BRA NZ, 0x7A8E
007A88  2F7440     MOV #0xF744, W0
007A8A  07FE93     RCALL lcdWriteStringQ
007A8C  37000A     BRA 0x7AA2
007A8E  FB0088     SE W8, W1
007A90  808250     MOV divtestb, W0
007A92  781801     MOV W1, [W0++]
007A94  888250     MOV W0, divtestb
007A96  276C41     MOV #0x76C4, W1
007A98  500F81     SUB W0, W1, [W15]
007A9A  3A0003     BRA NZ, 0x7AA2
007A9C  2FE000     MOV #0xFE00, W0
007A9E  400001     ADD W0, W1, W0
007AA0  888250     MOV W0, divtestb
143:                   if(!pad[9])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007AA2  270A90     MOV #0x70A9, W0
007AA4  E00410     CP0.B [W0]
007AA6  3A0003     BRA NZ, 0x7AAE
007AA8  2F7440     MOV #0xF744, W0
007AAA  07FE83     RCALL lcdWriteStringQ
007AAC  37000A     BRA 0x7AC2
007AAE  FB0088     SE W8, W1
007AB0  808250     MOV divtestb, W0
007AB2  781801     MOV W1, [W0++]
007AB4  888250     MOV W0, divtestb
007AB6  276C41     MOV #0x76C4, W1
007AB8  500F81     SUB W0, W1, [W15]
007ABA  3A0003     BRA NZ, 0x7AC2
007ABC  2FE000     MOV #0xFE00, W0
007ABE  400001     ADD W0, W1, W0
007AC0  888250     MOV W0, divtestb
144:                   if(!pad[10])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007AC2  270AA0     MOV #0x70AA, W0
007AC4  E00410     CP0.B [W0]
007AC6  3A0003     BRA NZ, 0x7ACE
007AC8  2F7440     MOV #0xF744, W0
007ACA  07FE73     RCALL lcdWriteStringQ
007ACC  37000A     BRA 0x7AE2
007ACE  FB0088     SE W8, W1
007AD0  808250     MOV divtestb, W0
007AD2  781801     MOV W1, [W0++]
007AD4  888250     MOV W0, divtestb
007AD6  276C41     MOV #0x76C4, W1
007AD8  500F81     SUB W0, W1, [W15]
007ADA  3A0003     BRA NZ, 0x7AE2
007ADC  2FE000     MOV #0xFE00, W0
007ADE  400001     ADD W0, W1, W0
007AE0  888250     MOV W0, divtestb
145:                   if(!pad[11])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007AE2  270AB0     MOV #0x70AB, W0
007AE4  E00410     CP0.B [W0]
007AE6  3A0003     BRA NZ, 0x7AEE
007AE8  2F7440     MOV #0xF744, W0
007AEA  07FE63     RCALL lcdWriteStringQ
007AEC  37000A     BRA 0x7B02
007AEE  FB0088     SE W8, W1
007AF0  808250     MOV divtestb, W0
007AF2  781801     MOV W1, [W0++]
007AF4  888250     MOV W0, divtestb
007AF6  276C41     MOV #0x76C4, W1
007AF8  500F81     SUB W0, W1, [W15]
007AFA  3A0003     BRA NZ, 0x7B02
007AFC  2FE000     MOV #0xFE00, W0
007AFE  400001     ADD W0, W1, W0
007B00  888250     MOV W0, divtestb
146:                   lcdSetCursorQ(col, 2);
007B02  B3C021     MOV.B #0x2, W1
007B04  784009     MOV.B W9, W0
007B06  07FE41     RCALL lcdSetCursorQ
147:                   if(!pad[4])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007B08  270A40     MOV #0x70A4, W0
007B0A  E00410     CP0.B [W0]
007B0C  3A0003     BRA NZ, 0x7B14
007B0E  2F7440     MOV #0xF744, W0
007B10  07FE50     RCALL lcdWriteStringQ
007B12  37000A     BRA 0x7B28
007B14  FB0088     SE W8, W1
007B16  808250     MOV divtestb, W0
007B18  781801     MOV W1, [W0++]
007B1A  888250     MOV W0, divtestb
007B1C  276C41     MOV #0x76C4, W1
007B1E  500F81     SUB W0, W1, [W15]
007B20  3A0003     BRA NZ, 0x7B28
007B22  2FE000     MOV #0xFE00, W0
007B24  400001     ADD W0, W1, W0
007B26  888250     MOV W0, divtestb
148:                   if(!pad[5])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007B28  270A50     MOV #0x70A5, W0
007B2A  E00410     CP0.B [W0]
007B2C  3A0003     BRA NZ, 0x7B34
007B2E  2F7440     MOV #0xF744, W0
007B30  07FE40     RCALL lcdWriteStringQ
007B32  37000A     BRA 0x7B48
007B34  FB0088     SE W8, W1
007B36  808250     MOV divtestb, W0
007B38  781801     MOV W1, [W0++]
007B3A  888250     MOV W0, divtestb
007B3C  276C41     MOV #0x76C4, W1
007B3E  500F81     SUB W0, W1, [W15]
007B40  3A0003     BRA NZ, 0x7B48
007B42  2FE000     MOV #0xFE00, W0
007B44  400001     ADD W0, W1, W0
007B46  888250     MOV W0, divtestb
149:                   if(!pad[6])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007B48  270A60     MOV #0x70A6, W0
007B4A  E00410     CP0.B [W0]
007B4C  3A0003     BRA NZ, 0x7B54
007B4E  2F7440     MOV #0xF744, W0
007B50  07FE30     RCALL lcdWriteStringQ
007B52  37000A     BRA 0x7B68
007B54  FB0088     SE W8, W1
007B56  808250     MOV divtestb, W0
007B58  781801     MOV W1, [W0++]
007B5A  888250     MOV W0, divtestb
007B5C  276C41     MOV #0x76C4, W1
007B5E  500F81     SUB W0, W1, [W15]
007B60  3A0003     BRA NZ, 0x7B68
007B62  2FE000     MOV #0xFE00, W0
007B64  400001     ADD W0, W1, W0
007B66  888250     MOV W0, divtestb
150:                   if(!pad[7])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007B68  270A70     MOV #0x70A7, W0
007B6A  E00410     CP0.B [W0]
007B6C  3A0003     BRA NZ, 0x7B74
007B6E  2F7440     MOV #0xF744, W0
007B70  07FE20     RCALL lcdWriteStringQ
007B72  37000A     BRA 0x7B88
007B74  FB0088     SE W8, W1
007B76  808250     MOV divtestb, W0
007B78  781801     MOV W1, [W0++]
007B7A  888250     MOV W0, divtestb
007B7C  276C41     MOV #0x76C4, W1
007B7E  500F81     SUB W0, W1, [W15]
007B80  3A0003     BRA NZ, 0x7B88
007B82  2FE000     MOV #0xFE00, W0
007B84  400001     ADD W0, W1, W0
007B86  888250     MOV W0, divtestb
151:                   lcdSetCursorQ(col, 3);
007B88  B3C031     MOV.B #0x3, W1
007B8A  784009     MOV.B W9, W0
007B8C  07FDFE     RCALL lcdSetCursorQ
152:                   if(!pad[0])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007B8E  270A00     MOV #0x70A0, W0
007B90  E00410     CP0.B [W0]
007B92  3A0003     BRA NZ, 0x7B9A
007B94  2F7440     MOV #0xF744, W0
007B96  07FE0D     RCALL lcdWriteStringQ
007B98  37000A     BRA 0x7BAE
007B9A  FB0088     SE W8, W1
007B9C  808250     MOV divtestb, W0
007B9E  781801     MOV W1, [W0++]
007BA0  888250     MOV W0, divtestb
007BA2  276C41     MOV #0x76C4, W1
007BA4  500F81     SUB W0, W1, [W15]
007BA6  3A0003     BRA NZ, 0x7BAE
007BA8  2FE000     MOV #0xFE00, W0
007BAA  400001     ADD W0, W1, W0
007BAC  888250     MOV W0, divtestb
153:                   if(!pad[1])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007BAE  270A10     MOV #0x70A1, W0
007BB0  E00410     CP0.B [W0]
007BB2  3A0003     BRA NZ, 0x7BBA
007BB4  2F7440     MOV #0xF744, W0
007BB6  07FDFD     RCALL lcdWriteStringQ
007BB8  37000A     BRA 0x7BCE
007BBA  FB0088     SE W8, W1
007BBC  808250     MOV divtestb, W0
007BBE  781801     MOV W1, [W0++]
007BC0  888250     MOV W0, divtestb
007BC2  276C41     MOV #0x76C4, W1
007BC4  500F81     SUB W0, W1, [W15]
007BC6  3A0003     BRA NZ, 0x7BCE
007BC8  2FE000     MOV #0xFE00, W0
007BCA  400001     ADD W0, W1, W0
007BCC  888250     MOV W0, divtestb
154:                   if(!pad[2])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007BCE  270A20     MOV #0x70A2, W0
007BD0  E00410     CP0.B [W0]
007BD2  3A0003     BRA NZ, 0x7BDA
007BD4  2F7440     MOV #0xF744, W0
007BD6  07FDED     RCALL lcdWriteStringQ
007BD8  37000A     BRA 0x7BEE
007BDA  FB0088     SE W8, W1
007BDC  808250     MOV divtestb, W0
007BDE  781801     MOV W1, [W0++]
007BE0  888250     MOV W0, divtestb
007BE2  276C41     MOV #0x76C4, W1
007BE4  500F81     SUB W0, W1, [W15]
007BE6  3A0003     BRA NZ, 0x7BEE
007BE8  2FE000     MOV #0xFE00, W0
007BEA  400001     ADD W0, W1, W0
007BEC  888250     MOV W0, divtestb
155:                   if(!pad[3])lcdWriteStringQ(" "); else lcdWriteQMac(block);
007BEE  270A30     MOV #0x70A3, W0
007BF0  E00410     CP0.B [W0]
007BF2  3A0003     BRA NZ, 0x7BFA
007BF4  2F7440     MOV #0xF744, W0
007BF6  07FDDD     RCALL lcdWriteStringQ
007BF8  37000A     BRA 0x7C0E
007BFA  FB0408     SE W8, W8
007BFC  808250     MOV divtestb, W0
007BFE  781808     MOV W8, [W0++]
007C00  888250     MOV W0, divtestb
007C02  276C41     MOV #0x76C4, W1
007C04  500F81     SUB W0, W1, [W15]
007C06  3A0003     BRA NZ, 0x7C0E
007C08  2FE000     MOV #0xFE00, W0
007C0A  400001     ADD W0, W1, W0
007C0C  888250     MOV W0, divtestb
156:               }
007C0E  BE044F     MOV.D [--W15], W8
007C10  060000     RETURN
157:               
158:               void lcdPoll(void){  
159:                   if(lcdWritePtr!=lcdReadPtr){   
007C12  808260     MOV 0x104C, W0
007C14  E3104A     CP divtestb
007C16  320018     BRA Z, 0x7C48
160:                       if((*lcdReadPtr>>8)&1) LCD_RS=0;
007C18  201001     MOV #0x100, W1
007C1A  608090     AND W1, [W0], W1
007C1C  320002     BRA Z, 0x7C22
007C1E  A9EE45     BCLR 0xE45, #7
007C20  370001     BRA 0x7C24
161:                       else LCD_RS=1;
007C22  A8EE45     BSET 0xE45, #7
162:                       if((*lcdReadPtr>>9)&1) PR3=0x2DF0; //2DF0 for ~1.3mS
007C24  202001     MOV #0x200, W1
007C26  608090     AND W1, [W0], W1
007C28  320003     BRA Z, 0x7C30
007C2A  22DF01     MOV #0x2DF0, W1
007C2C  880871     MOV W1, PR3
007C2E  370002     BRA 0x7C34
163:                       else PR3=0x0120; //120 for ~40uS
007C30  201201     MOV #0x120, W1
007C32  880871     MOV W1, PR3
164:                       PMDIN1=(*lcdReadPtr++)&0x00FF;
007C34  200FF1     MOV #0xFF, W1
007C36  6080B0     AND W1, [W0++], W1
007C38  883041     MOV W1, PMDIN1
007C3A  888260     MOV W0, 0x104C
165:                       if(lcdReadPtr==&lcdBuf[LCDBUF]) lcdReadPtr=lcdBuf;
007C3C  276C41     MOV #0x76C4, W1
007C3E  500F81     SUB W0, W1, [W15]
007C40  3A0003     BRA NZ, 0x7C48
007C42  2FE000     MOV #0xFE00, W0
007C44  400001     ADD W0, W1, W0
007C46  888260     MOV W0, 0x104C
166:                   } 
167:                   TMR3=0x0000; 
007C48  EF210A     CLR TMR3
168:               }
007C4A  060000     RETURN
169:               
170:               //ALWAYS SENDS, blocks program
171:               void lcdBlockingSend(unsigned char data){
007C4C  BE9F88     MOV.D W8, [W15++]
007C4E  781F8A     MOV W10, [W15++]
007C50  784500     MOV.B W0, W10
172:                   while(PMMODEbits.BUSY)Delay_us(2);
007C52  E20602     CP0 PMMODE
007C54  3D0007     BRA GE, 0x7C64
007C56  200028     MOV #0x2, W8
007C58  280009     MOV #0x8000, W9
007C5A  780008     MOV W8, W0
007C5C  07045E     RCALL Delay_us
007C5E  803011     MOV PMMODE, W1
007C60  648001     AND W9, W1, W0
007C62  3AFFFB     BRA NZ, 0x7C5A
173:                   PMDIN1=data; 
007C64  FB850A     ZE W10, W10
007C66  88304A     MOV W10, PMDIN1
174:               }
007C68  78054F     MOV [--W15], W10
007C6A  BE044F     MOV.D [--W15], W8
007C6C  060000     RETURN
175:               //ALWAYS SENDS, blocks program
176:               void lcdBlockingClear(void){
007C6E  BE9F88     MOV.D W8, [W15++]
177:                   while(PMMODEbits.BUSY)Delay_us(2);
007C70  E20602     CP0 PMMODE
007C72  3D0007     BRA GE, 0x7C82
007C74  200028     MOV #0x2, W8
007C76  280009     MOV #0x8000, W9
007C78  780008     MOV W8, W0
007C7A  07044F     RCALL Delay_us
007C7C  803011     MOV PMMODE, W1
007C7E  648001     AND W9, W1, W0
007C80  3AFFFB     BRA NZ, 0x7C78
178:                   PMDIN1=LCD_CLEARDISPLAY; 
007C82  200010     MOV #0x1, W0
007C84  883040     MOV W0, PMDIN1
179:               }
007C86  BE044F     MOV.D [--W15], W8
007C88  060000     RETURN
180:               
181:               //ALWAYS SENDS, blocks program
182:               void lcdBlockingReturn(void){
007C8A  BE9F88     MOV.D W8, [W15++]
183:                   while(PMMODEbits.BUSY)Delay_us(2);
007C8C  E20602     CP0 PMMODE
007C8E  3D0007     BRA GE, 0x7C9E
007C90  200028     MOV #0x2, W8
007C92  280009     MOV #0x8000, W9
007C94  780008     MOV W8, W0
007C96  070441     RCALL Delay_us
007C98  803011     MOV PMMODE, W1
007C9A  648001     AND W9, W1, W0
007C9C  3AFFFB     BRA NZ, 0x7C94
184:                   PMDIN1=LCD_RETURNHOME;
007C9E  200020     MOV #0x2, W0
007CA0  883040     MOV W0, PMDIN1
185:               }
007CA2  BE044F     MOV.D [--W15], W8
007CA4  060000     RETURN
186:               
187:               void lcdInit(void){
188:                   LCD_RS=0;
007CA6  A9EE45     BCLR 0xE45, #7
189:                   lcdBlockingSend(0x38);              //function set, 8 bits, 2 line disp, 5x8
007CA8  B3C380     MOV.B #0x38, W0
007CAA  07FFD0     RCALL lcdBlockingSend
190:                   Delay_us(4500);                //>4.1 mS required
007CAC  211940     MOV #0x1194, W0
007CAE  070435     RCALL Delay_us
191:                   lcdBlockingSend(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
007CB0  B3C0C0     MOV.B #0xC, W0
007CB2  07FFCC     RCALL lcdBlockingSend
192:                   Delay_us(4500);
007CB4  211940     MOV #0x1194, W0
007CB6  070431     RCALL Delay_us
193:                   lcdBlockingClear();                    //Display Clear  
007CB8  07FFDA     RCALL lcdBlockingClear
194:                   Delay_us(1800);                //>1.64mS required
007CBA  207080     MOV #0x708, W0
007CBC  07042E     RCALL Delay_us
195:                   lcdBlockingSend(0x06);               // entry Mode Set
007CBE  B3C060     MOV.B #0x6, W0
007CC0  07FFC5     RCALL lcdBlockingSend
196:                   Delay_us(200);
007CC2  200C80     MOV #0xC8, W0
007CC4  07042A     RCALL Delay_us
197:                   lcdBlockingReturn();
007CC6  07FFE1     RCALL lcdBlockingReturn
198:                   Delay_us(1500);
007CC8  205DC0     MOV #0x5DC, W0
007CCA  070427     RCALL Delay_us
199:                   
200:                   //lcdCustomSymbols();
201:                   Delay_us(200);
007CCC  200C80     MOV #0xC8, W0
007CCE  070425     RCALL Delay_us
202:                   lcdBlockingClear();                         //Display Clear  
007CD0  07FFCE     RCALL lcdBlockingClear
203:                   Delay_us(1500);
007CD2  205DC0     MOV #0x5DC, W0
007CD4  070422     RCALL Delay_us
204:                   lcdBlockingReturn();
007CD6  07FFD9     RCALL lcdBlockingReturn
205:                   Delay_us(200);
007CD8  200C80     MOV #0xC8, W0
007CDA  07041F     RCALL Delay_us
206:               }
007CDC  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/main.c  -----------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 #include "plcd.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = OFF   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                /* Data Buffers & index variables */
22:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
23:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
24:                unsigned int write_ptr=STREAMBUF, rw=0, frameReady=0;
25:                
26:                /* DMA BUFFERS */
27:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
28:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
29:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
31:                
32:                
33:                /* Debug Variables */
34:                unsigned int idle=0, cycle=0, process_time=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                              
37:                volatile unsigned char recording=TRUE;
38:                unsigned char UART_ON = FALSE;
39:                unsigned char TEST_SIN = FALSE;
40:                
41:                volatile unsigned char tremelo=FALSE;                                       
42:                volatile unsigned char looper=FALSE;
43:                volatile unsigned char lpf=FALSE;
44:                
45:                char flash_readback[512]={0};
46:                
47:                /* Screen state variables */
48:                enum screen state = scrnFX;
49:                enum screen laststate = invalid;
50:                
51:                /* Buttons & Potentiometers */
52:                unsigned char pad[BUTTONS];                                                            
53:                fractional pots[POTS]={0};
54:                fractional pots_percent[POTS]={0};
55:                
56:                void initBuffer(void){
008948  2689E7     MOV #0x689E, W7
00894A  26C9E6     MOV #0x6C9E, W6
00894C  2CBFE5     MOV #0xCBFE, W5
00894E  2C7FE4     MOV #0xC7FE, W4
008950  2C3FE3     MOV #0xC3FE, W3
008952  2BFFE2     MOV #0xBFFE, W2
008954  202001     MOV #0x200, W1
00896A  200232     MOV #0x23, W2
00896C  410100     ADD W2, W0, W2
57:                    int i;
58:                    for(i=0; i<STREAMBUF; i++){
008966  3AFFF8     BRA NZ, 0x8958
008968  2709F0     MOV #0x709F, W0
59:                        streamA[i]=0;
008956  EB0000     CLR W0
008958  782B80     MOV W0, [++W7]
60:                        streamB[i]=0;
00895A  782B00     MOV W0, [++W6]
61:                        txBufferA[i]=0;
00895C  782A80     MOV W0, [++W5]
62:                        txBufferB[i]=0;
00895E  782A00     MOV W0, [++W4]
63:                        rxBufferA[i]=0;
008960  782980     MOV W0, [++W3]
64:                        rxBufferB[i]=0;
008962  782900     MOV W0, [++W2]
008964  E90081     DEC W1, W1
65:                    }
66:                    
67:                    for(i=0; i<BUTTONS; i++)
008972  500F82     SUB W0, W2, [W15]
008974  3AFFFD     BRA NZ, 0x8970
68:                        pad[i]=1;
00896E  B3C011     MOV.B #0x1, W1
008970  786801     MOV.B W1, [++W0]
69:                }
008976  060000     RETURN
70:                
71:                int main(void) {
008978  BE9F88     MOV.D W8, [W15++]
00897A  BE9F8A     MOV.D W10, [W15++]
00897C  BE9F8C     MOV.D W12, [W15++]
00897E  781F8E     MOV W14, [W15++]
008994  2FC00D     MOV #0xFC00, W13
0089B2  44050D     ADD W8, W13, W10
72:                    initPorts();                    //configure io device & adc 
008980  07F9AE     RCALL initPorts
73:                    //initUART1();                    //configure & enable UART
74:                    initBuffer();
008982  07FFE2     RCALL initBuffer
75:                    initADC1();                     //configure & enable internal ADC
008984  07FA73     RCALL initADC1
76:                    initPMP();
008986  07FA90     RCALL initPMP
77:                    //||||||||----
78:                    //initDMA0();
79:                    initDCI_DAC();                  //configure & enable DAC
008988  07FACE     RCALL initDCI_DAC
80:                    initT1();                       //configure & start T1 
00898A  07FAA2     RCALL initT1
81:                    initT2();                       //configure & start T2 
00898C  07FAAA     RCALL initT2
82:                    initSPI3_MEM();                  //start segment display
00898E  07FB43     RCALL initSPI3_MEM
83:                    //initCAP_BPM();                  //configure bpm capture
84:                    initT3();                       //configure & start T3 for lcd
008990  07FAB4     RCALL initT3
85:                    initQEI_ENC();
008992  07FB63     RCALL initQEI_ENC
86:                    //initT5();
87:                    fractional temp;
88:                    int writePtr;
89:                    fractional *ping, *pong;
90:                    
91:                    while(1){    
92:                        if(frameReady) {
00899C  E21002     CP0 frameReady
00899E  32001E     BRA Z, 0x89DC
93:                            writePtr=STREAMBUF-1;
94:                            process_time=writePtr;  //DEBUG
0089A0  201FF0     MOV #0x1FF, W0
0089A2  888040     MOV W0, process_time
95:                            if(rw){
0089A4  E21000     CP0 rw
0089A6  320003     BRA Z, 0x89AE
96:                                ping = streamA+writePtr;
0089AA  26C9E8     MOV #0x6C9E, W8
0089AC  370002     BRA 0x89B2
97:                                pong = outputB+writePtr;
0089A8  2689E9     MOV #0x689E, W9
98:                            }else{
99:                                ping = streamB+writePtr;
0089B0  2709E8     MOV #0x709E, W8
100:                               pong = outputA+writePtr;
00899A  2649EE     MOV #0x649E, W14
0089AE  78048E     MOV W14, W9
101:                           }
102:                           
103:                           for(; writePtr>=0; writePtr--){
0089C6  540F8A     SUB W8, W10, [W15]
0089C8  3AFFF5     BRA NZ, 0x89B4
104:                               temp=*ping--; //!rw
0089B4  780028     MOV [W8--], W0
105:                               if(temp<=-32766||temp>=32766)hard_clipped=TRUE;
008996  27FFDB     MOV #0x7FFD, W11
008998  EBC600     SETM.B W12
0089B6  40008B     ADD W0, W11, W1
0089B8  408FE6     ADD W1, #0x6, [W15]
0089BA  360002     BRA LEU, 0x89C0
0089BC  2100A1     MOV #0x100A, W1
0089BE  78488C     MOV.B W12, [W1]
106:                               temp=fx(temp);    //run fx on latest sample
0089C0  07FE18     RCALL fx
107:                               *pong--=mixer(temp); //rw
0089C2  07FDB4     RCALL mixer
0089C4  781480     MOV W0, [W9--]
108:                               
109:                           }
110:                           process_time-=write_ptr;    //DEBUG
0089CA  8081F0     MOV 0x103E, W0
0089CC  B53008     SUB process_time
111:                           temp = 8*idle/STREAMBUF;
112:                           cycle=STREAMBUF/(STREAMBUF-write_ptr);
0089CE  202001     MOV #0x200, W1
0089D0  508100     SUB W1, W0, W2
0089D2  090011     REPEAT #0x11
0089D4  D88082     DIV.UW W1, W2
0089D6  888030     MOV W0, cycle
113:                           idle=0;
0089D8  EF3004     CLR idle
114:                           frameReady=0;
0089DA  EF3002     CLR frameReady
115:                           
116:                           
117:                       }
118:                       if(_T2IF){
0089DC  ABE800     BTST IFS0, #7
0089DE  320006     BRA Z, 0x89EC
119:                           scanButtons();                   //read button matrix
0089E0  07FC75     RCALL scanButtons
120:                           readPots();                     //read control pots
0089E2  07FD18     RCALL readPots
121:                           if(_AD1IF) readPots();
0089E4  ABA801     BTST 0x801, #5
0089E6  320001     BRA Z, 0x89EA
0089E8  07FD15     RCALL readPots
122:                           _T2IF=0;
0089EA  A9E800     BCLR IFS0, #7
123:                       }
124:                       if(_T1IF){
0089EC  AB6800     BTST IFS0, #3
0089EE  320002     BRA Z, 0x89F4
125:                           display();
0089F0  07FD73     RCALL display
126:                           _T1IF=0;
0089F2  A96800     BCLR IFS0, #3
127:                       }
128:                       if(_T3IF) {
0089F4  AB0801     BTST 0x801, #0
0089F6  32FFD2     BRA Z, 0x899C
129:                           lcdPoll();
0089F8  07F90C     RCALL lcdPoll
130:                           _T3IF=0;
0089FA  A90801     BCLR 0x801, #0
0089FC  37FFCF     BRA 0x899C
131:                       }
132:                   }
133:                   return 0;
134:               }
135:               // example test 
---  C:/Users/ryan/Documents/seniorproject/ps-040/flash.c  ----------------------------------------------
1:                 /*
2:                  * File:   flash.c
3:                  * Author: root
4:                  *
5:                  * Created on January 28, 2018, 5:00 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "flash.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                char flashBuf[STREAMBUF*2];
15:                char receive;
16:                
17:                void flashWriteReg(char command) {
18:                    SS3=0;
008822  A92E54     BCLR LATF, #1
19:                    SPI3BUF=command;               //WEL=1 for write enable
008824  FB0000     SE W0, W0
008826  881540     MOV W0, SPI3BUF
20:                    while(!_SPI3IF); _SPI3IF=0;
008828  208001     MOV #0x800, W1
00882A  804052     MOV IFS5, W2
00882C  608002     AND W1, W2, W0
00882E  32FFFD     BRA Z, 0x882A
008830  A9680B     BCLR 0x80B, #3
21:                    receive=SPI3BUF;
008832  801540     MOV SPI3BUF, W0
008834  B7F04E     MOV.B WREG, receive
22:                    SS3=1;
008836  A82E54     BSET LATF, #1
23:                }
008838  060000     RETURN
24:                
25:                char flashStatusCheck(void){
26:                    SS3=0;
00883A  A92E54     BCLR LATF, #1
27:                    SPI3BUF=FLASH_RDSR1;               //WEL=1 for write enable
00883C  200050     MOV #0x5, W0
00883E  881540     MOV W0, SPI3BUF
28:                    while(!_SPI3IF); _SPI3IF=0;
008840  208001     MOV #0x800, W1
008842  804052     MOV IFS5, W2
008844  608002     AND W1, W2, W0
008846  32FFFD     BRA Z, 0x8842
008848  A9680B     BCLR 0x80B, #3
29:                    receive=SPI3BUF;
00884A  801540     MOV SPI3BUF, W0
30:                    SPI3BUF=0x00;               //WEL=1 for write enable
00884C  EF22A8     CLR SPI3BUF
31:                    while(!_SPI3IF); _SPI3IF=0;
00884E  208001     MOV #0x800, W1
008850  804052     MOV IFS5, W2
008852  608002     AND W1, W2, W0
008854  32FFFD     BRA Z, 0x8850
008856  A9680B     BCLR 0x80B, #3
32:                    receive=SPI3BUF;
008858  801540     MOV SPI3BUF, W0
00885A  B7F04E     MOV.B WREG, receive
33:                    SS3=1;
00885C  A82E54     BSET LATF, #1
34:                    
35:                    return receive;
36:                }
00885E  060000     RETURN
37:                
38:                void flashWritePage(int addressH, int addressL){
39:                    int i;
40:                    SS3=0;
008860  A92E54     BCLR LATF, #1
41:                    SPI3BUF=FLASH_PP;
008862  200022     MOV #0x2, W2
008864  881542     MOV W2, SPI3BUF
42:                    while(!_SPI3IF); _SPI3IF=0;
008866  208003     MOV #0x800, W3
008868  804054     MOV IFS5, W4
00886A  618104     AND W3, W4, W2
00886C  32FFFD     BRA Z, 0x8868
00886E  A9680B     BCLR 0x80B, #3
43:                    receive=SPI3BUF;
008870  801542     MOV SPI3BUF, W2
44:                    SPI3BUF=addressH&&0xFF;
008872  A7F000     BTSC W0, #15
008874  EA0000     NEG W0, W0
008876  EA0000     NEG W0, W0
008878  DE004F     LSR W0, #15, W0
00887A  881540     MOV W0, SPI3BUF
45:                    while(!_SPI3IF); _SPI3IF=0;
00887C  208002     MOV #0x800, W2
00887E  804053     MOV IFS5, W3
008880  610003     AND W2, W3, W0
008882  32FFFD     BRA Z, 0x887E
008884  A9680B     BCLR 0x80B, #3
46:                    receive=SPI3BUF;
008886  801540     MOV SPI3BUF, W0
47:                    SPI3BUF=(addressL&&0xFF00)>>8;
008888  EF22A8     CLR SPI3BUF
48:                    while(!_SPI3IF); _SPI3IF=0;
00888A  208002     MOV #0x800, W2
00888C  804054     MOV IFS5, W4
00888E  610004     AND W2, W4, W0
008890  32FFFD     BRA Z, 0x888C
008892  A9680B     BCLR 0x80B, #3
49:                    receive=SPI3BUF;
008894  801540     MOV SPI3BUF, W0
50:                    SPI3BUF=addressL&&0xFF;
008896  780001     MOV W1, W0
008898  A7F000     BTSC W0, #15
00889A  EA0000     NEG W0, W0
00889C  EA0000     NEG W0, W0
00889E  DE004F     LSR W0, #15, W0
0088A0  881540     MOV W0, SPI3BUF
51:                    while(!_SPI3IF); _SPI3IF=0;
0088A2  208001     MOV #0x800, W1
0088A4  804052     MOV IFS5, W2
0088A6  608002     AND W1, W2, W0
0088A8  32FFFD     BRA Z, 0x88A4
0088AA  A9680B     BCLR 0x80B, #3
52:                    receive=SPI3BUF;
0088AC  801540     MOV SPI3BUF, W0
0088AE  202002     MOV #0x200, W2
53:                    
54:                    for(i=0; i<512;i++){    //write 512 bytes
0088C2  3AFFF8     BRA NZ, 0x88B4
0088C4  B7F04E     MOV.B WREG, receive
55:                        //send byte
56:                        SPI3BUF=0xAA;
0088B0  200AA3     MOV #0xAA, W3
0088B4  881543     MOV W3, SPI3BUF
57:                        while(!_SPI3IF); _SPI3IF=0;
0088B2  208001     MOV #0x800, W1
0088B6  804054     MOV IFS5, W4
0088B8  608004     AND W1, W4, W0
0088BA  32FFFD     BRA Z, 0x88B6
0088BC  A9680B     BCLR 0x80B, #3
58:                        receive=SPI3BUF;
0088BE  801540     MOV SPI3BUF, W0
0088C0  E90102     DEC W2, W2
59:                    }
60:                    SS3=1;
0088C6  A82E54     BSET LATF, #1
61:                }
0088C8  060000     RETURN
62:                
63:                void flashRead(char *array, int bytes){
0088CA  BE9F88     MOV.D W8, [W15++]
0088CC  BE9F8A     MOV.D W10, [W15++]
0088CE  781F8C     MOV W12, [W15++]
0088D0  780581     MOV W1, W11
64:                    int i;
65:                    
66:                    SS3=0;
0088D2  A92E54     BCLR LATF, #1
67:                    SPI3BUF=FLASH_READ;
0088D4  200031     MOV #0x3, W1
0088D6  881541     MOV W1, SPI3BUF
68:                    while(!_SPI3IF); _SPI3IF=0;
0088D8  208002     MOV #0x800, W2
0088DA  804053     MOV IFS5, W3
0088DC  610083     AND W2, W3, W1
0088DE  32FFFD     BRA Z, 0x88DA
0088E0  A9680B     BCLR 0x80B, #3
69:                    receive=SPI3BUF;
0088E2  801541     MOV SPI3BUF, W1
70:                    SPI3BUF=0x00;
0088E4  EF22A8     CLR SPI3BUF
71:                    while(!_SPI3IF); _SPI3IF=0;
0088E6  208002     MOV #0x800, W2
0088E8  804053     MOV IFS5, W3
0088EA  610083     AND W2, W3, W1
0088EC  32FFFD     BRA Z, 0x88E8
0088EE  A9680B     BCLR 0x80B, #3
72:                    receive=SPI3BUF;
0088F0  801541     MOV SPI3BUF, W1
73:                    SPI3BUF=0x00;
0088F2  EF22A8     CLR SPI3BUF
74:                    while(!_SPI3IF); _SPI3IF=0;
0088F4  208002     MOV #0x800, W2
0088F6  804053     MOV IFS5, W3
0088F8  610083     AND W2, W3, W1
0088FA  32FFFD     BRA Z, 0x88F6
0088FC  A9680B     BCLR 0x80B, #3
75:                    receive=SPI3BUF;
0088FE  801541     MOV SPI3BUF, W1
76:                    SPI3BUF=0x00;
008900  EF22A8     CLR SPI3BUF
77:                    while(!_SPI3IF); _SPI3IF=0;
008902  208002     MOV #0x800, W2
008904  804053     MOV IFS5, W3
008906  610083     AND W2, W3, W1
008908  32FFFD     BRA Z, 0x8904
00890A  A9680B     BCLR 0x80B, #3
78:                    receive=SPI3BUF;
00890C  801541     MOV SPI3BUF, W1
00890E  784181     MOV.B W1, W3
008910  2104E2     MOV #0x104E, W2
008912  784903     MOV.B W3, [W2]
79:                    
80:                    for(i=0; i<bytes;i++){    //read 512 bytes
008914  E0000B     CP0 W11
008916  340010     BRA LE, 0x8938
008918  780500     MOV W0, W10
00891A  EB0480     CLR W9
008932  E80489     INC W9, W9
008934  558F89     SUB W11, W9, [W15]
008936  3CFFF4     BRA GT, 0x8920
81:                        //receive byte
82:                        SPI3BUF=0x00;
00891C  EB0600     CLR W12
008920  88154C     MOV W12, SPI3BUF
83:                        while(!_SPI3IF); _SPI3IF=0;
00891E  208008     MOV #0x800, W8
008922  804051     MOV IFS5, W1
008924  640001     AND W8, W1, W0
008926  32FFFD     BRA Z, 0x8922
008928  A9680B     BCLR 0x80B, #3
84:                        Delay_us(1);
00892A  200010     MOV #0x1, W0
00892C  07FDF6     RCALL Delay_us
85:                        array[i]=SPI3BUF;
00892E  801540     MOV SPI3BUF, W0
008930  785D00     MOV.B W0, [W10++]
86:                    }
87:                    SS3=1;
008938  A82E54     BSET LATF, #1
88:                }
00893A  78064F     MOV [--W15], W12
00893C  BE054F     MOV.D [--W15], W10
00893E  BE044F     MOV.D [--W15], W8
008940  060000     RETURN
89:                
90:                void flashBulkErase(void) {
91:                    flashWriteReg(FLASH_FRMT);
008942  B3C600     MOV.B #0x60, W0
008944  07FF6E     RCALL flashWriteReg
92:                }
008946  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/devInits.c  -------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 #include <xc.h>
5:                 #include <p33EP512GM310.h>
6:                 #include <libpic30.h>
7:                 #include "common.h"
8:                 #include "devInits.h"
9:                 #include "utilities.h"
10:                #include "plcd.h"
11:                #include "screens.h"
12:                #include "flash.h"
13:                #include "dsp.h"
14:                
15:                extern unsigned char UART_ON;
16:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
17:                
18:                extern char flash_readback[512];
19:                
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
007CDE  2FF3F0     MOV #0xFF3F, W0
007CE0  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
007CE2  2FFE00     MOV #0xFFE0, W0
007CE4  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
007CE6  2FE000     MOV #0xFE00, W0
007CE8  B60746     AND PLLFBD, WREG
007CEA  B30490     IOR #0x49, W0
007CEC  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
007CEE  200201     MOV #0x20, W1
007CF0  803A12     MOV OSCCON, W2
007CF2  608002     AND W1, W2, W0
007CF4  32FFFD     BRA Z, 0x7CF0
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
007CF6  803A10     MOV OSCCON, W0
007CF8  A16000     BCLR W0, #6
007CFA  200462     MOV #0x46, W2
007CFC  200573     MOV #0x57, W3
007CFE  207421     MOV #0x742, W1
007D00  784882     MOV.B W2, [W1]
007D02  784883     MOV.B W3, [W1]
007D04  784880     MOV.B W0, [W1]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
007D06  2FFC00     MOV #0xFFC0, W0
007D08  803424     MOV RPOR2, W4
007D0A  600084     AND W0, W4, W1
007D0C  A00001     BSET W1, #0
007D0E  883421     MOV W1, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
007D10  2FF801     MOV #0xFF80, W1
007D12  803685     MOV RPINR24, W5
007D14  608205     AND W1, W5, W4
007D16  B303D4     IOR #0x3D, W4
007D18  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
007D1A  B60686     AND RPOR3, WREG
007D1C  B300C0     IOR #0xC, W0
007D1E  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
007D20  2C0FF0     MOV #0xC0FF, W0
007D22  803426     MOV RPOR2, W6
007D24  600286     AND W0, W6, W5
007D26  20D004     MOV #0xD00, W4
007D28  720205     IOR W4, W5, W4
007D2A  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
007D2C  803434     MOV RPOR3, W4
007D2E  600284     AND W0, W4, W5
007D30  20B004     MOV #0xB00, W4
007D32  720205     IOR W4, W5, W4
007D34  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
007D36  803575     MOV RPINR7, W5
007D38  608205     AND W1, W5, W4
007D3A  B305F4     IOR #0x5F, W4
007D3C  883574     MOV W4, RPINR7
36:                    RPINR29bits.SCK3R=0x39;     //SCK3 input on pin 84
007D3E  280FF4     MOV #0x80FF, W4
007D40  8036D5     MOV RPINR29, W5
007D42  620305     AND W4, W5, W6
007D44  239005     MOV #0x3900, W5
007D46  728286     IOR W5, W6, W5
007D48  8836D5     MOV W5, RPINR29
37:                    RPOR7bits.RP57R=0x20;       //SCK3 output on pin 84
007D4A  803476     MOV RPOR7, W6
007D4C  600286     AND W0, W6, W5
007D4E  A0D005     BSET W5, #13
007D50  883475     MOV W5, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
007D52  803485     MOV RPOR8, W5
007D54  600305     AND W0, W5, W6
007D56  21F005     MOV #0x1F00, W5
007D58  728286     IOR W5, W6, W5
007D5A  883485     MOV W5, RPOR8
39:                    RPOR9bits.RP97R=0x21;       //SS3 on pin 88
007D5C  B60692     AND RPOR9, WREG
007D5E  221005     MOV #0x2100, W5
007D60  728280     IOR W5, W0, W5
007D62  883495     MOV W5, RPOR9
40:                    RPINR29bits.SDI3R=0x4C;     //SDI on pin 79, RPI76
007D64  8036D6     MOV RPINR29, W6
007D66  608006     AND W1, W6, W0
007D68  B304C0     IOR #0x4C, W0
007D6A  8836D0     MOV W0, RPINR29
41:                    RPINR14bits.QEA1R=0x10;     //QEA on pin 22, RPI16
007D6C  8035E0     MOV RPINR14, W0
007D6E  608080     AND W1, W0, W1
007D70  A04001     BSET W1, #4
007D72  8835E1     MOV W1, RPINR14
42:                    RPINR14bits.QEB1R=0x1B;     //QEB on pin 21, RPI27
007D74  8035E5     MOV RPINR14, W5
007D76  620205     AND W4, W5, W4
007D78  21B000     MOV #0x1B00, W0
007D7A  700004     IOR W0, W4, W0
007D7C  8835E0     MOV W0, RPINR14
43:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
007D7E  803A10     MOV OSCCON, W0
007D80  A06000     BSET W0, #6
007D82  207421     MOV #0x742, W1
007D84  784882     MOV.B W2, [W1]
007D86  784883     MOV.B W3, [W1]
007D88  784880     MOV.B W0, [W1]
44:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
45:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
007D8A  EB8000     SETM W0
007D8C  883B60     MOV W0, PMD7
007D8E  F8076C     PUSH PMD7
007D90  F9076A     POP PMD6
007D92  F8076A     PUSH PMD6
007D94  F90766     POP PMD4
007D96  F80766     PUSH PMD4
007D98  F90764     POP PMD3
007D9A  F80764     PUSH PMD3
007D9C  F90762     POP PMD2
007D9E  F80762     PUSH PMD2
007DA0  F90760     POP PMD1
46:                    PMD1bits.AD1MD=0;
007DA2  A90760     BCLR PMD1, #0
47:                    PMD1bits.SPI1MD=0;
007DA4  A96760     BCLR PMD1, #3
48:                    PMD1bits.SPI2MD=0;
007DA6  A98760     BCLR PMD1, #4
49:                    PMD1bits.U1MD=0;
007DA8  A9A760     BCLR PMD1, #5
50:                    PMD1bits.U2MD=0;
007DAA  A9C760     BCLR PMD1, #6
51:                    PMD1bits.DCIMD=0;
007DAC  A90761     BCLR 0x761, #0
52:                    PMD1bits.T1MD=0;
007DAE  A96761     BCLR 0x761, #3
53:                    PMD1bits.T2MD=0;
007DB0  A98761     BCLR 0x761, #4
54:                    PMD1bits.T3MD=0;
007DB2  A9A761     BCLR 0x761, #5
55:                    PMD1bits.T4MD=0;
007DB4  A9C761     BCLR 0x761, #6
56:                    PMD1bits.T5MD=0;
007DB6  A9E761     BCLR 0x761, #7
57:                    PMD3bits.PMPMD=0;
007DB8  A90765     BCLR 0x765, #0
58:                    PMD3bits.CMPMD=0;
007DBA  A94765     BCLR 0x765, #2
59:                    PMD6bits.SPI3MD=0;
007DBC  A9076A     BCLR PMD6, #0
60:                    PMD7bits.DMA0MD=0;
007DBE  A9876C     BCLR PMD7, #4
61:                    
62:                    /* Digital IO DIRECTION (1 = input) */
63:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
007DC0  EF2E60     CLR TRISG
007DC2  F80E60     PUSH TRISG
007DC4  F90E50     POP TRISF
007DC6  F80E50     PUSH TRISF
007DC8  F90E40     POP TRISE
007DCA  F80E40     PUSH TRISE
007DCC  F90E30     POP TRISD
007DCE  F80E30     PUSH TRISD
007DD0  F90E20     POP TRISC
007DD2  F80E20     PUSH TRISC
007DD4  F90E10     POP TRISB
007DD6  F80E10     PUSH TRISB
007DD8  F90E00     POP TRISA
64:                    TRISA=0x1E01; CNPUA=0x0801;
007DDA  21E011     MOV #0x1E01, W1
007DDC  887001     MOV W1, TRISA
007DDE  208011     MOV #0x801, W1
007DE0  887051     MOV W1, CNPUA
65:                    TRISB=0x0000; CNPUB=0x0000;
007DE2  EF2E10     CLR TRISB
007DE4  EF2E1A     CLR CNPUB
66:                    TRISC=0x2087;
007DE6  220871     MOV #0x2087, W1
007DE8  887101     MOV W1, TRISC
67:                    TRISD=0x011E; CNPUD=0x001E;
007DEA  2011E1     MOV #0x11E, W1
007DEC  887181     MOV W1, TRISD
007DEE  2001E1     MOV #0x1E, W1
007DF0  8871D1     MOV W1, CNPUD
68:                    TRISE=0x7300;
007DF2  273001     MOV #0x7300, W1
007DF4  887201     MOV W1, TRISE
69:                    TRISF=0x00F0; CNPUF=0x00F1;
007DF6  200F01     MOV #0xF0, W1
007DF8  887281     MOV W1, TRISF
007DFA  E80081     INC W1, W1
007DFC  8872D1     MOV W1, CNPUF
70:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
007DFE  887350     MOV W0, CNPUG
007E00  F80E6A     PUSH CNPUG
007E02  F90E60     POP TRISG
71:                    
72:                    /* DIGITAL OUTPUT LATCH */
73:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
007E04  EF2E64     CLR LATG
007E06  F80E64     PUSH LATG
007E08  F90E54     POP LATF
007E0A  F80E54     PUSH LATF
007E0C  F90E44     POP LATE
007E0E  F80E44     PUSH LATE
007E10  F90E34     POP LATD
007E12  F80E34     PUSH LATD
007E14  F90E24     POP LATC
007E16  F80E24     PUSH LATC
007E18  F90E14     POP LATB
007E1A  F80E14     PUSH LATB
007E1C  F90E04     POP LATA
74:                    LATA=0x0040;
007E1E  200400     MOV #0x40, W0
007E20  887020     MOV W0, LATA
75:                    
76:                    /* ANALOG PINS (1 = analog) */
77:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
007E22  EF2E6E     CLR ANSELG
007E24  F80E6E     PUSH ANSELG
007E26  F90E5E     POP ANSELF
007E28  F80E5E     PUSH ANSELF
007E2A  F90E4E     POP ANSELE
007E2C  F80E4E     PUSH ANSELE
007E2E  F90E3E     POP ANSELD
007E30  F80E3E     PUSH ANSELD
007E32  F90E2E     POP ANSELC
007E34  F80E2E     PUSH ANSELC
007E36  F90E1E     POP ANSELB
007E38  F80E1E     PUSH ANSELB
007E3A  F90E0E     POP ANSELA
78:                    ANSELCbits.ANSC0=1;     //AN6
007E3C  A80E2E     BSET ANSELC, #0
79:                    ANSELCbits.ANSC1=1;     //AN7
007E3E  A82E2E     BSET ANSELC, #1
80:                    ANSELCbits.ANSC2=1;     //AN8
007E40  A84E2E     BSET ANSELC, #2
81:                    ANSELAbits.ANSA12=1;    //AN10 
007E42  A88E0F     BSET 0xE0F, #4
82:                    ANSELEbits.ANSE8=1;     //AN21
007E44  A80E4F     BSET 0xE4F, #0
83:                    ANSELEbits.ANSE9=1;     //AN20
007E46  A82E4F     BSET 0xE4F, #1
84:                    
85:                    
86:                    
87:                }
007E48  060000     RETURN
88:                
89:                void initUART1(void){
90:                    IFS0bits.U1TXIF = 0;        //clear flag
007E4A  A98801     BCLR 0x801, #4
91:                    IFS0bits.U1RXIF = 0;        //clear flag
007E4C  A96801     BCLR 0x801, #3
92:                    U1STA=0x1510;               //enable tx & rx
007E4E  215100     MOV #0x1510, W0
007E50  881110     MOV W0, U1STA
93:                    U1BRG=BRGVAL;               //baud rate
007E52  2004A0     MOV #0x4A, W0
007E54  881140     MOV W0, U1BRG
94:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
007E56  2FFF90     MOV #0xFFF9, W0
007E58  B60220     AND U1MODE, WREG
007E5A  A01000     BSET W0, #1
007E5C  881100     MOV W0, U1MODE
95:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
007E5E  270000     MOV #0x7000, W0
007E60  B72844     IOR IPC2
96:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
007E62  200070     MOV #0x7, W0
007E64  B72846     IOR IPC3
97:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
98:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
99:                    U1MODEbits.UARTEN = 1;      //start uart
007E66  A8E221     BSET 0x221, #7
100:                   UART_ON = TRUE;
007E68  EFF00B     SETM.B UART_ON
101:                   
102:               }
007E6A  060000     RETURN
103:               
104:               void initADC1(void){ 
105:               
106:                   /* Assign MUXA inputs */
107:                   AD1CON1 = 0x04E4; // Enable 12-bit mode, auto-sample and auto-conversion
007E6C  204E40     MOV #0x4E4, W0
007E6E  881900     MOV W0, AD1CON1
108:                   AD1CON2 = 0x0408; // Sample alternately using channel scanning
007E70  B10DC0     SUB #0xDC, W0
007E72  881910     MOV W0, AD1CON2
109:                   AD1CON2bits.SMPI=(POTS/2)-1; // Sample 6 channels
007E74  2FF830     MOV #0xFF83, W0
007E76  B60322     AND AD1CON2, WREG
007E78  B30140     IOR #0x14, W0
007E7A  881910     MOV W0, AD1CON2
110:                   AD1CON3 = 0x0F0F; // Sample for 15*TAD before converting
007E7C  20F0F0     MOV #0xF0F, W0
007E7E  881920     MOV W0, AD1CON3
111:                   AD1CON1bits.FORM=2;         //signed fractional format 
007E80  2FCFF0     MOV #0xFCFF, W0
007E82  B60320     AND AD1CON1, WREG
007E84  A09000     BSET W0, #9
007E86  881900     MOV W0, AD1CON1
112:                   AD1CON3bits.ADCS=0x07;
007E88  B3C070     MOV.B #0x7, W0
007E8A  B7E324     MOV.B WREG, AD1CON3
113:                   AD1CON3bits.SAMC=0x03;
007E8C  2E0FF0     MOV #0xE0FF, W0
007E8E  B60324     AND AD1CON3, WREG
007E90  B33000     IOR #0x300, W0
007E92  881920     MOV W0, AD1CON3
114:                   //select  AN6,7,8
115:                   AD1CSSLbits.CSS6=1; //AN6
007E94  A8C330     BSET AD1CSSL, #6
116:                   AD1CSSLbits.CSS7=1; //AN7
007E96  A8E330     BSET AD1CSSL, #7
117:                   AD1CSSLbits.CSS8=1; //AN8
007E98  A80331     BSET 0x331, #0
118:                   AD1CSSLbits.CSS10=1;//AN10
007E9A  A84331     BSET 0x331, #2
119:                   AD1CSSHbits.CSS20=1;//AN20
007E9C  A8832E     BSET AD1CSSH, #4
120:                   AD1CSSHbits.CSS21=1;//AN21
007E9E  A8A32E     BSET AD1CSSH, #5
121:                   //AD1CSSLbits.CSS9=1; //AN9
122:                   /* Enable ADC module and provide ADC stabilization delay */
123:                   AD1CON1bits.ADON = 1;
007EA0  A8E321     BSET 0x321, #7
124:                   Delay_us(30);
007EA2  2001E0     MOV #0x1E, W0
007EA4  07033A     RCALL Delay_us
125:               }
007EA6  060000     RETURN
126:               
127:               void initPMP(void){
128:                   /*
129:                    Data is clocked on falling edge of E
130:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
131:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
132:                    */
133:                   PMMODEbits.MODE=3;  //master mode 1 
007EA8  203000     MOV #0x300, W0
007EAA  B72602     IOR PMMODE
134:                   PMCONbits.PTWREN = 1;
007EAC  A82601     BSET 0x601, #1
135:                   PMCONbits.PTRDEN = 1;
007EAE  A80601     BSET 0x601, #0
136:                   PMCONbits.WRSP=1;   //write strobe active high
007EB0  A82600     BSET PMCON, #1
137:                   PMCONbits.RDSP=1;   //read strobe active high
007EB2  A80600     BSET PMCON, #0
138:               
139:                   PMMODEbits.WAITB = 0;
007EB4  2FF3F0     MOV #0xFF3F, W0
007EB6  B62602     AND PMMODE
140:                   PMMODEbits.WAITM = 0xC;
007EB8  2FFC30     MOV #0xFFC3, W0
007EBA  B60602     AND PMMODE, WREG
007EBC  B30300     IOR #0x30, W0
007EBE  883010     MOV W0, PMMODE
141:                   PMMODEbits.WAITE = 0;
007EC0  2FFFC0     MOV #0xFFFC, W0
007EC2  B62602     AND PMMODE
142:                   LCD_RS=0;
007EC4  A9EE45     BCLR 0xE45, #7
143:                   PMCONbits.PMPEN = 1;
007EC6  A8E601     BSET 0x601, #7
144:                   
145:                   /* INIT DEVICE */
146:                   Delay_us(40000);
007EC8  29C400     MOV #0x9C40, W0
007ECA  070327     RCALL Delay_us
147:                   lcdInit();
007ECC  07FEEC     RCALL lcdInit
148:                   
149:                   /* SETUP SCREEN */
150:                   //lcdSetupPots();
151:               }
007ECE  060000     RETURN
152:               
153:               
154:               //Description: Initializes timer for LED's UART and display
155:               //Prereq: initUART1()
156:               //Dependencies: _T1Interrupt(void)
157:               //Frequency: 15Hz
158:               void initT1(void){          //16 bit timer
159:                   TMR1 = 0x0000;          //clear timer 4
007ED0  EF2100     CLR TMR1
160:                   T1CONbits.TCKPS = 3;    //prescale 1:256
007ED2  200300     MOV #0x30, W0
007ED4  B72104     IOR T1CON
161:                   T1CONbits.TCS = 0;      //use internal clock
007ED6  A92104     BCLR T1CON, #1
162:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
007ED8  A9C104     BCLR T1CON, #6
163:                   PR1 = Fcy/(256*Fdisp);    //period register
007EDA  246500     MOV #0x4650, W0
007EDC  880810     MOV W0, PR1
164:                   //PR1=0x7FFF;
165:               
166:                   T1CONbits.TON = 1;      //start timer
007EDE  A8E105     BSET 0x105, #7
167:               }
007EE0  060000     RETURN
168:               
169:               //Description:  Initializes timer handles polling button input
170:               //Prereq: initADC1() 
171:               //Dependencies: _T2Interrupt(void)
172:               //Frequency: 512Hz
173:               void initT2(void){          //16/32 bit timer
174:                   TMR2 = 0x0000;          //clear timer 4
007EE2  EF2106     CLR TMR2
175:                   T2CONbits.T32 = 0;      //16 bit mode
007EE4  A96110     BCLR T2CON, #3
176:                   T2CONbits.TCKPS = 1;    //prescale 1:8
007EE6  2FFCF0     MOV #0xFFCF, W0
007EE8  B60110     AND T2CON, WREG
007EEA  A04000     BSET W0, #4
007EEC  880880     MOV W0, T2CON
177:                   T2CONbits.TCS = 0;      //use internal clock
007EEE  A92110     BCLR T2CON, #1
178:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
007EF0  A9C110     BCLR T2CON, #6
179:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
007EF2  207AC0     MOV #0x7AC, W0
007EF4  880860     MOV W0, PR2
180:               
181:                   T2CONbits.TON = 1;      //start timer
007EF6  A8E111     BSET 0x111, #7
182:               }
007EF8  060000     RETURN
183:               
184:               //Description: Initialize timer handling LCD sending
185:               //Dependencies: _T3Interrupt(void)
186:               //Frequency: 44.1kHz
187:               void initT3(void){          //16/32 bit timer
188:                   TMR3 = 0x0000;          //clear timer 3
007EFA  EF210A     CLR TMR3
189:                   T3CONbits.TCKPS = 1;    //prescale 8:1
007EFC  2FFCF0     MOV #0xFFCF, W0
007EFE  B60112     AND T3CON, WREG
007F00  A04000     BSET W0, #4
007F02  880890     MOV W0, T3CON
190:                   T3CONbits.TCS = 0;      //use internal clock
007F04  A92112     BCLR T3CON, #1
191:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
007F06  A9C112     BCLR T3CON, #6
192:                   //PR3 = Fcy/(256*T3freq);           //period register
193:                   PR3 = 0x01D0;           //45uS initial delay
007F08  201D00     MOV #0x1D0, W0
007F0A  880870     MOV W0, PR3
194:                   
195:                   T3CONbits.TON = 1;
007F0C  A8E113     BSET 0x113, #7
196:                   
197:               }
007F0E  060000     RETURN
198:               
199:               /*=============================================================================  
200:               Timer 5 is setup to time-out every 125 microseconds (8Khz Rate). As a result, the module 
201:               will stop sampling and trigger a conversion on every Timer3 time-out, i.e., Ts=125us. 
202:               =============================================================================*/
203:               void initT5() 
204:               {
205:                       TMR5 = 0x0000;
007F10  EF2118     CLR TMR5
206:                       PR5 = 4999;
007F12  213870     MOV #0x1387, W0
007F14  8808E0     MOV W0, PR5
207:                       T5CONbits.TCKPS = 2;    //prescale 8:1
007F16  2FFCF0     MOV #0xFFCF, W0
007F18  B60120     AND T5CON, WREG
007F1A  A05000     BSET W0, #5
007F1C  880900     MOV W0, T5CON
208:                       IFS1bits.T5IF = 0;
007F1E  A98803     BCLR 0x803, #4
209:                       IEC1bits.T5IE = 0;
007F20  A98823     BCLR 0x823, #4
210:               
211:                       //Start Timer 3
212:                       T5CONbits.TON = 1;
007F22  A8E121     BSET 0x121, #7
213:               
214:               }
007F24  060000     RETURN
215:               
216:               //Description: Initializes & starts 16 bit DCI I2S DAC
217:               //Prereq: initSPI_ADC(void)
218:               //Dependencies: readDAC(void)
219:               void initDCI_DAC(void){
220:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
007F26  2F0000     MOV #0xF000, W0
007F28  B60284     AND DCICON3, WREG
007F2A  B30170     IOR #0x17, W0
007F2C  881420     MOV W0, DCICON3
221:                   DCICON1bits.COFSM=1;                //i2s mode
007F2E  2FFFC0     MOV #0xFFFC, W0
007F30  B60280     AND DCICON1, WREG
007F32  A00000     BSET W0, #0
007F34  881400     MOV W0, DCICON1
222:                   DCICON1bits.CSCKE=1;                //sample on rising edge
007F36  A82281     BSET 0x281, #1
223:                   DCICON2bits.WS=0xF;                 //16 bit data word
007F38  2000F0     MOV #0xF, W0
007F3A  B72282     IOR DCICON2
224:                   DCICON2bits.COFSG=0;    //data frame has 1 word (per frame)
007F3C  2FE1F0     MOV #0xFE1F, W0
007F3E  B62282     AND DCICON2
225:                   DCICON1bits.DJST=0;     //align data
007F40  A9A280     BCLR DCICON1, #5
226:                   DCICON2bits.BLEN=3;     //4 words buffer btwn interrupts
007F42  20C000     MOV #0xC00, W0
007F44  B72282     IOR DCICON2
227:                   
228:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
007F46  A80288     BSET TSCON, #0
229:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
007F48  A82288     BSET TSCON, #1
230:                   TSCONbits.TSE2 = 1;     // Transmit on Time Slot 2     
007F4A  A84288     BSET TSCON, #2
231:                   TSCONbits.TSE3 = 1;     // Transmit on Time Slot 3   
007F4C  A86288     BSET TSCON, #3
232:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
007F4E  A8028C     BSET RSCON, #0
233:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
007F50  A8228C     BSET RSCON, #1
234:                   RSCONbits.RSE2 = 1;     // rcv on Time Slot 2     
007F52  A8428C     BSET RSCON, #2
235:                   RSCONbits.RSE3 = 1;     // rcv on Time Slot 3 
007F54  A8628C     BSET RSCON, #3
236:                   
237:               
238:                   
239:                   IPC15bits.DCIIP = 6;    // Interrput priority
007F56  2FFF80     MOV #0xFFF8, W0
007F58  B6085E     AND IPC15, WREG
007F5A  B30060     IOR #0x6, W0
007F5C  8842F0     MOV W0, IPC15
240:                   IFS3bits.DCIIF=0;
007F5E  A98807     BCLR 0x807, #4
241:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
007F60  A88827     BSET 0x827, #4
242:                   
243:                   // Pre-load send registers.
244:                   TXBUF0=0;
007F62  EF2298     CLR TXBUF0
245:                   TXBUF1=0;   
007F64  EF229A     CLR TXBUF1
246:                   TXBUF2=0;
007F66  EF229C     CLR TXBUF2
247:                   TXBUF3=0;
007F68  EF229E     CLR TXBUF3
248:                   DCICON1bits.DCIEN=1;    //ENABLE
007F6A  A8E281     BSET 0x281, #7
249:                   // Stabilization delay
250:                   Delay_us(20);
007F6C  200140     MOV #0x14, W0
007F6E  0702D5     RCALL Delay_us
251:               }
007F70  060000     RETURN
252:               
253:               void initDMA0(void){
254:                   unsigned long address;
255:                   
256:                   /*
257:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
258:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
259:                   DMA0PAD =  0X0608; // Point DMA to PMP
260:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
261:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
262:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
263:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
264:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
265:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
266:                   DMA0CONbits.CHEN=1; // Enable DMA
267:                   */
268:                   
269:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
007F72  A9CB01     BCLR 0xB01, #6
270:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
007F74  A8AB01     BSET 0xB01, #5
271:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
007F76  2FFCF4     MOV #0xFFCF, W4
007F78  20B000     MOV #0xB00, W0
007F7A  620810     AND W4, [W0], [W0]
272:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
007F7C  2FFFC3     MOV #0xFFFC, W3
007F7E  805801     MOV DMA0CON, W1
007F80  618001     AND W3, W1, W0
007F82  A01000     BSET W0, #1
007F84  885800     MOV W0, DMA0CON
273:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
007F86  A98B01     BCLR 0xB01, #4
274:                   DMA0CONbits.NULLW = 0;
007F88  A96B01     BCLR 0xB01, #3
275:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
007F8A  A9EB03     BCLR 0xB03, #7
276:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
007F8C  B3C3C2     MOV.B #0x3C, W2
007F8E  20B025     MOV #0xB02, W5
007F90  784A82     MOV.B W2, [W5]
277:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
007F92  27FFF0     MOV #0x7FFF, W0
007F94  2CC001     MOV #0xCC00, W1
007F96  608080     AND W1, W0, W1
278:                   address +=__builtin_edspage(txBufferA) << 15;
007F98  200016     MOV #0x1, W6
007F9A  DD334F     SL W6, #15, W6
007F9C  EB0380     CLR W7
007F9E  408306     ADD W1, W6, W6
007FA0  4B83E0     ADDC W7, #0x0, W7
279:                   DMA0STAL = address & 0xFFFF;
007FA2  885826     MOV W6, DMA0STAL
280:                   DMA0STAH = address >>16;
007FA4  885837     MOV W7, DMA0STAH
281:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
007FA6  2C8001     MOV #0xC800, W1
007FA8  608080     AND W1, W0, W1
282:                   address +=__builtin_edspage(txBufferB) << 15;
007FAA  200016     MOV #0x1, W6
007FAC  DD334F     SL W6, #15, W6
007FAE  EB0380     CLR W7
007FB0  408306     ADD W1, W6, W6
007FB2  4B83E0     ADDC W7, #0x0, W7
283:                   DMA0STBL = address & 0xFFFF;
007FB4  885846     MOV W6, DMA0STBL
284:                   DMA0STBH = address >>16;
007FB6  885857     MOV W7, DMA0STBH
285:                   DMA0PAD = (int)&TXBUF0;
007FB8  202981     MOV #0x298, W1
007FBA  885861     MOV W1, DMA0PAD
286:                   DMA0CNT = STREAMBUF-1;
007FBC  201FF1     MOV #0x1FF, W1
007FBE  885871     MOV W1, DMA0CNT
287:                   /* DMA 2 - DCI to DPSRAM*/
288:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
007FC0  A9CB21     BCLR 0xB21, #6
289:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
007FC2  A9AB21     BCLR 0xB21, #5
290:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
007FC4  A98B21     BCLR 0xB21, #4
291:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
007FC6  A96B21     BCLR 0xB21, #3
292:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
007FC8  20B205     MOV #0xB20, W5
007FCA  620A95     AND W4, [W5], [W5]
293:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
007FCC  805904     MOV DMA2CON, W4
007FCE  618184     AND W3, W4, W3
007FD0  A01003     BSET W3, #1
007FD2  885903     MOV W3, DMA2CON
294:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
007FD4  A9EB23     BCLR 0xB23, #7
295:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
007FD6  784182     MOV.B W2, W3
007FD8  20B225     MOV #0xB22, W5
007FDA  784A83     MOV.B W3, [W5]
296:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
007FDC  2C4004     MOV #0xC400, W4
007FDE  620200     AND W4, W0, W4
297:                   address +=__builtin_edspage(rxBufferA) << 15;
007FE0  200012     MOV #0x1, W2
007FE2  DD114F     SL W2, #15, W2
007FE4  EB0180     CLR W3
007FE6  420102     ADD W4, W2, W2
007FE8  4981E0     ADDC W3, #0x0, W3
298:                   DMA2STAL = address & 0xFFFF;
007FEA  885922     MOV W2, DMA2STAL
299:                   DMA2STAH = address >>16;
007FEC  885933     MOV W3, DMA2STAH
300:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
007FEE  2C0002     MOV #0xC000, W2
007FF0  610000     AND W2, W0, W0
301:                   address +=__builtin_edspage(rxBufferB) << 15;
007FF2  200012     MOV #0x1, W2
007FF4  DD114F     SL W2, #15, W2
007FF6  EB0180     CLR W3
007FF8  400102     ADD W0, W2, W2
007FFA  4981E0     ADDC W3, #0x0, W3
302:                   DMA2STBL = address & 0xFFFF;
007FFC  885942     MOV W2, DMA2STBL
303:                   DMA2STBH = address >>16;
007FFE  885953     MOV W3, DMA2STBH
304:                   DMA2PAD = (int)&RXBUF0;
008000  202900     MOV #0x290, W0
008002  885960     MOV W0, DMA2PAD
305:                   DMA2CNT = STREAMBUF-1;
008004  885971     MOV W1, DMA2CNT
306:                   _DMA2IP = 5;
008006  2FFF80     MOV #0xFFF8, W0
008008  B6084C     AND IPC6, WREG
00800A  B30050     IOR #0x5, W0
00800C  884260     MOV W0, IPC6
307:                   _DMA2IE = 1;
00800E  A80823     BSET 0x823, #0
308:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
008010  A8EB01     BSET 0xB01, #7
309:                   DMA2CONbits.CHEN = 1;
008012  A8EB21     BSET 0xB21, #7
310:               }
008014  060000     RETURN
311:               
312:               void initSPI3_MEM(void){
313:                   SS3=1;                     // Assert chip select (active low)
008016  A82E54     BSET LATF, #1
314:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
008018  A9680B     BCLR 0x80B, #3
315:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
00801A  A9682B     BCLR 0x82B, #3
316:                   SPI3CON1bits.MSTEN=1;       //master mode
00801C  A8A2A2     BSET SPI3CON1, #5
317:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
00801E  A982A3     BCLR 0x2A3, #4
318:                   SPI3CON1bits.MODE16=0;      //8 bit
008020  A942A3     BCLR 0x2A3, #2
319:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
008022  A962A3     BCLR 0x2A3, #3
320:                   SPI3CON1bits.SSEN=1;        //use SS
008024  A8E2A2     BSET SPI3CON1, #7
321:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
008026  A9E2A5     BCLR 0x2A5, #7
322:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
008028  A902A4     BCLR SPI3CON2, #0
323:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
00802A  2FFE33     MOV #0xFFE3, W3
00802C  801300     MOV SPI2STAT, W0
00802E  618080     AND W3, W0, W1
008030  B30141     IOR #0x14, W1
008032  881301     MOV W1, SPI2STAT
324:                   
325:                   SPI3CON1bits.SMP=1;         //data sampled at end of output time
008034  A822A3     BSET 0x2A3, #1
326:                   SPI3CON1bits.CKP=0;         //idle clock is low
008036  A9C2A2     BCLR SPI3CON1, #6
327:                   SPI3CON1bits.CKE=1;         //data changes from H to L
008038  A802A3     BSET 0x2A3, #0
328:                   
329:                   SPI3CON1bits.PPRE=3;        //1:1 primary prescale
00803A  200030     MOV #0x3, W0
00803C  B722A2     IOR SPI3CON1
330:                   SPI3CON1bits.SPRE=6;        //2:1 secondary
00803E  801511     MOV SPI3CON1, W1
008040  618001     AND W3, W1, W0
008042  B30180     IOR #0x18, W0
008044  881510     MOV W0, SPI3CON1
331:                   
332:                   SPI3STATbits.SPIROV = 0;        // Clear SPI1 receive overflow flag if set
008046  A9C2A0     BCLR SPI3STAT, #6
333:                   //IPC22bits.SPI3IP = 3;         // Interrupt priority
334:                   //IFS5bits.SPI3IF = 0;          // Clear the Interrupt flag
335:                   //IEC5bits.SPI3IE = 0;          // Enable the interrupt
336:                   SPI3STATbits.SPIEN = 1;         //start SPI module
008048  A8E2A1     BSET 0x2A1, #7
337:                  
338:                   Delay_us(20);                       // Stabilization Delay
00804A  200140     MOV #0x14, W0
00804C  070266     RCALL Delay_us
339:                   
340:                   flashWriteReg(FLASH_WREN);
00804E  B3C060     MOV.B #0x6, W0
008050  0703E8     RCALL flashWriteReg
341:                   /*
342:                   flashBulkErase();
343:                   while(flashStatusCheck()&1);
344:               
345:                   flashWritePage
346:                   while(flashStatusCheck()&1);
347:                   */
348:                   
349:                   flashRead(flash_readback, 256);     // READBACK
008052  201001     MOV #0x100, W1
008054  25E700     MOV #0x5E70, W0
008056  070439     RCALL flashRead
350:                   
351:               }
008058  060000     RETURN
352:               
353:               void initQEI_ENC(void){
354:                   QEI1CONbits.INTDIV=6;       // 1:64 prescaler
00805A  2FF8F0     MOV #0xFF8F, W0
00805C  B601C0     AND QEI1CON, WREG
00805E  B30600     IOR #0x60, W0
008060  880E00     MOV W0, QEI1CON
355:                   QEI1IOCbits.FLTREN=1;       // Enable input filter
008062  A8C1C3     BSET 0x1C3, #6
356:                   QEI1CONbits.QEIEN=1;        // Enable Quad encoder inteface
008064  A8E1C1     BSET 0x1C1, #7
357:               }
008066  060000     RETURN
358:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/audio.c  ----------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[8];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[4];
7:                 extern fractional pots_percent[4];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                fractional mixer(fractional sample){
00852C  F80022     PUSH ACCA
00852E  F80024     PUSH ACCAH
008530  F80026     PUSH ACCAU
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    
38:                
39:                    if(kick_playing==TRUE&&kick_ptr<kick_max){
008532  210321     MOV #0x1032, W1
008534  784091     MOV.B [W1], W1
008536  40CFE1     ADD.B W1, #0x1, [W15]
008538  3A0011     BRA NZ, 0x855C
00853A  877662     MOV 0xEECC, W2
00853C  8081A3     MOV kick_ptr, W3
00853E  518F82     SUB W3, W2, [W15]
008540  31000D     BRA C, 0x855C
40:                        result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
008542  780200     MOV W0, W4
008544  273325     MOV #0x7332, W5
008546  C00113     MPY W4*W5, A
41:                        result1 = __builtin_add(result1,kick[kick_ptr++],0);
008548  780003     MOV W3, W0
00854A  400080     ADD W0, W0, W1
00854C  2C36C2     MOV #0xC36C, W2
00854E  410081     ADD W2, W1, W1
008550  780091     MOV [W1], W1
008552  E80000     INC W0, W0
008554  8881A0     MOV W0, kick_ptr
008556  C90001     ADD W1, A
42:                        sample=__builtin_sac(result1, 0);
008558  CC0000     SAC A, W0
00855A  37000C     BRA 0x8574
43:                    }
44:                    else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
00855C  270A02     MOV #0x70A0, W2
00855E  B3C013     MOV.B #0x1, W3
008560  11CF92     SUBR.B W3, [W2], [W15]
008562  3A0008     BRA NZ, 0x8574
008564  40CFE1     ADD.B W1, #0x1, [W15]
008566  3A0006     BRA NZ, 0x8574
008568  877661     MOV 0xEECC, W1
00856A  8081A4     MOV kick_ptr, W4
00856C  520F81     SUB W4, W1, [W15]
00856E  3A0002     BRA NZ, 0x8574
45:                        kick_playing=FALSE;
008570  EF7032     CLR.B kick_playing
46:                        kick_ptr=0;
008572  EF3034     CLR kick_ptr
47:                    }
48:                    /*
49:                    if(hat_playing==TRUE&&hat_ptr<hat_max){
50:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
51:                        result1 = __builtin_add(result1,hat[hat_ptr++],0);
52:                        sample=__builtin_sac(result1, 0);
53:                    }
54:                    else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
55:                        hat_playing=FALSE;
56:                        hat_ptr=0;
57:                    }
58:                     */
59:                
60:                    if(snare_playing==TRUE&&snare_ptr<snare_max){
008574  210361     MOV #0x1036, W1
008576  784091     MOV.B [W1], W1
008578  40CFE1     ADD.B W1, #0x1, [W15]
00857A  3A0011     BRA NZ, 0x859E
00857C  877672     MOV 0xEECE, W2
00857E  8081C5     MOV snare_ptr, W5
008580  528F82     SUB W5, W2, [W15]
008582  31000D     BRA C, 0x859E
61:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
008584  780200     MOV W0, W4
008586  26CCC5     MOV #0x6CCC, W5
008588  C00113     MPY W4*W5, A
62:                        result1 = __builtin_add(result1,snare[snare_ptr++],0);
00858A  8081C0     MOV snare_ptr, W0
00858C  400080     ADD W0, W0, W1
00858E  292942     MOV #0x9294, W2
008590  410081     ADD W2, W1, W1
008592  780091     MOV [W1], W1
008594  E80000     INC W0, W0
008596  8881C0     MOV W0, snare_ptr
008598  C90001     ADD W1, A
63:                        sample=__builtin_sac(result1, 0);
00859A  CC0000     SAC A, W0
00859C  37000C     BRA 0x85B6
64:                    }
65:                    else if (pad[1]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
00859E  270A12     MOV #0x70A1, W2
0085A0  B3C013     MOV.B #0x1, W3
0085A2  11CF92     SUBR.B W3, [W2], [W15]
0085A4  3A0008     BRA NZ, 0x85B6
0085A6  40CFE1     ADD.B W1, #0x1, [W15]
0085A8  3A0006     BRA NZ, 0x85B6
0085AA  877671     MOV 0xEECE, W1
0085AC  8081C4     MOV snare_ptr, W4
0085AE  520F81     SUB W4, W1, [W15]
0085B0  3A0002     BRA NZ, 0x85B6
66:                        snare_playing=FALSE;
0085B2  EF7036     CLR.B snare_playing
67:                        snare_ptr=0;
0085B4  EF3038     CLR snare_ptr
68:                    }
69:                    
70:                    
71:                    //VOLUME CONTROL
72:                    
73:                    if(pots[2]==0x0007)
0085B6  8303A4     MOV 0x6074, W4
0085B8  520FE7     SUB W4, #0x7, [W15]
0085BA  320007     BRA Z, 0x85CA
74:                        sample=0;
0085CA  EB0000     CLR W0
75:                    else if(pots[2]>=0x7FF7);
0085BC  27FF61     MOV #0x7FF6, W1
0085BE  520F81     SUB W4, W1, [W15]
0085C0  3C0005     BRA GT, 0x85CC
76:                    else{
77:                        result1 =__builtin_mpy(sample,pots[2], NULL, NULL, 0, NULL, NULL, 0);
0085C2  780280     MOV W0, W5
0085C4  C00113     MPY W4*W5, A
78:                        sample=__builtin_sac(result1, 0);
0085C6  CC0000     SAC A, W0
0085C8  370001     BRA 0x85CC
79:                    }
80:                    
81:                    if (TEST_SIN==TRUE){
0085CC  2100C1     MOV #0x100C, W1
0085CE  784091     MOV.B [W1], W1
0085D0  40CFE1     ADD.B W1, #0x1, [W15]
0085D2  3A000B     BRA NZ, 0x85EA
82:                        i++;
0085D4  EC1022     INC i, WREG
0085D6  888110     MOV W0, i
83:                        if(i==1024)
0085D8  204001     MOV #0x400, W1
0085DA  500F81     SUB W0, W1, [W15]
0085DC  3A0001     BRA NZ, 0x85E0
84:                            i=0;
0085DE  EF3022     CLR i
85:                        return sintab[i];
0085E0  808110     MOV i, W0
0085E2  400000     ADD W0, W0, W0
0085E4  2EED21     MOV #0xEED2, W1
0085E6  408000     ADD W1, W0, W0
0085E8  780010     MOV [W0], W0
86:                    }
87:                    else 
88:                        return sample;
89:                    
90:                }
0085EA  F90026     POP ACCAU
0085EC  F90024     POP ACCAH
0085EE  F90022     POP ACCA
0085F0  060000     RETURN
91:                
92:                fractional fx(fractional sample){
0085F2  F80022     PUSH ACCA
0085F4  F80024     PUSH ACCAH
0085F6  F80026     PUSH ACCAU
0085F8  F80028     PUSH ACCB
0085FA  F8002A     PUSH ACCBH
0085FC  F8002C     PUSH ACCBU
93:                    volatile register int result1 asm("A");
94:                    volatile register int result2 asm("B");
95:                    static fractional delayed_sample;
96:                    static fractional trem_mod;
97:                    if(tremelo==TRUE){                                                          //TREMELO//
0085FE  2100D1     MOV #0x100D, W1
008600  784091     MOV.B [W1], W1
008602  40CFE1     ADD.B W1, #0x1, [W15]
008604  3A0027     BRA NZ, 0x8654
98:                        if (trem_var<=pots[3]){
008606  8080D1     MOV trem_var, W1
008608  8303B2     MOV 0x6076, W2
00860A  510F81     SUB W2, W1, [W15]
00860C  39000F     BRA NC, 0x862C
99:                            trem_var++;
00860E  E80081     INC W1, W1
008610  8880D1     MOV W1, trem_var
100:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
008612  8080B1     MOV tremelo_ptr, W1
008614  408081     ADD W1, W1, W1
008616  2EED22     MOV #0xEED2, W2
008618  410081     ADD W2, W1, W1
00861A  780291     MOV [W1], W5
00861C  808244     MOV 0x1048, W4
00861E  C00113     MPY W4*W5, A
101:                           trem_mod=__builtin_sac(result1, 0);
008620  CC0004     SAC A, W4
008622  8880F4     MOV W4, trem_mod
102:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008624  780280     MOV W0, W5
008626  C08113     MPY W4*W5, B
103:                           sample=__builtin_sac(result2, 0);
008628  CC8000     SAC B, W0
00862A  370014     BRA 0x8654
104:                       }
105:                       else{
106:                           trem_var=0;
00862C  EF301A     CLR trem_var
107:                           if(tremelo_ptr==1024)
00862E  204001     MOV #0x400, W1
008630  8080B2     MOV tremelo_ptr, W2
008632  510F81     SUB W2, W1, [W15]
008634  3A0001     BRA NZ, 0x8638
108:                               tremelo_ptr=0;
008636  EF3016     CLR tremelo_ptr
109:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
008638  8080B1     MOV tremelo_ptr, W1
00863A  408101     ADD W1, W1, W2
00863C  2EED23     MOV #0xEED2, W3
00863E  418102     ADD W3, W2, W2
008640  780292     MOV [W2], W5
008642  E80081     INC W1, W1
008644  8880B1     MOV W1, tremelo_ptr
008646  808244     MOV 0x1048, W4
008648  C00113     MPY W4*W5, A
110:                           trem_mod=__builtin_sac(result1, 0);
00864A  CC0004     SAC A, W4
00864C  8880F4     MOV W4, trem_mod
111:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
00864E  780280     MOV W0, W5
008650  C08113     MPY W4*W5, B
112:                           sample=__builtin_sac(result2, 0);
008652  CC8000     SAC B, W0
113:                       }
114:                   }
115:                   if(looper==TRUE){                                                           //LOOPER// 
008654  2100E1     MOV #0x100E, W1
008656  784091     MOV.B [W1], W1
008658  40CFE1     ADD.B W1, #0x1, [W15]
00865A  3A0019     BRA NZ, 0x868E
116:                       if(loop_lim>=LOOP_BUF_SIZE)
00865C  2270F0     MOV #0x270F, W0
00865E  E31014     CP loop_lim
008660  360002     BRA LEU, 0x8666
117:                           loop_lim=LOOP_BUF_SIZE;
008662  E80000     INC W0, W0
008664  8880A0     MOV W0, loop_lim
118:                       if(loop_ptr<loop_lim){
008666  8080A0     MOV loop_lim, W0
008668  E31012     CP loop_ptr
00866A  310008     BRA C, 0x867C
119:                           sample = (loop[loop_ptr++]);
00866C  808091     MOV loop_ptr, W1
00866E  408001     ADD W1, W1, W0
008670  210502     MOV #0x1050, W2
008672  410000     ADD W2, W0, W0
008674  780010     MOV [W0], W0
008676  E80081     INC W1, W1
008678  888091     MOV W1, loop_ptr
00867A  37001D     BRA 0x86B6
120:                       }
121:                       else {
122:                           loop_ptr=0;
00867C  EF3012     CLR loop_ptr
123:                           sample = (loop[loop_ptr++]);
00867E  808091     MOV loop_ptr, W1
008680  408001     ADD W1, W1, W0
008682  210502     MOV #0x1050, W2
008684  410000     ADD W2, W0, W0
008686  780010     MOV [W0], W0
008688  E80081     INC W1, W1
00868A  888091     MOV W1, loop_ptr
00868C  370014     BRA 0x86B6
124:                       }
125:                   }                                                                           
126:                   else {                                                                      //buffer
127:                       if(loop_ptr<LOOP_BUF_SIZE)
00868E  2270F1     MOV #0x270F, W1
008690  808092     MOV loop_ptr, W2
008692  510F81     SUB W2, W1, [W15]
008694  3E0008     BRA GTU, 0x86A6
128:                           loop[loop_ptr++]=sample;
008696  808091     MOV loop_ptr, W1
008698  408101     ADD W1, W1, W2
00869A  210503     MOV #0x1050, W3
00869C  418102     ADD W3, W2, W2
00869E  780900     MOV W0, [W2]
0086A0  E80081     INC W1, W1
0086A2  888091     MOV W1, loop_ptr
0086A4  370008     BRA 0x86B6
129:                       else {
130:                           loop_ptr=0;
0086A6  EF3012     CLR loop_ptr
131:                           loop[loop_ptr++]=sample;
0086A8  808091     MOV loop_ptr, W1
0086AA  408101     ADD W1, W1, W2
0086AC  210503     MOV #0x1050, W3
0086AE  418102     ADD W3, W2, W2
0086B0  780900     MOV W0, [W2]
0086B2  E80081     INC W1, W1
0086B4  888091     MOV W1, loop_ptr
132:                       }
133:                   }
134:                   
135:                                                                                               //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
136:                   if(lpf==TRUE){
0086B6  2100F1     MOV #0x100F, W1
0086B8  784091     MOV.B [W1], W1
0086BA  40CFE1     ADD.B W1, #0x1, [W15]
0086BC  3A0008     BRA NZ, 0x86CE
137:                       result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
0086BE  808224     MOV 0x1044, W4
0086C0  780280     MOV W0, W5
0086C2  C08113     MPY W4*W5, B
138:                       result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
0086C4  808234     MOV 0x1046, W4
0086C6  808105     MOV __Getmem, W5
0086C8  C08112     MAC W4*W5, B
139:                       delayed_sample=__builtin_sac(result2, 0);
0086CA  CC8000     SAC B, W0
0086CC  888100     MOV W0, __Getmem
140:                       sample=delayed_sample;
141:                   }
142:                   return sample;
143:               }
0086CE  F9002C     POP ACCBU
0086D0  F9002A     POP ACCBH
0086D2  F90028     POP ACCB
0086D4  F90026     POP ACCAU
0086D6  F90024     POP ACCAH
0086D8  F90022     POP ACCA
0086DA  060000     RETURN
144:               
145:               //test
