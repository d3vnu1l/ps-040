Disassembly Listing for sampler_0.49.2
Generated From:
C:/Users/ryan/Documents/seniorproject/ps-040/dist/default/production/ps-040.production.elf
Jan 30, 2018 4:57:55 PM

---  C:/Users/ryan/Documents/seniorproject/ps-040/utilitites.c  -----------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <libpic30.h>
4:                 #include <dsp.h>
5:                 #include <stdio.h>
6:                 #include <stdlib.h>
7:                 #include <math.h>
8:                 #include "common.h"
9:                 #include "sounds.h"
10:                #include "audio.h"
11:                #include "flash.h"
12:                #include "screens.h"
13:                #include "utilities.h"
14:                #include "devInits.h"
15:                
16:                
17:                //CONTROL VARIABLES//
18:                extern unsigned char pad[BUTTONS];
19:                extern fractional pots[POTS];
20:                extern fractional pots_percent[POTS];
21:                extern fractional pots_custom[POTS];
22:                extern unsigned char UART_ON; 
23:                extern enum screen state;
24:                
25:                //STATUS VARIABLES//
26:                extern unsigned char hard_clipped;
27:                extern unsigned char UART_EN;
28:                extern unsigned char TEST_SIN;
29:                extern fractional sampin;
30:                extern fractional sampout;
31:                
32:                //FX FLAGS & VARS
33:                extern unsigned char tremelo, looper, lpf;
34:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
35:                extern unsigned int loop_lim;
36:                extern fractional lpf_alpha, lpf_inv_alpha;
37:                extern fractional tremelo_depth;
38:                extern unsigned char kick_playing, snare_playing;   
39:                
40:                void scanButtons(void){
41:                    
42:                    static unsigned char pad_last[BUTTONS]={1};
43:                    int portrdG, portrdD, portrdF;
44:                
45:                    portrdG = PORTG;
0083F2  807313     MOV PORTG, W3
46:                    portrdD = PORTD;
0083F4  807191     MOV PORTD, W1
47:                    portrdF = PORTF;
0083F6  807292     MOV PORTF, W2
48:                    
49:                    pad[34]=(portrdF>>7)&1;     // Special function button
0083F8  DE9247     ASR W2, #7, W4
0083FA  624261     AND.B W4, #0x1, W4
0083FC  268D65     MOV #0x68D6, W5
0083FE  784A84     MOV.B W4, [W5]
50:                    
51:                    if(pad[34]){
008400  320033     BRA Z, 0x8468
52:                        pad[6]=(portrdF>>6)&1;
008402  DE92C6     ASR W2, #6, W5
008404  268BA4     MOV #0x68BA, W4
008406  62CA61     AND.B W5, #0x1, [W4]
53:                        pad[5]=(portrdF>>5)&1;
008408  DE92C5     ASR W2, #5, W5
00840A  E90204     DEC W4, W4
00840C  62CA61     AND.B W5, #0x1, [W4]
54:                        pad[4]=(portrdF>>4)&1;
00840E  DE9144     ASR W2, #4, W2
008410  E90204     DEC W4, W4
008412  614A61     AND.B W2, #0x1, [W4]
55:                        pad[0]=(portrdG)&1;
008414  520164     SUB W4, #0x4, W2
008416  61C961     AND.B W3, #0x1, [W2]
56:                        pad[1]=(portrdG>>1)&1;
008418  D18203     ASR W3, W4
00841A  E80102     INC W2, W2
00841C  624961     AND.B W4, #0x1, [W2]
57:                        pad[2]=(portrdG>>2)&1;
00841E  DE9A42     ASR W3, #2, W4
008420  E80102     INC W2, W2
008422  624961     AND.B W4, #0x1, [W2]
58:                        pad[3]=(portrdG>>3)&1;
008424  DE9A43     ASR W3, #3, W4
008426  E80102     INC W2, W2
008428  624961     AND.B W4, #0x1, [W2]
59:                        pad[16]=(portrdG>>10)&1;    // Encoder button
00842A  DE9A4A     ASR W3, #10, W4
00842C  41016D     ADD W2, #0xD, W2
00842E  624961     AND.B W4, #0x1, [W2]
60:                        pad[11]=(portrdG>>11)&1;
008430  DE9A4B     ASR W3, #11, W4
008432  510165     SUB W2, #0x5, W2
008434  624961     AND.B W4, #0x1, [W2]
61:                        pad[12]=(portrdG>>12)&1;
008436  DE9A4C     ASR W3, #12, W4
008438  E80102     INC W2, W2
00843A  624961     AND.B W4, #0x1, [W2]
62:                        pad[13]=(portrdG>>13)&1;
00843C  DE9A4D     ASR W3, #13, W4
00843E  E80102     INC W2, W2
008440  624961     AND.B W4, #0x1, [W2]
63:                        pad[14]=(portrdG>>14)&1;
008442  DE984E     ASR W3, #14, W0
008444  E80102     INC W2, W2
008446  604961     AND.B W0, #0x1, [W2]
64:                        pad[15]=(portrdG>>15)&1;
008448  DE19CF     LSR W3, #15, W3
00844A  E80002     INC W2, W0
00844C  784803     MOV.B W3, [W0]
65:                        pad[7]=(portrdD>>1)&1;
00844E  D18101     ASR W1, W2
008450  500068     SUB W0, #0x8, W0
008452  614861     AND.B W2, #0x1, [W0]
66:                        pad[8]=(portrdD>>2)&1;
008454  DE8942     ASR W1, #2, W2
008456  E80000     INC W0, W0
008458  614861     AND.B W2, #0x1, [W0]
67:                        pad[9]=(portrdD>>3)&1;
00845A  DE8943     ASR W1, #3, W2
00845C  E80000     INC W0, W0
00845E  614861     AND.B W2, #0x1, [W0]
68:                        pad[10]=(portrdD>>4)&1;
008460  DE88C4     ASR W1, #4, W1
008462  E80000     INC W0, W0
008464  60C861     AND.B W1, #0x1, [W0]
008466  370032     BRA 0x84CC
69:                    } else {
70:                        pad[23]=(portrdF>>6)&1;
008468  DE92C6     ASR W2, #6, W5
00846A  268CB4     MOV #0x68CB, W4
00846C  62CA61     AND.B W5, #0x1, [W4]
71:                        pad[22]=(portrdF>>5)&1;
00846E  DE92C5     ASR W2, #5, W5
008470  E90204     DEC W4, W4
008472  62CA61     AND.B W5, #0x1, [W4]
72:                        pad[21]=(portrdF>>4)&1;
008474  DE9144     ASR W2, #4, W2
008476  E90204     DEC W4, W4
008478  614A61     AND.B W2, #0x1, [W4]
73:                        pad[17]=(portrdG)&1;
00847A  520164     SUB W4, #0x4, W2
00847C  61C961     AND.B W3, #0x1, [W2]
74:                        pad[18]=(portrdG>>1)&1;
00847E  D18203     ASR W3, W4
008480  E80102     INC W2, W2
008482  624961     AND.B W4, #0x1, [W2]
75:                        pad[19]=(portrdG>>2)&1;
008484  DE9A42     ASR W3, #2, W4
008486  E80102     INC W2, W2
008488  624961     AND.B W4, #0x1, [W2]
76:                        pad[20]=(portrdG>>3)&1;
00848A  DE9A43     ASR W3, #3, W4
00848C  E80102     INC W2, W2
00848E  624961     AND.B W4, #0x1, [W2]
77:                        pad[33]=(portrdG>>10)&1;    // Encoder button
008490  DE9A4A     ASR W3, #10, W4
008492  41016D     ADD W2, #0xD, W2
008494  624961     AND.B W4, #0x1, [W2]
78:                        pad[28]=(portrdG>>11)&1;
008496  DE9A4B     ASR W3, #11, W4
008498  510165     SUB W2, #0x5, W2
00849A  624961     AND.B W4, #0x1, [W2]
79:                        pad[29]=(portrdG>>12)&1;
00849C  DE9A4C     ASR W3, #12, W4
00849E  E80102     INC W2, W2
0084A0  624961     AND.B W4, #0x1, [W2]
80:                        pad[30]=(portrdG>>13)&1;
0084A2  DE9A4D     ASR W3, #13, W4
0084A4  E80102     INC W2, W2
0084A6  624961     AND.B W4, #0x1, [W2]
81:                        pad[31]=(portrdG>>14)&1;
0084A8  DE984E     ASR W3, #14, W0
0084AA  E80102     INC W2, W2
0084AC  604961     AND.B W0, #0x1, [W2]
82:                        pad[32]=(portrdG>>15)&1;
0084AE  DE19CF     LSR W3, #15, W3
0084B0  E80002     INC W2, W0
0084B2  784803     MOV.B W3, [W0]
83:                        pad[24]=(portrdD>>1)&1;
0084B4  D18101     ASR W1, W2
0084B6  500068     SUB W0, #0x8, W0
0084B8  614861     AND.B W2, #0x1, [W0]
84:                        pad[25]=(portrdD>>2)&1;
0084BA  DE8942     ASR W1, #2, W2
0084BC  E80000     INC W0, W0
0084BE  614861     AND.B W2, #0x1, [W0]
85:                        pad[26]=(portrdD>>3)&1;
0084C0  DE8943     ASR W1, #3, W2
0084C2  E80000     INC W0, W0
0084C4  614861     AND.B W2, #0x1, [W0]
86:                        pad[27]=(portrdD>>4)&1;
0084C6  DE88C4     ASR W1, #4, W1
0084C8  E80000     INC W0, W0
0084CA  60C861     AND.B W1, #0x1, [W0]
87:                    }
88:                
89:                   
90:                    
91:                    if(pad[13]==0&&pad_last[13]==1){                                              //TREMELO CONTROL
0084CC  268C10     MOV #0x68C1, W0
0084CE  784010     MOV.B [W0], W0
0084D0  E00400     CP0.B W0
0084D2  3A000C     BRA NZ, 0x84EC
0084D4  26D6F1     MOV #0x6D6F, W1
0084D6  B3C012     MOV.B #0x1, W2
0084D8  114F91     SUBR.B W2, [W1], [W15]
0084DA  3A0008     BRA NZ, 0x84EC
92:                        pad_last[13]=0;
0084DC  780001     MOV W1, W0
0084DE  EB4800     CLR.B [W0]
93:                        if(tremelo==FALSE)
0084E0  E2501B     CP0.B tremelo
0084E2  3A0002     BRA NZ, 0x84E8
94:                            tremelo=TRUE;
0084E4  EFF01B     SETM.B tremelo
0084E6  370004     BRA 0x84F0
95:                        else tremelo=FALSE;
0084E8  EF701B     CLR.B tremelo
0084EA  370002     BRA 0x84F0
96:                    }
97:                    else{
98:                        pad_last[13]=pad[13];
0084EC  26D6F1     MOV #0x6D6F, W1
0084EE  784880     MOV.B W0, [W1]
99:                    }
100:                   
101:                   if(pad[14]==0) looper=TRUE;
0084F0  268C20     MOV #0x68C2, W0
0084F2  E00410     CP0.B [W0]
0084F4  3A0002     BRA NZ, 0x84FA
0084F6  EFF01C     SETM.B looper
0084F8  370001     BRA 0x84FC
102:                   else looper=FALSE;
0084FA  EF701C     CLR.B looper
103:                  
104:                   if(pad[15]==0&&pad_last[15]==1){                                              //LPF CONTROL
0084FC  268C30     MOV #0x68C3, W0
0084FE  784010     MOV.B [W0], W0
008500  E00400     CP0.B W0
008502  3A000C     BRA NZ, 0x851C
008504  26D711     MOV #0x6D71, W1
008506  B3C012     MOV.B #0x1, W2
008508  114F91     SUBR.B W2, [W1], [W15]
00850A  3A0008     BRA NZ, 0x851C
105:                       pad_last[15]=0;
00850C  780001     MOV W1, W0
00850E  EB4800     CLR.B [W0]
106:                       if(lpf==FALSE)
008510  E2501D     CP0.B lpf
008512  3A0002     BRA NZ, 0x8518
107:                           lpf=TRUE;
008514  EFF01D     SETM.B lpf
008516  370004     BRA 0x8520
108:                       else lpf=FALSE;
008518  EF701D     CLR.B lpf
00851A  370002     BRA 0x8520
109:                   }
110:                   else{
111:                       pad_last[15]=pad[15];
00851C  26D711     MOV #0x6D71, W1
00851E  784880     MOV.B W0, [W1]
112:                   }
113:                   
114:                   
115:                   // SAMPLE TRIGGERS 
116:                   if(pad[0]==0&&kick_playing==FALSE){                                         //kick
008520  268B40     MOV #0x68B4, W0
008522  E00410     CP0.B [W0]
008524  3A0003     BRA NZ, 0x852C
008526  E2502E     CP0.B kick_playing
008528  3A0001     BRA NZ, 0x852C
117:                       kick_playing=TRUE;
00852A  EFF02E     SETM.B kick_playing
118:                   }
119:                   /*
120:                   if(pad[2]==0&&hat_playing==FALSE){                                          //hat
121:                       hat_playing=TRUE;
122:                   }
123:                   */
124:                   if(pad[1]==0&&snare_playing==FALSE){                                        //snare
00852C  268B50     MOV #0x68B5, W0
00852E  E00410     CP0.B [W0]
008530  3A0003     BRA NZ, 0x8538
008532  E25032     CP0.B snare_playing
008534  3A0001     BRA NZ, 0x8538
125:                       snare_playing=TRUE;
008536  EFF032     SETM.B snare_playing
126:                   }
127:               }
008538  060000     RETURN
128:               
129:               void readPots(void){
00853A  FA0018     LNK #0x18
00853C  BE9F88     MOV.D W8, [W15++]
00853E  781F8A     MOV W10, [W15++]
008540  F80022     PUSH ACCA
008542  F80024     PUSH ACCAH
008544  F80026     PUSH ACCAU
130:                   volatile register int result asm("A");
131:                   fractional pots_buf[POTS];
132:                   const fractional pot_alpha = 0x0F00;    //larger = rougher, lower = more latency
133:                   const fractional pot_alpha_inv = 32767-pot_alpha;
134:                   int i;
135:                   _AD1IF = 0; // Clear conversion done status bit
008546  A9A801     BCLR 0x801, #5
136:                   if(pad[34])i=0;
00854A  268D61     MOV #0x68D6, W1
00854C  E00411     CP0.B [W1]
00854E  320001     BRA Z, 0x8552
008550  EB0000     CLR W0
137:                   else i=POTS/2;
008548  200060     MOV #0x6, W0
138:                   pots_buf[i++]=(ADC1BUF5>>1)|0x7;
008552  400080     ADD W0, W0, W1
008554  801852     MOV ADC1BUF5, W2
008556  D10102     LSR W2, W2
008558  B30072     IOR #0x7, W2
00855A  780202     MOV W2, W4
00855C  2FFDC3     MOV #0xFFDC, W3
00855E  418181     ADD W3, W1, W3
008560  79B784     MOV W4, [W15+W3]
008562  E80000     INC W0, W0
139:                   pots_buf[i++]=(ADC1BUF2>>1)|0x7;
008564  400100     ADD W0, W0, W2
008566  801823     MOV ADC1BUF2, W3
008568  D10183     LSR W3, W3
00856A  B30073     IOR #0x7, W3
00856C  780303     MOV W3, W6
00856E  2FFDC5     MOV #0xFFDC, W5
008570  428282     ADD W5, W2, W5
008572  7AB786     MOV W6, [W15+W5]
008574  E80000     INC W0, W0
140:                   pots_buf[i++]=(ADC1BUF4>>1)|0x7;
008576  400180     ADD W0, W0, W3
008578  801844     MOV ADC1BUF4, W4
00857A  D10204     LSR W4, W4
00857C  B30074     IOR #0x7, W4
00857E  780404     MOV W4, W8
008580  2FFDC7     MOV #0xFFDC, W7
008582  438383     ADD W7, W3, W7
008584  7BB788     MOV W8, [W15+W7]
008586  E80000     INC W0, W0
141:                   pots_buf[i++]=(ADC1BUF1>>1)|0x7;
008588  400500     ADD W0, W0, W10
00858A  801814     MOV ADC1BUF1, W4
00858C  D10204     LSR W4, W4
00858E  B30074     IOR #0x7, W4
008590  780304     MOV W4, W6
008592  2FFDC5     MOV #0xFFDC, W5
008594  42828A     ADD W5, W10, W5
008596  7AB786     MOV W6, [W15+W5]
008598  E80000     INC W0, W0
142:                   pots_buf[i++]=(ADC1BUF3>>1)|0x7;
00859A  400380     ADD W0, W0, W7
00859C  801834     MOV ADC1BUF3, W4
00859E  D10204     LSR W4, W4
0085A0  B30074     IOR #0x7, W4
0085A2  780284     MOV W4, W5
0085A4  2FFDC8     MOV #0xFFDC, W8
0085A6  440407     ADD W8, W7, W8
0085A8  7C3785     MOV W5, [W15+W8]
0085AA  E80400     INC W0, W8
143:                   pots_buf[i]=(ADC1BUF0>>1)|0x7;
0085AC  D50300     LSR ADC1BUF0, WREG
0085AE  780200     MOV W0, W4
0085B0  B30074     IOR #0x7, W4
0085B2  440408     ADD W8, W8, W8
0085B4  2FFDC6     MOV #0xFFDC, W6
0085B6  430308     ADD W6, W8, W6
0085B8  7B3784     MOV W4, [W15+W6]
144:               
145:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085BA  20F005     MOV #0xF00, W5
0085BC  C00113     MPY W4*W5, A
146:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
0085BE  2606C0     MOV #0x606C, W0
0085C0  400408     ADD W0, W8, W8
0085C2  780498     MOV [W8], W9
0085C4  270FF4     MOV #0x70FF, W4
0085C6  780309     MOV W9, W6
0085C8  C10112     MAC W4*W6, A
147:                   pots[i--]=__builtin_sac(result, 0);
0085CA  CC0018     SAC A, [W8]
148:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085CC  2FFDC6     MOV #0xFFDC, W6
0085CE  430307     ADD W6, W7, W6
0085D0  7B036F     MOV [W15+W6], W6
0085D2  C40113     MPY W5*W6, A
149:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
0085D4  400387     ADD W0, W7, W7
0085D6  780317     MOV [W7], W6
0085D8  C10112     MAC W4*W6, A
150:                   pots[i--]=__builtin_sac(result, 0);
0085DA  CC0017     SAC A, [W7]
151:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085DC  2FFDC8     MOV #0xFFDC, W8
0085DE  44040A     ADD W8, W10, W8
0085E0  7C03EF     MOV [W15+W8], W7
0085E2  C50113     MPY W5*W7, A
152:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
0085E4  40030A     ADD W0, W10, W6
0085E6  780396     MOV [W6], W7
0085E8  C20112     MAC W4*W7, A
153:                   pots[i--]=__builtin_sac(result, 0);
0085EA  CC0016     SAC A, [W6]
154:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085EC  2FFDC7     MOV #0xFFDC, W7
0085EE  438383     ADD W7, W3, W7
0085F0  7B836F     MOV [W15+W7], W6
0085F2  C40113     MPY W5*W6, A
155:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
0085F4  400183     ADD W0, W3, W3
0085F6  780313     MOV [W3], W6
0085F8  C10112     MAC W4*W6, A
156:                   pots[i--]=__builtin_sac(result, 0);
0085FA  CC0013     SAC A, [W3]
157:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085FC  2FFDC8     MOV #0xFFDC, W8
0085FE  440402     ADD W8, W2, W8
008600  7C036F     MOV [W15+W8], W6
008602  C40113     MPY W5*W6, A
158:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008604  400102     ADD W0, W2, W2
008606  780312     MOV [W2], W6
008608  C10112     MAC W4*W6, A
159:                   pots[i--]=__builtin_sac(result, 0);
00860A  CC0012     SAC A, [W2]
160:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
00860C  2FFDC2     MOV #0xFFDC, W2
00860E  410101     ADD W2, W1, W2
008610  79036F     MOV [W15+W2], W6
008612  C40113     MPY W5*W6, A
161:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008614  400081     ADD W0, W1, W1
008616  780291     MOV [W1], W5
008618  C00112     MAC W4*W5, A
162:                   pots[i]=__builtin_sac(result, 0);
00861A  CC0011     SAC A, [W1]
163:                   
164:                   loop_lim=pots[5];               //LOOPER CONTROL
00861C  8303B3     MOV 0x6076, W3
00861E  888013     MOV W3, loop_lim
165:                   if(pots[0]>=310){                      //LPF CONTROL
008620  780010     MOV [W0], W0
008622  201351     MOV #0x135, W1
008624  500F81     SUB W0, W1, [W15]
008626  340004     BRA LE, 0x8630
166:                       lpf_alpha=pots[0];
008628  888200     MOV W0, 0x1040
167:                       lpf_inv_alpha=(32767-lpf_alpha); 
00862A  27FFF1     MOV #0x7FFF, W1
00862C  508000     SUB W1, W0, W0
00862E  888210     MOV W0, 0x1042
168:                   }
169:                   tremelo_depth=pots[1];
008630  830374     MOV 0x606E, W4
008632  888224     MOV W4, 0x1044
170:               
171:                   
172:               }
008634  F90026     POP ACCAU
008636  F90024     POP ACCAH
008638  F90022     POP ACCA
00863A  78054F     MOV [--W15], W10
00863C  BE044F     MOV.D [--W15], W8
00863E  FA8000     ULNK
008640  060000     RETURN
173:               
174:               void scalePotsPercent(void){
008642  F80022     PUSH ACCA
008644  F80024     PUSH ACCAH
008646  F80026     PUSH ACCAU
175:                   /* Potentiometer scaling for fx or lcd display */
176:                   volatile register int scaled asm("A");
177:                   
178:                   
179:                   scaled=__builtin_mpy(pots[0],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008648  232644     MOV #0x3264, W4
00864A  830365     MOV pots, W5
00864C  C00113     MPY W4*W5, A
180:                   pots_percent[0]=__builtin_sac(scaled, 7);
00864E  260840     MOV #0x6084, W0
008650  CC0390     SAC A, #7, [W0]
181:                   scaled=__builtin_mpy(pots[1],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008652  830375     MOV 0x606E, W5
008654  C00113     MPY W4*W5, A
182:                   pots_percent[1]=__builtin_sac(scaled, 7);
008656  E88000     INC2 W0, W0
008658  CC0390     SAC A, #7, [W0]
183:                   scaled=__builtin_mpy(pots[2],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
00865A  830385     MOV 0x6070, W5
00865C  C00113     MPY W4*W5, A
184:                   pots_percent[2]=__builtin_sac(scaled, 7);
00865E  E88000     INC2 W0, W0
008660  CC0390     SAC A, #7, [W0]
185:                   scaled=__builtin_mpy(pots[3],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008662  830395     MOV 0x6072, W5
008664  C00113     MPY W4*W5, A
186:                   pots_percent[3]=__builtin_sac(scaled, 7);
008666  E88000     INC2 W0, W0
008668  CC0390     SAC A, #7, [W0]
187:                   scaled=__builtin_mpy(pots[4],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
00866A  8303A5     MOV 0x6074, W5
00866C  C00113     MPY W4*W5, A
188:                   pots_percent[4]=__builtin_sac(scaled, 7);
00866E  E88000     INC2 W0, W0
008670  CC0390     SAC A, #7, [W0]
189:                   scaled=__builtin_mpy(pots[5],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008672  8303B5     MOV 0x6076, W5
008674  C00113     MPY W4*W5, A
190:                   pots_percent[5]=__builtin_sac(scaled, 7);
008676  E88000     INC2 W0, W0
008678  CC0390     SAC A, #7, [W0]
191:               }
00867A  F90026     POP ACCAU
00867C  F90024     POP ACCAH
00867E  F90022     POP ACCA
008680  060000     RETURN
192:               
193:               void scalePotsCustom(unsigned int steps){
008682  F80022     PUSH ACCA
008684  F80024     PUSH ACCAH
008686  F80026     PUSH ACCAU
194:                   volatile register int scaled asm("A");
195:               
196:                   fractional scale = Q15(steps*0.000030518509476);
197:                   scaled=__builtin_mpy(pots[4],FXSCALE, NULL, NULL, 0, NULL, NULL, 0);
008688  EB0080     CLR W1
00868A  07BF8B     RCALL ___floatunsisf
00868C  201002     MOV #0x100, W2
00868E  238003     MOV #0x3800, W3
008690  07BFDD     RCALL ___mulsf3
008692  2FE002     MOV #0xFE00, W2
008694  246FF3     MOV #0x46FF, W3
008696  07BFDA     RCALL ___mulsf3
008698  200002     MOV #0x0, W2
00869A  23F003     MOV #0x3F00, W3
00869C  07BF04     RCALL ___addsf3
00869E  07BF60     RCALL ___fixsfsi
0086A0  8303A4     MOV 0x6074, W4
0086A2  780280     MOV W0, W5
0086A4  C00113     MPY W4*W5, A
198:                   pots_percent[4]=__builtin_sac(scaled, 0);
0086A6  2608C0     MOV #0x608C, W0
0086A8  CC0010     SAC A, [W0]
199:               }
0086AA  F90026     POP ACCAU
0086AC  F90024     POP ACCAH
0086AE  F90022     POP ACCA
0086B0  060000     RETURN
200:               
201:               void display(void){
202:                   scalePotsPercent();
0086B2  07FFC7     RCALL scalePotsPercent
203:                   scalePotsCustom(12);
0086B4  2000C0     MOV #0xC, W0
0086B6  07FFE5     RCALL scalePotsCustom
204:                   // Update ui state logic here
205:                   state = (ENCODERCNTL/4)+1;
0086B8  800E30     MOV POS1CNTL, W0
0086BA  DE0042     LSR W0, #2, W0
0086BC  E80000     INC W0, W0
0086BE  8881F0     MOV W0, 0x103E
206:                   
207:                   // Update screen here
208:                   screenUpdate();
0086C0  07016F     RCALL screenUpdate
209:                  
210:                  if(UART_ON==TRUE){
0086C2  BFD019     MOV.B UART_ON, WREG
0086C4  404FE1     ADD.B W0, #0x1, [W15]
0086C6  3A0007     BRA NZ, 0x86D6
211:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
212:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
213:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
214:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
0086C8  F86070     PUSH 0x6070
0086CA  F8606E     PUSH 0x606E
0086CC  F8606C     PUSH pots
0086CE  2F9BA0     MOV #0xF9BA, W0
0086D0  781F80     MOV W0, [W15++]
0086D2  07C02D     RCALL __printf_cdnopuxX
0086D4  5787E8     SUB W15, #0x8, W15
215:                       //printf("%d\r\n", sample);  //check input ADC
216:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
217:                   }
218:                  
219:                  SLED=~SLED;
0086D6  8072A0     MOV LATF, W0
0086D8  EA8000     COM W0, W0
0086DA  600061     AND W0, #0x1, W0
0086DC  8072A1     MOV LATF, W1
0086DE  A10001     BCLR W1, #0
0086E0  700081     IOR W0, W1, W1
0086E2  8872A1     MOV W1, LATF
220:               }
0086E4  060000     RETURN
221:               
222:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
223:                   /* This procedure loops back the received data to the*/
224:                   /* the codec output. The user application could process*/
225:                   /* this data as per application requirements.*/
226:                   int index;
227:                   for(index = 0;index < STREAMBUF;index ++)
0086E6  EB0100     CLR W2
0086E8  201003     MOV #0x100, W3
0086EC  E80102     INC W2, W2
0086EE  510F83     SUB W2, W3, [W15]
0086F0  3AFFFC     BRA NZ, 0x86EA
228:                   {
229:                       targetBuffer[index] = sourceBuffer[index];
0086EA  7818B0     MOV [W0++], [W1++]
230:                   }
231:               }
0086F2  060000     RETURN
232:               
233:               //A blocking delay function. Not very accurate but good enough.
234:               void Delay_us(unsigned int delay)
235:               {
236:                   int i;
237:                   for (i = 0; i < delay; i++)
0086F4  E00000     CP0 W0
0086F6  320006     BRA Z, 0x8704
0086F8  EB0080     CLR W1
0086FE  E80081     INC W1, W1
008700  500F81     SUB W0, W1, [W15]
008702  3EFFFB     BRA GTU, 0x86FA
238:                   {
239:                       __asm__ volatile ("repeat #50");
0086FA  090032     REPEAT #0x32
240:                       __asm__ volatile ("nop");
0086FC  000000     NOP
241:                   }
242:               }
008704  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/screens.c  --------------------------------------------
1:                 /*
2:                  * File:   screens.c
3:                  * Author: ryan
4:                  *
5:                  * Created on January 28, 2018, 11:17 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "common.h"
11:                #include "plcd.h"
12:                #include "dsp.h"
13:                #include "flash.h"
14:                
15:                extern unsigned char TEST_SIN;
16:                extern fractional pots[POTS];
17:                extern fractional pots_percent[POTS];
18:                extern unsigned char pad[BUTTONS];
19:                extern enum screen state, laststate;
20:                extern char flash_readback[512];
21:                extern unsigned int process_time;
22:                
23:                
24:                void screenDebugAudio(){
25:                
26:                }
008706  060000     RETURN
27:                
28:                void screenDebugBuffers(){
29:                    if(state!=laststate){
008708  8080F0     MOV laststate, W0
00870A  E3103E     CP 0x103E
00870C  32001B     BRA Z, 0x8744
30:                        //setup here
31:                        lcdClearQ();
00870E  07F977     RCALL lcdClearQ
32:                        lcdSetCursorQ(0,0);
008710  EB4080     CLR.B W1
008712  784001     MOV.B W1, W0
008714  07F97F     RCALL lcdSetCursorQ
33:                        lcdWriteStringQ("Buffer Debug");
008716  2F9400     MOV #0xF940, W0
008718  07F991     RCALL lcdWriteStringQ
34:                        lcdSetCursorQ(0,1);
00871A  B3C011     MOV.B #0x1, W1
00871C  EB4000     CLR.B W0
00871E  07F97A     RCALL lcdSetCursorQ
35:                        lcdWriteStringQ("FX time:");
008720  2F94D0     MOV #0xF94D, W0
008722  07F98C     RCALL lcdWriteStringQ
36:                        lcdSetCursorQ(11,1);
008724  B3C011     MOV.B #0x1, W1
008726  B3C0B0     MOV.B #0xB, W0
008728  07F975     RCALL lcdSetCursorQ
37:                        lcdWriteStringQ("/256");
00872A  2F9560     MOV #0xF956, W0
00872C  07F987     RCALL lcdWriteStringQ
38:                        lcdSetCursorQ(0,2);
00872E  B3C021     MOV.B #0x2, W1
008730  EB4000     CLR.B W0
008732  07F970     RCALL lcdSetCursorQ
39:                        lcdWriteStringQ("LCD:");
008734  2F95B0     MOV #0xF95B, W0
008736  07F982     RCALL lcdWriteStringQ
40:                        lcdSetCursorQ(0,3);
008738  B3C031     MOV.B #0x3, W1
00873A  EB4000     CLR.B W0
00873C  07F96B     RCALL lcdSetCursorQ
41:                        lcdWriteStringQ("Flash:");
00873E  2F9600     MOV #0xF960, W0
008740  07F97D     RCALL lcdWriteStringQ
008742  370006     BRA 0x8750
42:                    } else {
43:                        //update here
44:                        lcdSetCursorQ(8,1);
008744  B3C011     MOV.B #0x1, W1
008746  B3C080     MOV.B #0x8, W0
008748  07F965     RCALL lcdSetCursorQ
45:                        lcdWriteDecimalQ(process_time,3);
00874A  200031     MOV #0x3, W1
00874C  BFD016     MOV.B process_time, WREG
00874E  07FA5C     RCALL lcdWriteDecimalQ
46:                        //lcdSetCursorQ(4,2);
47:                        //lcdWriteDecimalQ();
48:                        //lcdSetCursorQ(6,3);
49:                        //lcdWriteDecimalQ();
50:                        
51:                    }
52:                }
008750  060000     RETURN
53:                
54:                void screenDebugPots(void){
008752  BE9F88     MOV.D W8, [W15++]
008754  BE9F8A     MOV.D W10, [W15++]
55:                    int bank=0;
008790  EB0480     CLR W9
56:                    
57:                    if(state!=laststate){
008756  8080F0     MOV laststate, W0
008758  E3103E     CP 0x103E
00875A  320016     BRA Z, 0x8788
58:                        // Setup here
59:                        lcdClearQ();
00875C  07F950     RCALL lcdClearQ
60:                        lcdSetCursorQ(0,0);
00875E  EB4080     CLR.B W1
008760  784001     MOV.B W1, W0
008762  07F958     RCALL lcdSetCursorQ
61:                        lcdWriteStringQ("Potentiometer Debug");
008764  2F9670     MOV #0xF967, W0
008766  07F96A     RCALL lcdWriteStringQ
62:                        lcdSetCursorQ(9,1);
008768  B3C011     MOV.B #0x1, W1
00876A  B3C090     MOV.B #0x9, W0
00876C  07F953     RCALL lcdSetCursorQ
63:                        lcdWriteStringQ("|");
00876E  2F97B0     MOV #0xF97B, W0
008770  07F965     RCALL lcdWriteStringQ
64:                         lcdSetCursorQ(9,2);
008772  B3C021     MOV.B #0x2, W1
008774  B3C090     MOV.B #0x9, W0
008776  07F94E     RCALL lcdSetCursorQ
65:                        lcdWriteStringQ("|");
008778  2F97B0     MOV #0xF97B, W0
00877A  07F960     RCALL lcdWriteStringQ
66:                         lcdSetCursorQ(9,3);
00877C  B3C031     MOV.B #0x3, W1
00877E  B3C090     MOV.B #0x9, W0
008780  07F949     RCALL lcdSetCursorQ
67:                        lcdWriteStringQ("|");
008782  2F97B0     MOV #0xF97B, W0
008784  07F95B     RCALL lcdWriteStringQ
008786  37005A     BRA 0x883C
68:                    } else {
69:                        // Update here
70:                        if(!pad[34])bank=POTS/2;
008788  200069     MOV #0x6, W9
00878A  268D60     MOV #0x68D6, W0
00878C  E00410     CP0.B [W0]
00878E  320001     BRA Z, 0x8792
71:                        lcdSetCursorQ(0,1);
008792  B3C011     MOV.B #0x1, W1
008794  EB4000     CLR.B W0
008796  07F93E     RCALL lcdSetCursorQ
72:                        lcdWriteDecimalQ(pots_percent[bank], 3);
008798  448589     ADD W9, W9, W11
00879A  260848     MOV #0x6084, W8
00879C  44000B     ADD W8, W11, W0
00879E  780010     MOV [W0], W0
0087A0  200031     MOV #0x3, W1
0087A2  07FA32     RCALL lcdWriteDecimalQ
73:                        lcdWriteQ(',');
0087A4  B3C2C0     MOV.B #0x2C, W0
0087A6  07F916     RCALL lcdWriteQ
74:                        lcdWriteWordUnsignedQ(pots[bank++]);
0087A8  E80509     INC W9, W10
0087AA  2606C9     MOV #0x606C, W9
0087AC  44858B     ADD W9, W11, W11
0087AE  78001B     MOV [W11], W0
0087B0  07F9D3     RCALL lcdWriteWordUnsignedQ
75:                        lcdSetCursorQ(11,1);
0087B2  B3C011     MOV.B #0x1, W1
0087B4  B3C0B0     MOV.B #0xB, W0
0087B6  07F92E     RCALL lcdSetCursorQ
76:                        lcdWriteDecimalQ(pots_percent[bank], 3);
0087B8  45058A     ADD W10, W10, W11
0087BA  44000B     ADD W8, W11, W0
0087BC  780010     MOV [W0], W0
0087BE  200031     MOV #0x3, W1
0087C0  07FA23     RCALL lcdWriteDecimalQ
77:                        lcdWriteQ(',');
0087C2  B3C2C0     MOV.B #0x2C, W0
0087C4  07F907     RCALL lcdWriteQ
78:                        lcdWriteWordUnsignedQ(pots[bank++]);
0087C6  E8050A     INC W10, W10
0087C8  44858B     ADD W9, W11, W11
0087CA  78001B     MOV [W11], W0
0087CC  07F9C5     RCALL lcdWriteWordUnsignedQ
79:                        lcdSetCursorQ(0,2);
0087CE  B3C021     MOV.B #0x2, W1
0087D0  EB4000     CLR.B W0
0087D2  07F920     RCALL lcdSetCursorQ
80:                        lcdWriteDecimalQ(pots_percent[bank], 3);
0087D4  45058A     ADD W10, W10, W11
0087D6  44000B     ADD W8, W11, W0
0087D8  780010     MOV [W0], W0
0087DA  200031     MOV #0x3, W1
0087DC  07FA15     RCALL lcdWriteDecimalQ
81:                        lcdWriteQ(',');
0087DE  B3C2C0     MOV.B #0x2C, W0
0087E0  07F8F9     RCALL lcdWriteQ
82:                        lcdWriteWordUnsignedQ(pots[bank++]);
0087E2  E8050A     INC W10, W10
0087E4  44858B     ADD W9, W11, W11
0087E6  78001B     MOV [W11], W0
0087E8  07F9B7     RCALL lcdWriteWordUnsignedQ
83:                        lcdSetCursorQ(11,2);
0087EA  B3C021     MOV.B #0x2, W1
0087EC  B3C0B0     MOV.B #0xB, W0
0087EE  07F912     RCALL lcdSetCursorQ
84:                        lcdWriteDecimalQ(pots_percent[bank], 3);
0087F0  45058A     ADD W10, W10, W11
0087F2  44000B     ADD W8, W11, W0
0087F4  780010     MOV [W0], W0
0087F6  200031     MOV #0x3, W1
0087F8  07FA07     RCALL lcdWriteDecimalQ
85:                        lcdWriteQ(',');
0087FA  B3C2C0     MOV.B #0x2C, W0
0087FC  07F8EB     RCALL lcdWriteQ
86:                        lcdWriteWordUnsignedQ(pots[bank++]);
0087FE  E8050A     INC W10, W10
008800  44858B     ADD W9, W11, W11
008802  78001B     MOV [W11], W0
008804  07F9A9     RCALL lcdWriteWordUnsignedQ
87:                        lcdSetCursorQ(0,3);
008806  B3C031     MOV.B #0x3, W1
008808  EB4000     CLR.B W0
00880A  07F904     RCALL lcdSetCursorQ
88:                        lcdWriteDecimalQ(pots_percent[bank], 3);
00880C  45058A     ADD W10, W10, W11
00880E  44000B     ADD W8, W11, W0
008810  780010     MOV [W0], W0
008812  200031     MOV #0x3, W1
008814  07F9F9     RCALL lcdWriteDecimalQ
89:                        lcdWriteQ(',');
008816  B3C2C0     MOV.B #0x2C, W0
008818  07F8DD     RCALL lcdWriteQ
90:                        lcdWriteWordUnsignedQ(pots[bank++]);
00881A  E8050A     INC W10, W10
00881C  44858B     ADD W9, W11, W11
00881E  78001B     MOV [W11], W0
008820  07F99B     RCALL lcdWriteWordUnsignedQ
91:                        lcdSetCursorQ(11,3);
008822  B3C031     MOV.B #0x3, W1
008824  B3C0B0     MOV.B #0xB, W0
008826  07F8F6     RCALL lcdSetCursorQ
92:                        lcdWriteDecimalQ(pots_percent[bank], 3);
008828  45050A     ADD W10, W10, W10
00882A  44040A     ADD W8, W10, W8
00882C  780018     MOV [W8], W0
00882E  200031     MOV #0x3, W1
008830  07F9EB     RCALL lcdWriteDecimalQ
93:                        lcdWriteQ(',');
008832  B3C2C0     MOV.B #0x2C, W0
008834  07F8CF     RCALL lcdWriteQ
94:                        lcdWriteWordUnsignedQ(pots[bank++]);
008836  44850A     ADD W9, W10, W10
008838  78001A     MOV [W10], W0
00883A  07F98E     RCALL lcdWriteWordUnsignedQ
95:                    }
96:                }
00883C  BE054F     MOV.D [--W15], W10
00883E  BE044F     MOV.D [--W15], W8
008840  060000     RETURN
97:                
98:                void screenFX(void){
99:                    if(state!=laststate){
008842  8080F0     MOV laststate, W0
008844  E3103E     CP 0x103E
008846  32002A     BRA Z, 0x889C
100:                       //setup here
101:                       lcdClearQ();
008848  07F8DA     RCALL lcdClearQ
102:                       lcdSetCursorQ(0,0);
00884A  EB4080     CLR.B W1
00884C  784001     MOV.B W1, W0
00884E  07F8E2     RCALL lcdSetCursorQ
103:                       lcdWriteStringQ("FX1:");
008850  2F97D0     MOV #0xF97D, W0
008852  07F8F4     RCALL lcdWriteStringQ
104:                       lcdSetCursorQ(10,0);
008854  EB4080     CLR.B W1
008856  B3C0A0     MOV.B #0xA, W0
008858  07F8DD     RCALL lcdSetCursorQ
105:                       lcdWriteStringQ("FX2:");
00885A  2F9820     MOV #0xF982, W0
00885C  07F8EF     RCALL lcdWriteStringQ
106:                       
107:                       lcdSetCursorQ(0,1);
00885E  B3C011     MOV.B #0x1, W1
008860  EB4000     CLR.B W0
008862  07F8D8     RCALL lcdSetCursorQ
108:                       lcdWriteStringQ("1:");
008864  2F9870     MOV #0xF987, W0
008866  07F8EA     RCALL lcdWriteStringQ
109:                       lcdSetCursorQ(10,1);
008868  B3C011     MOV.B #0x1, W1
00886A  B3C0A0     MOV.B #0xA, W0
00886C  07F8D3     RCALL lcdSetCursorQ
110:                       lcdWriteStringQ("4:");
00886E  2F98A0     MOV #0xF98A, W0
008870  07F8E5     RCALL lcdWriteStringQ
111:                       lcdSetCursorQ(0,2);
008872  B3C021     MOV.B #0x2, W1
008874  EB4000     CLR.B W0
008876  07F8CE     RCALL lcdSetCursorQ
112:                       lcdWriteStringQ("2:");
008878  2F98D0     MOV #0xF98D, W0
00887A  07F8E0     RCALL lcdWriteStringQ
113:                       lcdSetCursorQ(10,2);
00887C  B3C021     MOV.B #0x2, W1
00887E  B3C0A0     MOV.B #0xA, W0
008880  07F8C9     RCALL lcdSetCursorQ
114:                       lcdWriteStringQ("5:");
008882  2F9900     MOV #0xF990, W0
008884  07F8DB     RCALL lcdWriteStringQ
115:                       lcdSetCursorQ(0,3);
008886  B3C031     MOV.B #0x3, W1
008888  EB4000     CLR.B W0
00888A  07F8C4     RCALL lcdSetCursorQ
116:                       lcdWriteStringQ("3:");
00888C  2F9930     MOV #0xF993, W0
00888E  07F8D6     RCALL lcdWriteStringQ
117:                       lcdSetCursorQ(10,3);
008890  B3C031     MOV.B #0x3, W1
008892  B3C0A0     MOV.B #0xA, W0
008894  07F8BF     RCALL lcdSetCursorQ
118:                       lcdWriteStringQ("6:");
008896  2F9960     MOV #0xF996, W0
008898  07F8D1     RCALL lcdWriteStringQ
00889A  370024     BRA 0x88E4
119:                   } else {
120:                       //update here
121:                       lcdSetCursorQ(2,1);
00889C  B3C011     MOV.B #0x1, W1
00889E  B3C020     MOV.B #0x2, W0
0088A0  07F8B9     RCALL lcdSetCursorQ
122:                       lcdWriteDecimalQ(pots_percent[0], 3);
0088A2  200031     MOV #0x3, W1
0088A4  830420     MOV pots_percent, W0
0088A6  07F9B0     RCALL lcdWriteDecimalQ
123:                       lcdSetCursorQ(12,1);
0088A8  B3C011     MOV.B #0x1, W1
0088AA  B3C0C0     MOV.B #0xC, W0
0088AC  07F8B3     RCALL lcdSetCursorQ
124:                       lcdWriteDecimalQ(pots_percent[1], 3);
0088AE  200031     MOV #0x3, W1
0088B0  830430     MOV 0x6086, W0
0088B2  07F9AA     RCALL lcdWriteDecimalQ
125:                       lcdSetCursorQ(2,2);
0088B4  B3C021     MOV.B #0x2, W1
0088B6  784001     MOV.B W1, W0
0088B8  07F8AD     RCALL lcdSetCursorQ
126:                       lcdWriteDecimalQ(pots_percent[2], 3);
0088BA  200031     MOV #0x3, W1
0088BC  830440     MOV 0x6088, W0
0088BE  07F9A4     RCALL lcdWriteDecimalQ
127:                       lcdSetCursorQ(12,2);
0088C0  B3C021     MOV.B #0x2, W1
0088C2  B3C0C0     MOV.B #0xC, W0
0088C4  07F8A7     RCALL lcdSetCursorQ
128:                       lcdWriteDecimalQ(pots_percent[3], 3);
0088C6  200031     MOV #0x3, W1
0088C8  830450     MOV 0x608A, W0
0088CA  07F99E     RCALL lcdWriteDecimalQ
129:                       lcdSetCursorQ(2,3);
0088CC  B3C031     MOV.B #0x3, W1
0088CE  B3C020     MOV.B #0x2, W0
0088D0  07F8A1     RCALL lcdSetCursorQ
130:                       lcdWriteDecimalQ(pots_percent[4], 3);
0088D2  200031     MOV #0x3, W1
0088D4  830460     MOV 0x608C, W0
0088D6  07F998     RCALL lcdWriteDecimalQ
131:                       lcdSetCursorQ(12,3);
0088D8  B3C031     MOV.B #0x3, W1
0088DA  B3C0C0     MOV.B #0xC, W0
0088DC  07F89B     RCALL lcdSetCursorQ
132:                       lcdWriteDecimalQ(pots_percent[5], 3);
0088DE  200031     MOV #0x3, W1
0088E0  830470     MOV 0x608E, W0
0088E2  07F992     RCALL lcdWriteDecimalQ
133:               
134:                   }
135:               }
0088E4  060000     RETURN
136:               
137:               void screenDebugFlash(void){
0088E6  781F88     MOV W8, [W15++]
138:                       if(state!=laststate){
0088E8  8080F0     MOV laststate, W0
0088EA  E3103E     CP 0x103E
0088EC  32003D     BRA Z, 0x8968
139:                       //setup here
140:                       lcdClearQ();
0088EE  07F887     RCALL lcdClearQ
141:                       lcdSetCursorQ(0,0);
0088F0  EB4080     CLR.B W1
0088F2  784001     MOV.B W1, W0
0088F4  07F88F     RCALL lcdSetCursorQ
142:                       lcdWriteWordQ(flash_readback[2]);
0088F6  25E6E0     MOV #0x5E6E, W0
0088F8  FB0010     SE [W0], W0
0088FA  07F8BE     RCALL lcdWriteWordQ
143:                        lcdSetCursorQ(6,0);
0088FC  EB4080     CLR.B W1
0088FE  B3C060     MOV.B #0x6, W0
008900  07F889     RCALL lcdSetCursorQ
144:                       lcdWriteWordQ(flash_readback[3]);
008902  25E6F0     MOV #0x5E6F, W0
008904  FB0010     SE [W0], W0
008906  07F8B8     RCALL lcdWriteWordQ
145:                        lcdSetCursorQ(12,0);
008908  EB4080     CLR.B W1
00890A  B3C0C0     MOV.B #0xC, W0
00890C  07F883     RCALL lcdSetCursorQ
146:                       lcdWriteWordQ(flash_readback[4]);
00890E  25E700     MOV #0x5E70, W0
008910  FB0010     SE [W0], W0
008912  07F8B2     RCALL lcdWriteWordQ
147:                        lcdSetCursorQ(0,1);
008914  B3C011     MOV.B #0x1, W1
008916  EB4000     CLR.B W0
008918  07F87D     RCALL lcdSetCursorQ
148:                       lcdWriteWordQ(flash_readback[5]);
00891A  25E710     MOV #0x5E71, W0
00891C  FB0010     SE [W0], W0
00891E  07F8AC     RCALL lcdWriteWordQ
149:                       lcdSetCursorQ(6,1);
008920  B3C011     MOV.B #0x1, W1
008922  B3C060     MOV.B #0x6, W0
008924  07F877     RCALL lcdSetCursorQ
150:                       lcdWriteWordQ(flash_readback[6]);
008926  25E720     MOV #0x5E72, W0
008928  FB0010     SE [W0], W0
00892A  07F8A6     RCALL lcdWriteWordQ
151:                        lcdSetCursorQ(12,1);
00892C  B3C011     MOV.B #0x1, W1
00892E  B3C0C0     MOV.B #0xC, W0
008930  07F871     RCALL lcdSetCursorQ
152:                       lcdWriteWordQ(flash_readback[7]);
008932  25E730     MOV #0x5E73, W0
008934  FB0010     SE [W0], W0
008936  07F8A0     RCALL lcdWriteWordQ
153:                       lcdSetCursorQ(0,2);
008938  B3C021     MOV.B #0x2, W1
00893A  EB4000     CLR.B W0
00893C  07F86B     RCALL lcdSetCursorQ
154:                       lcdWriteWordQ(flash_readback[8]);
00893E  25E748     MOV #0x5E74, W8
008940  FB0018     SE [W8], W0
008942  07F89A     RCALL lcdWriteWordQ
155:                       lcdSetCursorQ(6,2);
008944  B3C021     MOV.B #0x2, W1
008946  B3C060     MOV.B #0x6, W0
008948  07F865     RCALL lcdSetCursorQ
156:                       lcdWriteWordQ(flash_readback[9]);
00894A  E80008     INC W8, W0
00894C  FB0010     SE [W0], W0
00894E  07F894     RCALL lcdWriteWordQ
157:                        lcdSetCursorQ(12,2);
008950  B3C021     MOV.B #0x2, W1
008952  B3C0C0     MOV.B #0xC, W0
008954  07F85F     RCALL lcdSetCursorQ
158:                       lcdWriteWordQ(flash_readback[10]);
008956  E88008     INC2 W8, W0
008958  FB0010     SE [W0], W0
00895A  07F88E     RCALL lcdWriteWordQ
159:                       lcdSetCursorQ(0,3);
00895C  B3C031     MOV.B #0x3, W1
00895E  EB4000     CLR.B W0
008960  07F859     RCALL lcdSetCursorQ
160:                       lcdWriteWordQ(flash_readback[8]);
008962  FB0018     SE [W8], W0
008964  07F889     RCALL lcdWriteWordQ
008966  370008     BRA 0x8978
161:                   } else {
162:                       //update here
163:                       lcdSetCursorQ(9,3);
008968  B3C031     MOV.B #0x3, W1
00896A  B3C090     MOV.B #0x9, W0
00896C  07F853     RCALL lcdSetCursorQ
164:                       lcdWriteStringQ("Stat:");
00896E  2F9990     MOV #0xF999, W0
008970  07F865     RCALL lcdWriteStringQ
165:                       lcdWriteWordQ(flashStatusCheck());
008972  0701F1     RCALL flashStatusCheck
008974  FB0000     SE W0, W0
008976  07F880     RCALL lcdWriteWordQ
166:                   }
167:               }
008978  78044F     MOV [--W15], W8
00897A  060000     RETURN
168:               
169:               void screenDebugInput(void){
170:                   if(state!=laststate){
00897C  8080F0     MOV laststate, W0
00897E  E3103E     CP 0x103E
008980  32000C     BRA Z, 0x899A
171:                       //setup here
172:                       lcdClearQ();
008982  07F83D     RCALL lcdClearQ
173:                       lcdSetCursorQ(0,0);
008984  EB4080     CLR.B W1
008986  784001     MOV.B W1, W0
008988  07F845     RCALL lcdSetCursorQ
174:                       lcdWriteStringQ("Input Debug");
00898A  2F99F0     MOV #0xF99F, W0
00898C  07F857     RCALL lcdWriteStringQ
175:                       lcdSetCursorQ(0,1);
00898E  B3C011     MOV.B #0x1, W1
008990  EB4000     CLR.B W0
008992  07F840     RCALL lcdSetCursorQ
176:                       lcdWriteStringQ("ADC variance: ");
008994  2F9AB0     MOV #0xF9AB, W0
008996  07F852     RCALL lcdWriteStringQ
008998  370002     BRA 0x899E
177:                   } else {
178:                       //update here
179:                       lcdDrawPads(16);
00899A  B3C100     MOV.B #0x10, W0
00899C  07F967     RCALL lcdDrawPads
180:                   }
181:               }
00899E  060000     RETURN
182:               
183:               void screenUpdate(void){
184:                   switch(state){
0089A0  8081F0     MOV 0x103E, W0
0089A2  500FE3     SUB W0, #0x3, [W15]
0089A4  32000F     BRA Z, 0x89C4
0089A6  3E0005     BRA GTU, 0x89B2
0089A8  500FE1     SUB W0, #0x1, [W15]
0089AA  320008     BRA Z, 0x89BC
0089AC  500FE2     SUB W0, #0x2, [W15]
0089AE  3A000F     BRA NZ, 0x89CE
0089B0  370007     BRA 0x89C0
0089B2  500FE4     SUB W0, #0x4, [W15]
0089B4  320009     BRA Z, 0x89C8
0089B6  500FE5     SUB W0, #0x5, [W15]
0089B8  3A000A     BRA NZ, 0x89CE
0089BA  370008     BRA 0x89CC
185:                       case start: break;
186:                       case scrnFX:            screenFX(); 
0089BC  07FF42     RCALL screenFX
187:                       break;
0089BE  370007     BRA 0x89CE
188:                       case debugscrnPOTS:     screenDebugPots();
0089C0  07FEC8     RCALL screenDebugPots
189:                       break;
0089C2  370005     BRA 0x89CE
190:                       case debugscrnFLASH:    screenDebugFlash();
0089C4  07FF90     RCALL screenDebugFlash
191:                       break;
0089C6  370003     BRA 0x89CE
192:                       case debugscrnBUFFERS:  screenDebugBuffers();
0089C8  07FE9F     RCALL screenDebugBuffers
193:                       break;
0089CA  370001     BRA 0x89CE
194:                       case debugscrnINPUT:    screenDebugInput();
0089CC  07FFD7     RCALL screenDebugInput
195:                       break;
196:                                       
197:                       default: break;
198:                   }
199:                   
200:                   laststate=state;
0089CE  F8103E     PUSH 0x103E
0089D0  F9101E     POP laststate
201:               }
0089D2  060000     RETURN
202:               
203:                   /*
204:                   lcdSetCursorQ(0,3);
205:                   if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
206:                       lcdWriteStringQ("CLIP");
207:                       hard_clipped=FALSE;  
208:                   }
209:                   else if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
210:                   else lcdWriteStringQ("THRU");
211:                    * 
212:                    *    lcdSetCursorQ(10,3);
213:                  lcdWriteWordQ(ENCODERCNTL);
214:                   */
215:               
216:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/routines.c  -------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
10:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
11:                extern unsigned int write_ptr, rw, frameReady;
12:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
13:                
14:                //misc.
15:                volatile fractional sampinA=0, sampinB=0;
16:                
17:                volatile int rxBufferIndicator = 0;
18:                fractional *ping, *pong;
19:                
20:                //Description: This interrupt triggers at the completion of DCI output
21:                //Dependancies: initSPI2(); 
22:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
000306  BE9F80     MOV.D W0, [W15++]
000308  BE9F82     MOV.D W2, [W15++]
00030A  781F84     MOV W4, [W15++]
00030C  F80032     PUSH DSRPAG
00030E  F80034     PUSH DSWPAG
000310  200010     MOV #0x1, W0
000312  8801A0     MOV W0, DSWPAG
000314  202000     MOV #0x200, W0
000316  880190     MOV W0, DSRPAG
000318  000000     NOP
23:                    static fractional sampoutA=0, sampoutB=0;
24:                    
25:                    int trashA=RXBUF0;
00031A  801480     MOV RXBUF0, W0
26:                    sampinA=RXBUF1;
00031C  F80292     PUSH RXBUF1
00031E  F91020     POP sampinA
27:                    int trashB=RXBUF2;
000320  8014A0     MOV RXBUF2, W0
28:                    sampinB=RXBUF3;
000322  F80296     PUSH RXBUF3
000324  F91022     POP sampinB
29:                    TXBUF0=TXBUF1=sampoutA;                                    //output buffered sample to DAC
000326  F8102C     PUSH sampoutA
000328  F9029A     POP TXBUF1
00032A  F8029A     PUSH TXBUF1
00032C  F90298     POP TXBUF0
30:                    TXBUF2=TXBUF3=sampoutB;
00032E  F8102A     PUSH sampoutB
000330  F9029E     POP TXBUF3
000332  F8029E     PUSH TXBUF3
000334  F9029C     POP TXBUF2
31:                
32:                
33:                    
34:                    __builtin_btg(&sampinA, 15);                             //convert to Q1.15 compatible format
000336  210200     MOV #0x1020, W0
000338  A2F010     BTG [W0], #15
35:                    __builtin_btg(&sampinB, 15);                             //convert to Q1.15 compatible format
00033A  210220     MOV #0x1022, W0
00033C  A2F010     BTG [W0], #15
36:                    
37:                
38:                      
39:                    
40:                    if(write_ptr--==0){                       //reset pointer when out of bounds
00033E  8081D0     MOV 0x103A, W0
000340  E90080     DEC W0, W1
000342  8881D1     MOV W1, 0x103A
000344  E00000     CP0 W0
000346  3A0005     BRA NZ, 0x352
41:                        write_ptr=STREAMBUF-1;
000348  200FF0     MOV #0xFF, W0
00034A  8881D0     MOV W0, 0x103A
42:                        __builtin_btg(&rw,0);
00034C  AA1012     BTG rw, #0
43:                        frameReady=1;
00034E  200010     MOV #0x1, W0
000350  8880A0     MOV W0, frameReady
44:                    }
45:                   
46:                    if(rw){
000352  E21012     CP0 rw
000354  320014     BRA Z, 0x37E
47:                        streamB[write_ptr]=sampinA;
000356  8081D0     MOV 0x103A, W0
000358  266B42     MOV #0x66B4, W2
00035A  400180     ADD W0, W0, W3
00035C  410083     ADD W2, W3, W1
00035E  808104     MOV sampinA, W4
000360  780884     MOV W4, [W1]
48:                        sampoutA=outputA[write_ptr--]; 
000362  260B41     MOV #0x60B4, W1
000364  408183     ADD W1, W3, W3
000366  780193     MOV [W3], W3
000368  888163     MOV W3, sampoutA
00036A  E90000     DEC W0, W0
00036C  8881D0     MOV W0, 0x103A
49:                        streamB[write_ptr]=sampinB;
00036E  400000     ADD W0, W0, W0
000370  410100     ADD W2, W0, W2
000372  808113     MOV sampinB, W3
000374  780903     MOV W3, [W2]
50:                        sampoutB=outputA[write_ptr];
000376  408000     ADD W1, W0, W0
000378  780010     MOV [W0], W0
00037A  888150     MOV W0, sampoutB
00037C  370013     BRA 0x3A4
51:                        
52:                    }
53:                    else {
54:                        streamA[write_ptr]=sampinA; 
00037E  8081D0     MOV 0x103A, W0
000380  264B42     MOV #0x64B4, W2
000382  400180     ADD W0, W0, W3
000384  410083     ADD W2, W3, W1
000386  808104     MOV sampinA, W4
000388  780884     MOV W4, [W1]
55:                        sampoutA=outputB[write_ptr--];  
00038A  262B41     MOV #0x62B4, W1
00038C  408183     ADD W1, W3, W3
00038E  780193     MOV [W3], W3
000390  888163     MOV W3, sampoutA
000392  E90000     DEC W0, W0
000394  8881D0     MOV W0, 0x103A
56:                        streamA[write_ptr]=sampinB; 
000396  400000     ADD W0, W0, W0
000398  410100     ADD W2, W0, W2
00039A  808113     MOV sampinB, W3
00039C  780903     MOV W3, [W2]
57:                        sampoutB=outputB[write_ptr];  
00039E  408000     ADD W1, W0, W0
0003A0  780010     MOV [W0], W0
0003A2  888150     MOV W0, sampoutB
58:                    } 
59:                    
60:                    _DCIIF=0;
0003A4  A98807     BCLR 0x807, #4
61:                }
0003A6  F90034     POP DSWPAG
0003A8  F90032     POP DSRPAG
0003AA  78024F     MOV [--W15], W4
0003AC  BE014F     MOV.D [--W15], W2
0003AE  BE004F     MOV.D [--W15], W0
0003B0  064000     RETFIE
62:                
63:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003B2  F80036     PUSH RCOUNT
0003B4  BE9F80     MOV.D W0, [W15++]
0003B6  BE9F82     MOV.D W2, [W15++]
0003B8  BE9F84     MOV.D W4, [W15++]
0003BA  BE9F86     MOV.D W6, [W15++]
64:                    _DMA2IF = 0; /* Received one frame of data*/    
0003BC  A90803     BCLR 0x803, #0
65:                    
66:                    if(rxBufferIndicator == 0)
0003BE  E21024     CP0 rxBufferIndicator
0003C0  3A0004     BRA NZ, 0x3CA
67:                    {
68:                         processRxData((int *)rxBufferA, (int*)txBufferA);
0003C2  2CE001     MOV #0xCE00, W1
0003C4  2CA000     MOV #0xCA00, W0
0003C6  07418F     RCALL processRxData
0003C8  370003     BRA 0x3D0
69:                    }
70:                    else
71:                    {
72:                         processRxData((int *)rxBufferB, (int*)txBufferB);
0003CA  2CC001     MOV #0xCC00, W1
0003CC  2C8000     MOV #0xC800, W0
0003CE  07418B     RCALL processRxData
73:                    }
74:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
0003D0  AA1024     BTG rxBufferIndicator, #0
75:                }
0003D2  BE034F     MOV.D [--W15], W6
0003D4  BE024F     MOV.D [--W15], W4
0003D6  BE014F     MOV.D [--W15], W2
0003D8  BE004F     MOV.D [--W15], W0
0003DA  F90036     POP RCOUNT
0003DC  064000     RETFIE
76:                
77:                /*
78:                //Description: This interrupt handles UART reception
79:                //Dependencies: initUART1();
80:                void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
81:                    unsigned char trash;
82:                    trash=U1RXREG;
83:                    printf("RECIEVED: %d\r\n", trash);
84:                    IFS0bits.U1RXIF = 0;            //clear flag, restart
85:                }
86:                
87:                //Description: This interrupt handles UART transmission
88:                //Dependencies: initUART1();
89:                void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
90:                    YLED=~YLED;
91:                    IFS0bits.U1TXIF = 0;            //clear flag, restart
92:                } 
93:                  
94:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
95:                    //SEG_SEL=1;
96:                    int trash=SPI3BUF;
97:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
98:                    IFS5bits.SPI3IF=0;
99:                    
100:               }
101:                */
---  C:/Users/ryan/Documents/seniorproject/ps-040/plcd.c  -----------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                #include "screens.h"
14:                
15:                extern unsigned char pad[BUTTONS];
16:                int lcdBuf[LCDBUF+1]={0};
17:                int *lcdWritePtr=lcdBuf;
18:                int *lcdReadPtr=lcdBuf;
19:                
20:                // There are write and command macros in the header, make sure these match.
21:                void lcdWriteQ(unsigned char data){
22:                    *lcdWritePtr++=data|0x0000;
0079D4  FB8000     ZE W0, W0
0079D6  808231     MOV 0x1046, W1
0079D8  781880     MOV W0, [W1++]
0079DA  888231     MOV W1, 0x1046
23:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
0079DC  26AD80     MOV #0x6AD8, W0
0079DE  508F80     SUB W1, W0, [W15]
0079E0  3A0002     BRA NZ, 0x79E6
24:                        lcdWritePtr=lcdBuf;
0079E2  B12000     SUB #0x200, W0
0079E4  888230     MOV W0, 0x1046
25:                }
0079E6  060000     RETURN
26:                
27:                // There are write and command macros in the header, make sure these match.
28:                void lcdCommandQ(unsigned char data){
29:                    *lcdWritePtr++=data|0x0100;     //flag for rs=1
0079E8  FB8000     ZE W0, W0
0079EA  808231     MOV 0x1046, W1
0079EC  A08000     BSET W0, #8
0079EE  781880     MOV W0, [W1++]
0079F0  888231     MOV W1, 0x1046
30:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
0079F2  26AD80     MOV #0x6AD8, W0
0079F4  508F80     SUB W1, W0, [W15]
0079F6  3A0002     BRA NZ, 0x79FC
31:                        lcdWritePtr=lcdBuf;
0079F8  B12000     SUB #0x200, W0
0079FA  888230     MOV W0, 0x1046
32:                }
0079FC  060000     RETURN
33:                
34:                void lcdClearQ(void){
35:                    *lcdWritePtr++=LCD_CLEARDISPLAY|0x0300;     //flag for rs=1 & long delay
0079FE  808230     MOV 0x1046, W0
007A00  203011     MOV #0x301, W1
007A02  781801     MOV W1, [W0++]
007A04  888230     MOV W0, 0x1046
36:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007A06  26AD81     MOV #0x6AD8, W1
007A08  500F81     SUB W0, W1, [W15]
007A0A  3A0003     BRA NZ, 0x7A12
37:                        lcdWritePtr=lcdBuf;
007A0C  2FE000     MOV #0xFE00, W0
007A0E  400001     ADD W0, W1, W0
007A10  888230     MOV W0, 0x1046
38:                }
007A12  060000     RETURN
39:                
40:                void lcdSetCursorQ(unsigned char col, unsigned char row) {
007A14  784101     MOV.B W1, W2
41:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
42:                  if (row > 3) {
43:                    row = 3;
44:                  }
45:                  *lcdWritePtr++=(LCD_SETDDRAMADDR | (col + offsets[row]))|0x0100;  //flag for rs=0 
007A16  808231     MOV 0x1046, W1
007A18  514FE3     SUB.B W2, #0x3, [W15]
007A1A  360001     BRA LEU, 0x7A1E
007A1C  B3C032     MOV.B #0x3, W2
007A1E  FB8102     ZE W2, W2
007A20  2F9D03     MOV #0xF9D0, W3
007A22  418102     ADD W3, W2, W2
007A24  FB8112     ZE [W2], W2
007A26  FB8000     ZE W0, W0
007A28  410000     ADD W2, W0, W0
007A2A  201802     MOV #0x180, W2
007A2C  701882     IOR W0, W2, [W1++]
007A2E  888231     MOV W1, 0x1046
46:                    if(lcdWritePtr==&lcdBuf[LCDBUF]) 
007A30  26AD80     MOV #0x6AD8, W0
007A32  508F80     SUB W1, W0, [W15]
007A34  3A0002     BRA NZ, 0x7A3A
47:                        lcdWritePtr=lcdBuf; 
007A36  B12000     SUB #0x200, W0
007A38  888230     MOV W0, 0x1046
48:                }
007A3A  060000     RETURN
49:                
50:                void lcdWriteStringQ(char *string) {
51:                    char *it = string;
52:                    for (; *it; it++) {
007A3C  784090     MOV.B [W0], W1
007A3E  E00401     CP0.B W1
007A40  32000D     BRA Z, 0x7A5C
007A56  7840D0     MOV.B [++W0], W1
007A58  E00401     CP0.B W1
007A5A  3AFFF6     BRA NZ, 0x7A48
53:                        lcdWriteQMac(*it);
007A42  26AD83     MOV #0x6AD8, W3
007A44  2FE004     MOV #0xFE00, W4
007A46  420203     ADD W4, W3, W4
007A48  FB0101     SE W1, W2
007A4A  808231     MOV 0x1046, W1
007A4C  781882     MOV W2, [W1++]
007A4E  888231     MOV W1, 0x1046
007A50  508F83     SUB W1, W3, [W15]
007A52  3A0001     BRA NZ, 0x7A56
007A54  888234     MOV W4, 0x1046
54:                  }
55:                }
007A5C  060000     RETURN
56:                
57:                void lcdCustomSymbols(void){
58:                    int i=0;
59:                    lcdCommandQMac(0x40);
007A5E  808230     MOV 0x1046, W0
007A60  201401     MOV #0x140, W1
007A62  781801     MOV W1, [W0++]
007A64  888230     MOV W0, 0x1046
007A66  26AD81     MOV #0x6AD8, W1
007A68  500F81     SUB W0, W1, [W15]
007A6A  3A0003     BRA NZ, 0x7A72
007A6C  2FE000     MOV #0xFE00, W0
007A6E  400001     ADD W0, W1, W0
007A70  888230     MOV W0, 0x1046
60:                    Delay_us(200);
007A72  200C80     MOV #0xC8, W0
007A74  07063F     RCALL Delay_us
61:                   // for(; i<8; i++)lcdWriteString(loadingOne[i]);
62:                    //lcdWriteString(loadingTwo);
63:                    //lcdWriteString(loadingThree);
64:                    //lcdWriteString(loadingFour);
65:                }
007A76  060000     RETURN
66:                
67:                void lcdWriteWordQ(int word){
007A78  4787E6     ADD W15, #0x6, W15
007A7A  781F8E     MOV W14, [W15++]
007ABE  200041     MOV #0x4, W1
68:                    int i;
69:                    char inchar[4];
70:                    
71:                    if(word<0) {
007A7C  E00000     CP0 W0
007A7E  3D000C     BRA GE, 0x7A98
72:                        lcdWriteQMac('-');
007A80  808231     MOV 0x1046, W1
007A82  2002D2     MOV #0x2D, W2
007A84  781882     MOV W2, [W1++]
007A86  888231     MOV W1, 0x1046
007A88  26AD82     MOV #0x6AD8, W2
007A8A  508F82     SUB W1, W2, [W15]
007A8C  3A0003     BRA NZ, 0x7A94
007A8E  2FE001     MOV #0xFE00, W1
007A90  408082     ADD W1, W2, W1
007A92  888231     MOV W1, 0x1046
73:                        word=~word+1;
007A94  EA0000     NEG W0, W0
007A96  37000A     BRA 0x7AAC
74:                    }else lcdWriteQMac(' ');
007A98  808231     MOV 0x1046, W1
007A9A  200202     MOV #0x20, W2
007A9C  781882     MOV W2, [W1++]
007A9E  888231     MOV W1, 0x1046
007AA0  26AD82     MOV #0x6AD8, W2
007AA2  508F82     SUB W1, W2, [W15]
007AA4  3A0003     BRA NZ, 0x7AAC
007AA6  2FE001     MOV #0xFE00, W1
007AA8  408082     ADD W1, W2, W1
007AAA  888231     MOV W1, 0x1046
75:                   
76:                   inchar[0] = word&0x000F; 
007AAC  6040EF     AND.B W0, #0xF, W1
77:                   if (inchar[0] > 9) 
007AAE  50CFE9     SUB.B W1, #0x9, [W15]
007AB0  340003     BRA LE, 0x7AB8
78:                       inchar[0]+=55;
007AB2  B04371     ADD.B #0x37, W1
007AB4  9FFFA1     MOV.B W1, [W15-6]
007AB6  370002     BRA 0x7ABC
79:                   else inchar[0]+=48;
007AB8  B04301     ADD.B #0x30, W1
007ABA  9FFFA1     MOV.B W1, [W15-6]
007ABC  578766     SUB W15, #0x6, W14
80:                   
81:                   for(i=1; i<4; i++){ 
007AD8  508FF0     SUB W1, #0x10, [W15]
007ADA  3AFFF2     BRA NZ, 0x7AC0
82:                      inchar[i] = ((word>>(i*4))&0x0000F); 
007AC0  DE8101     ASR W0, W1, W2
007AC2  61416F     AND.B W2, #0xF, W2
007AC4  E8070E     INC W14, W14
007AC6  784F02     MOV.B W2, [W14]
83:                      if (inchar[i] > 9) 
007AC8  514FE9     SUB.B W2, #0x9, [W15]
007ACA  340003     BRA LE, 0x7AD2
84:                          inchar[i]+=55;
007ACC  B3C374     MOV.B #0x37, W4
007ACE  414F04     ADD.B W2, W4, [W14]
007AD0  370002     BRA 0x7AD6
85:                      else inchar[i]+=48;
007AD2  B3C304     MOV.B #0x30, W4
007AD4  414F04     ADD.B W2, W4, [W14]
007AD6  4080E4     ADD W1, #0x4, W1
86:                   } 
87:                   lcdWriteQMac(inchar[3]);
007ADC  97F8DF     MOV.B [W15-3], W1
007ADE  FB0081     SE W1, W1
007AE0  808230     MOV 0x1046, W0
007AE2  781801     MOV W1, [W0++]
007AE4  26AD81     MOV #0x6AD8, W1
007AE6  500F81     SUB W0, W1, [W15]
007AE8  3A000A     BRA NZ, 0x7AFE
88:                   lcdWriteQMac(inchar[2]);
007AEA  97F84F     MOV.B [W15-4], W0
007AEC  FB0000     SE W0, W0
007AEE  8B46C0     MOV W0, lcdBuf
007AFE  97F8CF     MOV.B [W15-4], W1
007B00  FB0081     SE W1, W1
007B02  781801     MOV W1, [W0++]
007B04  888230     MOV W0, 0x1046
007B06  26AD81     MOV #0x6AD8, W1
007B08  500F81     SUB W0, W1, [W15]
007B0A  3A0009     BRA NZ, 0x7B1E
89:                   lcdWriteQMac(inchar[1]);
007AF0  97F83F     MOV.B [W15-5], W0
007AF2  FB0000     SE W0, W0
007AF4  8B46D0     MOV W0, 0x68DA
007AF6  2FE040     MOV #0xFE04, W0
007AF8  400001     ADD W0, W1, W0
007AFA  888230     MOV W0, 0x1046
007AFC  37001F     BRA 0x7B3C
007B0C  97F83F     MOV.B [W15-5], W0
007B0E  FB0000     SE W0, W0
007B10  8B46C0     MOV W0, lcdBuf
007B1E  97F8BF     MOV.B [W15-5], W1
007B20  FB0081     SE W1, W1
007B22  808230     MOV 0x1046, W0
007B24  781801     MOV W1, [W0++]
007B26  888230     MOV W0, 0x1046
007B28  26AD81     MOV #0x6AD8, W1
007B2A  500F81     SUB W0, W1, [W15]
007B2C  3A0007     BRA NZ, 0x7B3C
90:                   lcdWriteQMac(inchar[0]);
007B12  97F8AF     MOV.B [W15-6], W1
007B14  FB0001     SE W1, W0
007B16  8B46D0     MOV W0, 0x68DA
007B18  268DC0     MOV #0x68DC, W0
007B1A  888230     MOV W0, 0x1046
007B1C  37001A     BRA 0x7B52
007B2E  97FA2F     MOV.B [W15-6], W4
007B30  FB0004     SE W4, W0
007B32  8B46C0     MOV W0, lcdBuf
007B34  2FE020     MOV #0xFE02, W0
007B36  400001     ADD W0, W1, W0
007B38  888230     MOV W0, 0x1046
007B3A  37000B     BRA 0x7B52
007B3C  97F82F     MOV.B [W15-6], W0
007B3E  FB0080     SE W0, W1
007B40  808230     MOV 0x1046, W0
007B42  781801     MOV W1, [W0++]
007B44  888230     MOV W0, 0x1046
007B46  26AD81     MOV #0x6AD8, W1
007B48  500F81     SUB W0, W1, [W15]
007B4A  3A0003     BRA NZ, 0x7B52
007B4C  2FE000     MOV #0xFE00, W0
007B4E  400001     ADD W0, W1, W0
007B50  888230     MOV W0, 0x1046
91:                }
007B52  78074F     MOV [--W15], W14
007B54  B1006F     SUB #0x6, W15
007B56  060000     RETURN
92:                
93:                void lcdWriteWordUnsignedQ(unsigned int word){
007B58  4787E6     ADD W15, #0x6, W15
007B5A  781F8E     MOV W14, [W15++]
007B6E  200041     MOV #0x4, W1
94:                    int i;
95:                    char inchar[4];
96:                    
97:                   inchar[0] = word&0x000F; 
007B5C  6040EF     AND.B W0, #0xF, W1
98:                   if (inchar[0] > 9) 
007B5E  50CFE9     SUB.B W1, #0x9, [W15]
007B60  340003     BRA LE, 0x7B68
99:                       inchar[0]+=55;
007B62  B04371     ADD.B #0x37, W1
007B64  9FFFA1     MOV.B W1, [W15-6]
007B66  370002     BRA 0x7B6C
100:                  else inchar[0]+=48;
007B68  B04301     ADD.B #0x30, W1
007B6A  9FFFA1     MOV.B W1, [W15-6]
007B6C  578766     SUB W15, #0x6, W14
101:                  
102:                  for(i=1; i<4; i++){ 
007B88  508FF0     SUB W1, #0x10, [W15]
007B8A  3AFFF2     BRA NZ, 0x7B70
103:                     inchar[i] = ((word>>(i*4))&0x0000F); 
007B70  DE0101     LSR W0, W1, W2
007B72  61416F     AND.B W2, #0xF, W2
007B74  E8070E     INC W14, W14
007B76  784F02     MOV.B W2, [W14]
104:                     if (inchar[i] > 9) 
007B78  514FE9     SUB.B W2, #0x9, [W15]
007B7A  340003     BRA LE, 0x7B82
105:                         inchar[i]+=55;
007B7C  B3C374     MOV.B #0x37, W4
007B7E  414F04     ADD.B W2, W4, [W14]
007B80  370002     BRA 0x7B86
106:                     else inchar[i]+=48;
007B82  B3C304     MOV.B #0x30, W4
007B84  414F04     ADD.B W2, W4, [W14]
007B86  4080E4     ADD W1, #0x4, W1
107:                  } 
108:                  lcdWriteQMac(inchar[3]);
007B8C  97F8DF     MOV.B [W15-3], W1
007B8E  FB0081     SE W1, W1
007B90  808230     MOV 0x1046, W0
007B92  781801     MOV W1, [W0++]
007B94  26AD81     MOV #0x6AD8, W1
007B96  500F81     SUB W0, W1, [W15]
007B98  3A000A     BRA NZ, 0x7BAE
109:                  lcdWriteQMac(inchar[2]);
007B9A  97F84F     MOV.B [W15-4], W0
007B9C  FB0000     SE W0, W0
007B9E  8B46C0     MOV W0, lcdBuf
007BAE  97F8CF     MOV.B [W15-4], W1
007BB0  FB0081     SE W1, W1
007BB2  781801     MOV W1, [W0++]
007BB4  888230     MOV W0, 0x1046
007BB6  26AD81     MOV #0x6AD8, W1
007BB8  500F81     SUB W0, W1, [W15]
007BBA  3A0009     BRA NZ, 0x7BCE
110:                  lcdWriteQMac(inchar[1]);
007BA0  97F83F     MOV.B [W15-5], W0
007BA2  FB0000     SE W0, W0
007BA4  8B46D0     MOV W0, 0x68DA
007BA6  2FE040     MOV #0xFE04, W0
007BA8  400001     ADD W0, W1, W0
007BAA  888230     MOV W0, 0x1046
007BAC  37001F     BRA 0x7BEC
007BBC  97F83F     MOV.B [W15-5], W0
007BBE  FB0000     SE W0, W0
007BC0  8B46C0     MOV W0, lcdBuf
007BCE  97F8BF     MOV.B [W15-5], W1
007BD0  FB0081     SE W1, W1
007BD2  808230     MOV 0x1046, W0
007BD4  781801     MOV W1, [W0++]
007BD6  888230     MOV W0, 0x1046
007BD8  26AD81     MOV #0x6AD8, W1
007BDA  500F81     SUB W0, W1, [W15]
007BDC  3A0007     BRA NZ, 0x7BEC
111:                  lcdWriteQMac(inchar[0]);
007BC2  97F8AF     MOV.B [W15-6], W1
007BC4  FB0001     SE W1, W0
007BC6  8B46D0     MOV W0, 0x68DA
007BC8  268DC0     MOV #0x68DC, W0
007BCA  888230     MOV W0, 0x1046
007BCC  37001A     BRA 0x7C02
007BDE  97FA2F     MOV.B [W15-6], W4
007BE0  FB0004     SE W4, W0
007BE2  8B46C0     MOV W0, lcdBuf
007BE4  2FE020     MOV #0xFE02, W0
007BE6  400001     ADD W0, W1, W0
007BE8  888230     MOV W0, 0x1046
007BEA  37000B     BRA 0x7C02
007BEC  97F82F     MOV.B [W15-6], W0
007BEE  FB0080     SE W0, W1
007BF0  808230     MOV 0x1046, W0
007BF2  781801     MOV W1, [W0++]
007BF4  888230     MOV W0, 0x1046
007BF6  26AD81     MOV #0x6AD8, W1
007BF8  500F81     SUB W0, W1, [W15]
007BFA  3A0003     BRA NZ, 0x7C02
007BFC  2FE000     MOV #0xFE00, W0
007BFE  400001     ADD W0, W1, W0
007C00  888230     MOV W0, 0x1046
112:               }
007C02  78074F     MOV [--W15], W14
007C04  B1006F     SUB #0x6, W15
007C06  060000     RETURN
113:               
114:               void lcdWriteDecimalQ(char word, int digits){
007C08  FA0000     LNK #0x0
007C0A  781F88     MOV W8, [W15++]
007C0C  780381     MOV W1, W7
115:                   const char maxdigits = 4;
116:                   char result[maxdigits];
007C10  4787E6     ADD W15, #0x6, W15
007C12  780186     MOV W6, W3
117:                   char i = 3;
007C14  B3C032     MOV.B #0x3, W2
118:                   do {
119:                       result[i] = '0' + word % 10;
007C16  2000A4     MOV #0xA, W4
007C18  FB0282     SE W2, W5
007C1A  418285     ADD W3, W5, W5
007C1C  FB0000     SE W0, W0
007C1E  090011     REPEAT #0x11
007C20  D80004     DIV.SW W0, W4
007C22  B3C308     MOV.B #0x30, W8
007C24  40CA88     ADD.B W1, W8, [W5]
120:                       word /= 10;
121:                       i--;
007C26  E94102     DEC.B W2, W2
122:                   }
123:                   while (word > 0);
007C28  E00400     CP0.B W0
007C2A  3CFFF6     BRA GT, 0x7C18
124:                   while (i>=0) result[i--] = ' '; 
007C2C  E00402     CP0.B W2
007C2E  350007     BRA LT, 0x7C3E
007C30  B3C204     MOV.B #0x20, W4
007C32  FB0002     SE W2, W0
007C34  418000     ADD W3, W0, W0
007C36  784804     MOV.B W4, [W0]
007C38  E94102     DEC.B W2, W2
007C3A  414FE1     ADD.B W2, #0x1, [W15]
007C3C  3AFFFA     BRA NZ, 0x7C32
125:                 
126:                   for (i=maxdigits-digits; i<maxdigits; i++) {
007C3E  B3C041     MOV.B #0x4, W1
007C40  50C087     SUB.B W1, W7, W1
007C42  50CFE3     SUB.B W1, #0x3, [W15]
007C44  3C000F     BRA GT, 0x7C64
007C5E  E84081     INC.B W1, W1
007C60  50CFE4     SUB.B W1, #0x4, [W15]
007C62  3AFFF4     BRA NZ, 0x7C4C
127:                       lcdWriteQMac(result[i]);
007C46  26AD84     MOV #0x6AD8, W4
007C48  2FE005     MOV #0xFE00, W5
007C4A  428284     ADD W5, W4, W5
007C4C  FB0001     SE W1, W0
007C4E  418000     ADD W3, W0, W0
007C50  FB0110     SE [W0], W2
007C52  808230     MOV 0x1046, W0
007C54  781802     MOV W2, [W0++]
007C56  888230     MOV W0, 0x1046
007C58  500F84     SUB W0, W4, [W15]
007C5A  3A0001     BRA NZ, 0x7C5E
007C5C  888235     MOV W5, 0x1046
128:                   }
129:               }
007C0E  78030F     MOV W15, W6
007C64  780786     MOV W6, W15
007C66  78044F     MOV [--W15], W8
007C68  FA8000     ULNK
007C6A  060000     RETURN
130:               
131:               //4x4 pad debug
132:               void lcdDrawPads(unsigned char col){
007C6C  BE9F88     MOV.D W8, [W15++]
007C6E  784480     MOV.B W0, W9
133:                   unsigned char block=0xFF;
007C7E  EBC400     SETM.B W8
134:                   if(!pad[34]||!pad[16]) block='*';
007C70  B3C2A8     MOV.B #0x2A, W8
007C72  268D60     MOV #0x68D6, W0
007C74  E00410     CP0.B [W0]
007C76  320004     BRA Z, 0x7C80
007C78  500072     SUB W0, #0x12, W0
007C7A  E00410     CP0.B [W0]
007C7C  320001     BRA Z, 0x7C80
135:                   
136:                   lcdSetCursorQ(col, 0);
007C80  EB4080     CLR.B W1
007C82  784009     MOV.B W9, W0
007C84  07FEC7     RCALL lcdSetCursorQ
137:                   if(!pad[12]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007C86  268C00     MOV #0x68C0, W0
007C88  E00410     CP0.B [W0]
007C8A  3A000B     BRA NZ, 0x7CA2
007C8C  808230     MOV 0x1046, W0
007C8E  200201     MOV #0x20, W1
007C90  781801     MOV W1, [W0++]
007C92  888230     MOV W0, 0x1046
007C94  26AD81     MOV #0x6AD8, W1
007C96  500F81     SUB W0, W1, [W15]
007C98  3A000E     BRA NZ, 0x7CB6
007C9A  2FE000     MOV #0xFE00, W0
007C9C  400001     ADD W0, W1, W0
007C9E  888230     MOV W0, 0x1046
007CA0  37000A     BRA 0x7CB6
007CA2  FB8088     ZE W8, W1
007CA4  808230     MOV 0x1046, W0
007CA6  781801     MOV W1, [W0++]
007CA8  888230     MOV W0, 0x1046
007CAA  26AD81     MOV #0x6AD8, W1
007CAC  500F81     SUB W0, W1, [W15]
007CAE  3A0003     BRA NZ, 0x7CB6
007CB0  2FE000     MOV #0xFE00, W0
007CB2  400001     ADD W0, W1, W0
007CB4  888230     MOV W0, 0x1046
138:                   if(!pad[13]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007CB6  268C10     MOV #0x68C1, W0
007CB8  E00410     CP0.B [W0]
007CBA  3A000B     BRA NZ, 0x7CD2
007CBC  808230     MOV 0x1046, W0
007CBE  200201     MOV #0x20, W1
007CC0  781801     MOV W1, [W0++]
007CC2  888230     MOV W0, 0x1046
007CC4  26AD81     MOV #0x6AD8, W1
007CC6  500F81     SUB W0, W1, [W15]
007CC8  3A000E     BRA NZ, 0x7CE6
007CCA  2FE000     MOV #0xFE00, W0
007CCC  400001     ADD W0, W1, W0
007CCE  888230     MOV W0, 0x1046
007CD0  37000A     BRA 0x7CE6
007CD2  FB8088     ZE W8, W1
007CD4  808230     MOV 0x1046, W0
007CD6  781801     MOV W1, [W0++]
007CD8  888230     MOV W0, 0x1046
007CDA  26AD81     MOV #0x6AD8, W1
007CDC  500F81     SUB W0, W1, [W15]
007CDE  3A0003     BRA NZ, 0x7CE6
007CE0  2FE000     MOV #0xFE00, W0
007CE2  400001     ADD W0, W1, W0
007CE4  888230     MOV W0, 0x1046
139:                   if(!pad[14]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007CE6  268C20     MOV #0x68C2, W0
007CE8  E00410     CP0.B [W0]
007CEA  3A000B     BRA NZ, 0x7D02
007CEC  808230     MOV 0x1046, W0
007CEE  200201     MOV #0x20, W1
007CF0  781801     MOV W1, [W0++]
007CF2  888230     MOV W0, 0x1046
007CF4  26AD81     MOV #0x6AD8, W1
007CF6  500F81     SUB W0, W1, [W15]
007CF8  3A000E     BRA NZ, 0x7D16
007CFA  2FE000     MOV #0xFE00, W0
007CFC  400001     ADD W0, W1, W0
007CFE  888230     MOV W0, 0x1046
007D00  37000A     BRA 0x7D16
007D02  FB8088     ZE W8, W1
007D04  808230     MOV 0x1046, W0
007D06  781801     MOV W1, [W0++]
007D08  888230     MOV W0, 0x1046
007D0A  26AD81     MOV #0x6AD8, W1
007D0C  500F81     SUB W0, W1, [W15]
007D0E  3A0003     BRA NZ, 0x7D16
007D10  2FE000     MOV #0xFE00, W0
007D12  400001     ADD W0, W1, W0
007D14  888230     MOV W0, 0x1046
140:                   if(!pad[15]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D16  268C30     MOV #0x68C3, W0
007D18  E00410     CP0.B [W0]
007D1A  3A000B     BRA NZ, 0x7D32
007D1C  808230     MOV 0x1046, W0
007D1E  200201     MOV #0x20, W1
007D20  781801     MOV W1, [W0++]
007D22  888230     MOV W0, 0x1046
007D24  26AD81     MOV #0x6AD8, W1
007D26  500F81     SUB W0, W1, [W15]
007D28  3A000E     BRA NZ, 0x7D46
007D2A  2FE000     MOV #0xFE00, W0
007D2C  400001     ADD W0, W1, W0
007D2E  888230     MOV W0, 0x1046
007D30  37000A     BRA 0x7D46
007D32  FB8088     ZE W8, W1
007D34  808230     MOV 0x1046, W0
007D36  781801     MOV W1, [W0++]
007D38  888230     MOV W0, 0x1046
007D3A  26AD81     MOV #0x6AD8, W1
007D3C  500F81     SUB W0, W1, [W15]
007D3E  3A0003     BRA NZ, 0x7D46
007D40  2FE000     MOV #0xFE00, W0
007D42  400001     ADD W0, W1, W0
007D44  888230     MOV W0, 0x1046
141:                   lcdSetCursorQ(col, 1);
007D46  B3C011     MOV.B #0x1, W1
007D48  784009     MOV.B W9, W0
007D4A  07FE64     RCALL lcdSetCursorQ
142:                   if(!pad[8]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D4C  268BC0     MOV #0x68BC, W0
007D4E  E00410     CP0.B [W0]
007D50  3A000B     BRA NZ, 0x7D68
007D52  808230     MOV 0x1046, W0
007D54  200201     MOV #0x20, W1
007D56  781801     MOV W1, [W0++]
007D58  888230     MOV W0, 0x1046
007D5A  26AD81     MOV #0x6AD8, W1
007D5C  500F81     SUB W0, W1, [W15]
007D5E  3A000E     BRA NZ, 0x7D7C
007D60  2FE000     MOV #0xFE00, W0
007D62  400001     ADD W0, W1, W0
007D64  888230     MOV W0, 0x1046
007D66  37000A     BRA 0x7D7C
007D68  FB8088     ZE W8, W1
007D6A  808230     MOV 0x1046, W0
007D6C  781801     MOV W1, [W0++]
007D6E  888230     MOV W0, 0x1046
007D70  26AD81     MOV #0x6AD8, W1
007D72  500F81     SUB W0, W1, [W15]
007D74  3A0003     BRA NZ, 0x7D7C
007D76  2FE000     MOV #0xFE00, W0
007D78  400001     ADD W0, W1, W0
007D7A  888230     MOV W0, 0x1046
143:                   if(!pad[9]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D7C  268BD0     MOV #0x68BD, W0
007D7E  E00410     CP0.B [W0]
007D80  3A000B     BRA NZ, 0x7D98
007D82  808230     MOV 0x1046, W0
007D84  200201     MOV #0x20, W1
007D86  781801     MOV W1, [W0++]
007D88  888230     MOV W0, 0x1046
007D8A  26AD81     MOV #0x6AD8, W1
007D8C  500F81     SUB W0, W1, [W15]
007D8E  3A000E     BRA NZ, 0x7DAC
007D90  2FE000     MOV #0xFE00, W0
007D92  400001     ADD W0, W1, W0
007D94  888230     MOV W0, 0x1046
007D96  37000A     BRA 0x7DAC
007D98  FB8088     ZE W8, W1
007D9A  808230     MOV 0x1046, W0
007D9C  781801     MOV W1, [W0++]
007D9E  888230     MOV W0, 0x1046
007DA0  26AD81     MOV #0x6AD8, W1
007DA2  500F81     SUB W0, W1, [W15]
007DA4  3A0003     BRA NZ, 0x7DAC
007DA6  2FE000     MOV #0xFE00, W0
007DA8  400001     ADD W0, W1, W0
007DAA  888230     MOV W0, 0x1046
144:                   if(!pad[10]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007DAC  268BE0     MOV #0x68BE, W0
007DAE  E00410     CP0.B [W0]
007DB0  3A000B     BRA NZ, 0x7DC8
007DB2  808230     MOV 0x1046, W0
007DB4  200201     MOV #0x20, W1
007DB6  781801     MOV W1, [W0++]
007DB8  888230     MOV W0, 0x1046
007DBA  26AD81     MOV #0x6AD8, W1
007DBC  500F81     SUB W0, W1, [W15]
007DBE  3A000E     BRA NZ, 0x7DDC
007DC0  2FE000     MOV #0xFE00, W0
007DC2  400001     ADD W0, W1, W0
007DC4  888230     MOV W0, 0x1046
007DC6  37000A     BRA 0x7DDC
007DC8  FB8088     ZE W8, W1
007DCA  808230     MOV 0x1046, W0
007DCC  781801     MOV W1, [W0++]
007DCE  888230     MOV W0, 0x1046
007DD0  26AD81     MOV #0x6AD8, W1
007DD2  500F81     SUB W0, W1, [W15]
007DD4  3A0003     BRA NZ, 0x7DDC
007DD6  2FE000     MOV #0xFE00, W0
007DD8  400001     ADD W0, W1, W0
007DDA  888230     MOV W0, 0x1046
145:                   if(!pad[11]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007DDC  268BF0     MOV #0x68BF, W0
007DDE  E00410     CP0.B [W0]
007DE0  3A000B     BRA NZ, 0x7DF8
007DE2  808230     MOV 0x1046, W0
007DE4  200201     MOV #0x20, W1
007DE6  781801     MOV W1, [W0++]
007DE8  888230     MOV W0, 0x1046
007DEA  26AD81     MOV #0x6AD8, W1
007DEC  500F81     SUB W0, W1, [W15]
007DEE  3A000E     BRA NZ, 0x7E0C
007DF0  2FE000     MOV #0xFE00, W0
007DF2  400001     ADD W0, W1, W0
007DF4  888230     MOV W0, 0x1046
007DF6  37000A     BRA 0x7E0C
007DF8  FB8088     ZE W8, W1
007DFA  808230     MOV 0x1046, W0
007DFC  781801     MOV W1, [W0++]
007DFE  888230     MOV W0, 0x1046
007E00  26AD81     MOV #0x6AD8, W1
007E02  500F81     SUB W0, W1, [W15]
007E04  3A0003     BRA NZ, 0x7E0C
007E06  2FE000     MOV #0xFE00, W0
007E08  400001     ADD W0, W1, W0
007E0A  888230     MOV W0, 0x1046
146:                   lcdSetCursorQ(col, 2);
007E0C  B3C021     MOV.B #0x2, W1
007E0E  784009     MOV.B W9, W0
007E10  07FE01     RCALL lcdSetCursorQ
147:                   if(!pad[4]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E12  268B80     MOV #0x68B8, W0
007E14  E00410     CP0.B [W0]
007E16  3A000B     BRA NZ, 0x7E2E
007E18  808230     MOV 0x1046, W0
007E1A  200201     MOV #0x20, W1
007E1C  781801     MOV W1, [W0++]
007E1E  888230     MOV W0, 0x1046
007E20  26AD81     MOV #0x6AD8, W1
007E22  500F81     SUB W0, W1, [W15]
007E24  3A000E     BRA NZ, 0x7E42
007E26  2FE000     MOV #0xFE00, W0
007E28  400001     ADD W0, W1, W0
007E2A  888230     MOV W0, 0x1046
007E2C  37000A     BRA 0x7E42
007E2E  FB8088     ZE W8, W1
007E30  808230     MOV 0x1046, W0
007E32  781801     MOV W1, [W0++]
007E34  888230     MOV W0, 0x1046
007E36  26AD81     MOV #0x6AD8, W1
007E38  500F81     SUB W0, W1, [W15]
007E3A  3A0003     BRA NZ, 0x7E42
007E3C  2FE000     MOV #0xFE00, W0
007E3E  400001     ADD W0, W1, W0
007E40  888230     MOV W0, 0x1046
148:                   if(!pad[5]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E42  268B90     MOV #0x68B9, W0
007E44  E00410     CP0.B [W0]
007E46  3A000B     BRA NZ, 0x7E5E
007E48  808230     MOV 0x1046, W0
007E4A  200201     MOV #0x20, W1
007E4C  781801     MOV W1, [W0++]
007E4E  888230     MOV W0, 0x1046
007E50  26AD81     MOV #0x6AD8, W1
007E52  500F81     SUB W0, W1, [W15]
007E54  3A000E     BRA NZ, 0x7E72
007E56  2FE000     MOV #0xFE00, W0
007E58  400001     ADD W0, W1, W0
007E5A  888230     MOV W0, 0x1046
007E5C  37000A     BRA 0x7E72
007E5E  FB8088     ZE W8, W1
007E60  808230     MOV 0x1046, W0
007E62  781801     MOV W1, [W0++]
007E64  888230     MOV W0, 0x1046
007E66  26AD81     MOV #0x6AD8, W1
007E68  500F81     SUB W0, W1, [W15]
007E6A  3A0003     BRA NZ, 0x7E72
007E6C  2FE000     MOV #0xFE00, W0
007E6E  400001     ADD W0, W1, W0
007E70  888230     MOV W0, 0x1046
149:                   if(!pad[6]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E72  268BA0     MOV #0x68BA, W0
007E74  E00410     CP0.B [W0]
007E76  3A000B     BRA NZ, 0x7E8E
007E78  808230     MOV 0x1046, W0
007E7A  200201     MOV #0x20, W1
007E7C  781801     MOV W1, [W0++]
007E7E  888230     MOV W0, 0x1046
007E80  26AD81     MOV #0x6AD8, W1
007E82  500F81     SUB W0, W1, [W15]
007E84  3A000E     BRA NZ, 0x7EA2
007E86  2FE000     MOV #0xFE00, W0
007E88  400001     ADD W0, W1, W0
007E8A  888230     MOV W0, 0x1046
007E8C  37000A     BRA 0x7EA2
007E8E  FB8088     ZE W8, W1
007E90  808230     MOV 0x1046, W0
007E92  781801     MOV W1, [W0++]
007E94  888230     MOV W0, 0x1046
007E96  26AD81     MOV #0x6AD8, W1
007E98  500F81     SUB W0, W1, [W15]
007E9A  3A0003     BRA NZ, 0x7EA2
007E9C  2FE000     MOV #0xFE00, W0
007E9E  400001     ADD W0, W1, W0
007EA0  888230     MOV W0, 0x1046
150:                   if(!pad[7]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007EA2  268BB0     MOV #0x68BB, W0
007EA4  E00410     CP0.B [W0]
007EA6  3A000B     BRA NZ, 0x7EBE
007EA8  808230     MOV 0x1046, W0
007EAA  200201     MOV #0x20, W1
007EAC  781801     MOV W1, [W0++]
007EAE  888230     MOV W0, 0x1046
007EB0  26AD81     MOV #0x6AD8, W1
007EB2  500F81     SUB W0, W1, [W15]
007EB4  3A000E     BRA NZ, 0x7ED2
007EB6  2FE000     MOV #0xFE00, W0
007EB8  400001     ADD W0, W1, W0
007EBA  888230     MOV W0, 0x1046
007EBC  37000A     BRA 0x7ED2
007EBE  FB8088     ZE W8, W1
007EC0  808230     MOV 0x1046, W0
007EC2  781801     MOV W1, [W0++]
007EC4  888230     MOV W0, 0x1046
007EC6  26AD81     MOV #0x6AD8, W1
007EC8  500F81     SUB W0, W1, [W15]
007ECA  3A0003     BRA NZ, 0x7ED2
007ECC  2FE000     MOV #0xFE00, W0
007ECE  400001     ADD W0, W1, W0
007ED0  888230     MOV W0, 0x1046
151:                   lcdSetCursorQ(col, 3);
007ED2  B3C031     MOV.B #0x3, W1
007ED4  784009     MOV.B W9, W0
007ED6  07FD9E     RCALL lcdSetCursorQ
152:                   if(!pad[0]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007ED8  268B40     MOV #0x68B4, W0
007EDA  E00410     CP0.B [W0]
007EDC  3A000B     BRA NZ, 0x7EF4
007EDE  808230     MOV 0x1046, W0
007EE0  200201     MOV #0x20, W1
007EE2  781801     MOV W1, [W0++]
007EE4  888230     MOV W0, 0x1046
007EE6  26AD81     MOV #0x6AD8, W1
007EE8  500F81     SUB W0, W1, [W15]
007EEA  3A000E     BRA NZ, 0x7F08
007EEC  2FE000     MOV #0xFE00, W0
007EEE  400001     ADD W0, W1, W0
007EF0  888230     MOV W0, 0x1046
007EF2  37000A     BRA 0x7F08
007EF4  FB8088     ZE W8, W1
007EF6  808230     MOV 0x1046, W0
007EF8  781801     MOV W1, [W0++]
007EFA  888230     MOV W0, 0x1046
007EFC  26AD81     MOV #0x6AD8, W1
007EFE  500F81     SUB W0, W1, [W15]
007F00  3A0003     BRA NZ, 0x7F08
007F02  2FE000     MOV #0xFE00, W0
007F04  400001     ADD W0, W1, W0
007F06  888230     MOV W0, 0x1046
153:                   if(!pad[1]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F08  268B50     MOV #0x68B5, W0
007F0A  E00410     CP0.B [W0]
007F0C  3A000B     BRA NZ, 0x7F24
007F0E  808230     MOV 0x1046, W0
007F10  200201     MOV #0x20, W1
007F12  781801     MOV W1, [W0++]
007F14  888230     MOV W0, 0x1046
007F16  26AD81     MOV #0x6AD8, W1
007F18  500F81     SUB W0, W1, [W15]
007F1A  3A000E     BRA NZ, 0x7F38
007F1C  2FE000     MOV #0xFE00, W0
007F1E  400001     ADD W0, W1, W0
007F20  888230     MOV W0, 0x1046
007F22  37000A     BRA 0x7F38
007F24  FB8088     ZE W8, W1
007F26  808230     MOV 0x1046, W0
007F28  781801     MOV W1, [W0++]
007F2A  888230     MOV W0, 0x1046
007F2C  26AD81     MOV #0x6AD8, W1
007F2E  500F81     SUB W0, W1, [W15]
007F30  3A0003     BRA NZ, 0x7F38
007F32  2FE000     MOV #0xFE00, W0
007F34  400001     ADD W0, W1, W0
007F36  888230     MOV W0, 0x1046
154:                   if(!pad[2]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F38  268B60     MOV #0x68B6, W0
007F3A  E00410     CP0.B [W0]
007F3C  3A000B     BRA NZ, 0x7F54
007F3E  808230     MOV 0x1046, W0
007F40  200201     MOV #0x20, W1
007F42  781801     MOV W1, [W0++]
007F44  888230     MOV W0, 0x1046
007F46  26AD81     MOV #0x6AD8, W1
007F48  500F81     SUB W0, W1, [W15]
007F4A  3A000E     BRA NZ, 0x7F68
007F4C  2FE000     MOV #0xFE00, W0
007F4E  400001     ADD W0, W1, W0
007F50  888230     MOV W0, 0x1046
007F52  37000A     BRA 0x7F68
007F54  FB8088     ZE W8, W1
007F56  808230     MOV 0x1046, W0
007F58  781801     MOV W1, [W0++]
007F5A  888230     MOV W0, 0x1046
007F5C  26AD81     MOV #0x6AD8, W1
007F5E  500F81     SUB W0, W1, [W15]
007F60  3A0003     BRA NZ, 0x7F68
007F62  2FE000     MOV #0xFE00, W0
007F64  400001     ADD W0, W1, W0
007F66  888230     MOV W0, 0x1046
155:                   if(!pad[3]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F68  268B70     MOV #0x68B7, W0
007F6A  E00410     CP0.B [W0]
007F6C  3A000B     BRA NZ, 0x7F84
007F6E  808230     MOV 0x1046, W0
007F70  200201     MOV #0x20, W1
007F72  781801     MOV W1, [W0++]
007F74  888230     MOV W0, 0x1046
007F76  26AD81     MOV #0x6AD8, W1
007F78  500F81     SUB W0, W1, [W15]
007F7A  3A000E     BRA NZ, 0x7F98
007F7C  2FE000     MOV #0xFE00, W0
007F7E  400001     ADD W0, W1, W0
007F80  888230     MOV W0, 0x1046
007F82  37000A     BRA 0x7F98
007F84  FB8408     ZE W8, W8
007F86  808230     MOV 0x1046, W0
007F88  781808     MOV W8, [W0++]
007F8A  888230     MOV W0, 0x1046
007F8C  26AD81     MOV #0x6AD8, W1
007F8E  500F81     SUB W0, W1, [W15]
007F90  3A0003     BRA NZ, 0x7F98
007F92  2FE000     MOV #0xFE00, W0
007F94  400001     ADD W0, W1, W0
007F96  888230     MOV W0, 0x1046
156:               }
007F98  BE044F     MOV.D [--W15], W8
007F9A  060000     RETURN
157:               
158:               void lcdPoll(void){  
159:                   if(lcdWritePtr!=lcdReadPtr){   
007F9C  808240     MOV 0x1048, W0
007F9E  E31046     CP 0x1046
007FA0  320018     BRA Z, 0x7FD2
160:                       if((*lcdReadPtr>>8)&1) LCD_RS=0;
007FA2  201001     MOV #0x100, W1
007FA4  608090     AND W1, [W0], W1
007FA6  320002     BRA Z, 0x7FAC
007FA8  A9EE45     BCLR 0xE45, #7
007FAA  370001     BRA 0x7FAE
161:                       else LCD_RS=1;
007FAC  A8EE45     BSET 0xE45, #7
162:                       if((*lcdReadPtr>>9)&1) PR3=0x2DF0; //2DF0 for ~1.3mS
007FAE  202001     MOV #0x200, W1
007FB0  608090     AND W1, [W0], W1
007FB2  320003     BRA Z, 0x7FBA
007FB4  22DF01     MOV #0x2DF0, W1
007FB6  880871     MOV W1, PR3
007FB8  370002     BRA 0x7FBE
163:                       else PR3=0x0120; //120 for ~40uS
007FBA  201201     MOV #0x120, W1
007FBC  880871     MOV W1, PR3
164:                       PMDIN1=(*lcdReadPtr++)&0x00FF;
007FBE  200FF1     MOV #0xFF, W1
007FC0  6080B0     AND W1, [W0++], W1
007FC2  883041     MOV W1, PMDIN1
007FC4  888240     MOV W0, 0x1048
165:                       if(lcdReadPtr==&lcdBuf[LCDBUF]) lcdReadPtr=lcdBuf;
007FC6  26AD81     MOV #0x6AD8, W1
007FC8  500F81     SUB W0, W1, [W15]
007FCA  3A0003     BRA NZ, 0x7FD2
007FCC  2FE000     MOV #0xFE00, W0
007FCE  400001     ADD W0, W1, W0
007FD0  888240     MOV W0, 0x1048
166:                   } 
167:                   TMR3=0x0000; 
007FD2  EF210A     CLR TMR3
168:               }
007FD4  060000     RETURN
169:               
170:               //ALWAYS SENDS, blocks program
171:               void lcdBlockingSend(unsigned char data){
007FD6  BE9F88     MOV.D W8, [W15++]
007FD8  781F8A     MOV W10, [W15++]
007FDA  784500     MOV.B W0, W10
172:                   while(PMMODEbits.BUSY)Delay_us(2);
007FDC  E20602     CP0 PMMODE
007FDE  3D0007     BRA GE, 0x7FEE
007FE0  200028     MOV #0x2, W8
007FE2  280009     MOV #0x8000, W9
007FE4  780008     MOV W8, W0
007FE6  070386     RCALL Delay_us
007FE8  803011     MOV PMMODE, W1
007FEA  648001     AND W9, W1, W0
007FEC  3AFFFB     BRA NZ, 0x7FE4
173:                   PMDIN1=data; 
007FEE  FB850A     ZE W10, W10
007FF0  88304A     MOV W10, PMDIN1
174:               }
007FF2  78054F     MOV [--W15], W10
007FF4  BE044F     MOV.D [--W15], W8
007FF6  060000     RETURN
175:               //ALWAYS SENDS, blocks program
176:               void lcdBlockingClear(void){
007FF8  BE9F88     MOV.D W8, [W15++]
177:                   while(PMMODEbits.BUSY)Delay_us(2);
007FFA  E20602     CP0 PMMODE
007FFC  3D0007     BRA GE, 0x800C
007FFE  200028     MOV #0x2, W8
008000  280009     MOV #0x8000, W9
008002  780008     MOV W8, W0
008004  070377     RCALL Delay_us
008006  803011     MOV PMMODE, W1
008008  648001     AND W9, W1, W0
00800A  3AFFFB     BRA NZ, 0x8002
178:                   PMDIN1=LCD_CLEARDISPLAY; 
00800C  200010     MOV #0x1, W0
00800E  883040     MOV W0, PMDIN1
179:               }
008010  BE044F     MOV.D [--W15], W8
008012  060000     RETURN
180:               
181:               //ALWAYS SENDS, blocks program
182:               void lcdBlockingReturn(void){
008014  BE9F88     MOV.D W8, [W15++]
183:                   while(PMMODEbits.BUSY)Delay_us(2);
008016  E20602     CP0 PMMODE
008018  3D0007     BRA GE, 0x8028
00801A  200028     MOV #0x2, W8
00801C  280009     MOV #0x8000, W9
00801E  780008     MOV W8, W0
008020  070369     RCALL Delay_us
008022  803011     MOV PMMODE, W1
008024  648001     AND W9, W1, W0
008026  3AFFFB     BRA NZ, 0x801E
184:                   PMDIN1=LCD_RETURNHOME;
008028  200020     MOV #0x2, W0
00802A  883040     MOV W0, PMDIN1
185:               }
00802C  BE044F     MOV.D [--W15], W8
00802E  060000     RETURN
186:               
187:               void lcdInit(void){
188:                   LCD_RS=0;
008030  A9EE45     BCLR 0xE45, #7
189:                   lcdBlockingSend(0x38);              //function set, 8 bits, 2 line disp, 5x8
008032  B3C380     MOV.B #0x38, W0
008034  07FFD0     RCALL lcdBlockingSend
190:                   Delay_us(4500);                //>4.1 mS required
008036  211940     MOV #0x1194, W0
008038  07035D     RCALL Delay_us
191:                   lcdBlockingSend(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
00803A  B3C0C0     MOV.B #0xC, W0
00803C  07FFCC     RCALL lcdBlockingSend
192:                   Delay_us(4500);
00803E  211940     MOV #0x1194, W0
008040  070359     RCALL Delay_us
193:                   lcdBlockingClear();                    //Display Clear  
008042  07FFDA     RCALL lcdBlockingClear
194:                   Delay_us(1800);                //>1.64mS required
008044  207080     MOV #0x708, W0
008046  070356     RCALL Delay_us
195:                   lcdBlockingSend(0x06);               // entry Mode Set
008048  B3C060     MOV.B #0x6, W0
00804A  07FFC5     RCALL lcdBlockingSend
196:                   Delay_us(200);
00804C  200C80     MOV #0xC8, W0
00804E  070352     RCALL Delay_us
197:                   lcdBlockingReturn();
008050  07FFE1     RCALL lcdBlockingReturn
198:                   Delay_us(1500);
008052  205DC0     MOV #0x5DC, W0
008054  07034F     RCALL Delay_us
199:                   
200:                   //lcdCustomSymbols();
201:                   Delay_us(200);
008056  200C80     MOV #0xC8, W0
008058  07034D     RCALL Delay_us
202:                   lcdBlockingClear();                         //Display Clear  
00805A  07FFCE     RCALL lcdBlockingClear
203:                   Delay_us(1500);
00805C  205DC0     MOV #0x5DC, W0
00805E  07034A     RCALL Delay_us
204:                   lcdBlockingReturn();
008060  07FFD9     RCALL lcdBlockingReturn
205:                   Delay_us(200);
008062  200C80     MOV #0xC8, W0
008064  070347     RCALL Delay_us
206:               }
008066  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/main.c  -----------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 #include "plcd.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = OFF   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                /* Data Buffers & index variables */
22:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
23:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
24:                unsigned int write_ptr=STREAMBUF, rw=0, frameReady=0;
25:                
26:                /* DMA BUFFERS */
27:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
28:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
29:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
31:                
32:                
33:                /* Debug Variables */
34:                unsigned int process_time=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                              
37:                volatile unsigned char recording=TRUE;
38:                unsigned char UART_ON = FALSE;
39:                unsigned char TEST_SIN = FALSE;
40:                
41:                volatile unsigned char tremelo=FALSE;                                       
42:                volatile unsigned char looper=FALSE;
43:                volatile unsigned char lpf=FALSE;
44:                
45:                char flash_readback[512]={0};
46:                
47:                /* Screen state variables */
48:                enum screen state = scrnFX;
49:                enum screen laststate = invalid;
50:                
51:                /* Buttons & Potentiometers */
52:                unsigned char pad[BUTTONS];                                                            
53:                fractional pots[POTS]={0};
54:                fractional pots_percent[POTS]={0};
55:                fractional pots_custom[POTS]={0};
56:                
57:                void initBuffer(void){
008E64  264B27     MOV #0x64B2, W7
008E66  266B26     MOV #0x66B2, W6
008E68  2CDFE5     MOV #0xCDFE, W5
008E6A  2CBFE4     MOV #0xCBFE, W4
008E6C  2C9FE3     MOV #0xC9FE, W3
008E6E  2C7FE2     MOV #0xC7FE, W2
008E70  201001     MOV #0x100, W1
008E86  200232     MOV #0x23, W2
008E88  410100     ADD W2, W0, W2
58:                    int i;
59:                    for(i=0; i<STREAMBUF; i++){
008E82  3AFFF8     BRA NZ, 0x8E74
008E84  268B30     MOV #0x68B3, W0
60:                        streamA[i]=0;
008E72  EB0000     CLR W0
008E74  782B80     MOV W0, [++W7]
61:                        streamB[i]=0;
008E76  782B00     MOV W0, [++W6]
62:                        txBufferA[i]=0;
008E78  782A80     MOV W0, [++W5]
63:                        txBufferB[i]=0;
008E7A  782A00     MOV W0, [++W4]
64:                        rxBufferA[i]=0;
008E7C  782980     MOV W0, [++W3]
65:                        rxBufferB[i]=0;
008E7E  782900     MOV W0, [++W2]
008E80  E90081     DEC W1, W1
66:                    }
67:                    
68:                    for(i=0; i<BUTTONS; i++)
008E8E  500F82     SUB W0, W2, [W15]
008E90  3AFFFD     BRA NZ, 0x8E8C
69:                        pad[i]=1;
008E8A  B3C011     MOV.B #0x1, W1
008E8C  786801     MOV.B W1, [++W0]
70:                }
008E92  060000     RETURN
71:                
72:                int main(void) {
008E94  BE9F88     MOV.D W8, [W15++]
008E96  BE9F8A     MOV.D W10, [W15++]
008E98  781F8C     MOV W12, [W15++]
73:                    initPorts();                    //configure io device & adc 
008E9A  07F8E6     RCALL initPorts
74:                    //initUART1();                    //configure & enable UART
75:                    initBuffer();
008E9C  07FFE3     RCALL initBuffer
76:                    initADC1();                     //configure & enable internal ADC
008E9E  07F9AB     RCALL initADC1
77:                    initPMP();
008EA0  07F9C8     RCALL initPMP
78:                    //||||||||----
79:                    //initDMA0();
80:                    initDCI_DAC();                  //configure & enable DAC
008EA2  07FA06     RCALL initDCI_DAC
81:                    initT1();                       //configure & start T1 
008EA4  07F9DA     RCALL initT1
82:                    initT2();                       //configure & start T2 
008EA6  07F9E2     RCALL initT2
83:                    initSPI3_MEM();                  //start segment display
008EA8  07FA7B     RCALL initSPI3_MEM
84:                    //initCAP_BPM();                  //configure bpm capture
85:                    initT3();                       //configure & start T3 for lcd
008EAA  07F9EC     RCALL initT3
86:                    initQEI_ENC();
008EAC  07FA9B     RCALL initQEI_ENC
87:                    //initT5();
88:                    fractional temp;
89:                    fractional *ping, *pong;
90:                    
91:                    while(1){    
92:                        if(frameReady) {
008EB8  E21014     CP0 frameReady
008EBA  32000F     BRA Z, 0x8EDA
93:                            process_time=(STREAMBUF-1);             //DEBUG
008EBC  200FF0     MOV #0xFF, W0
008EBE  8880B0     MOV W0, process_time
94:                            if(rw){
008EC0  E21012     CP0 rw
008EC2  320003     BRA Z, 0x8ECA
95:                                ping = streamA+(STREAMBUF-1);
008EB4  266B2C     MOV #0x66B2, W12
008EC6  78000C     MOV W12, W0
008EC8  370002     BRA 0x8ECE
96:                                pong = outputB+(STREAMBUF-1);
008EB2  264B2B     MOV #0x64B2, W11
008EC4  78008B     MOV W11, W1
97:                            }else{
98:                                ping = streamB+(STREAMBUF-1);
008EB0  268B2A     MOV #0x68B2, W10
008ECC  78000A     MOV W10, W0
99:                                pong = outputA+(STREAMBUF-1);
008EAE  262B29     MOV #0x62B2, W9
008ECA  780089     MOV W9, W1
100:                           }
101:                           
102:                           processAudio(ping, pong); 
008ECE  07FE15     RCALL processAudio
103:                           process_time=(STREAMBUF-1)-write_ptr;    //DEBUG
008ED0  8081D0     MOV 0x103A, W0
008ED2  200FF1     MOV #0xFF, W1
008ED4  508000     SUB W1, W0, W0
008ED6  8880B0     MOV W0, process_time
104:                           frameReady=0;
008ED8  EF3014     CLR frameReady
105:                           
106:                           
107:                       }
108:                       if(_T2IF){
008EDA  ABE800     BTST IFS0, #7
008EDC  320006     BRA Z, 0x8EEA
109:                           scanButtons();                   //read button matrix
008EDE  07FA89     RCALL scanButtons
110:                           if(_AD1IF) readPots();
008EB6  220008     MOV #0x2000, W8
008EE0  804001     MOV IFS0, W1
008EE2  640001     AND W8, W1, W0
008EE4  320001     BRA Z, 0x8EE8
008EE6  07FB29     RCALL readPots
111:                           _T2IF=0;
008EE8  A9E800     BCLR IFS0, #7
112:                       }
113:                       if(_T1IF){
008EEA  AB6800     BTST IFS0, #3
008EEC  320002     BRA Z, 0x8EF2
114:                           display();
008EEE  07FBE1     RCALL display
115:                           _T1IF=0;
008EF0  A96800     BCLR IFS0, #3
116:                       }
117:                       if(_T3IF) {
008EF2  AB0801     BTST 0x801, #0
008EF4  32FFE1     BRA Z, 0x8EB8
118:                           lcdPoll();
008EF6  07F852     RCALL lcdPoll
119:                           _T3IF=0;
008EF8  A90801     BCLR 0x801, #0
008EFA  37FFDE     BRA 0x8EB8
120:                       }
121:                   }
122:                   return 0;
123:               }
124:               // example test 
---  C:/Users/ryan/Documents/seniorproject/ps-040/flash.c  ----------------------------------------------
1:                 /*
2:                  * File:   flash.c
3:                  * Author: root
4:                  *
5:                  * Created on January 28, 2018, 5:00 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "flash.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                char flashBuf[STREAMBUF*2];
15:                char receive;
16:                
17:                void flashWriteReg(char command) {
18:                    SS3=0;
008D3E  A92E54     BCLR LATF, #1
19:                    SPI3BUF=command;               //WEL=1 for write enable
008D40  FB0000     SE W0, W0
008D42  881540     MOV W0, SPI3BUF
20:                    while(!_SPI3IF); _SPI3IF=0;
008D44  208001     MOV #0x800, W1
008D46  804052     MOV IFS5, W2
008D48  608002     AND W1, W2, W0
008D4A  32FFFD     BRA Z, 0x8D46
008D4C  A9680B     BCLR 0x80B, #3
21:                    receive=SPI3BUF;
008D4E  801540     MOV SPI3BUF, W0
008D50  B7F04A     MOV.B WREG, receive
22:                    SS3=1;
008D52  A82E54     BSET LATF, #1
23:                }
008D54  060000     RETURN
24:                
25:                char flashStatusCheck(void){
26:                    SS3=0;
008D56  A92E54     BCLR LATF, #1
27:                    SPI3BUF=FLASH_RDSR1;               //WEL=1 for write enable
008D58  200050     MOV #0x5, W0
008D5A  881540     MOV W0, SPI3BUF
28:                    while(!_SPI3IF); _SPI3IF=0;
008D5C  208001     MOV #0x800, W1
008D5E  804052     MOV IFS5, W2
008D60  608002     AND W1, W2, W0
008D62  32FFFD     BRA Z, 0x8D5E
008D64  A9680B     BCLR 0x80B, #3
29:                    receive=SPI3BUF;
008D66  801540     MOV SPI3BUF, W0
30:                    SPI3BUF=0x00;               //WEL=1 for write enable
008D68  EF22A8     CLR SPI3BUF
31:                    while(!_SPI3IF); _SPI3IF=0;
008D6A  208001     MOV #0x800, W1
008D6C  804052     MOV IFS5, W2
008D6E  608002     AND W1, W2, W0
008D70  32FFFD     BRA Z, 0x8D6C
008D72  A9680B     BCLR 0x80B, #3
32:                    receive=SPI3BUF;
008D74  801540     MOV SPI3BUF, W0
008D76  B7F04A     MOV.B WREG, receive
33:                    SS3=1;
008D78  A82E54     BSET LATF, #1
34:                    
35:                    return receive;
36:                }
008D7A  060000     RETURN
37:                
38:                void flashWritePage(int addressH, int addressL){
39:                    int i;
40:                    SS3=0;
008D7C  A92E54     BCLR LATF, #1
41:                    SPI3BUF=FLASH_PP;
008D7E  200022     MOV #0x2, W2
008D80  881542     MOV W2, SPI3BUF
42:                    while(!_SPI3IF); _SPI3IF=0;
008D82  208003     MOV #0x800, W3
008D84  804054     MOV IFS5, W4
008D86  618104     AND W3, W4, W2
008D88  32FFFD     BRA Z, 0x8D84
008D8A  A9680B     BCLR 0x80B, #3
43:                    receive=SPI3BUF;
008D8C  801542     MOV SPI3BUF, W2
44:                    SPI3BUF=addressH&&0xFF;
008D8E  A7F000     BTSC W0, #15
008D90  EA0000     NEG W0, W0
008D92  EA0000     NEG W0, W0
008D94  DE004F     LSR W0, #15, W0
008D96  881540     MOV W0, SPI3BUF
45:                    while(!_SPI3IF); _SPI3IF=0;
008D98  208002     MOV #0x800, W2
008D9A  804053     MOV IFS5, W3
008D9C  610003     AND W2, W3, W0
008D9E  32FFFD     BRA Z, 0x8D9A
008DA0  A9680B     BCLR 0x80B, #3
46:                    receive=SPI3BUF;
008DA2  801540     MOV SPI3BUF, W0
47:                    SPI3BUF=(addressL&&0xFF00)>>8;
008DA4  EF22A8     CLR SPI3BUF
48:                    while(!_SPI3IF); _SPI3IF=0;
008DA6  208002     MOV #0x800, W2
008DA8  804054     MOV IFS5, W4
008DAA  610004     AND W2, W4, W0
008DAC  32FFFD     BRA Z, 0x8DA8
008DAE  A9680B     BCLR 0x80B, #3
49:                    receive=SPI3BUF;
008DB0  801540     MOV SPI3BUF, W0
50:                    SPI3BUF=addressL&&0xFF;
008DB2  780001     MOV W1, W0
008DB4  A7F000     BTSC W0, #15
008DB6  EA0000     NEG W0, W0
008DB8  EA0000     NEG W0, W0
008DBA  DE004F     LSR W0, #15, W0
008DBC  881540     MOV W0, SPI3BUF
51:                    while(!_SPI3IF); _SPI3IF=0;
008DBE  208001     MOV #0x800, W1
008DC0  804052     MOV IFS5, W2
008DC2  608002     AND W1, W2, W0
008DC4  32FFFD     BRA Z, 0x8DC0
008DC6  A9680B     BCLR 0x80B, #3
52:                    receive=SPI3BUF;
008DC8  801540     MOV SPI3BUF, W0
008DCA  202002     MOV #0x200, W2
53:                    
54:                    for(i=0; i<512;i++){    //write 512 bytes
008DDE  3AFFF8     BRA NZ, 0x8DD0
008DE0  B7F04A     MOV.B WREG, receive
55:                        //send byte
56:                        SPI3BUF=0xAA;
008DCC  200AA3     MOV #0xAA, W3
008DD0  881543     MOV W3, SPI3BUF
57:                        while(!_SPI3IF); _SPI3IF=0;
008DCE  208001     MOV #0x800, W1
008DD2  804054     MOV IFS5, W4
008DD4  608004     AND W1, W4, W0
008DD6  32FFFD     BRA Z, 0x8DD2
008DD8  A9680B     BCLR 0x80B, #3
58:                        receive=SPI3BUF;
008DDA  801540     MOV SPI3BUF, W0
008DDC  E90102     DEC W2, W2
59:                    }
60:                    SS3=1;
008DE2  A82E54     BSET LATF, #1
61:                }
008DE4  060000     RETURN
62:                
63:                void flashRead(char *array, int bytes){
008DE6  BE9F88     MOV.D W8, [W15++]
008DE8  BE9F8A     MOV.D W10, [W15++]
008DEA  781F8C     MOV W12, [W15++]
008DEC  780581     MOV W1, W11
64:                    int i;
65:                    
66:                    SS3=0;
008DEE  A92E54     BCLR LATF, #1
67:                    SPI3BUF=FLASH_READ;
008DF0  200031     MOV #0x3, W1
008DF2  881541     MOV W1, SPI3BUF
68:                    while(!_SPI3IF); _SPI3IF=0;
008DF4  208002     MOV #0x800, W2
008DF6  804053     MOV IFS5, W3
008DF8  610083     AND W2, W3, W1
008DFA  32FFFD     BRA Z, 0x8DF6
008DFC  A9680B     BCLR 0x80B, #3
69:                    receive=SPI3BUF;
008DFE  801541     MOV SPI3BUF, W1
70:                    SPI3BUF=0x00;
008E00  EF22A8     CLR SPI3BUF
71:                    while(!_SPI3IF); _SPI3IF=0;
008E02  208002     MOV #0x800, W2
008E04  804053     MOV IFS5, W3
008E06  610083     AND W2, W3, W1
008E08  32FFFD     BRA Z, 0x8E04
008E0A  A9680B     BCLR 0x80B, #3
72:                    receive=SPI3BUF;
008E0C  801541     MOV SPI3BUF, W1
73:                    SPI3BUF=0x00;
008E0E  EF22A8     CLR SPI3BUF
74:                    while(!_SPI3IF); _SPI3IF=0;
008E10  208002     MOV #0x800, W2
008E12  804053     MOV IFS5, W3
008E14  610083     AND W2, W3, W1
008E16  32FFFD     BRA Z, 0x8E12
008E18  A9680B     BCLR 0x80B, #3
75:                    receive=SPI3BUF;
008E1A  801541     MOV SPI3BUF, W1
76:                    SPI3BUF=0x00;
008E1C  EF22A8     CLR SPI3BUF
77:                    while(!_SPI3IF); _SPI3IF=0;
008E1E  208002     MOV #0x800, W2
008E20  804053     MOV IFS5, W3
008E22  610083     AND W2, W3, W1
008E24  32FFFD     BRA Z, 0x8E20
008E26  A9680B     BCLR 0x80B, #3
78:                    receive=SPI3BUF;
008E28  801541     MOV SPI3BUF, W1
008E2A  784181     MOV.B W1, W3
008E2C  2104A2     MOV #0x104A, W2
008E2E  784903     MOV.B W3, [W2]
79:                    
80:                    for(i=0; i<bytes;i++){    //read 512 bytes
008E30  E0000B     CP0 W11
008E32  340010     BRA LE, 0x8E54
008E34  780500     MOV W0, W10
008E36  EB0480     CLR W9
008E4E  E80489     INC W9, W9
008E50  558F89     SUB W11, W9, [W15]
008E52  3CFFF4     BRA GT, 0x8E3C
81:                        //receive byte
82:                        SPI3BUF=0x00;
008E38  EB0600     CLR W12
008E3C  88154C     MOV W12, SPI3BUF
83:                        while(!_SPI3IF); _SPI3IF=0;
008E3A  208008     MOV #0x800, W8
008E3E  804051     MOV IFS5, W1
008E40  640001     AND W8, W1, W0
008E42  32FFFD     BRA Z, 0x8E3E
008E44  A9680B     BCLR 0x80B, #3
84:                        Delay_us(1);
008E46  200010     MOV #0x1, W0
008E48  07FC55     RCALL Delay_us
85:                        array[i]=SPI3BUF;
008E4A  801540     MOV SPI3BUF, W0
008E4C  785D00     MOV.B W0, [W10++]
86:                    }
87:                    SS3=1;
008E54  A82E54     BSET LATF, #1
88:                }
008E56  78064F     MOV [--W15], W12
008E58  BE054F     MOV.D [--W15], W10
008E5A  BE044F     MOV.D [--W15], W8
008E5C  060000     RETURN
89:                
90:                void flashBulkErase(void) {
91:                    flashWriteReg(FLASH_FRMT);
008E5E  B3C600     MOV.B #0x60, W0
008E60  07FF6E     RCALL flashWriteReg
92:                }
008E62  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/devInits.c  -------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 #include <xc.h>
5:                 #include <p33EP512GM310.h>
6:                 #include <libpic30.h>
7:                 #include "common.h"
8:                 #include "devInits.h"
9:                 #include "utilities.h"
10:                #include "plcd.h"
11:                #include "screens.h"
12:                #include "flash.h"
13:                #include "dsp.h"
14:                
15:                extern unsigned char UART_ON;
16:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
17:                
18:                extern char flash_readback[512];
19:                
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
008068  2FF3F0     MOV #0xFF3F, W0
00806A  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
00806C  2FFE00     MOV #0xFFE0, W0
00806E  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
008070  2FE000     MOV #0xFE00, W0
008072  B60746     AND PLLFBD, WREG
008074  B30490     IOR #0x49, W0
008076  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
008078  200201     MOV #0x20, W1
00807A  803A12     MOV OSCCON, W2
00807C  608002     AND W1, W2, W0
00807E  32FFFD     BRA Z, 0x807A
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
008080  803A10     MOV OSCCON, W0
008082  A16000     BCLR W0, #6
008084  200462     MOV #0x46, W2
008086  200573     MOV #0x57, W3
008088  207421     MOV #0x742, W1
00808A  784882     MOV.B W2, [W1]
00808C  784883     MOV.B W3, [W1]
00808E  784880     MOV.B W0, [W1]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
008090  2FFC00     MOV #0xFFC0, W0
008092  803424     MOV RPOR2, W4
008094  600084     AND W0, W4, W1
008096  A00001     BSET W1, #0
008098  883421     MOV W1, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
00809A  2FF801     MOV #0xFF80, W1
00809C  803685     MOV RPINR24, W5
00809E  608205     AND W1, W5, W4
0080A0  B303D4     IOR #0x3D, W4
0080A2  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
0080A4  B60686     AND RPOR3, WREG
0080A6  B300C0     IOR #0xC, W0
0080A8  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
0080AA  2C0FF0     MOV #0xC0FF, W0
0080AC  803426     MOV RPOR2, W6
0080AE  600286     AND W0, W6, W5
0080B0  20D004     MOV #0xD00, W4
0080B2  720205     IOR W4, W5, W4
0080B4  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
0080B6  803434     MOV RPOR3, W4
0080B8  600284     AND W0, W4, W5
0080BA  20B004     MOV #0xB00, W4
0080BC  720205     IOR W4, W5, W4
0080BE  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
0080C0  803575     MOV RPINR7, W5
0080C2  608205     AND W1, W5, W4
0080C4  B305F4     IOR #0x5F, W4
0080C6  883574     MOV W4, RPINR7
36:                    RPINR29bits.SCK3R=0x39;     //SCK3 input on pin 84
0080C8  280FF4     MOV #0x80FF, W4
0080CA  8036D5     MOV RPINR29, W5
0080CC  620305     AND W4, W5, W6
0080CE  239005     MOV #0x3900, W5
0080D0  728286     IOR W5, W6, W5
0080D2  8836D5     MOV W5, RPINR29
37:                    RPOR7bits.RP57R=0x20;       //SCK3 output on pin 84
0080D4  803476     MOV RPOR7, W6
0080D6  600286     AND W0, W6, W5
0080D8  A0D005     BSET W5, #13
0080DA  883475     MOV W5, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
0080DC  803485     MOV RPOR8, W5
0080DE  600305     AND W0, W5, W6
0080E0  21F005     MOV #0x1F00, W5
0080E2  728286     IOR W5, W6, W5
0080E4  883485     MOV W5, RPOR8
39:                    RPOR9bits.RP97R=0x21;       //SS3 on pin 88
0080E6  B60692     AND RPOR9, WREG
0080E8  221005     MOV #0x2100, W5
0080EA  728280     IOR W5, W0, W5
0080EC  883495     MOV W5, RPOR9
40:                    RPINR29bits.SDI3R=0x4C;     //SDI on pin 79, RPI76
0080EE  8036D6     MOV RPINR29, W6
0080F0  608006     AND W1, W6, W0
0080F2  B304C0     IOR #0x4C, W0
0080F4  8836D0     MOV W0, RPINR29
41:                    RPINR14bits.QEA1R=0x10;     //QEA on pin 22, RPI16
0080F6  8035E0     MOV RPINR14, W0
0080F8  608080     AND W1, W0, W1
0080FA  A04001     BSET W1, #4
0080FC  8835E1     MOV W1, RPINR14
42:                    RPINR14bits.QEB1R=0x1B;     //QEB on pin 21, RPI27
0080FE  8035E5     MOV RPINR14, W5
008100  620205     AND W4, W5, W4
008102  21B000     MOV #0x1B00, W0
008104  700004     IOR W0, W4, W0
008106  8835E0     MOV W0, RPINR14
43:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
008108  803A10     MOV OSCCON, W0
00810A  A06000     BSET W0, #6
00810C  207421     MOV #0x742, W1
00810E  784882     MOV.B W2, [W1]
008110  784883     MOV.B W3, [W1]
008112  784880     MOV.B W0, [W1]
44:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
45:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
008114  EB8000     SETM W0
008116  883B60     MOV W0, PMD7
008118  F8076C     PUSH PMD7
00811A  F9076A     POP PMD6
00811C  F8076A     PUSH PMD6
00811E  F90766     POP PMD4
008120  F80766     PUSH PMD4
008122  F90764     POP PMD3
008124  F80764     PUSH PMD3
008126  F90762     POP PMD2
008128  F80762     PUSH PMD2
00812A  F90760     POP PMD1
46:                    PMD1bits.AD1MD=0;
00812C  A90760     BCLR PMD1, #0
47:                    PMD1bits.SPI1MD=0;
00812E  A96760     BCLR PMD1, #3
48:                    PMD1bits.SPI2MD=0;
008130  A98760     BCLR PMD1, #4
49:                    PMD1bits.U1MD=0;
008132  A9A760     BCLR PMD1, #5
50:                    PMD1bits.U2MD=0;
008134  A9C760     BCLR PMD1, #6
51:                    PMD1bits.DCIMD=0;
008136  A90761     BCLR 0x761, #0
52:                    PMD1bits.T1MD=0;
008138  A96761     BCLR 0x761, #3
53:                    PMD1bits.T2MD=0;
00813A  A98761     BCLR 0x761, #4
54:                    PMD1bits.T3MD=0;
00813C  A9A761     BCLR 0x761, #5
55:                    PMD1bits.T4MD=0;
00813E  A9C761     BCLR 0x761, #6
56:                    PMD1bits.T5MD=0;
008140  A9E761     BCLR 0x761, #7
57:                    PMD3bits.PMPMD=0;
008142  A90765     BCLR 0x765, #0
58:                    PMD3bits.CMPMD=0;
008144  A94765     BCLR 0x765, #2
59:                    PMD6bits.SPI3MD=0;
008146  A9076A     BCLR PMD6, #0
60:                    PMD7bits.DMA0MD=0;
008148  A9876C     BCLR PMD7, #4
61:                    
62:                    /* Digital IO DIRECTION (1 = input) */
63:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
00814A  EF2E60     CLR TRISG
00814C  F80E60     PUSH TRISG
00814E  F90E50     POP TRISF
008150  F80E50     PUSH TRISF
008152  F90E40     POP TRISE
008154  F80E40     PUSH TRISE
008156  F90E30     POP TRISD
008158  F80E30     PUSH TRISD
00815A  F90E20     POP TRISC
00815C  F80E20     PUSH TRISC
00815E  F90E10     POP TRISB
008160  F80E10     PUSH TRISB
008162  F90E00     POP TRISA
64:                    TRISA=0x1E01; CNPUA=0x0801;
008164  21E011     MOV #0x1E01, W1
008166  887001     MOV W1, TRISA
008168  208011     MOV #0x801, W1
00816A  887051     MOV W1, CNPUA
65:                    TRISB=0x0000; CNPUB=0x0000;
00816C  EF2E10     CLR TRISB
00816E  EF2E1A     CLR CNPUB
66:                    TRISC=0x2087;
008170  220871     MOV #0x2087, W1
008172  887101     MOV W1, TRISC
67:                    TRISD=0x011E; CNPUD=0x001E;
008174  2011E1     MOV #0x11E, W1
008176  887181     MOV W1, TRISD
008178  2001E1     MOV #0x1E, W1
00817A  8871D1     MOV W1, CNPUD
68:                    TRISE=0x7300;
00817C  273001     MOV #0x7300, W1
00817E  887201     MOV W1, TRISE
69:                    TRISF=0x00F0; CNPUF=0x00F1;
008180  200F01     MOV #0xF0, W1
008182  887281     MOV W1, TRISF
008184  E80081     INC W1, W1
008186  8872D1     MOV W1, CNPUF
70:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
008188  887350     MOV W0, CNPUG
00818A  F80E6A     PUSH CNPUG
00818C  F90E60     POP TRISG
71:                    
72:                    /* DIGITAL OUTPUT LATCH */
73:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
00818E  EF2E64     CLR LATG
008190  F80E64     PUSH LATG
008192  F90E54     POP LATF
008194  F80E54     PUSH LATF
008196  F90E44     POP LATE
008198  F80E44     PUSH LATE
00819A  F90E34     POP LATD
00819C  F80E34     PUSH LATD
00819E  F90E24     POP LATC
0081A0  F80E24     PUSH LATC
0081A2  F90E14     POP LATB
0081A4  F80E14     PUSH LATB
0081A6  F90E04     POP LATA
74:                    LATA=0x0040;
0081A8  200400     MOV #0x40, W0
0081AA  887020     MOV W0, LATA
75:                    
76:                    /* ANALOG PINS (1 = analog) */
77:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
0081AC  EF2E6E     CLR ANSELG
0081AE  F80E6E     PUSH ANSELG
0081B0  F90E5E     POP ANSELF
0081B2  F80E5E     PUSH ANSELF
0081B4  F90E4E     POP ANSELE
0081B6  F80E4E     PUSH ANSELE
0081B8  F90E3E     POP ANSELD
0081BA  F80E3E     PUSH ANSELD
0081BC  F90E2E     POP ANSELC
0081BE  F80E2E     PUSH ANSELC
0081C0  F90E1E     POP ANSELB
0081C2  F80E1E     PUSH ANSELB
0081C4  F90E0E     POP ANSELA
78:                    ANSELCbits.ANSC0=1;     //AN6
0081C6  A80E2E     BSET ANSELC, #0
79:                    ANSELCbits.ANSC1=1;     //AN7
0081C8  A82E2E     BSET ANSELC, #1
80:                    ANSELCbits.ANSC2=1;     //AN8
0081CA  A84E2E     BSET ANSELC, #2
81:                    ANSELAbits.ANSA12=1;    //AN10 
0081CC  A88E0F     BSET 0xE0F, #4
82:                    ANSELEbits.ANSE8=1;     //AN21
0081CE  A80E4F     BSET 0xE4F, #0
83:                    ANSELEbits.ANSE9=1;     //AN20
0081D0  A82E4F     BSET 0xE4F, #1
84:                    
85:                    
86:                    
87:                }
0081D2  060000     RETURN
88:                
89:                void initUART1(void){
90:                    IFS0bits.U1TXIF = 0;        //clear flag
0081D4  A98801     BCLR 0x801, #4
91:                    IFS0bits.U1RXIF = 0;        //clear flag
0081D6  A96801     BCLR 0x801, #3
92:                    U1STA=0x1510;               //enable tx & rx
0081D8  215100     MOV #0x1510, W0
0081DA  881110     MOV W0, U1STA
93:                    U1BRG=BRGVAL;               //baud rate
0081DC  2004A0     MOV #0x4A, W0
0081DE  881140     MOV W0, U1BRG
94:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
0081E0  2FFF90     MOV #0xFFF9, W0
0081E2  B60220     AND U1MODE, WREG
0081E4  A01000     BSET W0, #1
0081E6  881100     MOV W0, U1MODE
95:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
0081E8  270000     MOV #0x7000, W0
0081EA  B72844     IOR IPC2
96:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
0081EC  200070     MOV #0x7, W0
0081EE  B72846     IOR IPC3
97:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
98:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
99:                    U1MODEbits.UARTEN = 1;      //start uart
0081F0  A8E221     BSET 0x221, #7
100:                   UART_ON = TRUE;
0081F2  EFF019     SETM.B UART_ON
101:                   
102:               }
0081F4  060000     RETURN
103:               
104:               void initADC1(void){ 
105:               
106:                   /* Assign MUXA inputs */
107:                   AD1CON1 = 0x04E4; // Enable 12-bit mode, auto-sample and auto-conversion
0081F6  204E40     MOV #0x4E4, W0
0081F8  881900     MOV W0, AD1CON1
108:                   AD1CON2 = 0x0408; // Sample alternately using channel scanning
0081FA  B10DC0     SUB #0xDC, W0
0081FC  881910     MOV W0, AD1CON2
109:                   AD1CON2bits.SMPI=(POTS/2)-1; // Sample 6 channels
0081FE  2FF830     MOV #0xFF83, W0
008200  B60322     AND AD1CON2, WREG
008202  B30140     IOR #0x14, W0
008204  881910     MOV W0, AD1CON2
110:                   AD1CON3 = 0x0F0F; // Sample for 15*TAD before converting
008206  20F0F0     MOV #0xF0F, W0
008208  881920     MOV W0, AD1CON3
111:                   AD1CON1bits.FORM=2;         //signed fractional format 
00820A  2FCFF0     MOV #0xFCFF, W0
00820C  B60320     AND AD1CON1, WREG
00820E  A09000     BSET W0, #9
008210  881900     MOV W0, AD1CON1
112:                   AD1CON3bits.ADCS=0x07;
008212  B3C070     MOV.B #0x7, W0
008214  B7E324     MOV.B WREG, AD1CON3
113:                   AD1CON3bits.SAMC=0x03;
008216  2E0FF0     MOV #0xE0FF, W0
008218  B60324     AND AD1CON3, WREG
00821A  B33000     IOR #0x300, W0
00821C  881920     MOV W0, AD1CON3
114:                   //select  AN6,7,8
115:                   AD1CSSLbits.CSS6=1; //AN6
00821E  A8C330     BSET AD1CSSL, #6
116:                   AD1CSSLbits.CSS7=1; //AN7
008220  A8E330     BSET AD1CSSL, #7
117:                   AD1CSSLbits.CSS8=1; //AN8
008222  A80331     BSET 0x331, #0
118:                   AD1CSSLbits.CSS10=1;//AN10
008224  A84331     BSET 0x331, #2
119:                   AD1CSSHbits.CSS20=1;//AN20
008226  A8832E     BSET AD1CSSH, #4
120:                   AD1CSSHbits.CSS21=1;//AN21
008228  A8A32E     BSET AD1CSSH, #5
121:                   //AD1CSSLbits.CSS9=1; //AN9
122:                   /* Enable ADC module and provide ADC stabilization delay */
123:                   AD1CON1bits.ADON = 1;
00822A  A8E321     BSET 0x321, #7
124:                   Delay_us(30);
00822C  2001E0     MOV #0x1E, W0
00822E  070262     RCALL Delay_us
125:               }
008230  060000     RETURN
126:               
127:               void initPMP(void){
128:                   /*
129:                    Data is clocked on falling edge of E
130:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
131:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
132:                    */
133:                   PMMODEbits.MODE=3;  //master mode 1 
008232  203000     MOV #0x300, W0
008234  B72602     IOR PMMODE
134:                   PMCONbits.PTWREN = 1;
008236  A82601     BSET 0x601, #1
135:                   PMCONbits.PTRDEN = 1;
008238  A80601     BSET 0x601, #0
136:                   PMCONbits.WRSP=1;   //write strobe active high
00823A  A82600     BSET PMCON, #1
137:                   PMCONbits.RDSP=1;   //read strobe active high
00823C  A80600     BSET PMCON, #0
138:               
139:                   PMMODEbits.WAITB = 0;
00823E  2FF3F0     MOV #0xFF3F, W0
008240  B62602     AND PMMODE
140:                   PMMODEbits.WAITM = 0xC;
008242  2FFC30     MOV #0xFFC3, W0
008244  B60602     AND PMMODE, WREG
008246  B30300     IOR #0x30, W0
008248  883010     MOV W0, PMMODE
141:                   PMMODEbits.WAITE = 0;
00824A  2FFFC0     MOV #0xFFFC, W0
00824C  B62602     AND PMMODE
142:                   LCD_RS=0;
00824E  A9EE45     BCLR 0xE45, #7
143:                   PMCONbits.PMPEN = 1;
008250  A8E601     BSET 0x601, #7
144:                   
145:                   /* INIT DEVICE */
146:                   Delay_us(40000);
008252  29C400     MOV #0x9C40, W0
008254  07024F     RCALL Delay_us
147:                   lcdInit();
008256  07FEEC     RCALL lcdInit
148:                   
149:                   /* SETUP SCREEN */
150:                   //lcdSetupPots();
151:               }
008258  060000     RETURN
152:               
153:               
154:               //Description: Initializes timer for LED's UART and display
155:               //Prereq: initUART1()
156:               //Dependencies: _T1Interrupt(void)
157:               //Frequency: 15Hz
158:               void initT1(void){          //16 bit timer
159:                   TMR1 = 0x0000;          //clear timer 4
00825A  EF2100     CLR TMR1
160:                   T1CONbits.TCKPS = 3;    //prescale 1:256
00825C  200300     MOV #0x30, W0
00825E  B72104     IOR T1CON
161:                   T1CONbits.TCS = 0;      //use internal clock
008260  A92104     BCLR T1CON, #1
162:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
008262  A9C104     BCLR T1CON, #6
163:                   PR1 = Fcy/(256*Fdisp);    //period register
008264  246500     MOV #0x4650, W0
008266  880810     MOV W0, PR1
164:                   //PR1=0x7FFF;
165:               
166:                   T1CONbits.TON = 1;      //start timer
008268  A8E105     BSET 0x105, #7
167:               }
00826A  060000     RETURN
168:               
169:               //Description:  Initializes timer handles polling button input
170:               //Prereq: initADC1() 
171:               //Dependencies: _T2Interrupt(void)
172:               //Frequency: 512Hz
173:               void initT2(void){          //16/32 bit timer
174:                   TMR2 = 0x0000;          //clear timer 4
00826C  EF2106     CLR TMR2
175:                   T2CONbits.T32 = 0;      //16 bit mode
00826E  A96110     BCLR T2CON, #3
176:                   T2CONbits.TCKPS = 1;    //prescale 1:8
008270  2FFCF0     MOV #0xFFCF, W0
008272  B60110     AND T2CON, WREG
008274  A04000     BSET W0, #4
008276  880880     MOV W0, T2CON
177:                   T2CONbits.TCS = 0;      //use internal clock
008278  A92110     BCLR T2CON, #1
178:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
00827A  A9C110     BCLR T2CON, #6
179:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
00827C  283D60     MOV #0x83D6, W0
00827E  880860     MOV W0, PR2
180:               
181:                   T2CONbits.TON = 1;      //start timer
008280  A8E111     BSET 0x111, #7
182:               }
008282  060000     RETURN
183:               
184:               //Description: Initialize timer handling LCD sending
185:               //Dependencies: _T3Interrupt(void)
186:               //Frequency: 44.1kHz
187:               void initT3(void){          //16/32 bit timer
188:                   TMR3 = 0x0000;          //clear timer 3
008284  EF210A     CLR TMR3
189:                   T3CONbits.TCKPS = 1;    //prescale 8:1
008286  2FFCF0     MOV #0xFFCF, W0
008288  B60112     AND T3CON, WREG
00828A  A04000     BSET W0, #4
00828C  880890     MOV W0, T3CON
190:                   T3CONbits.TCS = 0;      //use internal clock
00828E  A92112     BCLR T3CON, #1
191:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
008290  A9C112     BCLR T3CON, #6
192:                   //PR3 = Fcy/(256*T3freq);           //period register
193:                   PR3 = 0x01D0;           //45uS initial delay
008292  201D00     MOV #0x1D0, W0
008294  880870     MOV W0, PR3
194:                   
195:                   T3CONbits.TON = 1;
008296  A8E113     BSET 0x113, #7
196:                   
197:               }
008298  060000     RETURN
198:               
199:               /*=============================================================================  
200:               Timer 5 is setup to time-out every 125 microseconds (8Khz Rate). As a result, the module 
201:               will stop sampling and trigger a conversion on every Timer3 time-out, i.e., Ts=125us. 
202:               =============================================================================*/
203:               void initT5() 
204:               {
205:                       TMR5 = 0x0000;
00829A  EF2118     CLR TMR5
206:                       PR5 = 4999;
00829C  213870     MOV #0x1387, W0
00829E  8808E0     MOV W0, PR5
207:                       T5CONbits.TCKPS = 2;    //prescale 8:1
0082A0  2FFCF0     MOV #0xFFCF, W0
0082A2  B60120     AND T5CON, WREG
0082A4  A05000     BSET W0, #5
0082A6  880900     MOV W0, T5CON
208:                       IFS1bits.T5IF = 0;
0082A8  A98803     BCLR 0x803, #4
209:                       IEC1bits.T5IE = 0;
0082AA  A98823     BCLR 0x823, #4
210:               
211:                       //Start Timer 3
212:                       T5CONbits.TON = 1;
0082AC  A8E121     BSET 0x121, #7
213:               
214:               }
0082AE  060000     RETURN
215:               
216:               //Description: Initializes & starts 16 bit DCI I2S DAC
217:               //Prereq: initSPI_ADC(void)
218:               //Dependencies: readDAC(void)
219:               void initDCI_DAC(void){
220:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
0082B0  2F0000     MOV #0xF000, W0
0082B2  B60284     AND DCICON3, WREG
0082B4  B30170     IOR #0x17, W0
0082B6  881420     MOV W0, DCICON3
221:                   DCICON1bits.COFSM=1;                //i2s mode
0082B8  2FFFC0     MOV #0xFFFC, W0
0082BA  B60280     AND DCICON1, WREG
0082BC  A00000     BSET W0, #0
0082BE  881400     MOV W0, DCICON1
222:                   DCICON1bits.CSCKE=1;                //sample on rising edge
0082C0  A82281     BSET 0x281, #1
223:                   DCICON2bits.WS=0xF;                 //16 bit data word
0082C2  2000F0     MOV #0xF, W0
0082C4  B72282     IOR DCICON2
224:                   DCICON2bits.COFSG=0;    //data frame has 1 word (per frame)
0082C6  2FE1F0     MOV #0xFE1F, W0
0082C8  B62282     AND DCICON2
225:                   DCICON1bits.DJST=0;     //align data
0082CA  A9A280     BCLR DCICON1, #5
226:                   DCICON2bits.BLEN=3;     //4 words buffer btwn interrupts
0082CC  20C000     MOV #0xC00, W0
0082CE  B72282     IOR DCICON2
227:                   
228:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
0082D0  A80288     BSET TSCON, #0
229:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
0082D2  A82288     BSET TSCON, #1
230:                   TSCONbits.TSE2 = 1;     // Transmit on Time Slot 2     
0082D4  A84288     BSET TSCON, #2
231:                   TSCONbits.TSE3 = 1;     // Transmit on Time Slot 3   
0082D6  A86288     BSET TSCON, #3
232:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
0082D8  A8028C     BSET RSCON, #0
233:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
0082DA  A8228C     BSET RSCON, #1
234:                   RSCONbits.RSE2 = 1;     // rcv on Time Slot 2     
0082DC  A8428C     BSET RSCON, #2
235:                   RSCONbits.RSE3 = 1;     // rcv on Time Slot 3 
0082DE  A8628C     BSET RSCON, #3
236:                   
237:               
238:                   
239:                   IPC15bits.DCIIP = 6;    // Interrput priority
0082E0  2FFF80     MOV #0xFFF8, W0
0082E2  B6085E     AND IPC15, WREG
0082E4  B30060     IOR #0x6, W0
0082E6  8842F0     MOV W0, IPC15
240:                   IFS3bits.DCIIF=0;
0082E8  A98807     BCLR 0x807, #4
241:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
0082EA  A88827     BSET 0x827, #4
242:                   
243:                   // Pre-load send registers.
244:                   TXBUF0=0;
0082EC  EF2298     CLR TXBUF0
245:                   TXBUF1=0;   
0082EE  EF229A     CLR TXBUF1
246:                   TXBUF2=0;
0082F0  EF229C     CLR TXBUF2
247:                   TXBUF3=0;
0082F2  EF229E     CLR TXBUF3
248:                   DCICON1bits.DCIEN=1;    //ENABLE
0082F4  A8E281     BSET 0x281, #7
249:                   // Stabilization delay
250:                   Delay_us(20);
0082F6  200140     MOV #0x14, W0
0082F8  0701FD     RCALL Delay_us
251:               }
0082FA  060000     RETURN
252:               
253:               void initDMA0(void){
254:                   unsigned long address;
255:                   
256:                   /*
257:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
258:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
259:                   DMA0PAD =  0X0608; // Point DMA to PMP
260:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
261:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
262:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
263:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
264:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
265:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
266:                   DMA0CONbits.CHEN=1; // Enable DMA
267:                   */
268:                   
269:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
0082FC  A9CB01     BCLR 0xB01, #6
270:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
0082FE  A8AB01     BSET 0xB01, #5
271:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
008300  2FFCF4     MOV #0xFFCF, W4
008302  20B000     MOV #0xB00, W0
008304  620810     AND W4, [W0], [W0]
272:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
008306  2FFFC3     MOV #0xFFFC, W3
008308  805801     MOV DMA0CON, W1
00830A  618001     AND W3, W1, W0
00830C  A01000     BSET W0, #1
00830E  885800     MOV W0, DMA0CON
273:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
008310  A98B01     BCLR 0xB01, #4
274:                   DMA0CONbits.NULLW = 0;
008312  A96B01     BCLR 0xB01, #3
275:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
008314  A9EB03     BCLR 0xB03, #7
276:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
008316  B3C3C2     MOV.B #0x3C, W2
008318  20B025     MOV #0xB02, W5
00831A  784A82     MOV.B W2, [W5]
277:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
00831C  27FFF0     MOV #0x7FFF, W0
00831E  2CE001     MOV #0xCE00, W1
008320  608080     AND W1, W0, W1
278:                   address +=__builtin_edspage(txBufferA) << 15;
008322  200016     MOV #0x1, W6
008324  DD334F     SL W6, #15, W6
008326  EB0380     CLR W7
008328  408306     ADD W1, W6, W6
00832A  4B83E0     ADDC W7, #0x0, W7
279:                   DMA0STAL = address & 0xFFFF;
00832C  885826     MOV W6, DMA0STAL
280:                   DMA0STAH = address >>16;
00832E  885837     MOV W7, DMA0STAH
281:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
008330  2CC001     MOV #0xCC00, W1
008332  608080     AND W1, W0, W1
282:                   address +=__builtin_edspage(txBufferB) << 15;
008334  200016     MOV #0x1, W6
008336  DD334F     SL W6, #15, W6
008338  EB0380     CLR W7
00833A  408306     ADD W1, W6, W6
00833C  4B83E0     ADDC W7, #0x0, W7
283:                   DMA0STBL = address & 0xFFFF;
00833E  885846     MOV W6, DMA0STBL
284:                   DMA0STBH = address >>16;
008340  885857     MOV W7, DMA0STBH
285:                   DMA0PAD = (int)&TXBUF0;
008342  202981     MOV #0x298, W1
008344  885861     MOV W1, DMA0PAD
286:                   DMA0CNT = STREAMBUF-1;
008346  200FF1     MOV #0xFF, W1
008348  885871     MOV W1, DMA0CNT
287:                   /* DMA 2 - DCI to DPSRAM*/
288:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
00834A  A9CB21     BCLR 0xB21, #6
289:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
00834C  A9AB21     BCLR 0xB21, #5
290:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
00834E  A98B21     BCLR 0xB21, #4
291:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
008350  A96B21     BCLR 0xB21, #3
292:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
008352  20B205     MOV #0xB20, W5
008354  620A95     AND W4, [W5], [W5]
293:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
008356  805904     MOV DMA2CON, W4
008358  618184     AND W3, W4, W3
00835A  A01003     BSET W3, #1
00835C  885903     MOV W3, DMA2CON
294:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
00835E  A9EB23     BCLR 0xB23, #7
295:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
008360  784182     MOV.B W2, W3
008362  20B225     MOV #0xB22, W5
008364  784A83     MOV.B W3, [W5]
296:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
008366  2CA004     MOV #0xCA00, W4
008368  620200     AND W4, W0, W4
297:                   address +=__builtin_edspage(rxBufferA) << 15;
00836A  200012     MOV #0x1, W2
00836C  DD114F     SL W2, #15, W2
00836E  EB0180     CLR W3
008370  420102     ADD W4, W2, W2
008372  4981E0     ADDC W3, #0x0, W3
298:                   DMA2STAL = address & 0xFFFF;
008374  885922     MOV W2, DMA2STAL
299:                   DMA2STAH = address >>16;
008376  885933     MOV W3, DMA2STAH
300:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
008378  2C8002     MOV #0xC800, W2
00837A  610000     AND W2, W0, W0
301:                   address +=__builtin_edspage(rxBufferB) << 15;
00837C  200012     MOV #0x1, W2
00837E  DD114F     SL W2, #15, W2
008380  EB0180     CLR W3
008382  400102     ADD W0, W2, W2
008384  4981E0     ADDC W3, #0x0, W3
302:                   DMA2STBL = address & 0xFFFF;
008386  885942     MOV W2, DMA2STBL
303:                   DMA2STBH = address >>16;
008388  885953     MOV W3, DMA2STBH
304:                   DMA2PAD = (int)&RXBUF0;
00838A  202900     MOV #0x290, W0
00838C  885960     MOV W0, DMA2PAD
305:                   DMA2CNT = STREAMBUF-1;
00838E  885971     MOV W1, DMA2CNT
306:                   _DMA2IP = 5;
008390  2FFF80     MOV #0xFFF8, W0
008392  B6084C     AND IPC6, WREG
008394  B30050     IOR #0x5, W0
008396  884260     MOV W0, IPC6
307:                   _DMA2IE = 1;
008398  A80823     BSET 0x823, #0
308:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
00839A  A8EB01     BSET 0xB01, #7
309:                   DMA2CONbits.CHEN = 1;
00839C  A8EB21     BSET 0xB21, #7
310:               }
00839E  060000     RETURN
311:               
312:               void initSPI3_MEM(void){
313:                   SS3=1;                     // Assert chip select (active low)
0083A0  A82E54     BSET LATF, #1
314:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
0083A2  A9680B     BCLR 0x80B, #3
315:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
0083A4  A9682B     BCLR 0x82B, #3
316:                   SPI3CON1bits.MSTEN=1;       //master mode
0083A6  A8A2A2     BSET SPI3CON1, #5
317:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
0083A8  A982A3     BCLR 0x2A3, #4
318:                   SPI3CON1bits.MODE16=0;      //8 bit
0083AA  A942A3     BCLR 0x2A3, #2
319:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
0083AC  A962A3     BCLR 0x2A3, #3
320:                   SPI3CON1bits.SSEN=1;        //use SS
0083AE  A8E2A2     BSET SPI3CON1, #7
321:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
0083B0  A9E2A5     BCLR 0x2A5, #7
322:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
0083B2  A902A4     BCLR SPI3CON2, #0
323:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
0083B4  2FFE33     MOV #0xFFE3, W3
0083B6  801300     MOV SPI2STAT, W0
0083B8  618080     AND W3, W0, W1
0083BA  B30141     IOR #0x14, W1
0083BC  881301     MOV W1, SPI2STAT
324:                   
325:                   SPI3CON1bits.SMP=1;         //data sampled at end of output time
0083BE  A822A3     BSET 0x2A3, #1
326:                   SPI3CON1bits.CKP=0;         //idle clock is low
0083C0  A9C2A2     BCLR SPI3CON1, #6
327:                   SPI3CON1bits.CKE=1;         //data changes from H to L
0083C2  A802A3     BSET 0x2A3, #0
328:                   
329:                   SPI3CON1bits.PPRE=3;        //1:1 primary prescale
0083C4  200030     MOV #0x3, W0
0083C6  B722A2     IOR SPI3CON1
330:                   SPI3CON1bits.SPRE=6;        //2:1 secondary
0083C8  801511     MOV SPI3CON1, W1
0083CA  618001     AND W3, W1, W0
0083CC  B30180     IOR #0x18, W0
0083CE  881510     MOV W0, SPI3CON1
331:                   
332:                   SPI3STATbits.SPIROV = 0;        // Clear SPI1 receive overflow flag if set
0083D0  A9C2A0     BCLR SPI3STAT, #6
333:                   //IPC22bits.SPI3IP = 3;         // Interrupt priority
334:                   //IFS5bits.SPI3IF = 0;          // Clear the Interrupt flag
335:                   //IEC5bits.SPI3IE = 0;          // Enable the interrupt
336:                   SPI3STATbits.SPIEN = 1;         //start SPI module
0083D2  A8E2A1     BSET 0x2A1, #7
337:                  
338:                   Delay_us(20);                       // Stabilization Delay
0083D4  200140     MOV #0x14, W0
0083D6  07018E     RCALL Delay_us
339:                   
340:                   flashWriteReg(FLASH_WREN);
0083D8  B3C060     MOV.B #0x6, W0
0083DA  0704B1     RCALL flashWriteReg
341:                   /*
342:                   flashBulkErase();
343:                   while(flashStatusCheck()&1);
344:               
345:                   flashWritePage
346:                   while(flashStatusCheck()&1);
347:                   */
348:                   
349:                   flashRead(flash_readback, 256);     // READBACK
0083DC  201001     MOV #0x100, W1
0083DE  25E6C0     MOV #0x5E6C, W0
0083E0  070502     RCALL flashRead
350:                   
351:               }
0083E2  060000     RETURN
352:               
353:               void initQEI_ENC(void){
354:                   QEI1CONbits.INTDIV=6;       // 1:64 prescaler
0083E4  2FF8F0     MOV #0xFF8F, W0
0083E6  B601C0     AND QEI1CON, WREG
0083E8  B30600     IOR #0x60, W0
0083EA  880E00     MOV W0, QEI1CON
355:                   QEI1IOCbits.FLTREN=1;       // Enable input filter
0083EC  A8C1C3     BSET 0x1C3, #6
356:                   QEI1CONbits.QEIEN=1;        // Enable Quad encoder inteface
0083EE  A8E1C1     BSET 0x1C1, #7
357:               }
0083F0  060000     RETURN
358:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/audio.c  ----------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[BUTTONS];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[POTS];
7:                 extern fractional pots_percent[POTS];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                void processAudio(fractional *source, fractional *destination){
008AFA  4787E4     ADD W15, #0x4, W15
008AFC  BE9F88     MOV.D W8, [W15++]
008AFE  BE9F8A     MOV.D W10, [W15++]
008B00  BE9F8C     MOV.D W12, [W15++]
008B02  781F8E     MOV W14, [W15++]
008B04  F80022     PUSH ACCA
008B06  F80024     PUSH ACCAH
008B08  F80026     PUSH ACCAU
008B0A  BE0400     MOV.D W0, W8
008B12  2FE002     MOV #0xFE00, W2
008B14  410108     ADD W2, W8, W2
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    volatile fractional sample;
38:                    int counter=(STREAMBUF-1);
39:                    
40:                    runFX(source, source);
008B0C  780088     MOV W8, W1
008B0E  780008     MOV W8, W0
008B10  07FF61     RCALL runFX
41:                    
42:                
43:                    for(; counter>=0; counter--){
008BDC  540F82     SUB W8, W2, [W15]
008BDE  3AFFA3     BRA NZ, 0x8B26
44:                        sample=*source--; //!rw
008B26  780028     MOV [W8--], W0
008B28  9FB7D0     MOV W0, [W15-22]
45:                
46:                        if(kick_playing==TRUE&&kick_ptr<kick_max){
008B2A  BFD02E     MOV.B kick_playing, WREG
008B2C  404FE1     ADD.B W0, #0x1, [W15]
008B2E  3A0011     BRA NZ, 0x8B52
008B30  8789D4     MOV 0xF13A, W4
008B32  808187     MOV kick_ptr, W7
008B34  538F84     SUB W7, W4, [W15]
008B36  31000D     BRA C, 0x8B52
47:                            result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
008B18  27332E     MOV #0x7332, W14
008B38  97B3DF     MOV [W15-22], W7
008B3A  78020E     MOV W14, W4
008B3C  C20113     MPY W4*W7, A
48:                            result1 = __builtin_add(result1,kick[kick_ptr++],0);
008B1A  2C5DAD     MOV #0xC5DA, W13
008B3E  808180     MOV kick_ptr, W0
008B40  400200     ADD W0, W0, W4
008B42  468204     ADD W13, W4, W4
008B44  780214     MOV [W4], W4
008B46  E80000     INC W0, W0
008B48  888180     MOV W0, kick_ptr
008B4A  C90004     ADD W4, A
49:                            sample=__builtin_sac(result1, 0);
008B4C  CC0007     SAC A, W7
008B4E  9FB7D7     MOV W7, [W15-22]
008B50  37000A     BRA 0x8B66
50:                        }
51:                        else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
008B16  268B45     MOV #0x68B4, W5
008B52  B3C01B     MOV.B #0x1, W11
008B54  15CF95     SUBR.B W11, [W5], [W15]
008B56  3A0007     BRA NZ, 0x8B66
008B58  404FE1     ADD.B W0, #0x1, [W15]
008B5A  3A0005     BRA NZ, 0x8B66
008B5C  8789D0     MOV 0xF13A, W0
008B5E  E31030     CP kick_ptr
008B60  3A0002     BRA NZ, 0x8B66
52:                            kick_playing=FALSE;
008B62  EF702E     CLR.B kick_playing
53:                            kick_ptr=0;
008B64  EF3030     CLR kick_ptr
54:                        }
55:                        /*
56:                        if(hat_playing==TRUE&&hat_ptr<hat_max){
57:                            result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
58:                            result1 = __builtin_add(result1,hat[hat_ptr++],0);
59:                            sample=__builtin_sac(result1, 0);
60:                        }
61:                        else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
62:                            hat_playing=FALSE;
63:                            hat_ptr=0;
64:                        }
65:                         */
66:                
67:                        if(snare_playing==TRUE&&snare_ptr<snare_max){
008B66  BFD032     MOV.B snare_playing, WREG
008B68  404FE1     ADD.B W0, #0x1, [W15]
008B6A  3A0012     BRA NZ, 0x8B90
008B6C  8789E4     MOV 0xF13C, W4
008B6E  8081A7     MOV snare_ptr, W7
008B70  538F84     SUB W7, W4, [W15]
008B72  31000E     BRA C, 0x8B90
68:                            result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
008B1E  26CCCC     MOV #0x6CCC, W12
008B74  97B3DF     MOV [W15-22], W7
008B76  78020C     MOV W12, W4
008B78  C20113     MPY W4*W7, A
69:                            result1 = __builtin_add(result1,snare[snare_ptr++],0);
008B7A  8081A0     MOV snare_ptr, W0
008B7C  400200     ADD W0, W0, W4
008B7E  295027     MOV #0x9502, W7
008B80  438204     ADD W7, W4, W4
008B82  780214     MOV [W4], W4
008B84  E80000     INC W0, W0
008B86  8881A0     MOV W0, snare_ptr
008B88  C90004     ADD W4, A
70:                            sample=__builtin_sac(result1, 0);
008B8A  CC000B     SAC A, W11
008B8C  9FB7DB     MOV W11, [W15-22]
008B8E  37000A     BRA 0x8BA4
71:                        }
72:                        else if (pad[1]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
008B1C  E80185     INC W5, W3
008B90  B3C014     MOV.B #0x1, W4
008B92  124F93     SUBR.B W4, [W3], [W15]
008B94  3A0007     BRA NZ, 0x8BA4
008B96  404FE1     ADD.B W0, #0x1, [W15]
008B98  3A0005     BRA NZ, 0x8BA4
008B9A  8789E0     MOV 0xF13C, W0
008B9C  E31034     CP snare_ptr
008B9E  3A0002     BRA NZ, 0x8BA4
73:                            snare_playing=FALSE;
008BA0  EF7032     CLR.B snare_playing
74:                            snare_ptr=0;
008BA2  EF3034     CLR snare_ptr
75:                        }
76:                
77:                
78:                        if (TEST_SIN==TRUE){
008BA4  BFD01A     MOV.B TEST_SIN, WREG
008BA6  404FE1     ADD.B W0, #0x1, [W15]
008BA8  3A000B     BRA NZ, 0x8BC0
79:                            i++;
008BAA  EC1010     INC i, WREG
008BAC  888080     MOV W0, i
80:                            if(i==1024)
008B20  20400A     MOV #0x400, W10
008BAE  500F8A     SUB W0, W10, [W15]
008BB0  3A0001     BRA NZ, 0x8BB4
81:                                i=0;
008BB2  EF3010     CLR i
82:                            sample=sintab[i];
008BB4  808080     MOV i, W0
008BB6  400000     ADD W0, W0, W0
008BB8  2F1407     MOV #0xF140, W7
008BBA  438000     ADD W7, W0, W0
008BBC  780010     MOV [W0], W0
008BBE  9FB7D0     MOV W0, [W15-22]
83:                        }
84:                
85:                        //VOLUME CONTROL
86:                        if(pots[POT_VOLUME]==0x0007)
008B22  2607A1     MOV #0x607A, W1
008BC0  780211     MOV [W1], W4
008BC2  520FE7     SUB W4, #0x7, [W15]
008BC4  3A0003     BRA NZ, 0x8BCC
87:                            sample=0;
008BC6  EB0580     CLR W11
008BC8  9FB7DB     MOV W11, [W15-22]
008BCA  370006     BRA 0x8BD8
88:                        else if(pots[POT_VOLUME]>=0x7FF7);
008B24  27FF66     MOV #0x7FF6, W6
008BCC  520F86     SUB W4, W6, [W15]
008BCE  3C0004     BRA GT, 0x8BD8
89:                        else{
90:                            result1 =__builtin_mpy(sample,pots[POT_VOLUME], NULL, NULL, 0, NULL, NULL, 0);
008BD0  97B3DF     MOV [W15-22], W7
008BD2  C20113     MPY W4*W7, A
91:                            sample=__builtin_sac(result1, 0);
008BD4  CC000B     SAC A, W11
008BD6  9FB7DB     MOV W11, [W15-22]
92:                        }
93:                        
94:                        //return sample;
95:                        *destination--=sample; //rw
008BD8  97B05F     MOV [W15-22], W0
008BDA  781480     MOV W0, [W9--]
96:                    }
97:                }
008BE0  F90026     POP ACCAU
008BE2  F90024     POP ACCAH
008BE4  F90022     POP ACCA
008BE6  78074F     MOV [--W15], W14
008BE8  BE064F     MOV.D [--W15], W12
008BEA  BE054F     MOV.D [--W15], W10
008BEC  BE044F     MOV.D [--W15], W8
008BEE  B1004F     SUB #0x4, W15
008BF0  060000     RETURN
98:                
99:                void runFX(fractional *source, fractional *destination){
0089D4  FA0002     LNK #0x2
0089D6  BE9F88     MOV.D W8, [W15++]
0089D8  BE9F8A     MOV.D W10, [W15++]
0089DA  BE9F8C     MOV.D W12, [W15++]
0089DC  F80022     PUSH ACCA
0089DE  F80024     PUSH ACCAH
0089E0  F80026     PUSH ACCAU
0089E2  F80028     PUSH ACCB
0089E4  F8002A     PUSH ACCBH
0089E6  F8002C     PUSH ACCBU
0089E8  2FE003     MOV #0xFE00, W3
0089EA  418180     ADD W3, W0, W3
100:                   volatile register int result1 asm("A");
101:                   volatile register int result2 asm("B");
102:                   static fractional delayed_sample;
103:                   static fractional trem_mod; 
104:                   volatile fractional sample;
105:                   
106:                   
107:                   int *readPTR=source;
108:                   int *rewritePTR=destination;
109:                   
110:                   
111:                   int counter=(STREAMBUF-1);
112:                   for(; counter>=0; counter--){
008AE0  500F83     SUB W0, W3, [W15]
008AE2  3AFF8B     BRA NZ, 0x89FA
113:                       sample=*readPTR--; //!rw
0089FA  780120     MOV [W0--], W2
0089FC  9FB7B2     MOV W2, [W15-26]
114:               
115:                       if(tremelo==TRUE){                                                          //TREMELO//
0089FE  2101B2     MOV #0x101B, W2
008A00  784112     MOV.B [W2], W2
008A02  414FE1     ADD.B W2, #0x1, [W15]
008A04  3A002B     BRA NZ, 0x8A5C
116:                           if (trem_var<=pots[3]){
0089EC  26072D     MOV #0x6072, W13
008A06  808042     MOV trem_var, W2
008A08  110F9D     SUBR W2, [W13], [W15]
008A0A  390012     BRA NC, 0x8A30
117:                               trem_var++;
008A0C  E80102     INC W2, W2
008A0E  888042     MOV W2, trem_var
118:                               result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
008A10  808022     MOV tremelo_ptr, W2
008A12  410102     ADD W2, W2, W2
008A14  440102     ADD W8, W2, W2
008A16  780592     MOV [W2], W11
008A18  808226     MOV 0x1044, W6
008A1A  78038B     MOV W11, W7
008A1C  C60113     MPY W6*W7, A
119:                               trem_mod=__builtin_sac(result1, 0);
008A1E  CC0002     SAC A, W2
008A20  888062     MOV W2, trem_mod
120:                               result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008A22  97B5BF     MOV [W15-26], W11
008A24  780302     MOV W2, W6
008A26  78038B     MOV W11, W7
008A28  C68113     MPY W6*W7, B
121:                               sample=__builtin_sac(result2, 0);
008A2A  CC8002     SAC B, W2
008A2C  9FB7B2     MOV W2, [W15-26]
008A2E  370016     BRA 0x8A5C
122:                           }
123:                           else{
124:                               trem_var=0;
0089EE  EB0600     CLR W12
008A30  88804C     MOV W12, trem_var
125:                               if(tremelo_ptr==1024)
0089F0  204009     MOV #0x400, W9
008A32  808026     MOV tremelo_ptr, W6
008A34  530F89     SUB W6, W9, [W15]
008A36  3A0001     BRA NZ, 0x8A3A
126:                                   tremelo_ptr=0;
008A38  88802C     MOV W12, tremelo_ptr
127:                               result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
0089F2  2F1408     MOV #0xF140, W8
008A3A  808022     MOV tremelo_ptr, W2
008A3C  410582     ADD W2, W2, W11
008A3E  44058B     ADD W8, W11, W11
008A40  78059B     MOV [W11], W11
008A42  E80102     INC W2, W2
008A44  888022     MOV W2, tremelo_ptr
008A46  808227     MOV 0x1044, W7
008A48  78030B     MOV W11, W6
008A4A  C60113     MPY W6*W7, A
128:                               trem_mod=__builtin_sac(result1, 0);
008A4C  CC0002     SAC A, W2
008A4E  888062     MOV W2, trem_mod
129:                               result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008A50  97B5BF     MOV [W15-26], W11
008A52  780382     MOV W2, W7
008A54  78030B     MOV W11, W6
008A56  C68113     MPY W6*W7, B
130:                               sample=__builtin_sac(result2, 0);
008A58  CC8007     SAC B, W7
008A5A  9FB7B7     MOV W7, [W15-26]
131:                           }
132:                       }
133:                       if(looper==TRUE){                           //LOOPER// 
008A5C  2101C2     MOV #0x101C, W2
008A5E  784112     MOV.B [W2], W2
008A60  414FE1     ADD.B W2, #0x1, [W15]
008A62  3A0019     BRA NZ, 0x8A96
134:                           if(loop_lim>=LOOP_BUF_SIZE)
008A64  808012     MOV loop_lim, W2
008A66  510F84     SUB W2, W4, [W15]
008A68  360001     BRA LEU, 0x8A6C
135:                               loop_lim=LOOP_BUF_SIZE;
0089F8  22710A     MOV #0x2710, W10
008A6A  88801A     MOV W10, loop_lim
136:                           if(loop_ptr<loop_lim){
008A6C  808012     MOV loop_lim, W2
008A6E  808006     MOV loop_ptr, W6
008A70  530F82     SUB W6, W2, [W15]
008A72  310008     BRA C, 0x8A84
137:                               sample = (loop[loop_ptr++]);
008A74  808002     MOV loop_ptr, W2
008A76  410582     ADD W2, W2, W11
008A78  42858B     ADD W5, W11, W11
008A7A  78059B     MOV [W11], W11
008A7C  9FB7BB     MOV W11, [W15-26]
008A7E  E80102     INC W2, W2
008A80  888002     MOV W2, loop_ptr
008A82  37001C     BRA 0x8ABC
138:                           }
139:                           else {
140:                               loop_ptr=0;
008A84  88800C     MOV W12, loop_ptr
141:                               sample = (loop[loop_ptr++]);
008A86  808002     MOV loop_ptr, W2
008A88  410582     ADD W2, W2, W11
008A8A  42858B     ADD W5, W11, W11
008A8C  78059B     MOV [W11], W11
008A8E  9FB7BB     MOV W11, [W15-26]
008A90  E80102     INC W2, W2
008A92  888002     MOV W2, loop_ptr
008A94  370013     BRA 0x8ABC
142:                           }
143:                       }                                                                           
144:                       else {                                      //buffer
145:                           if(loop_ptr<LOOP_BUF_SIZE)
0089F4  2270F4     MOV #0x270F, W4
008A96  808007     MOV loop_ptr, W7
008A98  538F84     SUB W7, W4, [W15]
008A9A  3E0008     BRA GTU, 0x8AAC
146:                               loop[loop_ptr++]=sample;
008A9C  808002     MOV loop_ptr, W2
008A9E  410582     ADD W2, W2, W11
008AA0  42858B     ADD W5, W11, W11
008AA2  97B33F     MOV [W15-26], W6
008AA4  780D86     MOV W6, [W11]
008AA6  E80102     INC W2, W2
008AA8  888002     MOV W2, loop_ptr
008AAA  370008     BRA 0x8ABC
147:                           else {
148:                               loop_ptr=0;
008AAC  88800C     MOV W12, loop_ptr
149:                               loop[loop_ptr++]=sample;
0089F6  2104C5     MOV #0x104C, W5
008AAE  808002     MOV loop_ptr, W2
008AB0  410582     ADD W2, W2, W11
008AB2  42858B     ADD W5, W11, W11
008AB4  97B3BF     MOV [W15-26], W7
008AB6  780D87     MOV W7, [W11]
008AB8  E80102     INC W2, W2
008ABA  888002     MOV W2, loop_ptr
150:                           }
151:                       }
152:               
153:                       //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
154:                       if(lpf==TRUE){
008ABC  2101D2     MOV #0x101D, W2
008ABE  784112     MOV.B [W2], W2
008AC0  414FE1     ADD.B W2, #0x1, [W15]
008AC2  3A000C     BRA NZ, 0x8ADC
155:                           result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
008AC4  97B13F     MOV [W15-26], W2
008AC6  80820B     MOV 0x1040, W11
008AC8  780302     MOV W2, W6
008ACA  78038B     MOV W11, W7
008ACC  C68113     MPY W6*W7, B
156:                           result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
008ACE  808212     MOV 0x1042, W2
008AD0  808076     MOV delayed_sample, W6
008AD2  780382     MOV W2, W7
008AD4  C68112     MAC W6*W7, B
157:                           delayed_sample=__builtin_sac(result2, 0);
008AD6  CC8002     SAC B, W2
008AD8  888072     MOV W2, delayed_sample
158:                           sample=delayed_sample;
008ADA  9FB7B2     MOV W2, [W15-26]
159:                       }
160:                       
161:                       *rewritePTR--=sample; //rw
008ADC  97B13F     MOV [W15-26], W2
008ADE  781082     MOV W2, [W1--]
162:                   }
163:               }
008AE4  F9002C     POP ACCBU
008AE6  F9002A     POP ACCBH
008AE8  F90028     POP ACCB
008AEA  F90026     POP ACCAU
008AEC  F90024     POP ACCAH
008AEE  F90022     POP ACCA
008AF0  BE064F     MOV.D [--W15], W12
008AF2  BE054F     MOV.D [--W15], W10
008AF4  BE044F     MOV.D [--W15], W8
008AF6  FA8000     ULNK
008AF8  060000     RETURN
164:               
165:               //test
