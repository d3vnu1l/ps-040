Disassembly Listing for sampler_0.49.2
Generated From:
C:/Users/ryan/Documents/seniorproject/ps-040/dist/default/production/ps-040.production.elf
Jan 30, 2018 6:19:22 PM

---  C:/Users/ryan/Documents/seniorproject/ps-040/utilitites.c  -----------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <libpic30.h>
4:                 #include <dsp.h>
5:                 #include <stdio.h>
6:                 #include <stdlib.h>
7:                 #include <math.h>
8:                 #include "common.h"
9:                 #include "sounds.h"
10:                #include "audio.h"
11:                #include "flash.h"
12:                #include "screens.h"
13:                #include "utilities.h"
14:                #include "devInits.h"
15:                
16:                fractional FXSCALE = Q15(NUMFX*0.000030518509476);
17:                
18:                //CONTROL VARIABLES//
19:                extern unsigned char pad[BUTTONS];
20:                extern fractional pots[POTS];
21:                extern fractional pots_scaled[POTS];
22:                extern fractional pots_custom[POTS];
23:                extern unsigned char UART_ON; 
24:                extern enum screen state;
25:                
26:                //STATUS VARIABLES//
27:                extern unsigned char hard_clipped;
28:                extern unsigned char UART_EN;
29:                extern unsigned char TEST_SIN;
30:                extern fractional sampin;
31:                extern fractional sampout;
32:                
33:                //FX FLAGS & VARS
34:                extern unsigned char tremelo, looper, lpf;
35:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
36:                extern unsigned int loop_lim;
37:                extern fractional lpf_alpha, lpf_inv_alpha;
38:                extern fractional tremelo_depth;
39:                extern unsigned char kick_playing, snare_playing;   
40:                
41:                void scanButtons(void){
42:                    
43:                    static unsigned char pad_last[BUTTONS]={1};
44:                    int portrdG, portrdD, portrdF;
45:                
46:                    portrdG = PORTG;
0083F2  807313     MOV PORTG, W3
47:                    portrdD = PORTD;
0083F4  807191     MOV PORTD, W1
48:                    portrdF = PORTF;
0083F6  807292     MOV PORTF, W2
49:                    
50:                    pad[34]=(portrdF>>7)&1;     // Special function button
0083F8  DE9247     ASR W2, #7, W4
0083FA  624261     AND.B W4, #0x1, W4
0083FC  268D85     MOV #0x68D8, W5
0083FE  784A84     MOV.B W4, [W5]
51:                    
52:                    if(pad[34]){
008400  320033     BRA Z, 0x8468
53:                        pad[6]=(portrdF>>6)&1;
008402  DE92C6     ASR W2, #6, W5
008404  268BC4     MOV #0x68BC, W4
008406  62CA61     AND.B W5, #0x1, [W4]
54:                        pad[5]=(portrdF>>5)&1;
008408  DE92C5     ASR W2, #5, W5
00840A  E90204     DEC W4, W4
00840C  62CA61     AND.B W5, #0x1, [W4]
55:                        pad[4]=(portrdF>>4)&1;
00840E  DE9144     ASR W2, #4, W2
008410  E90204     DEC W4, W4
008412  614A61     AND.B W2, #0x1, [W4]
56:                        pad[0]=(portrdG)&1;
008414  520164     SUB W4, #0x4, W2
008416  61C961     AND.B W3, #0x1, [W2]
57:                        pad[1]=(portrdG>>1)&1;
008418  D18203     ASR W3, W4
00841A  E80102     INC W2, W2
00841C  624961     AND.B W4, #0x1, [W2]
58:                        pad[2]=(portrdG>>2)&1;
00841E  DE9A42     ASR W3, #2, W4
008420  E80102     INC W2, W2
008422  624961     AND.B W4, #0x1, [W2]
59:                        pad[3]=(portrdG>>3)&1;
008424  DE9A43     ASR W3, #3, W4
008426  E80102     INC W2, W2
008428  624961     AND.B W4, #0x1, [W2]
60:                        pad[16]=(portrdG>>10)&1;    // Encoder button
00842A  DE9A4A     ASR W3, #10, W4
00842C  41016D     ADD W2, #0xD, W2
00842E  624961     AND.B W4, #0x1, [W2]
61:                        pad[11]=(portrdG>>11)&1;
008430  DE9A4B     ASR W3, #11, W4
008432  510165     SUB W2, #0x5, W2
008434  624961     AND.B W4, #0x1, [W2]
62:                        pad[12]=(portrdG>>12)&1;
008436  DE9A4C     ASR W3, #12, W4
008438  E80102     INC W2, W2
00843A  624961     AND.B W4, #0x1, [W2]
63:                        pad[13]=(portrdG>>13)&1;
00843C  DE9A4D     ASR W3, #13, W4
00843E  E80102     INC W2, W2
008440  624961     AND.B W4, #0x1, [W2]
64:                        pad[14]=(portrdG>>14)&1;
008442  DE984E     ASR W3, #14, W0
008444  E80102     INC W2, W2
008446  604961     AND.B W0, #0x1, [W2]
65:                        pad[15]=(portrdG>>15)&1;
008448  DE19CF     LSR W3, #15, W3
00844A  E80002     INC W2, W0
00844C  784803     MOV.B W3, [W0]
66:                        pad[7]=(portrdD>>1)&1;
00844E  D18101     ASR W1, W2
008450  500068     SUB W0, #0x8, W0
008452  614861     AND.B W2, #0x1, [W0]
67:                        pad[8]=(portrdD>>2)&1;
008454  DE8942     ASR W1, #2, W2
008456  E80000     INC W0, W0
008458  614861     AND.B W2, #0x1, [W0]
68:                        pad[9]=(portrdD>>3)&1;
00845A  DE8943     ASR W1, #3, W2
00845C  E80000     INC W0, W0
00845E  614861     AND.B W2, #0x1, [W0]
69:                        pad[10]=(portrdD>>4)&1;
008460  DE88C4     ASR W1, #4, W1
008462  E80000     INC W0, W0
008464  60C861     AND.B W1, #0x1, [W0]
008466  370032     BRA 0x84CC
70:                    } else {
71:                        pad[23]=(portrdF>>6)&1;
008468  DE92C6     ASR W2, #6, W5
00846A  268CD4     MOV #0x68CD, W4
00846C  62CA61     AND.B W5, #0x1, [W4]
72:                        pad[22]=(portrdF>>5)&1;
00846E  DE92C5     ASR W2, #5, W5
008470  E90204     DEC W4, W4
008472  62CA61     AND.B W5, #0x1, [W4]
73:                        pad[21]=(portrdF>>4)&1;
008474  DE9144     ASR W2, #4, W2
008476  E90204     DEC W4, W4
008478  614A61     AND.B W2, #0x1, [W4]
74:                        pad[17]=(portrdG)&1;
00847A  520164     SUB W4, #0x4, W2
00847C  61C961     AND.B W3, #0x1, [W2]
75:                        pad[18]=(portrdG>>1)&1;
00847E  D18203     ASR W3, W4
008480  E80102     INC W2, W2
008482  624961     AND.B W4, #0x1, [W2]
76:                        pad[19]=(portrdG>>2)&1;
008484  DE9A42     ASR W3, #2, W4
008486  E80102     INC W2, W2
008488  624961     AND.B W4, #0x1, [W2]
77:                        pad[20]=(portrdG>>3)&1;
00848A  DE9A43     ASR W3, #3, W4
00848C  E80102     INC W2, W2
00848E  624961     AND.B W4, #0x1, [W2]
78:                        pad[33]=(portrdG>>10)&1;    // Encoder button
008490  DE9A4A     ASR W3, #10, W4
008492  41016D     ADD W2, #0xD, W2
008494  624961     AND.B W4, #0x1, [W2]
79:                        pad[28]=(portrdG>>11)&1;
008496  DE9A4B     ASR W3, #11, W4
008498  510165     SUB W2, #0x5, W2
00849A  624961     AND.B W4, #0x1, [W2]
80:                        pad[29]=(portrdG>>12)&1;
00849C  DE9A4C     ASR W3, #12, W4
00849E  E80102     INC W2, W2
0084A0  624961     AND.B W4, #0x1, [W2]
81:                        pad[30]=(portrdG>>13)&1;
0084A2  DE9A4D     ASR W3, #13, W4
0084A4  E80102     INC W2, W2
0084A6  624961     AND.B W4, #0x1, [W2]
82:                        pad[31]=(portrdG>>14)&1;
0084A8  DE984E     ASR W3, #14, W0
0084AA  E80102     INC W2, W2
0084AC  604961     AND.B W0, #0x1, [W2]
83:                        pad[32]=(portrdG>>15)&1;
0084AE  DE19CF     LSR W3, #15, W3
0084B0  E80002     INC W2, W0
0084B2  784803     MOV.B W3, [W0]
84:                        pad[24]=(portrdD>>1)&1;
0084B4  D18101     ASR W1, W2
0084B6  500068     SUB W0, #0x8, W0
0084B8  614861     AND.B W2, #0x1, [W0]
85:                        pad[25]=(portrdD>>2)&1;
0084BA  DE8942     ASR W1, #2, W2
0084BC  E80000     INC W0, W0
0084BE  614861     AND.B W2, #0x1, [W0]
86:                        pad[26]=(portrdD>>3)&1;
0084C0  DE8943     ASR W1, #3, W2
0084C2  E80000     INC W0, W0
0084C4  614861     AND.B W2, #0x1, [W0]
87:                        pad[27]=(portrdD>>4)&1;
0084C6  DE88C4     ASR W1, #4, W1
0084C8  E80000     INC W0, W0
0084CA  60C861     AND.B W1, #0x1, [W0]
88:                    }
89:                
90:                   
91:                    
92:                    if(pad[13]==0&&pad_last[13]==1){                                              //TREMELO CONTROL
0084CC  268C30     MOV #0x68C3, W0
0084CE  784010     MOV.B [W0], W0
0084D0  E00400     CP0.B W0
0084D2  3A000C     BRA NZ, 0x84EC
0084D4  26D711     MOV #0x6D71, W1
0084D6  B3C012     MOV.B #0x1, W2
0084D8  114F91     SUBR.B W2, [W1], [W15]
0084DA  3A0008     BRA NZ, 0x84EC
93:                        pad_last[13]=0;
0084DC  780001     MOV W1, W0
0084DE  EB4800     CLR.B [W0]
94:                        if(tremelo==FALSE)
0084E0  E2501B     CP0.B tremelo
0084E2  3A0002     BRA NZ, 0x84E8
95:                            tremelo=TRUE;
0084E4  EFF01B     SETM.B tremelo
0084E6  370004     BRA 0x84F0
96:                        else tremelo=FALSE;
0084E8  EF701B     CLR.B tremelo
0084EA  370002     BRA 0x84F0
97:                    }
98:                    else{
99:                        pad_last[13]=pad[13];
0084EC  26D711     MOV #0x6D71, W1
0084EE  784880     MOV.B W0, [W1]
100:                   }
101:                   
102:                   if(pad[14]==0) looper=TRUE;
0084F0  268C40     MOV #0x68C4, W0
0084F2  E00410     CP0.B [W0]
0084F4  3A0002     BRA NZ, 0x84FA
0084F6  EFF01C     SETM.B looper
0084F8  370001     BRA 0x84FC
103:                   else looper=FALSE;
0084FA  EF701C     CLR.B looper
104:                  
105:                   if(pad[15]==0&&pad_last[15]==1){                                              //LPF CONTROL
0084FC  268C50     MOV #0x68C5, W0
0084FE  784010     MOV.B [W0], W0
008500  E00400     CP0.B W0
008502  3A000C     BRA NZ, 0x851C
008504  26D731     MOV #0x6D73, W1
008506  B3C012     MOV.B #0x1, W2
008508  114F91     SUBR.B W2, [W1], [W15]
00850A  3A0008     BRA NZ, 0x851C
106:                       pad_last[15]=0;
00850C  780001     MOV W1, W0
00850E  EB4800     CLR.B [W0]
107:                       if(lpf==FALSE)
008510  E2501D     CP0.B lpf
008512  3A0002     BRA NZ, 0x8518
108:                           lpf=TRUE;
008514  EFF01D     SETM.B lpf
008516  370004     BRA 0x8520
109:                       else lpf=FALSE;
008518  EF701D     CLR.B lpf
00851A  370002     BRA 0x8520
110:                   }
111:                   else{
112:                       pad_last[15]=pad[15];
00851C  26D731     MOV #0x6D73, W1
00851E  784880     MOV.B W0, [W1]
113:                   }
114:                   
115:                   
116:                   // SAMPLE TRIGGERS 
117:                   if(pad[0]==0&&kick_playing==FALSE){                                         //kick
008520  268B60     MOV #0x68B6, W0
008522  E00410     CP0.B [W0]
008524  3A0003     BRA NZ, 0x852C
008526  E2502E     CP0.B kick_playing
008528  3A0001     BRA NZ, 0x852C
118:                       kick_playing=TRUE;
00852A  EFF02E     SETM.B kick_playing
119:                   }
120:                   /*
121:                   if(pad[2]==0&&hat_playing==FALSE){                                          //hat
122:                       hat_playing=TRUE;
123:                   }
124:                   */
125:                   if(pad[1]==0&&snare_playing==FALSE){                                        //snare
00852C  268B70     MOV #0x68B7, W0
00852E  E00410     CP0.B [W0]
008530  3A0003     BRA NZ, 0x8538
008532  E25032     CP0.B snare_playing
008534  3A0001     BRA NZ, 0x8538
126:                       snare_playing=TRUE;
008536  EFF032     SETM.B snare_playing
127:                   }
128:               }
008538  060000     RETURN
129:               
130:               void readPots(void){
00853A  FA0018     LNK #0x18
00853C  BE9F88     MOV.D W8, [W15++]
00853E  781F8A     MOV W10, [W15++]
008540  F80022     PUSH ACCA
008542  F80024     PUSH ACCAH
008544  F80026     PUSH ACCAU
131:                   volatile register int result asm("A");
132:                   fractional pots_buf[POTS];
133:                   const fractional pot_alpha = 0x0F00;    //larger = rougher, lower = more latency
134:                   const fractional pot_alpha_inv = 32767-pot_alpha;
135:                   int i;
136:                   _AD1IF = 0; // Clear conversion done status bit
008546  A9A801     BCLR 0x801, #5
137:                   if(pad[34])i=0;
00854A  268D81     MOV #0x68D8, W1
00854C  E00411     CP0.B [W1]
00854E  320001     BRA Z, 0x8552
008550  EB0000     CLR W0
138:                   else i=POTS/2;
008548  200060     MOV #0x6, W0
139:                   pots_buf[i++]=(ADC1BUF5>>1)|0x7;
008552  400080     ADD W0, W0, W1
008554  801852     MOV ADC1BUF5, W2
008556  D10102     LSR W2, W2
008558  B30072     IOR #0x7, W2
00855A  780202     MOV W2, W4
00855C  2FFDC3     MOV #0xFFDC, W3
00855E  418181     ADD W3, W1, W3
008560  79B784     MOV W4, [W15+W3]
008562  E80000     INC W0, W0
140:                   pots_buf[i++]=(ADC1BUF2>>1)|0x7;
008564  400100     ADD W0, W0, W2
008566  801823     MOV ADC1BUF2, W3
008568  D10183     LSR W3, W3
00856A  B30073     IOR #0x7, W3
00856C  780303     MOV W3, W6
00856E  2FFDC5     MOV #0xFFDC, W5
008570  428282     ADD W5, W2, W5
008572  7AB786     MOV W6, [W15+W5]
008574  E80000     INC W0, W0
141:                   pots_buf[i++]=(ADC1BUF4>>1)|0x7;
008576  400180     ADD W0, W0, W3
008578  801844     MOV ADC1BUF4, W4
00857A  D10204     LSR W4, W4
00857C  B30074     IOR #0x7, W4
00857E  780404     MOV W4, W8
008580  2FFDC7     MOV #0xFFDC, W7
008582  438383     ADD W7, W3, W7
008584  7BB788     MOV W8, [W15+W7]
008586  E80000     INC W0, W0
142:                   pots_buf[i++]=(ADC1BUF1>>1)|0x7;
008588  400500     ADD W0, W0, W10
00858A  801814     MOV ADC1BUF1, W4
00858C  D10204     LSR W4, W4
00858E  B30074     IOR #0x7, W4
008590  780304     MOV W4, W6
008592  2FFDC5     MOV #0xFFDC, W5
008594  42828A     ADD W5, W10, W5
008596  7AB786     MOV W6, [W15+W5]
008598  E80000     INC W0, W0
143:                   pots_buf[i++]=(ADC1BUF3>>1)|0x7;
00859A  400380     ADD W0, W0, W7
00859C  801834     MOV ADC1BUF3, W4
00859E  D10204     LSR W4, W4
0085A0  B30074     IOR #0x7, W4
0085A2  780284     MOV W4, W5
0085A4  2FFDC8     MOV #0xFFDC, W8
0085A6  440407     ADD W8, W7, W8
0085A8  7C3785     MOV W5, [W15+W8]
0085AA  E80400     INC W0, W8
144:                   pots_buf[i]=(ADC1BUF0>>1)|0x7;
0085AC  D50300     LSR ADC1BUF0, WREG
0085AE  780200     MOV W0, W4
0085B0  B30074     IOR #0x7, W4
0085B2  440408     ADD W8, W8, W8
0085B4  2FFDC6     MOV #0xFFDC, W6
0085B6  430308     ADD W6, W8, W6
0085B8  7B3784     MOV W4, [W15+W6]
145:               
146:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085BA  20F005     MOV #0xF00, W5
0085BC  C00113     MPY W4*W5, A
147:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
0085BE  2606E0     MOV #0x606E, W0
0085C0  400408     ADD W0, W8, W8
0085C2  780498     MOV [W8], W9
0085C4  270FF4     MOV #0x70FF, W4
0085C6  780309     MOV W9, W6
0085C8  C10112     MAC W4*W6, A
148:                   pots[i--]=__builtin_sac(result, 0);
0085CA  CC0018     SAC A, [W8]
149:                   
150:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085CC  2FFDC6     MOV #0xFFDC, W6
0085CE  430307     ADD W6, W7, W6
0085D0  7B036F     MOV [W15+W6], W6
0085D2  C40113     MPY W5*W6, A
151:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
0085D4  400387     ADD W0, W7, W7
0085D6  780317     MOV [W7], W6
0085D8  C10112     MAC W4*W6, A
152:                   pots[i--]=__builtin_sac(result, 0);
0085DA  CC0017     SAC A, [W7]
153:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085DC  2FFDC8     MOV #0xFFDC, W8
0085DE  44040A     ADD W8, W10, W8
0085E0  7C03EF     MOV [W15+W8], W7
0085E2  C50113     MPY W5*W7, A
154:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
0085E4  40030A     ADD W0, W10, W6
0085E6  780396     MOV [W6], W7
0085E8  C20112     MAC W4*W7, A
155:                   pots[i--]=__builtin_sac(result, 0);
0085EA  CC0016     SAC A, [W6]
156:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085EC  2FFDC7     MOV #0xFFDC, W7
0085EE  438383     ADD W7, W3, W7
0085F0  7B836F     MOV [W15+W7], W6
0085F2  C40113     MPY W5*W6, A
157:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
0085F4  400183     ADD W0, W3, W3
0085F6  780313     MOV [W3], W6
0085F8  C10112     MAC W4*W6, A
158:                   pots[i--]=__builtin_sac(result, 0);
0085FA  CC0013     SAC A, [W3]
159:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
0085FC  2FFDC8     MOV #0xFFDC, W8
0085FE  440402     ADD W8, W2, W8
008600  7C036F     MOV [W15+W8], W6
008602  C40113     MPY W5*W6, A
160:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008604  400102     ADD W0, W2, W2
008606  780312     MOV [W2], W6
008608  C10112     MAC W4*W6, A
161:                   pots[i--]=__builtin_sac(result, 0);
00860A  CC0012     SAC A, [W2]
162:                   result =__builtin_mpy(pots_buf[i],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
00860C  2FFDC2     MOV #0xFFDC, W2
00860E  410101     ADD W2, W1, W2
008610  79036F     MOV [W15+W2], W6
008612  C40113     MPY W5*W6, A
163:                   result =__builtin_mac(result, pots[i], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008614  400081     ADD W0, W1, W1
008616  780291     MOV [W1], W5
008618  C00112     MAC W4*W5, A
164:                   pots[i]=__builtin_sac(result, 0);
00861A  CC0011     SAC A, [W1]
165:                   
166:                   loop_lim=pots[5];               //LOOPER CONTROL
00861C  8303C3     MOV 0x6078, W3
00861E  888013     MOV W3, loop_lim
167:                   if(pots[0]>=310){                      //LPF CONTROL
008620  780010     MOV [W0], W0
008622  201351     MOV #0x135, W1
008624  500F81     SUB W0, W1, [W15]
008626  340004     BRA LE, 0x8630
168:                       lpf_alpha=pots[0];
008628  888200     MOV W0, 0x1040
169:                       lpf_inv_alpha=(32767-lpf_alpha); 
00862A  27FFF1     MOV #0x7FFF, W1
00862C  508000     SUB W1, W0, W0
00862E  888210     MOV W0, 0x1042
170:                   }
171:                   tremelo_depth=pots[1];
008630  830384     MOV 0x6070, W4
008632  888224     MOV W4, 0x1044
172:               
173:                   
174:               }
008634  F90026     POP ACCAU
008636  F90024     POP ACCAH
008638  F90022     POP ACCA
00863A  78054F     MOV [--W15], W10
00863C  BE044F     MOV.D [--W15], W8
00863E  FA8000     ULNK
008640  060000     RETURN
175:               
176:               void scalePots(void){
008642  F80022     PUSH ACCA
008644  F80024     PUSH ACCAH
008646  F80026     PUSH ACCAU
177:                   /* Potentiometer scaling for fx or lcd display */
178:                   volatile register int scaled asm("A");
179:                   
180:                   
181:                   scaled=__builtin_mpy(pots[0],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008648  232644     MOV #0x3264, W4
00864A  830375     MOV pots, W5
00864C  C00113     MPY W4*W5, A
182:                   pots_scaled[0]=__builtin_sac(scaled, 7);
00864E  260860     MOV #0x6086, W0
008650  CC0390     SAC A, #7, [W0]
183:                   scaled=__builtin_mpy(pots[1],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008652  830385     MOV 0x6070, W5
008654  C00113     MPY W4*W5, A
184:                   pots_scaled[1]=__builtin_sac(scaled, 7);
008656  E88000     INC2 W0, W0
008658  CC0390     SAC A, #7, [W0]
185:                   scaled=__builtin_mpy(pots[2],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
00865A  830395     MOV 0x6072, W5
00865C  C00113     MPY W4*W5, A
186:                   pots_scaled[2]=__builtin_sac(scaled, 7);
00865E  E88000     INC2 W0, W0
008660  CC0390     SAC A, #7, [W0]
187:                   scaled=__builtin_mpy(pots[3],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008662  8303A5     MOV 0x6074, W5
008664  C00113     MPY W4*W5, A
188:                   pots_scaled[3]=__builtin_sac(scaled, 7);
008666  E88000     INC2 W0, W0
008668  CC0390     SAC A, #7, [W0]
189:                   scaled=__builtin_mpy(pots[4],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
00866A  8303B5     MOV 0x6076, W5
00866C  C00113     MPY W4*W5, A
190:                   pots_scaled[4]=__builtin_sac(scaled, 7);
00866E  E88000     INC2 W0, W0
008670  CC0390     SAC A, #7, [W0]
191:                   scaled=__builtin_mpy(pots[5],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008672  8303C5     MOV 0x6078, W5
008674  C00113     MPY W4*W5, A
192:                   pots_scaled[5]=__builtin_sac(scaled, 7);
008676  E88000     INC2 W0, W0
008678  CC0390     SAC A, #7, [W0]
193:                   
194:                   scaled=__builtin_mpy(pots[POT_FX_SELECT1],FXSCALE, NULL, NULL, 0, NULL, NULL, 0);
00867A  808254     MOV 0x104A, W4
00867C  830415     MOV 0x6082, W5
00867E  C00113     MPY W4*W5, A
195:                   pots_scaled[POT_FX_SELECT1]=__builtin_sac(scaled, 0);
008680  40006A     ADD W0, #0xA, W0
008682  CC0010     SAC A, [W0]
196:                   scaled=__builtin_mpy(pots[POT_FX_SELECT2],FXSCALE, NULL, NULL, 0, NULL, NULL, 0);
008684  830425     MOV 0x6084, W5
008686  C00113     MPY W4*W5, A
197:                   pots_scaled[POT_FX_SELECT2]=__builtin_sac(scaled, 0);
008688  E88000     INC2 W0, W0
00868A  CC0010     SAC A, [W0]
198:               }
00868C  F90026     POP ACCAU
00868E  F90024     POP ACCAH
008690  F90022     POP ACCA
008692  060000     RETURN
199:               
200:               void scalePotsCustom(unsigned int steps){
008694  F80022     PUSH ACCA
008696  F80024     PUSH ACCAH
008698  F80026     PUSH ACCAU
201:                   volatile register int scaled asm("A");
202:                   fractional scale = Q15(steps*0.000030518509476);
00869A  EB0080     CLR W1
00869C  07BF82     RCALL ___floatunsisf
00869E  201002     MOV #0x100, W2
0086A0  238003     MOV #0x3800, W3
0086A2  07BFD4     RCALL ___mulsf3
0086A4  2FE002     MOV #0xFE00, W2
0086A6  246FF3     MOV #0x46FF, W3
0086A8  07BFD1     RCALL ___mulsf3
0086AA  200002     MOV #0x0, W2
0086AC  23F003     MOV #0x3F00, W3
0086AE  07BEFB     RCALL ___addsf3
0086B0  07BF57     RCALL ___fixsfsi
203:                   
204:                   scaled=__builtin_mpy(pots[4],scale, NULL, NULL, 0, NULL, NULL, 0);
0086B2  8303B4     MOV 0x6076, W4
0086B4  780280     MOV W0, W5
0086B6  C00113     MPY W4*W5, A
205:                   pots_scaled[4]=__builtin_sac(scaled, 0);
0086B8  2608E0     MOV #0x608E, W0
0086BA  CC0010     SAC A, [W0]
206:               }
0086BC  F90026     POP ACCAU
0086BE  F90024     POP ACCAH
0086C0  F90022     POP ACCA
0086C2  060000     RETURN
207:               
208:               void display(void){
209:                   scalePots();
0086C4  07FFBE     RCALL scalePots
210:                   // Update ui state logic here
211:                   state = (ENCODERCNTL/4)+1;
0086C6  800E30     MOV POS1CNTL, W0
0086C8  DE0042     LSR W0, #2, W0
0086CA  E80000     INC W0, W0
0086CC  8881F0     MOV W0, 0x103E
212:                   
213:                   // Update screen here
214:                   screenUpdate();
0086CE  07016F     RCALL screenUpdate
215:                  
216:                  if(UART_ON==TRUE){
0086D0  BFD019     MOV.B UART_ON, WREG
0086D2  404FE1     ADD.B W0, #0x1, [W15]
0086D4  3A0007     BRA NZ, 0x86E4
217:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
218:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
219:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
220:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
0086D6  F86072     PUSH 0x6072
0086D8  F86070     PUSH 0x6070
0086DA  F8606E     PUSH pots
0086DC  2F9BA0     MOV #0xF9BA, W0
0086DE  781F80     MOV W0, [W15++]
0086E0  07C026     RCALL __printf_cdnopuxX
0086E2  5787E8     SUB W15, #0x8, W15
221:                       //printf("%d\r\n", sample);  //check input ADC
222:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
223:                   }
224:                  
225:                  SLED=~SLED;
0086E4  8072A0     MOV LATF, W0
0086E6  EA8000     COM W0, W0
0086E8  600061     AND W0, #0x1, W0
0086EA  8072A1     MOV LATF, W1
0086EC  A10001     BCLR W1, #0
0086EE  700081     IOR W0, W1, W1
0086F0  8872A1     MOV W1, LATF
226:               }
0086F2  060000     RETURN
227:               
228:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
229:                   /* This procedure loops back the received data to the*/
230:                   /* the codec output. The user application could process*/
231:                   /* this data as per application requirements.*/
232:                   int index;
233:                   for(index = 0;index < STREAMBUF;index ++)
0086F4  EB0100     CLR W2
0086F6  201003     MOV #0x100, W3
0086FA  E80102     INC W2, W2
0086FC  510F83     SUB W2, W3, [W15]
0086FE  3AFFFC     BRA NZ, 0x86F8
234:                   {
235:                       targetBuffer[index] = sourceBuffer[index];
0086F8  7818B0     MOV [W0++], [W1++]
236:                   }
237:               }
008700  060000     RETURN
238:               
239:               //A blocking delay function. Not very accurate but good enough.
240:               void Delay_us(unsigned int delay)
241:               {
242:                   int i;
243:                   for (i = 0; i < delay; i++)
008702  E00000     CP0 W0
008704  320006     BRA Z, 0x8712
008706  EB0080     CLR W1
00870C  E80081     INC W1, W1
00870E  500F81     SUB W0, W1, [W15]
008710  3EFFFB     BRA GTU, 0x8708
244:                   {
245:                       __asm__ volatile ("repeat #50");
008708  090032     REPEAT #0x32
246:                       __asm__ volatile ("nop");
00870A  000000     NOP
247:                   }
248:               }
008712  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/screens.c  --------------------------------------------
1:                 /*
2:                  * File:   screens.c
3:                  * Author: ryan
4:                  *
5:                  * Created on January 28, 2018, 11:17 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "common.h"
11:                #include "plcd.h"
12:                #include "dsp.h"
13:                #include "flash.h"
14:                
15:                extern unsigned char TEST_SIN;
16:                extern fractional pots[POTS];
17:                extern fractional pots_scaled[POTS];
18:                extern unsigned char pad[BUTTONS];
19:                extern enum screen state, laststate;
20:                extern char flash_readback[512];
21:                extern unsigned int process_time;
22:                
23:                
24:                void screenDebugAudio(){
25:                
26:                }
008714  060000     RETURN
27:                
28:                void screenDebugBuffers(){
29:                    if(state!=laststate){
008716  8080F0     MOV laststate, W0
008718  E3103E     CP 0x103E
00871A  32001B     BRA Z, 0x8752
30:                        //setup here
31:                        lcdClearQ();
00871C  07F970     RCALL lcdClearQ
32:                        lcdSetCursorQ(0,0);
00871E  EB4080     CLR.B W1
008720  784001     MOV.B W1, W0
008722  07F978     RCALL lcdSetCursorQ
33:                        lcdWriteStringQ("Buffer Debug");
008724  2F9400     MOV #0xF940, W0
008726  07F98A     RCALL lcdWriteStringQ
34:                        lcdSetCursorQ(0,1);
008728  B3C011     MOV.B #0x1, W1
00872A  EB4000     CLR.B W0
00872C  07F973     RCALL lcdSetCursorQ
35:                        lcdWriteStringQ("FX time:");
00872E  2F94D0     MOV #0xF94D, W0
008730  07F985     RCALL lcdWriteStringQ
36:                        lcdSetCursorQ(11,1);
008732  B3C011     MOV.B #0x1, W1
008734  B3C0B0     MOV.B #0xB, W0
008736  07F96E     RCALL lcdSetCursorQ
37:                        lcdWriteStringQ("/256");
008738  2F9560     MOV #0xF956, W0
00873A  07F980     RCALL lcdWriteStringQ
38:                        lcdSetCursorQ(0,2);
00873C  B3C021     MOV.B #0x2, W1
00873E  EB4000     CLR.B W0
008740  07F969     RCALL lcdSetCursorQ
39:                        lcdWriteStringQ("LCD:");
008742  2F95B0     MOV #0xF95B, W0
008744  07F97B     RCALL lcdWriteStringQ
40:                        lcdSetCursorQ(0,3);
008746  B3C031     MOV.B #0x3, W1
008748  EB4000     CLR.B W0
00874A  07F964     RCALL lcdSetCursorQ
41:                        lcdWriteStringQ("Flash:");
00874C  2F9600     MOV #0xF960, W0
00874E  07F976     RCALL lcdWriteStringQ
008750  370006     BRA 0x875E
42:                    } else {
43:                        //update here
44:                        lcdSetCursorQ(8,1);
008752  B3C011     MOV.B #0x1, W1
008754  B3C080     MOV.B #0x8, W0
008756  07F95E     RCALL lcdSetCursorQ
45:                        lcdWriteDecimalQ(process_time,3);
008758  200031     MOV #0x3, W1
00875A  BFD016     MOV.B process_time, WREG
00875C  07FA55     RCALL lcdWriteDecimalQ
46:                        //lcdSetCursorQ(4,2);
47:                        //lcdWriteDecimalQ();
48:                        //lcdSetCursorQ(6,3);
49:                        //lcdWriteDecimalQ();
50:                        
51:                    }
52:                }
00875E  060000     RETURN
53:                
54:                void screenDebugPots(void){
008760  BE9F88     MOV.D W8, [W15++]
008762  BE9F8A     MOV.D W10, [W15++]
55:                    int bank=0;
00879E  EB0480     CLR W9
56:                    
57:                    if(state!=laststate){
008764  8080F0     MOV laststate, W0
008766  E3103E     CP 0x103E
008768  320016     BRA Z, 0x8796
58:                        // Setup here
59:                        lcdClearQ();
00876A  07F949     RCALL lcdClearQ
60:                        lcdSetCursorQ(0,0);
00876C  EB4080     CLR.B W1
00876E  784001     MOV.B W1, W0
008770  07F951     RCALL lcdSetCursorQ
61:                        lcdWriteStringQ("Potentiometer Debug");
008772  2F9670     MOV #0xF967, W0
008774  07F963     RCALL lcdWriteStringQ
62:                        lcdSetCursorQ(9,1);
008776  B3C011     MOV.B #0x1, W1
008778  B3C090     MOV.B #0x9, W0
00877A  07F94C     RCALL lcdSetCursorQ
63:                        lcdWriteStringQ("|");
00877C  2F97B0     MOV #0xF97B, W0
00877E  07F95E     RCALL lcdWriteStringQ
64:                         lcdSetCursorQ(9,2);
008780  B3C021     MOV.B #0x2, W1
008782  B3C090     MOV.B #0x9, W0
008784  07F947     RCALL lcdSetCursorQ
65:                        lcdWriteStringQ("|");
008786  2F97B0     MOV #0xF97B, W0
008788  07F959     RCALL lcdWriteStringQ
66:                         lcdSetCursorQ(9,3);
00878A  B3C031     MOV.B #0x3, W1
00878C  B3C090     MOV.B #0x9, W0
00878E  07F942     RCALL lcdSetCursorQ
67:                        lcdWriteStringQ("|");
008790  2F97B0     MOV #0xF97B, W0
008792  07F954     RCALL lcdWriteStringQ
008794  37005A     BRA 0x884A
68:                    } else {
69:                        // Update here
70:                        if(!pad[34])bank=POTS/2;
008796  200069     MOV #0x6, W9
008798  268D80     MOV #0x68D8, W0
00879A  E00410     CP0.B [W0]
00879C  320001     BRA Z, 0x87A0
71:                        lcdSetCursorQ(0,1);
0087A0  B3C011     MOV.B #0x1, W1
0087A2  EB4000     CLR.B W0
0087A4  07F937     RCALL lcdSetCursorQ
72:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
0087A6  448589     ADD W9, W9, W11
0087A8  260868     MOV #0x6086, W8
0087AA  44000B     ADD W8, W11, W0
0087AC  780010     MOV [W0], W0
0087AE  200031     MOV #0x3, W1
0087B0  07FA2B     RCALL lcdWriteDecimalQ
73:                        lcdWriteQ(',');
0087B2  B3C2C0     MOV.B #0x2C, W0
0087B4  07F90F     RCALL lcdWriteQ
74:                        lcdWriteWordUnsignedQ(pots[bank++]);
0087B6  E80509     INC W9, W10
0087B8  2606E9     MOV #0x606E, W9
0087BA  44858B     ADD W9, W11, W11
0087BC  78001B     MOV [W11], W0
0087BE  07F9CC     RCALL lcdWriteWordUnsignedQ
75:                        lcdSetCursorQ(11,1);
0087C0  B3C011     MOV.B #0x1, W1
0087C2  B3C0B0     MOV.B #0xB, W0
0087C4  07F927     RCALL lcdSetCursorQ
76:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
0087C6  45058A     ADD W10, W10, W11
0087C8  44000B     ADD W8, W11, W0
0087CA  780010     MOV [W0], W0
0087CC  200031     MOV #0x3, W1
0087CE  07FA1C     RCALL lcdWriteDecimalQ
77:                        lcdWriteQ(',');
0087D0  B3C2C0     MOV.B #0x2C, W0
0087D2  07F900     RCALL lcdWriteQ
78:                        lcdWriteWordUnsignedQ(pots[bank++]);
0087D4  E8050A     INC W10, W10
0087D6  44858B     ADD W9, W11, W11
0087D8  78001B     MOV [W11], W0
0087DA  07F9BE     RCALL lcdWriteWordUnsignedQ
79:                        lcdSetCursorQ(0,2);
0087DC  B3C021     MOV.B #0x2, W1
0087DE  EB4000     CLR.B W0
0087E0  07F919     RCALL lcdSetCursorQ
80:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
0087E2  45058A     ADD W10, W10, W11
0087E4  44000B     ADD W8, W11, W0
0087E6  780010     MOV [W0], W0
0087E8  200031     MOV #0x3, W1
0087EA  07FA0E     RCALL lcdWriteDecimalQ
81:                        lcdWriteQ(',');
0087EC  B3C2C0     MOV.B #0x2C, W0
0087EE  07F8F2     RCALL lcdWriteQ
82:                        lcdWriteWordUnsignedQ(pots[bank++]);
0087F0  E8050A     INC W10, W10
0087F2  44858B     ADD W9, W11, W11
0087F4  78001B     MOV [W11], W0
0087F6  07F9B0     RCALL lcdWriteWordUnsignedQ
83:                        lcdSetCursorQ(11,2);
0087F8  B3C021     MOV.B #0x2, W1
0087FA  B3C0B0     MOV.B #0xB, W0
0087FC  07F90B     RCALL lcdSetCursorQ
84:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
0087FE  45058A     ADD W10, W10, W11
008800  44000B     ADD W8, W11, W0
008802  780010     MOV [W0], W0
008804  200031     MOV #0x3, W1
008806  07FA00     RCALL lcdWriteDecimalQ
85:                        lcdWriteQ(',');
008808  B3C2C0     MOV.B #0x2C, W0
00880A  07F8E4     RCALL lcdWriteQ
86:                        lcdWriteWordUnsignedQ(pots[bank++]);
00880C  E8050A     INC W10, W10
00880E  44858B     ADD W9, W11, W11
008810  78001B     MOV [W11], W0
008812  07F9A2     RCALL lcdWriteWordUnsignedQ
87:                        lcdSetCursorQ(0,3);
008814  B3C031     MOV.B #0x3, W1
008816  EB4000     CLR.B W0
008818  07F8FD     RCALL lcdSetCursorQ
88:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
00881A  45058A     ADD W10, W10, W11
00881C  44000B     ADD W8, W11, W0
00881E  780010     MOV [W0], W0
008820  200031     MOV #0x3, W1
008822  07F9F2     RCALL lcdWriteDecimalQ
89:                        lcdWriteQ(',');
008824  B3C2C0     MOV.B #0x2C, W0
008826  07F8D6     RCALL lcdWriteQ
90:                        lcdWriteWordUnsignedQ(pots[bank++]);
008828  E8050A     INC W10, W10
00882A  44858B     ADD W9, W11, W11
00882C  78001B     MOV [W11], W0
00882E  07F994     RCALL lcdWriteWordUnsignedQ
91:                        lcdSetCursorQ(11,3);
008830  B3C031     MOV.B #0x3, W1
008832  B3C0B0     MOV.B #0xB, W0
008834  07F8EF     RCALL lcdSetCursorQ
92:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
008836  45050A     ADD W10, W10, W10
008838  44040A     ADD W8, W10, W8
00883A  780018     MOV [W8], W0
00883C  200031     MOV #0x3, W1
00883E  07F9E4     RCALL lcdWriteDecimalQ
93:                        lcdWriteQ(',');
008840  B3C2C0     MOV.B #0x2C, W0
008842  07F8C8     RCALL lcdWriteQ
94:                        lcdWriteWordUnsignedQ(pots[bank++]);
008844  44850A     ADD W9, W10, W10
008846  78001A     MOV [W10], W0
008848  07F987     RCALL lcdWriteWordUnsignedQ
95:                    }
96:                }
00884A  BE054F     MOV.D [--W15], W10
00884C  BE044F     MOV.D [--W15], W8
00884E  060000     RETURN
97:                
98:                void screenFX(void){
99:                    if(state!=laststate){
008850  8080F0     MOV laststate, W0
008852  E3103E     CP 0x103E
008854  32002A     BRA Z, 0x88AA
100:                       //setup here
101:                       lcdClearQ();
008856  07F8D3     RCALL lcdClearQ
102:                       lcdSetCursorQ(0,0);
008858  EB4080     CLR.B W1
00885A  784001     MOV.B W1, W0
00885C  07F8DB     RCALL lcdSetCursorQ
103:                       lcdWriteStringQ("FX1:");
00885E  2F97D0     MOV #0xF97D, W0
008860  07F8ED     RCALL lcdWriteStringQ
104:                       lcdSetCursorQ(10,0);
008862  EB4080     CLR.B W1
008864  B3C0A0     MOV.B #0xA, W0
008866  07F8D6     RCALL lcdSetCursorQ
105:                       lcdWriteStringQ("FX2:");
008868  2F9820     MOV #0xF982, W0
00886A  07F8E8     RCALL lcdWriteStringQ
106:                       
107:                       lcdSetCursorQ(0,1);
00886C  B3C011     MOV.B #0x1, W1
00886E  EB4000     CLR.B W0
008870  07F8D1     RCALL lcdSetCursorQ
108:                       lcdWriteStringQ("1:");
008872  2F9870     MOV #0xF987, W0
008874  07F8E3     RCALL lcdWriteStringQ
109:                       lcdSetCursorQ(10,1);
008876  B3C011     MOV.B #0x1, W1
008878  B3C0A0     MOV.B #0xA, W0
00887A  07F8CC     RCALL lcdSetCursorQ
110:                       lcdWriteStringQ("4:");
00887C  2F98A0     MOV #0xF98A, W0
00887E  07F8DE     RCALL lcdWriteStringQ
111:                       lcdSetCursorQ(0,2);
008880  B3C021     MOV.B #0x2, W1
008882  EB4000     CLR.B W0
008884  07F8C7     RCALL lcdSetCursorQ
112:                       lcdWriteStringQ("2:");
008886  2F98D0     MOV #0xF98D, W0
008888  07F8D9     RCALL lcdWriteStringQ
113:                       lcdSetCursorQ(10,2);
00888A  B3C021     MOV.B #0x2, W1
00888C  B3C0A0     MOV.B #0xA, W0
00888E  07F8C2     RCALL lcdSetCursorQ
114:                       lcdWriteStringQ("5:");
008890  2F9900     MOV #0xF990, W0
008892  07F8D4     RCALL lcdWriteStringQ
115:                       lcdSetCursorQ(0,3);
008894  B3C031     MOV.B #0x3, W1
008896  EB4000     CLR.B W0
008898  07F8BD     RCALL lcdSetCursorQ
116:                       lcdWriteStringQ("3:");
00889A  2F9930     MOV #0xF993, W0
00889C  07F8CF     RCALL lcdWriteStringQ
117:                       lcdSetCursorQ(10,3);
00889E  B3C031     MOV.B #0x3, W1
0088A0  B3C0A0     MOV.B #0xA, W0
0088A2  07F8B8     RCALL lcdSetCursorQ
118:                       lcdWriteStringQ("6:");
0088A4  2F9960     MOV #0xF996, W0
0088A6  07F8CA     RCALL lcdWriteStringQ
0088A8  370024     BRA 0x88F2
119:                   } else {
120:                       //update here
121:                       lcdSetCursorQ(2,1);
0088AA  B3C011     MOV.B #0x1, W1
0088AC  B3C020     MOV.B #0x2, W0
0088AE  07F8B2     RCALL lcdSetCursorQ
122:                       lcdWriteDecimalQ(pots_scaled[0], 3);
0088B0  200031     MOV #0x3, W1
0088B2  830430     MOV pots_scaled, W0
0088B4  07F9A9     RCALL lcdWriteDecimalQ
123:                       lcdSetCursorQ(12,1);
0088B6  B3C011     MOV.B #0x1, W1
0088B8  B3C0C0     MOV.B #0xC, W0
0088BA  07F8AC     RCALL lcdSetCursorQ
124:                       lcdWriteDecimalQ(pots_scaled[1], 3);
0088BC  200031     MOV #0x3, W1
0088BE  830440     MOV 0x6088, W0
0088C0  07F9A3     RCALL lcdWriteDecimalQ
125:                       lcdSetCursorQ(2,2);
0088C2  B3C021     MOV.B #0x2, W1
0088C4  784001     MOV.B W1, W0
0088C6  07F8A6     RCALL lcdSetCursorQ
126:                       lcdWriteDecimalQ(pots_scaled[2], 3);
0088C8  200031     MOV #0x3, W1
0088CA  830450     MOV 0x608A, W0
0088CC  07F99D     RCALL lcdWriteDecimalQ
127:                       lcdSetCursorQ(12,2);
0088CE  B3C021     MOV.B #0x2, W1
0088D0  B3C0C0     MOV.B #0xC, W0
0088D2  07F8A0     RCALL lcdSetCursorQ
128:                       lcdWriteDecimalQ(pots_scaled[3], 3);
0088D4  200031     MOV #0x3, W1
0088D6  830460     MOV 0x608C, W0
0088D8  07F997     RCALL lcdWriteDecimalQ
129:                       lcdSetCursorQ(2,3);
0088DA  B3C031     MOV.B #0x3, W1
0088DC  B3C020     MOV.B #0x2, W0
0088DE  07F89A     RCALL lcdSetCursorQ
130:                       lcdWriteDecimalQ(pots_scaled[4], 3);
0088E0  200031     MOV #0x3, W1
0088E2  830470     MOV 0x608E, W0
0088E4  07F991     RCALL lcdWriteDecimalQ
131:                       lcdSetCursorQ(12,3);
0088E6  B3C031     MOV.B #0x3, W1
0088E8  B3C0C0     MOV.B #0xC, W0
0088EA  07F894     RCALL lcdSetCursorQ
132:                       lcdWriteDecimalQ(pots_scaled[5], 3);
0088EC  200031     MOV #0x3, W1
0088EE  830480     MOV 0x6090, W0
0088F0  07F98B     RCALL lcdWriteDecimalQ
133:               
134:                   }
135:               }
0088F2  060000     RETURN
136:               
137:               void screenDebugFlash(void){
0088F4  781F88     MOV W8, [W15++]
138:                       if(state!=laststate){
0088F6  8080F0     MOV laststate, W0
0088F8  E3103E     CP 0x103E
0088FA  32003D     BRA Z, 0x8976
139:                       //setup here
140:                       lcdClearQ();
0088FC  07F880     RCALL lcdClearQ
141:                       lcdSetCursorQ(0,0);
0088FE  EB4080     CLR.B W1
008900  784001     MOV.B W1, W0
008902  07F888     RCALL lcdSetCursorQ
142:                       lcdWriteWordQ(flash_readback[2]);
008904  25E700     MOV #0x5E70, W0
008906  FB0010     SE [W0], W0
008908  07F8B7     RCALL lcdWriteWordQ
143:                        lcdSetCursorQ(6,0);
00890A  EB4080     CLR.B W1
00890C  B3C060     MOV.B #0x6, W0
00890E  07F882     RCALL lcdSetCursorQ
144:                       lcdWriteWordQ(flash_readback[3]);
008910  25E710     MOV #0x5E71, W0
008912  FB0010     SE [W0], W0
008914  07F8B1     RCALL lcdWriteWordQ
145:                        lcdSetCursorQ(12,0);
008916  EB4080     CLR.B W1
008918  B3C0C0     MOV.B #0xC, W0
00891A  07F87C     RCALL lcdSetCursorQ
146:                       lcdWriteWordQ(flash_readback[4]);
00891C  25E720     MOV #0x5E72, W0
00891E  FB0010     SE [W0], W0
008920  07F8AB     RCALL lcdWriteWordQ
147:                        lcdSetCursorQ(0,1);
008922  B3C011     MOV.B #0x1, W1
008924  EB4000     CLR.B W0
008926  07F876     RCALL lcdSetCursorQ
148:                       lcdWriteWordQ(flash_readback[5]);
008928  25E730     MOV #0x5E73, W0
00892A  FB0010     SE [W0], W0
00892C  07F8A5     RCALL lcdWriteWordQ
149:                       lcdSetCursorQ(6,1);
00892E  B3C011     MOV.B #0x1, W1
008930  B3C060     MOV.B #0x6, W0
008932  07F870     RCALL lcdSetCursorQ
150:                       lcdWriteWordQ(flash_readback[6]);
008934  25E740     MOV #0x5E74, W0
008936  FB0010     SE [W0], W0
008938  07F89F     RCALL lcdWriteWordQ
151:                        lcdSetCursorQ(12,1);
00893A  B3C011     MOV.B #0x1, W1
00893C  B3C0C0     MOV.B #0xC, W0
00893E  07F86A     RCALL lcdSetCursorQ
152:                       lcdWriteWordQ(flash_readback[7]);
008940  25E750     MOV #0x5E75, W0
008942  FB0010     SE [W0], W0
008944  07F899     RCALL lcdWriteWordQ
153:                       lcdSetCursorQ(0,2);
008946  B3C021     MOV.B #0x2, W1
008948  EB4000     CLR.B W0
00894A  07F864     RCALL lcdSetCursorQ
154:                       lcdWriteWordQ(flash_readback[8]);
00894C  25E768     MOV #0x5E76, W8
00894E  FB0018     SE [W8], W0
008950  07F893     RCALL lcdWriteWordQ
155:                       lcdSetCursorQ(6,2);
008952  B3C021     MOV.B #0x2, W1
008954  B3C060     MOV.B #0x6, W0
008956  07F85E     RCALL lcdSetCursorQ
156:                       lcdWriteWordQ(flash_readback[9]);
008958  E80008     INC W8, W0
00895A  FB0010     SE [W0], W0
00895C  07F88D     RCALL lcdWriteWordQ
157:                        lcdSetCursorQ(12,2);
00895E  B3C021     MOV.B #0x2, W1
008960  B3C0C0     MOV.B #0xC, W0
008962  07F858     RCALL lcdSetCursorQ
158:                       lcdWriteWordQ(flash_readback[10]);
008964  E88008     INC2 W8, W0
008966  FB0010     SE [W0], W0
008968  07F887     RCALL lcdWriteWordQ
159:                       lcdSetCursorQ(0,3);
00896A  B3C031     MOV.B #0x3, W1
00896C  EB4000     CLR.B W0
00896E  07F852     RCALL lcdSetCursorQ
160:                       lcdWriteWordQ(flash_readback[8]);
008970  FB0018     SE [W8], W0
008972  07F882     RCALL lcdWriteWordQ
008974  370008     BRA 0x8986
161:                   } else {
162:                       //update here
163:                       lcdSetCursorQ(9,3);
008976  B3C031     MOV.B #0x3, W1
008978  B3C090     MOV.B #0x9, W0
00897A  07F84C     RCALL lcdSetCursorQ
164:                       lcdWriteStringQ("Stat:");
00897C  2F9990     MOV #0xF999, W0
00897E  07F85E     RCALL lcdWriteStringQ
165:                       lcdWriteWordQ(flashStatusCheck());
008980  0701F5     RCALL flashStatusCheck
008982  FB0000     SE W0, W0
008984  07F879     RCALL lcdWriteWordQ
166:                   }
167:               }
008986  78044F     MOV [--W15], W8
008988  060000     RETURN
168:               
169:               void screenDebugInput(void){
170:                   if(state!=laststate){
00898A  8080F0     MOV laststate, W0
00898C  E3103E     CP 0x103E
00898E  32000C     BRA Z, 0x89A8
171:                       //setup here
172:                       lcdClearQ();
008990  07F836     RCALL lcdClearQ
173:                       lcdSetCursorQ(0,0);
008992  EB4080     CLR.B W1
008994  784001     MOV.B W1, W0
008996  07F83E     RCALL lcdSetCursorQ
174:                       lcdWriteStringQ("Input Debug");
008998  2F99F0     MOV #0xF99F, W0
00899A  07F850     RCALL lcdWriteStringQ
175:                       lcdSetCursorQ(0,1);
00899C  B3C011     MOV.B #0x1, W1
00899E  EB4000     CLR.B W0
0089A0  07F839     RCALL lcdSetCursorQ
176:                       lcdWriteStringQ("ADC variance: ");
0089A2  2F9AB0     MOV #0xF9AB, W0
0089A4  07F84B     RCALL lcdWriteStringQ
0089A6  370002     BRA 0x89AC
177:                   } else {
178:                       //update here
179:                       lcdDrawPads(16);
0089A8  B3C100     MOV.B #0x10, W0
0089AA  07F960     RCALL lcdDrawPads
180:                   }
181:               }
0089AC  060000     RETURN
182:               
183:               void screenUpdate(void){
184:                   switch(state){
0089AE  8081F0     MOV 0x103E, W0
0089B0  500FE3     SUB W0, #0x3, [W15]
0089B2  32000F     BRA Z, 0x89D2
0089B4  3E0005     BRA GTU, 0x89C0
0089B6  500FE1     SUB W0, #0x1, [W15]
0089B8  320008     BRA Z, 0x89CA
0089BA  500FE2     SUB W0, #0x2, [W15]
0089BC  3A000F     BRA NZ, 0x89DC
0089BE  370007     BRA 0x89CE
0089C0  500FE4     SUB W0, #0x4, [W15]
0089C2  320009     BRA Z, 0x89D6
0089C4  500FE5     SUB W0, #0x5, [W15]
0089C6  3A000A     BRA NZ, 0x89DC
0089C8  370008     BRA 0x89DA
185:                       case start: break;
186:                       case scrnFX:            screenFX(); 
0089CA  07FF42     RCALL screenFX
187:                       break;
0089CC  370007     BRA 0x89DC
188:                       case debugscrnPOTS:     screenDebugPots();
0089CE  07FEC8     RCALL screenDebugPots
189:                       break;
0089D0  370005     BRA 0x89DC
190:                       case debugscrnFLASH:    screenDebugFlash();
0089D2  07FF90     RCALL screenDebugFlash
191:                       break;
0089D4  370003     BRA 0x89DC
192:                       case debugscrnBUFFERS:  screenDebugBuffers();
0089D6  07FE9F     RCALL screenDebugBuffers
193:                       break;
0089D8  370001     BRA 0x89DC
194:                       case debugscrnINPUT:    screenDebugInput();
0089DA  07FFD7     RCALL screenDebugInput
195:                       break;
196:                                       
197:                       default: break;
198:                   }
199:                   
200:                   laststate=state;
0089DC  F8103E     PUSH 0x103E
0089DE  F9101E     POP laststate
201:               }
0089E0  060000     RETURN
202:               
203:                   /*
204:                   lcdSetCursorQ(0,3);
205:                   if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
206:                       lcdWriteStringQ("CLIP");
207:                       hard_clipped=FALSE;  
208:                   }
209:                   else if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
210:                   else lcdWriteStringQ("THRU");
211:                    * 
212:                    *    lcdSetCursorQ(10,3);
213:                  lcdWriteWordQ(ENCODERCNTL);
214:                   */
215:               
216:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/routines.c  -------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
10:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
11:                extern unsigned int write_ptr, rw, frameReady;
12:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
13:                
14:                //misc.
15:                volatile fractional sampinA=0, sampinB=0;
16:                
17:                volatile int rxBufferIndicator = 0;
18:                fractional *ping, *pong;
19:                
20:                //Description: This interrupt triggers at the completion of DCI output
21:                //Dependancies: initSPI2(); 
22:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
000306  BE9F80     MOV.D W0, [W15++]
000308  BE9F82     MOV.D W2, [W15++]
00030A  781F84     MOV W4, [W15++]
00030C  F80032     PUSH DSRPAG
00030E  F80034     PUSH DSWPAG
000310  200010     MOV #0x1, W0
000312  8801A0     MOV W0, DSWPAG
000314  202000     MOV #0x200, W0
000316  880190     MOV W0, DSRPAG
000318  000000     NOP
23:                    static fractional sampoutA=0, sampoutB=0;
24:                    
25:                    int trashA=RXBUF0;
00031A  801480     MOV RXBUF0, W0
26:                    sampinA=RXBUF1;
00031C  F80292     PUSH RXBUF1
00031E  F91020     POP sampinA
27:                    int trashB=RXBUF2;
000320  8014A0     MOV RXBUF2, W0
28:                    sampinB=RXBUF3;
000322  F80296     PUSH RXBUF3
000324  F91022     POP sampinB
29:                    TXBUF0=TXBUF1=sampoutA;                                    //output buffered sample to DAC
000326  F8102C     PUSH sampoutA
000328  F9029A     POP TXBUF1
00032A  F8029A     PUSH TXBUF1
00032C  F90298     POP TXBUF0
30:                    TXBUF2=TXBUF3=sampoutB;
00032E  F8102A     PUSH sampoutB
000330  F9029E     POP TXBUF3
000332  F8029E     PUSH TXBUF3
000334  F9029C     POP TXBUF2
31:                
32:                
33:                    
34:                    __builtin_btg(&sampinA, 15);                             //convert to Q1.15 compatible format
000336  210200     MOV #0x1020, W0
000338  A2F010     BTG [W0], #15
35:                    __builtin_btg(&sampinB, 15);                             //convert to Q1.15 compatible format
00033A  210220     MOV #0x1022, W0
00033C  A2F010     BTG [W0], #15
36:                    
37:                
38:                      
39:                    
40:                    if(write_ptr--==0){                       //reset pointer when out of bounds
00033E  8081D0     MOV 0x103A, W0
000340  E90080     DEC W0, W1
000342  8881D1     MOV W1, 0x103A
000344  E00000     CP0 W0
000346  3A0005     BRA NZ, 0x352
41:                        write_ptr=STREAMBUF-1;
000348  200FF0     MOV #0xFF, W0
00034A  8881D0     MOV W0, 0x103A
42:                        __builtin_btg(&rw,0);
00034C  AA1012     BTG rw, #0
43:                        frameReady=1;
00034E  200010     MOV #0x1, W0
000350  8880A0     MOV W0, frameReady
44:                    }
45:                   
46:                    if(rw){
000352  E21012     CP0 rw
000354  320014     BRA Z, 0x37E
47:                        streamB[write_ptr]=sampinA;
000356  8081D0     MOV 0x103A, W0
000358  266B62     MOV #0x66B6, W2
00035A  400180     ADD W0, W0, W3
00035C  410083     ADD W2, W3, W1
00035E  808104     MOV sampinA, W4
000360  780884     MOV W4, [W1]
48:                        sampoutA=outputA[write_ptr--]; 
000362  260B61     MOV #0x60B6, W1
000364  408183     ADD W1, W3, W3
000366  780193     MOV [W3], W3
000368  888163     MOV W3, sampoutA
00036A  E90000     DEC W0, W0
00036C  8881D0     MOV W0, 0x103A
49:                        streamB[write_ptr]=sampinB;
00036E  400000     ADD W0, W0, W0
000370  410100     ADD W2, W0, W2
000372  808113     MOV sampinB, W3
000374  780903     MOV W3, [W2]
50:                        sampoutB=outputA[write_ptr];
000376  408000     ADD W1, W0, W0
000378  780010     MOV [W0], W0
00037A  888150     MOV W0, sampoutB
00037C  370013     BRA 0x3A4
51:                        
52:                    }
53:                    else {
54:                        streamA[write_ptr]=sampinA; 
00037E  8081D0     MOV 0x103A, W0
000380  264B62     MOV #0x64B6, W2
000382  400180     ADD W0, W0, W3
000384  410083     ADD W2, W3, W1
000386  808104     MOV sampinA, W4
000388  780884     MOV W4, [W1]
55:                        sampoutA=outputB[write_ptr--];  
00038A  262B61     MOV #0x62B6, W1
00038C  408183     ADD W1, W3, W3
00038E  780193     MOV [W3], W3
000390  888163     MOV W3, sampoutA
000392  E90000     DEC W0, W0
000394  8881D0     MOV W0, 0x103A
56:                        streamA[write_ptr]=sampinB; 
000396  400000     ADD W0, W0, W0
000398  410100     ADD W2, W0, W2
00039A  808113     MOV sampinB, W3
00039C  780903     MOV W3, [W2]
57:                        sampoutB=outputB[write_ptr];  
00039E  408000     ADD W1, W0, W0
0003A0  780010     MOV [W0], W0
0003A2  888150     MOV W0, sampoutB
58:                    } 
59:                    
60:                    _DCIIF=0;
0003A4  A98807     BCLR 0x807, #4
61:                }
0003A6  F90034     POP DSWPAG
0003A8  F90032     POP DSRPAG
0003AA  78024F     MOV [--W15], W4
0003AC  BE014F     MOV.D [--W15], W2
0003AE  BE004F     MOV.D [--W15], W0
0003B0  064000     RETFIE
62:                
63:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003B2  F80036     PUSH RCOUNT
0003B4  BE9F80     MOV.D W0, [W15++]
0003B6  BE9F82     MOV.D W2, [W15++]
0003B8  BE9F84     MOV.D W4, [W15++]
0003BA  BE9F86     MOV.D W6, [W15++]
64:                    _DMA2IF = 0; /* Received one frame of data*/    
0003BC  A90803     BCLR 0x803, #0
65:                    
66:                    if(rxBufferIndicator == 0)
0003BE  E21024     CP0 rxBufferIndicator
0003C0  3A0004     BRA NZ, 0x3CA
67:                    {
68:                         processRxData((int *)rxBufferA, (int*)txBufferA);
0003C2  2CE001     MOV #0xCE00, W1
0003C4  2CA000     MOV #0xCA00, W0
0003C6  074196     RCALL processRxData
0003C8  370003     BRA 0x3D0
69:                    }
70:                    else
71:                    {
72:                         processRxData((int *)rxBufferB, (int*)txBufferB);
0003CA  2CC001     MOV #0xCC00, W1
0003CC  2C8000     MOV #0xC800, W0
0003CE  074192     RCALL processRxData
73:                    }
74:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
0003D0  AA1024     BTG rxBufferIndicator, #0
75:                }
0003D2  BE034F     MOV.D [--W15], W6
0003D4  BE024F     MOV.D [--W15], W4
0003D6  BE014F     MOV.D [--W15], W2
0003D8  BE004F     MOV.D [--W15], W0
0003DA  F90036     POP RCOUNT
0003DC  064000     RETFIE
76:                
77:                /*
78:                //Description: This interrupt handles UART reception
79:                //Dependencies: initUART1();
80:                void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
81:                    unsigned char trash;
82:                    trash=U1RXREG;
83:                    printf("RECIEVED: %d\r\n", trash);
84:                    IFS0bits.U1RXIF = 0;            //clear flag, restart
85:                }
86:                
87:                //Description: This interrupt handles UART transmission
88:                //Dependencies: initUART1();
89:                void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
90:                    YLED=~YLED;
91:                    IFS0bits.U1TXIF = 0;            //clear flag, restart
92:                } 
93:                  
94:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
95:                    //SEG_SEL=1;
96:                    int trash=SPI3BUF;
97:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
98:                    IFS5bits.SPI3IF=0;
99:                    
100:               }
101:                */
---  C:/Users/ryan/Documents/seniorproject/ps-040/plcd.c  -----------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                #include "screens.h"
14:                
15:                extern unsigned char pad[BUTTONS];
16:                int lcdBuf[LCDBUF+1]={0};
17:                int *lcdWritePtr=lcdBuf;
18:                int *lcdReadPtr=lcdBuf;
19:                
20:                // There are write and command macros in the header, make sure these match.
21:                void lcdWriteQ(unsigned char data){
22:                    *lcdWritePtr++=data|0x0000;
0079D4  FB8000     ZE W0, W0
0079D6  808231     MOV 0x1046, W1
0079D8  781880     MOV W0, [W1++]
0079DA  888231     MOV W1, 0x1046
23:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
0079DC  26ADA0     MOV #0x6ADA, W0
0079DE  508F80     SUB W1, W0, [W15]
0079E0  3A0002     BRA NZ, 0x79E6
24:                        lcdWritePtr=lcdBuf;
0079E2  B12000     SUB #0x200, W0
0079E4  888230     MOV W0, 0x1046
25:                }
0079E6  060000     RETURN
26:                
27:                // There are write and command macros in the header, make sure these match.
28:                void lcdCommandQ(unsigned char data){
29:                    *lcdWritePtr++=data|0x0100;     //flag for rs=1
0079E8  FB8000     ZE W0, W0
0079EA  808231     MOV 0x1046, W1
0079EC  A08000     BSET W0, #8
0079EE  781880     MOV W0, [W1++]
0079F0  888231     MOV W1, 0x1046
30:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
0079F2  26ADA0     MOV #0x6ADA, W0
0079F4  508F80     SUB W1, W0, [W15]
0079F6  3A0002     BRA NZ, 0x79FC
31:                        lcdWritePtr=lcdBuf;
0079F8  B12000     SUB #0x200, W0
0079FA  888230     MOV W0, 0x1046
32:                }
0079FC  060000     RETURN
33:                
34:                void lcdClearQ(void){
35:                    *lcdWritePtr++=LCD_CLEARDISPLAY|0x0300;     //flag for rs=1 & long delay
0079FE  808230     MOV 0x1046, W0
007A00  203011     MOV #0x301, W1
007A02  781801     MOV W1, [W0++]
007A04  888230     MOV W0, 0x1046
36:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007A06  26ADA1     MOV #0x6ADA, W1
007A08  500F81     SUB W0, W1, [W15]
007A0A  3A0003     BRA NZ, 0x7A12
37:                        lcdWritePtr=lcdBuf;
007A0C  2FE000     MOV #0xFE00, W0
007A0E  400001     ADD W0, W1, W0
007A10  888230     MOV W0, 0x1046
38:                }
007A12  060000     RETURN
39:                
40:                void lcdSetCursorQ(unsigned char col, unsigned char row) {
007A14  784101     MOV.B W1, W2
41:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
42:                  if (row > 3) {
43:                    row = 3;
44:                  }
45:                  *lcdWritePtr++=(LCD_SETDDRAMADDR | (col + offsets[row]))|0x0100;  //flag for rs=0 
007A16  808231     MOV 0x1046, W1
007A18  514FE3     SUB.B W2, #0x3, [W15]
007A1A  360001     BRA LEU, 0x7A1E
007A1C  B3C032     MOV.B #0x3, W2
007A1E  FB8102     ZE W2, W2
007A20  2F9D03     MOV #0xF9D0, W3
007A22  418102     ADD W3, W2, W2
007A24  FB8112     ZE [W2], W2
007A26  FB8000     ZE W0, W0
007A28  410000     ADD W2, W0, W0
007A2A  201802     MOV #0x180, W2
007A2C  701882     IOR W0, W2, [W1++]
007A2E  888231     MOV W1, 0x1046
46:                    if(lcdWritePtr==&lcdBuf[LCDBUF]) 
007A30  26ADA0     MOV #0x6ADA, W0
007A32  508F80     SUB W1, W0, [W15]
007A34  3A0002     BRA NZ, 0x7A3A
47:                        lcdWritePtr=lcdBuf; 
007A36  B12000     SUB #0x200, W0
007A38  888230     MOV W0, 0x1046
48:                }
007A3A  060000     RETURN
49:                
50:                void lcdWriteStringQ(char *string) {
51:                    char *it = string;
52:                    for (; *it; it++) {
007A3C  784090     MOV.B [W0], W1
007A3E  E00401     CP0.B W1
007A40  32000D     BRA Z, 0x7A5C
007A56  7840D0     MOV.B [++W0], W1
007A58  E00401     CP0.B W1
007A5A  3AFFF6     BRA NZ, 0x7A48
53:                        lcdWriteQMac(*it);
007A42  26ADA3     MOV #0x6ADA, W3
007A44  2FE004     MOV #0xFE00, W4
007A46  420203     ADD W4, W3, W4
007A48  FB0101     SE W1, W2
007A4A  808231     MOV 0x1046, W1
007A4C  781882     MOV W2, [W1++]
007A4E  888231     MOV W1, 0x1046
007A50  508F83     SUB W1, W3, [W15]
007A52  3A0001     BRA NZ, 0x7A56
007A54  888234     MOV W4, 0x1046
54:                  }
55:                }
007A5C  060000     RETURN
56:                
57:                void lcdCustomSymbols(void){
58:                    int i=0;
59:                    lcdCommandQMac(0x40);
007A5E  808230     MOV 0x1046, W0
007A60  201401     MOV #0x140, W1
007A62  781801     MOV W1, [W0++]
007A64  888230     MOV W0, 0x1046
007A66  26ADA1     MOV #0x6ADA, W1
007A68  500F81     SUB W0, W1, [W15]
007A6A  3A0003     BRA NZ, 0x7A72
007A6C  2FE000     MOV #0xFE00, W0
007A6E  400001     ADD W0, W1, W0
007A70  888230     MOV W0, 0x1046
60:                    Delay_us(200);
007A72  200C80     MOV #0xC8, W0
007A74  070646     RCALL Delay_us
61:                   // for(; i<8; i++)lcdWriteString(loadingOne[i]);
62:                    //lcdWriteString(loadingTwo);
63:                    //lcdWriteString(loadingThree);
64:                    //lcdWriteString(loadingFour);
65:                }
007A76  060000     RETURN
66:                
67:                void lcdWriteWordQ(int word){
007A78  4787E6     ADD W15, #0x6, W15
007A7A  781F8E     MOV W14, [W15++]
007ABE  200041     MOV #0x4, W1
68:                    int i;
69:                    char inchar[4];
70:                    
71:                    if(word<0) {
007A7C  E00000     CP0 W0
007A7E  3D000C     BRA GE, 0x7A98
72:                        lcdWriteQMac('-');
007A80  808231     MOV 0x1046, W1
007A82  2002D2     MOV #0x2D, W2
007A84  781882     MOV W2, [W1++]
007A86  888231     MOV W1, 0x1046
007A88  26ADA2     MOV #0x6ADA, W2
007A8A  508F82     SUB W1, W2, [W15]
007A8C  3A0003     BRA NZ, 0x7A94
007A8E  2FE001     MOV #0xFE00, W1
007A90  408082     ADD W1, W2, W1
007A92  888231     MOV W1, 0x1046
73:                        word=~word+1;
007A94  EA0000     NEG W0, W0
007A96  37000A     BRA 0x7AAC
74:                    }else lcdWriteQMac(' ');
007A98  808231     MOV 0x1046, W1
007A9A  200202     MOV #0x20, W2
007A9C  781882     MOV W2, [W1++]
007A9E  888231     MOV W1, 0x1046
007AA0  26ADA2     MOV #0x6ADA, W2
007AA2  508F82     SUB W1, W2, [W15]
007AA4  3A0003     BRA NZ, 0x7AAC
007AA6  2FE001     MOV #0xFE00, W1
007AA8  408082     ADD W1, W2, W1
007AAA  888231     MOV W1, 0x1046
75:                   
76:                   inchar[0] = word&0x000F; 
007AAC  6040EF     AND.B W0, #0xF, W1
77:                   if (inchar[0] > 9) 
007AAE  50CFE9     SUB.B W1, #0x9, [W15]
007AB0  340003     BRA LE, 0x7AB8
78:                       inchar[0]+=55;
007AB2  B04371     ADD.B #0x37, W1
007AB4  9FFFA1     MOV.B W1, [W15-6]
007AB6  370002     BRA 0x7ABC
79:                   else inchar[0]+=48;
007AB8  B04301     ADD.B #0x30, W1
007ABA  9FFFA1     MOV.B W1, [W15-6]
007ABC  578766     SUB W15, #0x6, W14
80:                   
81:                   for(i=1; i<4; i++){ 
007AD8  508FF0     SUB W1, #0x10, [W15]
007ADA  3AFFF2     BRA NZ, 0x7AC0
82:                      inchar[i] = ((word>>(i*4))&0x0000F); 
007AC0  DE8101     ASR W0, W1, W2
007AC2  61416F     AND.B W2, #0xF, W2
007AC4  E8070E     INC W14, W14
007AC6  784F02     MOV.B W2, [W14]
83:                      if (inchar[i] > 9) 
007AC8  514FE9     SUB.B W2, #0x9, [W15]
007ACA  340003     BRA LE, 0x7AD2
84:                          inchar[i]+=55;
007ACC  B3C374     MOV.B #0x37, W4
007ACE  414F04     ADD.B W2, W4, [W14]
007AD0  370002     BRA 0x7AD6
85:                      else inchar[i]+=48;
007AD2  B3C304     MOV.B #0x30, W4
007AD4  414F04     ADD.B W2, W4, [W14]
007AD6  4080E4     ADD W1, #0x4, W1
86:                   } 
87:                   lcdWriteQMac(inchar[3]);
007ADC  97F8DF     MOV.B [W15-3], W1
007ADE  FB0081     SE W1, W1
007AE0  808230     MOV 0x1046, W0
007AE2  781801     MOV W1, [W0++]
007AE4  26ADA1     MOV #0x6ADA, W1
007AE6  500F81     SUB W0, W1, [W15]
007AE8  3A000A     BRA NZ, 0x7AFE
88:                   lcdWriteQMac(inchar[2]);
007AEA  97F84F     MOV.B [W15-4], W0
007AEC  FB0000     SE W0, W0
007AEE  8B46D0     MOV W0, lcdBuf
007AFE  97F8CF     MOV.B [W15-4], W1
007B00  FB0081     SE W1, W1
007B02  781801     MOV W1, [W0++]
007B04  888230     MOV W0, 0x1046
007B06  26ADA1     MOV #0x6ADA, W1
007B08  500F81     SUB W0, W1, [W15]
007B0A  3A0009     BRA NZ, 0x7B1E
89:                   lcdWriteQMac(inchar[1]);
007AF0  97F83F     MOV.B [W15-5], W0
007AF2  FB0000     SE W0, W0
007AF4  8B46E0     MOV W0, 0x68DC
007AF6  2FE040     MOV #0xFE04, W0
007AF8  400001     ADD W0, W1, W0
007AFA  888230     MOV W0, 0x1046
007AFC  37001F     BRA 0x7B3C
007B0C  97F83F     MOV.B [W15-5], W0
007B0E  FB0000     SE W0, W0
007B10  8B46D0     MOV W0, lcdBuf
007B1E  97F8BF     MOV.B [W15-5], W1
007B20  FB0081     SE W1, W1
007B22  808230     MOV 0x1046, W0
007B24  781801     MOV W1, [W0++]
007B26  888230     MOV W0, 0x1046
007B28  26ADA1     MOV #0x6ADA, W1
007B2A  500F81     SUB W0, W1, [W15]
007B2C  3A0007     BRA NZ, 0x7B3C
90:                   lcdWriteQMac(inchar[0]);
007B12  97F8AF     MOV.B [W15-6], W1
007B14  FB0001     SE W1, W0
007B16  8B46E0     MOV W0, 0x68DC
007B18  268DE0     MOV #0x68DE, W0
007B1A  888230     MOV W0, 0x1046
007B1C  37001A     BRA 0x7B52
007B2E  97FA2F     MOV.B [W15-6], W4
007B30  FB0004     SE W4, W0
007B32  8B46D0     MOV W0, lcdBuf
007B34  2FE020     MOV #0xFE02, W0
007B36  400001     ADD W0, W1, W0
007B38  888230     MOV W0, 0x1046
007B3A  37000B     BRA 0x7B52
007B3C  97F82F     MOV.B [W15-6], W0
007B3E  FB0080     SE W0, W1
007B40  808230     MOV 0x1046, W0
007B42  781801     MOV W1, [W0++]
007B44  888230     MOV W0, 0x1046
007B46  26ADA1     MOV #0x6ADA, W1
007B48  500F81     SUB W0, W1, [W15]
007B4A  3A0003     BRA NZ, 0x7B52
007B4C  2FE000     MOV #0xFE00, W0
007B4E  400001     ADD W0, W1, W0
007B50  888230     MOV W0, 0x1046
91:                }
007B52  78074F     MOV [--W15], W14
007B54  B1006F     SUB #0x6, W15
007B56  060000     RETURN
92:                
93:                void lcdWriteWordUnsignedQ(unsigned int word){
007B58  4787E6     ADD W15, #0x6, W15
007B5A  781F8E     MOV W14, [W15++]
007B6E  200041     MOV #0x4, W1
94:                    int i;
95:                    char inchar[4];
96:                    
97:                   inchar[0] = word&0x000F; 
007B5C  6040EF     AND.B W0, #0xF, W1
98:                   if (inchar[0] > 9) 
007B5E  50CFE9     SUB.B W1, #0x9, [W15]
007B60  340003     BRA LE, 0x7B68
99:                       inchar[0]+=55;
007B62  B04371     ADD.B #0x37, W1
007B64  9FFFA1     MOV.B W1, [W15-6]
007B66  370002     BRA 0x7B6C
100:                  else inchar[0]+=48;
007B68  B04301     ADD.B #0x30, W1
007B6A  9FFFA1     MOV.B W1, [W15-6]
007B6C  578766     SUB W15, #0x6, W14
101:                  
102:                  for(i=1; i<4; i++){ 
007B88  508FF0     SUB W1, #0x10, [W15]
007B8A  3AFFF2     BRA NZ, 0x7B70
103:                     inchar[i] = ((word>>(i*4))&0x0000F); 
007B70  DE0101     LSR W0, W1, W2
007B72  61416F     AND.B W2, #0xF, W2
007B74  E8070E     INC W14, W14
007B76  784F02     MOV.B W2, [W14]
104:                     if (inchar[i] > 9) 
007B78  514FE9     SUB.B W2, #0x9, [W15]
007B7A  340003     BRA LE, 0x7B82
105:                         inchar[i]+=55;
007B7C  B3C374     MOV.B #0x37, W4
007B7E  414F04     ADD.B W2, W4, [W14]
007B80  370002     BRA 0x7B86
106:                     else inchar[i]+=48;
007B82  B3C304     MOV.B #0x30, W4
007B84  414F04     ADD.B W2, W4, [W14]
007B86  4080E4     ADD W1, #0x4, W1
107:                  } 
108:                  lcdWriteQMac(inchar[3]);
007B8C  97F8DF     MOV.B [W15-3], W1
007B8E  FB0081     SE W1, W1
007B90  808230     MOV 0x1046, W0
007B92  781801     MOV W1, [W0++]
007B94  26ADA1     MOV #0x6ADA, W1
007B96  500F81     SUB W0, W1, [W15]
007B98  3A000A     BRA NZ, 0x7BAE
109:                  lcdWriteQMac(inchar[2]);
007B9A  97F84F     MOV.B [W15-4], W0
007B9C  FB0000     SE W0, W0
007B9E  8B46D0     MOV W0, lcdBuf
007BAE  97F8CF     MOV.B [W15-4], W1
007BB0  FB0081     SE W1, W1
007BB2  781801     MOV W1, [W0++]
007BB4  888230     MOV W0, 0x1046
007BB6  26ADA1     MOV #0x6ADA, W1
007BB8  500F81     SUB W0, W1, [W15]
007BBA  3A0009     BRA NZ, 0x7BCE
110:                  lcdWriteQMac(inchar[1]);
007BA0  97F83F     MOV.B [W15-5], W0
007BA2  FB0000     SE W0, W0
007BA4  8B46E0     MOV W0, 0x68DC
007BA6  2FE040     MOV #0xFE04, W0
007BA8  400001     ADD W0, W1, W0
007BAA  888230     MOV W0, 0x1046
007BAC  37001F     BRA 0x7BEC
007BBC  97F83F     MOV.B [W15-5], W0
007BBE  FB0000     SE W0, W0
007BC0  8B46D0     MOV W0, lcdBuf
007BCE  97F8BF     MOV.B [W15-5], W1
007BD0  FB0081     SE W1, W1
007BD2  808230     MOV 0x1046, W0
007BD4  781801     MOV W1, [W0++]
007BD6  888230     MOV W0, 0x1046
007BD8  26ADA1     MOV #0x6ADA, W1
007BDA  500F81     SUB W0, W1, [W15]
007BDC  3A0007     BRA NZ, 0x7BEC
111:                  lcdWriteQMac(inchar[0]);
007BC2  97F8AF     MOV.B [W15-6], W1
007BC4  FB0001     SE W1, W0
007BC6  8B46E0     MOV W0, 0x68DC
007BC8  268DE0     MOV #0x68DE, W0
007BCA  888230     MOV W0, 0x1046
007BCC  37001A     BRA 0x7C02
007BDE  97FA2F     MOV.B [W15-6], W4
007BE0  FB0004     SE W4, W0
007BE2  8B46D0     MOV W0, lcdBuf
007BE4  2FE020     MOV #0xFE02, W0
007BE6  400001     ADD W0, W1, W0
007BE8  888230     MOV W0, 0x1046
007BEA  37000B     BRA 0x7C02
007BEC  97F82F     MOV.B [W15-6], W0
007BEE  FB0080     SE W0, W1
007BF0  808230     MOV 0x1046, W0
007BF2  781801     MOV W1, [W0++]
007BF4  888230     MOV W0, 0x1046
007BF6  26ADA1     MOV #0x6ADA, W1
007BF8  500F81     SUB W0, W1, [W15]
007BFA  3A0003     BRA NZ, 0x7C02
007BFC  2FE000     MOV #0xFE00, W0
007BFE  400001     ADD W0, W1, W0
007C00  888230     MOV W0, 0x1046
112:               }
007C02  78074F     MOV [--W15], W14
007C04  B1006F     SUB #0x6, W15
007C06  060000     RETURN
113:               
114:               void lcdWriteDecimalQ(char word, int digits){
007C08  FA0000     LNK #0x0
007C0A  781F88     MOV W8, [W15++]
007C0C  780381     MOV W1, W7
115:                   const char maxdigits = 4;
116:                   char result[maxdigits];
007C10  4787E6     ADD W15, #0x6, W15
007C12  780186     MOV W6, W3
117:                   char i = 3;
007C14  B3C032     MOV.B #0x3, W2
118:                   do {
119:                       result[i] = '0' + word % 10;
007C16  2000A4     MOV #0xA, W4
007C18  FB0282     SE W2, W5
007C1A  418285     ADD W3, W5, W5
007C1C  FB0000     SE W0, W0
007C1E  090011     REPEAT #0x11
007C20  D80004     DIV.SW W0, W4
007C22  B3C308     MOV.B #0x30, W8
007C24  40CA88     ADD.B W1, W8, [W5]
120:                       word /= 10;
121:                       i--;
007C26  E94102     DEC.B W2, W2
122:                   }
123:                   while (word > 0);
007C28  E00400     CP0.B W0
007C2A  3CFFF6     BRA GT, 0x7C18
124:                   while (i>=0) result[i--] = ' '; 
007C2C  E00402     CP0.B W2
007C2E  350007     BRA LT, 0x7C3E
007C30  B3C204     MOV.B #0x20, W4
007C32  FB0002     SE W2, W0
007C34  418000     ADD W3, W0, W0
007C36  784804     MOV.B W4, [W0]
007C38  E94102     DEC.B W2, W2
007C3A  414FE1     ADD.B W2, #0x1, [W15]
007C3C  3AFFFA     BRA NZ, 0x7C32
125:                 
126:                   for (i=maxdigits-digits; i<maxdigits; i++) {
007C3E  B3C041     MOV.B #0x4, W1
007C40  50C087     SUB.B W1, W7, W1
007C42  50CFE3     SUB.B W1, #0x3, [W15]
007C44  3C000F     BRA GT, 0x7C64
007C5E  E84081     INC.B W1, W1
007C60  50CFE4     SUB.B W1, #0x4, [W15]
007C62  3AFFF4     BRA NZ, 0x7C4C
127:                       lcdWriteQMac(result[i]);
007C46  26ADA4     MOV #0x6ADA, W4
007C48  2FE005     MOV #0xFE00, W5
007C4A  428284     ADD W5, W4, W5
007C4C  FB0001     SE W1, W0
007C4E  418000     ADD W3, W0, W0
007C50  FB0110     SE [W0], W2
007C52  808230     MOV 0x1046, W0
007C54  781802     MOV W2, [W0++]
007C56  888230     MOV W0, 0x1046
007C58  500F84     SUB W0, W4, [W15]
007C5A  3A0001     BRA NZ, 0x7C5E
007C5C  888235     MOV W5, 0x1046
128:                   }
129:               }
007C0E  78030F     MOV W15, W6
007C64  780786     MOV W6, W15
007C66  78044F     MOV [--W15], W8
007C68  FA8000     ULNK
007C6A  060000     RETURN
130:               
131:               //4x4 pad debug
132:               void lcdDrawPads(unsigned char col){
007C6C  BE9F88     MOV.D W8, [W15++]
007C6E  784480     MOV.B W0, W9
133:                   unsigned char block=0xFF;
007C7E  EBC400     SETM.B W8
134:                   if(!pad[34]||!pad[16]) block='*';
007C70  B3C2A8     MOV.B #0x2A, W8
007C72  268D80     MOV #0x68D8, W0
007C74  E00410     CP0.B [W0]
007C76  320004     BRA Z, 0x7C80
007C78  500072     SUB W0, #0x12, W0
007C7A  E00410     CP0.B [W0]
007C7C  320001     BRA Z, 0x7C80
135:                   
136:                   lcdSetCursorQ(col, 0);
007C80  EB4080     CLR.B W1
007C82  784009     MOV.B W9, W0
007C84  07FEC7     RCALL lcdSetCursorQ
137:                   if(!pad[12]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007C86  268C20     MOV #0x68C2, W0
007C88  E00410     CP0.B [W0]
007C8A  3A000B     BRA NZ, 0x7CA2
007C8C  808230     MOV 0x1046, W0
007C8E  200201     MOV #0x20, W1
007C90  781801     MOV W1, [W0++]
007C92  888230     MOV W0, 0x1046
007C94  26ADA1     MOV #0x6ADA, W1
007C96  500F81     SUB W0, W1, [W15]
007C98  3A000E     BRA NZ, 0x7CB6
007C9A  2FE000     MOV #0xFE00, W0
007C9C  400001     ADD W0, W1, W0
007C9E  888230     MOV W0, 0x1046
007CA0  37000A     BRA 0x7CB6
007CA2  FB8088     ZE W8, W1
007CA4  808230     MOV 0x1046, W0
007CA6  781801     MOV W1, [W0++]
007CA8  888230     MOV W0, 0x1046
007CAA  26ADA1     MOV #0x6ADA, W1
007CAC  500F81     SUB W0, W1, [W15]
007CAE  3A0003     BRA NZ, 0x7CB6
007CB0  2FE000     MOV #0xFE00, W0
007CB2  400001     ADD W0, W1, W0
007CB4  888230     MOV W0, 0x1046
138:                   if(!pad[13]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007CB6  268C30     MOV #0x68C3, W0
007CB8  E00410     CP0.B [W0]
007CBA  3A000B     BRA NZ, 0x7CD2
007CBC  808230     MOV 0x1046, W0
007CBE  200201     MOV #0x20, W1
007CC0  781801     MOV W1, [W0++]
007CC2  888230     MOV W0, 0x1046
007CC4  26ADA1     MOV #0x6ADA, W1
007CC6  500F81     SUB W0, W1, [W15]
007CC8  3A000E     BRA NZ, 0x7CE6
007CCA  2FE000     MOV #0xFE00, W0
007CCC  400001     ADD W0, W1, W0
007CCE  888230     MOV W0, 0x1046
007CD0  37000A     BRA 0x7CE6
007CD2  FB8088     ZE W8, W1
007CD4  808230     MOV 0x1046, W0
007CD6  781801     MOV W1, [W0++]
007CD8  888230     MOV W0, 0x1046
007CDA  26ADA1     MOV #0x6ADA, W1
007CDC  500F81     SUB W0, W1, [W15]
007CDE  3A0003     BRA NZ, 0x7CE6
007CE0  2FE000     MOV #0xFE00, W0
007CE2  400001     ADD W0, W1, W0
007CE4  888230     MOV W0, 0x1046
139:                   if(!pad[14]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007CE6  268C40     MOV #0x68C4, W0
007CE8  E00410     CP0.B [W0]
007CEA  3A000B     BRA NZ, 0x7D02
007CEC  808230     MOV 0x1046, W0
007CEE  200201     MOV #0x20, W1
007CF0  781801     MOV W1, [W0++]
007CF2  888230     MOV W0, 0x1046
007CF4  26ADA1     MOV #0x6ADA, W1
007CF6  500F81     SUB W0, W1, [W15]
007CF8  3A000E     BRA NZ, 0x7D16
007CFA  2FE000     MOV #0xFE00, W0
007CFC  400001     ADD W0, W1, W0
007CFE  888230     MOV W0, 0x1046
007D00  37000A     BRA 0x7D16
007D02  FB8088     ZE W8, W1
007D04  808230     MOV 0x1046, W0
007D06  781801     MOV W1, [W0++]
007D08  888230     MOV W0, 0x1046
007D0A  26ADA1     MOV #0x6ADA, W1
007D0C  500F81     SUB W0, W1, [W15]
007D0E  3A0003     BRA NZ, 0x7D16
007D10  2FE000     MOV #0xFE00, W0
007D12  400001     ADD W0, W1, W0
007D14  888230     MOV W0, 0x1046
140:                   if(!pad[15]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D16  268C50     MOV #0x68C5, W0
007D18  E00410     CP0.B [W0]
007D1A  3A000B     BRA NZ, 0x7D32
007D1C  808230     MOV 0x1046, W0
007D1E  200201     MOV #0x20, W1
007D20  781801     MOV W1, [W0++]
007D22  888230     MOV W0, 0x1046
007D24  26ADA1     MOV #0x6ADA, W1
007D26  500F81     SUB W0, W1, [W15]
007D28  3A000E     BRA NZ, 0x7D46
007D2A  2FE000     MOV #0xFE00, W0
007D2C  400001     ADD W0, W1, W0
007D2E  888230     MOV W0, 0x1046
007D30  37000A     BRA 0x7D46
007D32  FB8088     ZE W8, W1
007D34  808230     MOV 0x1046, W0
007D36  781801     MOV W1, [W0++]
007D38  888230     MOV W0, 0x1046
007D3A  26ADA1     MOV #0x6ADA, W1
007D3C  500F81     SUB W0, W1, [W15]
007D3E  3A0003     BRA NZ, 0x7D46
007D40  2FE000     MOV #0xFE00, W0
007D42  400001     ADD W0, W1, W0
007D44  888230     MOV W0, 0x1046
141:                   lcdSetCursorQ(col, 1);
007D46  B3C011     MOV.B #0x1, W1
007D48  784009     MOV.B W9, W0
007D4A  07FE64     RCALL lcdSetCursorQ
142:                   if(!pad[8]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D4C  268BE0     MOV #0x68BE, W0
007D4E  E00410     CP0.B [W0]
007D50  3A000B     BRA NZ, 0x7D68
007D52  808230     MOV 0x1046, W0
007D54  200201     MOV #0x20, W1
007D56  781801     MOV W1, [W0++]
007D58  888230     MOV W0, 0x1046
007D5A  26ADA1     MOV #0x6ADA, W1
007D5C  500F81     SUB W0, W1, [W15]
007D5E  3A000E     BRA NZ, 0x7D7C
007D60  2FE000     MOV #0xFE00, W0
007D62  400001     ADD W0, W1, W0
007D64  888230     MOV W0, 0x1046
007D66  37000A     BRA 0x7D7C
007D68  FB8088     ZE W8, W1
007D6A  808230     MOV 0x1046, W0
007D6C  781801     MOV W1, [W0++]
007D6E  888230     MOV W0, 0x1046
007D70  26ADA1     MOV #0x6ADA, W1
007D72  500F81     SUB W0, W1, [W15]
007D74  3A0003     BRA NZ, 0x7D7C
007D76  2FE000     MOV #0xFE00, W0
007D78  400001     ADD W0, W1, W0
007D7A  888230     MOV W0, 0x1046
143:                   if(!pad[9]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D7C  268BF0     MOV #0x68BF, W0
007D7E  E00410     CP0.B [W0]
007D80  3A000B     BRA NZ, 0x7D98
007D82  808230     MOV 0x1046, W0
007D84  200201     MOV #0x20, W1
007D86  781801     MOV W1, [W0++]
007D88  888230     MOV W0, 0x1046
007D8A  26ADA1     MOV #0x6ADA, W1
007D8C  500F81     SUB W0, W1, [W15]
007D8E  3A000E     BRA NZ, 0x7DAC
007D90  2FE000     MOV #0xFE00, W0
007D92  400001     ADD W0, W1, W0
007D94  888230     MOV W0, 0x1046
007D96  37000A     BRA 0x7DAC
007D98  FB8088     ZE W8, W1
007D9A  808230     MOV 0x1046, W0
007D9C  781801     MOV W1, [W0++]
007D9E  888230     MOV W0, 0x1046
007DA0  26ADA1     MOV #0x6ADA, W1
007DA2  500F81     SUB W0, W1, [W15]
007DA4  3A0003     BRA NZ, 0x7DAC
007DA6  2FE000     MOV #0xFE00, W0
007DA8  400001     ADD W0, W1, W0
007DAA  888230     MOV W0, 0x1046
144:                   if(!pad[10]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007DAC  268C00     MOV #0x68C0, W0
007DAE  E00410     CP0.B [W0]
007DB0  3A000B     BRA NZ, 0x7DC8
007DB2  808230     MOV 0x1046, W0
007DB4  200201     MOV #0x20, W1
007DB6  781801     MOV W1, [W0++]
007DB8  888230     MOV W0, 0x1046
007DBA  26ADA1     MOV #0x6ADA, W1
007DBC  500F81     SUB W0, W1, [W15]
007DBE  3A000E     BRA NZ, 0x7DDC
007DC0  2FE000     MOV #0xFE00, W0
007DC2  400001     ADD W0, W1, W0
007DC4  888230     MOV W0, 0x1046
007DC6  37000A     BRA 0x7DDC
007DC8  FB8088     ZE W8, W1
007DCA  808230     MOV 0x1046, W0
007DCC  781801     MOV W1, [W0++]
007DCE  888230     MOV W0, 0x1046
007DD0  26ADA1     MOV #0x6ADA, W1
007DD2  500F81     SUB W0, W1, [W15]
007DD4  3A0003     BRA NZ, 0x7DDC
007DD6  2FE000     MOV #0xFE00, W0
007DD8  400001     ADD W0, W1, W0
007DDA  888230     MOV W0, 0x1046
145:                   if(!pad[11]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007DDC  268C10     MOV #0x68C1, W0
007DDE  E00410     CP0.B [W0]
007DE0  3A000B     BRA NZ, 0x7DF8
007DE2  808230     MOV 0x1046, W0
007DE4  200201     MOV #0x20, W1
007DE6  781801     MOV W1, [W0++]
007DE8  888230     MOV W0, 0x1046
007DEA  26ADA1     MOV #0x6ADA, W1
007DEC  500F81     SUB W0, W1, [W15]
007DEE  3A000E     BRA NZ, 0x7E0C
007DF0  2FE000     MOV #0xFE00, W0
007DF2  400001     ADD W0, W1, W0
007DF4  888230     MOV W0, 0x1046
007DF6  37000A     BRA 0x7E0C
007DF8  FB8088     ZE W8, W1
007DFA  808230     MOV 0x1046, W0
007DFC  781801     MOV W1, [W0++]
007DFE  888230     MOV W0, 0x1046
007E00  26ADA1     MOV #0x6ADA, W1
007E02  500F81     SUB W0, W1, [W15]
007E04  3A0003     BRA NZ, 0x7E0C
007E06  2FE000     MOV #0xFE00, W0
007E08  400001     ADD W0, W1, W0
007E0A  888230     MOV W0, 0x1046
146:                   lcdSetCursorQ(col, 2);
007E0C  B3C021     MOV.B #0x2, W1
007E0E  784009     MOV.B W9, W0
007E10  07FE01     RCALL lcdSetCursorQ
147:                   if(!pad[4]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E12  268BA0     MOV #0x68BA, W0
007E14  E00410     CP0.B [W0]
007E16  3A000B     BRA NZ, 0x7E2E
007E18  808230     MOV 0x1046, W0
007E1A  200201     MOV #0x20, W1
007E1C  781801     MOV W1, [W0++]
007E1E  888230     MOV W0, 0x1046
007E20  26ADA1     MOV #0x6ADA, W1
007E22  500F81     SUB W0, W1, [W15]
007E24  3A000E     BRA NZ, 0x7E42
007E26  2FE000     MOV #0xFE00, W0
007E28  400001     ADD W0, W1, W0
007E2A  888230     MOV W0, 0x1046
007E2C  37000A     BRA 0x7E42
007E2E  FB8088     ZE W8, W1
007E30  808230     MOV 0x1046, W0
007E32  781801     MOV W1, [W0++]
007E34  888230     MOV W0, 0x1046
007E36  26ADA1     MOV #0x6ADA, W1
007E38  500F81     SUB W0, W1, [W15]
007E3A  3A0003     BRA NZ, 0x7E42
007E3C  2FE000     MOV #0xFE00, W0
007E3E  400001     ADD W0, W1, W0
007E40  888230     MOV W0, 0x1046
148:                   if(!pad[5]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E42  268BB0     MOV #0x68BB, W0
007E44  E00410     CP0.B [W0]
007E46  3A000B     BRA NZ, 0x7E5E
007E48  808230     MOV 0x1046, W0
007E4A  200201     MOV #0x20, W1
007E4C  781801     MOV W1, [W0++]
007E4E  888230     MOV W0, 0x1046
007E50  26ADA1     MOV #0x6ADA, W1
007E52  500F81     SUB W0, W1, [W15]
007E54  3A000E     BRA NZ, 0x7E72
007E56  2FE000     MOV #0xFE00, W0
007E58  400001     ADD W0, W1, W0
007E5A  888230     MOV W0, 0x1046
007E5C  37000A     BRA 0x7E72
007E5E  FB8088     ZE W8, W1
007E60  808230     MOV 0x1046, W0
007E62  781801     MOV W1, [W0++]
007E64  888230     MOV W0, 0x1046
007E66  26ADA1     MOV #0x6ADA, W1
007E68  500F81     SUB W0, W1, [W15]
007E6A  3A0003     BRA NZ, 0x7E72
007E6C  2FE000     MOV #0xFE00, W0
007E6E  400001     ADD W0, W1, W0
007E70  888230     MOV W0, 0x1046
149:                   if(!pad[6]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E72  268BC0     MOV #0x68BC, W0
007E74  E00410     CP0.B [W0]
007E76  3A000B     BRA NZ, 0x7E8E
007E78  808230     MOV 0x1046, W0
007E7A  200201     MOV #0x20, W1
007E7C  781801     MOV W1, [W0++]
007E7E  888230     MOV W0, 0x1046
007E80  26ADA1     MOV #0x6ADA, W1
007E82  500F81     SUB W0, W1, [W15]
007E84  3A000E     BRA NZ, 0x7EA2
007E86  2FE000     MOV #0xFE00, W0
007E88  400001     ADD W0, W1, W0
007E8A  888230     MOV W0, 0x1046
007E8C  37000A     BRA 0x7EA2
007E8E  FB8088     ZE W8, W1
007E90  808230     MOV 0x1046, W0
007E92  781801     MOV W1, [W0++]
007E94  888230     MOV W0, 0x1046
007E96  26ADA1     MOV #0x6ADA, W1
007E98  500F81     SUB W0, W1, [W15]
007E9A  3A0003     BRA NZ, 0x7EA2
007E9C  2FE000     MOV #0xFE00, W0
007E9E  400001     ADD W0, W1, W0
007EA0  888230     MOV W0, 0x1046
150:                   if(!pad[7]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007EA2  268BD0     MOV #0x68BD, W0
007EA4  E00410     CP0.B [W0]
007EA6  3A000B     BRA NZ, 0x7EBE
007EA8  808230     MOV 0x1046, W0
007EAA  200201     MOV #0x20, W1
007EAC  781801     MOV W1, [W0++]
007EAE  888230     MOV W0, 0x1046
007EB0  26ADA1     MOV #0x6ADA, W1
007EB2  500F81     SUB W0, W1, [W15]
007EB4  3A000E     BRA NZ, 0x7ED2
007EB6  2FE000     MOV #0xFE00, W0
007EB8  400001     ADD W0, W1, W0
007EBA  888230     MOV W0, 0x1046
007EBC  37000A     BRA 0x7ED2
007EBE  FB8088     ZE W8, W1
007EC0  808230     MOV 0x1046, W0
007EC2  781801     MOV W1, [W0++]
007EC4  888230     MOV W0, 0x1046
007EC6  26ADA1     MOV #0x6ADA, W1
007EC8  500F81     SUB W0, W1, [W15]
007ECA  3A0003     BRA NZ, 0x7ED2
007ECC  2FE000     MOV #0xFE00, W0
007ECE  400001     ADD W0, W1, W0
007ED0  888230     MOV W0, 0x1046
151:                   lcdSetCursorQ(col, 3);
007ED2  B3C031     MOV.B #0x3, W1
007ED4  784009     MOV.B W9, W0
007ED6  07FD9E     RCALL lcdSetCursorQ
152:                   if(!pad[0]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007ED8  268B60     MOV #0x68B6, W0
007EDA  E00410     CP0.B [W0]
007EDC  3A000B     BRA NZ, 0x7EF4
007EDE  808230     MOV 0x1046, W0
007EE0  200201     MOV #0x20, W1
007EE2  781801     MOV W1, [W0++]
007EE4  888230     MOV W0, 0x1046
007EE6  26ADA1     MOV #0x6ADA, W1
007EE8  500F81     SUB W0, W1, [W15]
007EEA  3A000E     BRA NZ, 0x7F08
007EEC  2FE000     MOV #0xFE00, W0
007EEE  400001     ADD W0, W1, W0
007EF0  888230     MOV W0, 0x1046
007EF2  37000A     BRA 0x7F08
007EF4  FB8088     ZE W8, W1
007EF6  808230     MOV 0x1046, W0
007EF8  781801     MOV W1, [W0++]
007EFA  888230     MOV W0, 0x1046
007EFC  26ADA1     MOV #0x6ADA, W1
007EFE  500F81     SUB W0, W1, [W15]
007F00  3A0003     BRA NZ, 0x7F08
007F02  2FE000     MOV #0xFE00, W0
007F04  400001     ADD W0, W1, W0
007F06  888230     MOV W0, 0x1046
153:                   if(!pad[1]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F08  268B70     MOV #0x68B7, W0
007F0A  E00410     CP0.B [W0]
007F0C  3A000B     BRA NZ, 0x7F24
007F0E  808230     MOV 0x1046, W0
007F10  200201     MOV #0x20, W1
007F12  781801     MOV W1, [W0++]
007F14  888230     MOV W0, 0x1046
007F16  26ADA1     MOV #0x6ADA, W1
007F18  500F81     SUB W0, W1, [W15]
007F1A  3A000E     BRA NZ, 0x7F38
007F1C  2FE000     MOV #0xFE00, W0
007F1E  400001     ADD W0, W1, W0
007F20  888230     MOV W0, 0x1046
007F22  37000A     BRA 0x7F38
007F24  FB8088     ZE W8, W1
007F26  808230     MOV 0x1046, W0
007F28  781801     MOV W1, [W0++]
007F2A  888230     MOV W0, 0x1046
007F2C  26ADA1     MOV #0x6ADA, W1
007F2E  500F81     SUB W0, W1, [W15]
007F30  3A0003     BRA NZ, 0x7F38
007F32  2FE000     MOV #0xFE00, W0
007F34  400001     ADD W0, W1, W0
007F36  888230     MOV W0, 0x1046
154:                   if(!pad[2]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F38  268B80     MOV #0x68B8, W0
007F3A  E00410     CP0.B [W0]
007F3C  3A000B     BRA NZ, 0x7F54
007F3E  808230     MOV 0x1046, W0
007F40  200201     MOV #0x20, W1
007F42  781801     MOV W1, [W0++]
007F44  888230     MOV W0, 0x1046
007F46  26ADA1     MOV #0x6ADA, W1
007F48  500F81     SUB W0, W1, [W15]
007F4A  3A000E     BRA NZ, 0x7F68
007F4C  2FE000     MOV #0xFE00, W0
007F4E  400001     ADD W0, W1, W0
007F50  888230     MOV W0, 0x1046
007F52  37000A     BRA 0x7F68
007F54  FB8088     ZE W8, W1
007F56  808230     MOV 0x1046, W0
007F58  781801     MOV W1, [W0++]
007F5A  888230     MOV W0, 0x1046
007F5C  26ADA1     MOV #0x6ADA, W1
007F5E  500F81     SUB W0, W1, [W15]
007F60  3A0003     BRA NZ, 0x7F68
007F62  2FE000     MOV #0xFE00, W0
007F64  400001     ADD W0, W1, W0
007F66  888230     MOV W0, 0x1046
155:                   if(!pad[3]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F68  268B90     MOV #0x68B9, W0
007F6A  E00410     CP0.B [W0]
007F6C  3A000B     BRA NZ, 0x7F84
007F6E  808230     MOV 0x1046, W0
007F70  200201     MOV #0x20, W1
007F72  781801     MOV W1, [W0++]
007F74  888230     MOV W0, 0x1046
007F76  26ADA1     MOV #0x6ADA, W1
007F78  500F81     SUB W0, W1, [W15]
007F7A  3A000E     BRA NZ, 0x7F98
007F7C  2FE000     MOV #0xFE00, W0
007F7E  400001     ADD W0, W1, W0
007F80  888230     MOV W0, 0x1046
007F82  37000A     BRA 0x7F98
007F84  FB8408     ZE W8, W8
007F86  808230     MOV 0x1046, W0
007F88  781808     MOV W8, [W0++]
007F8A  888230     MOV W0, 0x1046
007F8C  26ADA1     MOV #0x6ADA, W1
007F8E  500F81     SUB W0, W1, [W15]
007F90  3A0003     BRA NZ, 0x7F98
007F92  2FE000     MOV #0xFE00, W0
007F94  400001     ADD W0, W1, W0
007F96  888230     MOV W0, 0x1046
156:               }
007F98  BE044F     MOV.D [--W15], W8
007F9A  060000     RETURN
157:               
158:               void lcdPoll(void){  
159:                   if(lcdWritePtr!=lcdReadPtr){   
007F9C  808240     MOV 0x1048, W0
007F9E  E31046     CP 0x1046
007FA0  320018     BRA Z, 0x7FD2
160:                       if((*lcdReadPtr>>8)&1) LCD_RS=0;
007FA2  201001     MOV #0x100, W1
007FA4  608090     AND W1, [W0], W1
007FA6  320002     BRA Z, 0x7FAC
007FA8  A9EE45     BCLR 0xE45, #7
007FAA  370001     BRA 0x7FAE
161:                       else LCD_RS=1;
007FAC  A8EE45     BSET 0xE45, #7
162:                       if((*lcdReadPtr>>9)&1) PR3=0x2DF0; //2DF0 for ~1.3mS
007FAE  202001     MOV #0x200, W1
007FB0  608090     AND W1, [W0], W1
007FB2  320003     BRA Z, 0x7FBA
007FB4  22DF01     MOV #0x2DF0, W1
007FB6  880871     MOV W1, PR3
007FB8  370002     BRA 0x7FBE
163:                       else PR3=0x0120; //120 for ~40uS
007FBA  201201     MOV #0x120, W1
007FBC  880871     MOV W1, PR3
164:                       PMDIN1=(*lcdReadPtr++)&0x00FF;
007FBE  200FF1     MOV #0xFF, W1
007FC0  6080B0     AND W1, [W0++], W1
007FC2  883041     MOV W1, PMDIN1
007FC4  888240     MOV W0, 0x1048
165:                       if(lcdReadPtr==&lcdBuf[LCDBUF]) lcdReadPtr=lcdBuf;
007FC6  26ADA1     MOV #0x6ADA, W1
007FC8  500F81     SUB W0, W1, [W15]
007FCA  3A0003     BRA NZ, 0x7FD2
007FCC  2FE000     MOV #0xFE00, W0
007FCE  400001     ADD W0, W1, W0
007FD0  888240     MOV W0, 0x1048
166:                   } 
167:                   TMR3=0x0000; 
007FD2  EF210A     CLR TMR3
168:               }
007FD4  060000     RETURN
169:               
170:               //ALWAYS SENDS, blocks program
171:               void lcdBlockingSend(unsigned char data){
007FD6  BE9F88     MOV.D W8, [W15++]
007FD8  781F8A     MOV W10, [W15++]
007FDA  784500     MOV.B W0, W10
172:                   while(PMMODEbits.BUSY)Delay_us(2);
007FDC  E20602     CP0 PMMODE
007FDE  3D0007     BRA GE, 0x7FEE
007FE0  200028     MOV #0x2, W8
007FE2  280009     MOV #0x8000, W9
007FE4  780008     MOV W8, W0
007FE6  07038D     RCALL Delay_us
007FE8  803011     MOV PMMODE, W1
007FEA  648001     AND W9, W1, W0
007FEC  3AFFFB     BRA NZ, 0x7FE4
173:                   PMDIN1=data; 
007FEE  FB850A     ZE W10, W10
007FF0  88304A     MOV W10, PMDIN1
174:               }
007FF2  78054F     MOV [--W15], W10
007FF4  BE044F     MOV.D [--W15], W8
007FF6  060000     RETURN
175:               //ALWAYS SENDS, blocks program
176:               void lcdBlockingClear(void){
007FF8  BE9F88     MOV.D W8, [W15++]
177:                   while(PMMODEbits.BUSY)Delay_us(2);
007FFA  E20602     CP0 PMMODE
007FFC  3D0007     BRA GE, 0x800C
007FFE  200028     MOV #0x2, W8
008000  280009     MOV #0x8000, W9
008002  780008     MOV W8, W0
008004  07037E     RCALL Delay_us
008006  803011     MOV PMMODE, W1
008008  648001     AND W9, W1, W0
00800A  3AFFFB     BRA NZ, 0x8002
178:                   PMDIN1=LCD_CLEARDISPLAY; 
00800C  200010     MOV #0x1, W0
00800E  883040     MOV W0, PMDIN1
179:               }
008010  BE044F     MOV.D [--W15], W8
008012  060000     RETURN
180:               
181:               //ALWAYS SENDS, blocks program
182:               void lcdBlockingReturn(void){
008014  BE9F88     MOV.D W8, [W15++]
183:                   while(PMMODEbits.BUSY)Delay_us(2);
008016  E20602     CP0 PMMODE
008018  3D0007     BRA GE, 0x8028
00801A  200028     MOV #0x2, W8
00801C  280009     MOV #0x8000, W9
00801E  780008     MOV W8, W0
008020  070370     RCALL Delay_us
008022  803011     MOV PMMODE, W1
008024  648001     AND W9, W1, W0
008026  3AFFFB     BRA NZ, 0x801E
184:                   PMDIN1=LCD_RETURNHOME;
008028  200020     MOV #0x2, W0
00802A  883040     MOV W0, PMDIN1
185:               }
00802C  BE044F     MOV.D [--W15], W8
00802E  060000     RETURN
186:               
187:               void lcdInit(void){
188:                   LCD_RS=0;
008030  A9EE45     BCLR 0xE45, #7
189:                   lcdBlockingSend(0x38);              //function set, 8 bits, 2 line disp, 5x8
008032  B3C380     MOV.B #0x38, W0
008034  07FFD0     RCALL lcdBlockingSend
190:                   Delay_us(4500);                //>4.1 mS required
008036  211940     MOV #0x1194, W0
008038  070364     RCALL Delay_us
191:                   lcdBlockingSend(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
00803A  B3C0C0     MOV.B #0xC, W0
00803C  07FFCC     RCALL lcdBlockingSend
192:                   Delay_us(4500);
00803E  211940     MOV #0x1194, W0
008040  070360     RCALL Delay_us
193:                   lcdBlockingClear();                    //Display Clear  
008042  07FFDA     RCALL lcdBlockingClear
194:                   Delay_us(1800);                //>1.64mS required
008044  207080     MOV #0x708, W0
008046  07035D     RCALL Delay_us
195:                   lcdBlockingSend(0x06);               // entry Mode Set
008048  B3C060     MOV.B #0x6, W0
00804A  07FFC5     RCALL lcdBlockingSend
196:                   Delay_us(200);
00804C  200C80     MOV #0xC8, W0
00804E  070359     RCALL Delay_us
197:                   lcdBlockingReturn();
008050  07FFE1     RCALL lcdBlockingReturn
198:                   Delay_us(1500);
008052  205DC0     MOV #0x5DC, W0
008054  070356     RCALL Delay_us
199:                   
200:                   //lcdCustomSymbols();
201:                   Delay_us(200);
008056  200C80     MOV #0xC8, W0
008058  070354     RCALL Delay_us
202:                   lcdBlockingClear();                         //Display Clear  
00805A  07FFCE     RCALL lcdBlockingClear
203:                   Delay_us(1500);
00805C  205DC0     MOV #0x5DC, W0
00805E  070351     RCALL Delay_us
204:                   lcdBlockingReturn();
008060  07FFD9     RCALL lcdBlockingReturn
205:                   Delay_us(200);
008062  200C80     MOV #0xC8, W0
008064  07034E     RCALL Delay_us
206:               }
008066  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/main.c  -----------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 #include "plcd.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = OFF   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                /* Data Buffers & index variables */
22:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
23:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
24:                unsigned int write_ptr=STREAMBUF, rw=0, frameReady=0;
25:                
26:                /* DMA BUFFERS */
27:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
28:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
29:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
31:                
32:                
33:                /* Debug Variables */
34:                unsigned int process_time=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                              
37:                volatile unsigned char recording=TRUE;
38:                unsigned char UART_ON = FALSE;
39:                unsigned char TEST_SIN = FALSE;
40:                
41:                volatile unsigned char tremelo=FALSE;                                       
42:                volatile unsigned char looper=FALSE;
43:                volatile unsigned char lpf=FALSE;
44:                
45:                char flash_readback[512]={0};
46:                
47:                /* Screen state variables */
48:                enum screen state = scrnFX;
49:                enum screen laststate = invalid;
50:                
51:                /* Buttons & Potentiometers */
52:                unsigned char pad[BUTTONS];                                                            
53:                fractional pots[POTS]={0};
54:                fractional pots_scaled[POTS]={0};
55:                fractional pots_custom[POTS]={0};
56:                
57:                void initBuffer(void){
008E7A  264B47     MOV #0x64B4, W7
008E7C  266B46     MOV #0x66B4, W6
008E7E  2CDFE5     MOV #0xCDFE, W5
008E80  2CBFE4     MOV #0xCBFE, W4
008E82  2C9FE3     MOV #0xC9FE, W3
008E84  2C7FE2     MOV #0xC7FE, W2
008E86  201001     MOV #0x100, W1
008E9C  200232     MOV #0x23, W2
008E9E  410100     ADD W2, W0, W2
58:                    int i;
59:                    for(i=0; i<STREAMBUF; i++){
008E98  3AFFF8     BRA NZ, 0x8E8A
008E9A  268B50     MOV #0x68B5, W0
60:                        streamA[i]=0;
008E88  EB0000     CLR W0
008E8A  782B80     MOV W0, [++W7]
61:                        streamB[i]=0;
008E8C  782B00     MOV W0, [++W6]
62:                        txBufferA[i]=0;
008E8E  782A80     MOV W0, [++W5]
63:                        txBufferB[i]=0;
008E90  782A00     MOV W0, [++W4]
64:                        rxBufferA[i]=0;
008E92  782980     MOV W0, [++W3]
65:                        rxBufferB[i]=0;
008E94  782900     MOV W0, [++W2]
008E96  E90081     DEC W1, W1
66:                    }
67:                    
68:                    for(i=0; i<BUTTONS; i++)
008EA4  500F82     SUB W0, W2, [W15]
008EA6  3AFFFD     BRA NZ, 0x8EA2
69:                        pad[i]=1;
008EA0  B3C011     MOV.B #0x1, W1
008EA2  786801     MOV.B W1, [++W0]
70:                }
008EA8  060000     RETURN
71:                
72:                int main(void) {
008EAA  BE9F88     MOV.D W8, [W15++]
008EAC  BE9F8A     MOV.D W10, [W15++]
008EAE  781F8C     MOV W12, [W15++]
73:                    initPorts();                    //configure io device & adc 
008EB0  07F8DB     RCALL initPorts
74:                    //initUART1();                    //configure & enable UART
75:                    initBuffer();
008EB2  07FFE3     RCALL initBuffer
76:                    initADC1();                     //configure & enable internal ADC
008EB4  07F9A0     RCALL initADC1
77:                    initPMP();
008EB6  07F9BD     RCALL initPMP
78:                    //||||||||----
79:                    //initDMA0();
80:                    initDCI_DAC();                  //configure & enable DAC
008EB8  07F9FB     RCALL initDCI_DAC
81:                    initT1();                       //configure & start T1 
008EBA  07F9CF     RCALL initT1
82:                    initT2();                       //configure & start T2 
008EBC  07F9D7     RCALL initT2
83:                    initSPI3_MEM();                  //start segment display
008EBE  07FA70     RCALL initSPI3_MEM
84:                    //initCAP_BPM();                  //configure bpm capture
85:                    initT3();                       //configure & start T3 for lcd
008EC0  07F9E1     RCALL initT3
86:                    initQEI_ENC();
008EC2  07FA90     RCALL initQEI_ENC
87:                    //initT5();
88:                    fractional temp;
89:                    fractional *ping, *pong;
90:                    
91:                    while(1){    
92:                        if(frameReady) {
008ECE  E21014     CP0 frameReady
008ED0  32000F     BRA Z, 0x8EF0
93:                            process_time=(STREAMBUF-1);             //DEBUG
008ED2  200FF0     MOV #0xFF, W0
008ED4  8880B0     MOV W0, process_time
94:                            if(rw){
008ED6  E21012     CP0 rw
008ED8  320003     BRA Z, 0x8EE0
95:                                ping = streamA+(STREAMBUF-1);
008ECA  266B4C     MOV #0x66B4, W12
008EDC  78000C     MOV W12, W0
008EDE  370002     BRA 0x8EE4
96:                                pong = outputB+(STREAMBUF-1);
008EC8  264B4B     MOV #0x64B4, W11
008EDA  78008B     MOV W11, W1
97:                            }else{
98:                                ping = streamB+(STREAMBUF-1);
008EC6  268B4A     MOV #0x68B4, W10
008EE2  78000A     MOV W10, W0
99:                                pong = outputA+(STREAMBUF-1);
008EC4  262B49     MOV #0x62B4, W9
008EE0  780089     MOV W9, W1
100:                           }
101:                           
102:                           processAudio(ping, pong); 
008EE4  07FE11     RCALL processAudio
103:                           process_time=(STREAMBUF-1)-write_ptr;    //DEBUG
008EE6  8081D0     MOV 0x103A, W0
008EE8  200FF1     MOV #0xFF, W1
008EEA  508000     SUB W1, W0, W0
008EEC  8880B0     MOV W0, process_time
104:                           frameReady=0;
008EEE  EF3014     CLR frameReady
105:                           
106:                           
107:                       }
108:                       if(_T2IF){
008EF0  ABE800     BTST IFS0, #7
008EF2  320006     BRA Z, 0x8F00
109:                           scanButtons();                   //read button matrix
008EF4  07FA7E     RCALL scanButtons
110:                           if(_AD1IF) readPots();
008ECC  220008     MOV #0x2000, W8
008EF6  804001     MOV IFS0, W1
008EF8  640001     AND W8, W1, W0
008EFA  320001     BRA Z, 0x8EFE
008EFC  07FB1E     RCALL readPots
111:                           _T2IF=0;
008EFE  A9E800     BCLR IFS0, #7
112:                       }
113:                       if(_T1IF){
008F00  AB6800     BTST IFS0, #3
008F02  320002     BRA Z, 0x8F08
114:                           display();
008F04  07FBDF     RCALL display
115:                           _T1IF=0;
008F06  A96800     BCLR IFS0, #3
116:                       }
117:                       if(_T3IF) {
008F08  AB0801     BTST 0x801, #0
008F0A  32FFE1     BRA Z, 0x8ECE
118:                           lcdPoll();
008F0C  07F847     RCALL lcdPoll
119:                           _T3IF=0;
008F0E  A90801     BCLR 0x801, #0
008F10  37FFDE     BRA 0x8ECE
120:                       }
121:                   }
122:                   return 0;
123:               }
124:               // example test 
---  C:/Users/ryan/Documents/seniorproject/ps-040/flash.c  ----------------------------------------------
1:                 /*
2:                  * File:   flash.c
3:                  * Author: root
4:                  *
5:                  * Created on January 28, 2018, 5:00 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "flash.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                char flashBuf[STREAMBUF*2];
15:                char receive;
16:                
17:                void flashWriteReg(char command) {
18:                    SS3=0;
008D54  A92E54     BCLR LATF, #1
19:                    SPI3BUF=command;               //WEL=1 for write enable
008D56  FB0000     SE W0, W0
008D58  881540     MOV W0, SPI3BUF
20:                    while(!_SPI3IF); _SPI3IF=0;
008D5A  208001     MOV #0x800, W1
008D5C  804052     MOV IFS5, W2
008D5E  608002     AND W1, W2, W0
008D60  32FFFD     BRA Z, 0x8D5C
008D62  A9680B     BCLR 0x80B, #3
21:                    receive=SPI3BUF;
008D64  801540     MOV SPI3BUF, W0
008D66  B7F04C     MOV.B WREG, receive
22:                    SS3=1;
008D68  A82E54     BSET LATF, #1
23:                }
008D6A  060000     RETURN
24:                
25:                char flashStatusCheck(void){
26:                    SS3=0;
008D6C  A92E54     BCLR LATF, #1
27:                    SPI3BUF=FLASH_RDSR1;               //WEL=1 for write enable
008D6E  200050     MOV #0x5, W0
008D70  881540     MOV W0, SPI3BUF
28:                    while(!_SPI3IF); _SPI3IF=0;
008D72  208001     MOV #0x800, W1
008D74  804052     MOV IFS5, W2
008D76  608002     AND W1, W2, W0
008D78  32FFFD     BRA Z, 0x8D74
008D7A  A9680B     BCLR 0x80B, #3
29:                    receive=SPI3BUF;
008D7C  801540     MOV SPI3BUF, W0
30:                    SPI3BUF=0x00;               //WEL=1 for write enable
008D7E  EF22A8     CLR SPI3BUF
31:                    while(!_SPI3IF); _SPI3IF=0;
008D80  208001     MOV #0x800, W1
008D82  804052     MOV IFS5, W2
008D84  608002     AND W1, W2, W0
008D86  32FFFD     BRA Z, 0x8D82
008D88  A9680B     BCLR 0x80B, #3
32:                    receive=SPI3BUF;
008D8A  801540     MOV SPI3BUF, W0
008D8C  B7F04C     MOV.B WREG, receive
33:                    SS3=1;
008D8E  A82E54     BSET LATF, #1
34:                    
35:                    return receive;
36:                }
008D90  060000     RETURN
37:                
38:                void flashWritePage(int addressH, int addressL){
39:                    int i;
40:                    SS3=0;
008D92  A92E54     BCLR LATF, #1
41:                    SPI3BUF=FLASH_PP;
008D94  200022     MOV #0x2, W2
008D96  881542     MOV W2, SPI3BUF
42:                    while(!_SPI3IF); _SPI3IF=0;
008D98  208003     MOV #0x800, W3
008D9A  804054     MOV IFS5, W4
008D9C  618104     AND W3, W4, W2
008D9E  32FFFD     BRA Z, 0x8D9A
008DA0  A9680B     BCLR 0x80B, #3
43:                    receive=SPI3BUF;
008DA2  801542     MOV SPI3BUF, W2
44:                    SPI3BUF=addressH&&0xFF;
008DA4  A7F000     BTSC W0, #15
008DA6  EA0000     NEG W0, W0
008DA8  EA0000     NEG W0, W0
008DAA  DE004F     LSR W0, #15, W0
008DAC  881540     MOV W0, SPI3BUF
45:                    while(!_SPI3IF); _SPI3IF=0;
008DAE  208002     MOV #0x800, W2
008DB0  804053     MOV IFS5, W3
008DB2  610003     AND W2, W3, W0
008DB4  32FFFD     BRA Z, 0x8DB0
008DB6  A9680B     BCLR 0x80B, #3
46:                    receive=SPI3BUF;
008DB8  801540     MOV SPI3BUF, W0
47:                    SPI3BUF=(addressL&&0xFF00)>>8;
008DBA  EF22A8     CLR SPI3BUF
48:                    while(!_SPI3IF); _SPI3IF=0;
008DBC  208002     MOV #0x800, W2
008DBE  804054     MOV IFS5, W4
008DC0  610004     AND W2, W4, W0
008DC2  32FFFD     BRA Z, 0x8DBE
008DC4  A9680B     BCLR 0x80B, #3
49:                    receive=SPI3BUF;
008DC6  801540     MOV SPI3BUF, W0
50:                    SPI3BUF=addressL&&0xFF;
008DC8  780001     MOV W1, W0
008DCA  A7F000     BTSC W0, #15
008DCC  EA0000     NEG W0, W0
008DCE  EA0000     NEG W0, W0
008DD0  DE004F     LSR W0, #15, W0
008DD2  881540     MOV W0, SPI3BUF
51:                    while(!_SPI3IF); _SPI3IF=0;
008DD4  208001     MOV #0x800, W1
008DD6  804052     MOV IFS5, W2
008DD8  608002     AND W1, W2, W0
008DDA  32FFFD     BRA Z, 0x8DD6
008DDC  A9680B     BCLR 0x80B, #3
52:                    receive=SPI3BUF;
008DDE  801540     MOV SPI3BUF, W0
008DE0  202002     MOV #0x200, W2
53:                    
54:                    for(i=0; i<512;i++){    //write 512 bytes
008DF4  3AFFF8     BRA NZ, 0x8DE6
008DF6  B7F04C     MOV.B WREG, receive
55:                        //send byte
56:                        SPI3BUF=0xAA;
008DE2  200AA3     MOV #0xAA, W3
008DE6  881543     MOV W3, SPI3BUF
57:                        while(!_SPI3IF); _SPI3IF=0;
008DE4  208001     MOV #0x800, W1
008DE8  804054     MOV IFS5, W4
008DEA  608004     AND W1, W4, W0
008DEC  32FFFD     BRA Z, 0x8DE8
008DEE  A9680B     BCLR 0x80B, #3
58:                        receive=SPI3BUF;
008DF0  801540     MOV SPI3BUF, W0
008DF2  E90102     DEC W2, W2
59:                    }
60:                    SS3=1;
008DF8  A82E54     BSET LATF, #1
61:                }
008DFA  060000     RETURN
62:                
63:                void flashRead(char *array, int bytes){
008DFC  BE9F88     MOV.D W8, [W15++]
008DFE  BE9F8A     MOV.D W10, [W15++]
008E00  781F8C     MOV W12, [W15++]
008E02  780581     MOV W1, W11
64:                    int i;
65:                    
66:                    SS3=0;
008E04  A92E54     BCLR LATF, #1
67:                    SPI3BUF=FLASH_READ;
008E06  200031     MOV #0x3, W1
008E08  881541     MOV W1, SPI3BUF
68:                    while(!_SPI3IF); _SPI3IF=0;
008E0A  208002     MOV #0x800, W2
008E0C  804053     MOV IFS5, W3
008E0E  610083     AND W2, W3, W1
008E10  32FFFD     BRA Z, 0x8E0C
008E12  A9680B     BCLR 0x80B, #3
69:                    receive=SPI3BUF;
008E14  801541     MOV SPI3BUF, W1
70:                    SPI3BUF=0x00;
008E16  EF22A8     CLR SPI3BUF
71:                    while(!_SPI3IF); _SPI3IF=0;
008E18  208002     MOV #0x800, W2
008E1A  804053     MOV IFS5, W3
008E1C  610083     AND W2, W3, W1
008E1E  32FFFD     BRA Z, 0x8E1A
008E20  A9680B     BCLR 0x80B, #3
72:                    receive=SPI3BUF;
008E22  801541     MOV SPI3BUF, W1
73:                    SPI3BUF=0x00;
008E24  EF22A8     CLR SPI3BUF
74:                    while(!_SPI3IF); _SPI3IF=0;
008E26  208002     MOV #0x800, W2
008E28  804053     MOV IFS5, W3
008E2A  610083     AND W2, W3, W1
008E2C  32FFFD     BRA Z, 0x8E28
008E2E  A9680B     BCLR 0x80B, #3
75:                    receive=SPI3BUF;
008E30  801541     MOV SPI3BUF, W1
76:                    SPI3BUF=0x00;
008E32  EF22A8     CLR SPI3BUF
77:                    while(!_SPI3IF); _SPI3IF=0;
008E34  208002     MOV #0x800, W2
008E36  804053     MOV IFS5, W3
008E38  610083     AND W2, W3, W1
008E3A  32FFFD     BRA Z, 0x8E36
008E3C  A9680B     BCLR 0x80B, #3
78:                    receive=SPI3BUF;
008E3E  801541     MOV SPI3BUF, W1
008E40  784181     MOV.B W1, W3
008E42  2104C2     MOV #0x104C, W2
008E44  784903     MOV.B W3, [W2]
79:                    
80:                    for(i=0; i<bytes;i++){    //read 512 bytes
008E46  E0000B     CP0 W11
008E48  340010     BRA LE, 0x8E6A
008E4A  780500     MOV W0, W10
008E4C  EB0480     CLR W9
008E64  E80489     INC W9, W9
008E66  558F89     SUB W11, W9, [W15]
008E68  3CFFF4     BRA GT, 0x8E52
81:                        //receive byte
82:                        SPI3BUF=0x00;
008E4E  EB0600     CLR W12
008E52  88154C     MOV W12, SPI3BUF
83:                        while(!_SPI3IF); _SPI3IF=0;
008E50  208008     MOV #0x800, W8
008E54  804051     MOV IFS5, W1
008E56  640001     AND W8, W1, W0
008E58  32FFFD     BRA Z, 0x8E54
008E5A  A9680B     BCLR 0x80B, #3
84:                        Delay_us(1);
008E5C  200010     MOV #0x1, W0
008E5E  07FC51     RCALL Delay_us
85:                        array[i]=SPI3BUF;
008E60  801540     MOV SPI3BUF, W0
008E62  785D00     MOV.B W0, [W10++]
86:                    }
87:                    SS3=1;
008E6A  A82E54     BSET LATF, #1
88:                }
008E6C  78064F     MOV [--W15], W12
008E6E  BE054F     MOV.D [--W15], W10
008E70  BE044F     MOV.D [--W15], W8
008E72  060000     RETURN
89:                
90:                void flashBulkErase(void) {
91:                    flashWriteReg(FLASH_FRMT);
008E74  B3C600     MOV.B #0x60, W0
008E76  07FF6E     RCALL flashWriteReg
92:                }
008E78  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/devInits.c  -------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 #include <xc.h>
5:                 #include <p33EP512GM310.h>
6:                 #include <libpic30.h>
7:                 #include "common.h"
8:                 #include "devInits.h"
9:                 #include "utilities.h"
10:                #include "plcd.h"
11:                #include "screens.h"
12:                #include "flash.h"
13:                #include "dsp.h"
14:                
15:                extern unsigned char UART_ON;
16:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
17:                
18:                extern char flash_readback[512];
19:                
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
008068  2FF3F0     MOV #0xFF3F, W0
00806A  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
00806C  2FFE00     MOV #0xFFE0, W0
00806E  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
008070  2FE000     MOV #0xFE00, W0
008072  B60746     AND PLLFBD, WREG
008074  B30490     IOR #0x49, W0
008076  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
008078  200201     MOV #0x20, W1
00807A  803A12     MOV OSCCON, W2
00807C  608002     AND W1, W2, W0
00807E  32FFFD     BRA Z, 0x807A
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
008080  803A10     MOV OSCCON, W0
008082  A16000     BCLR W0, #6
008084  200462     MOV #0x46, W2
008086  200573     MOV #0x57, W3
008088  207421     MOV #0x742, W1
00808A  784882     MOV.B W2, [W1]
00808C  784883     MOV.B W3, [W1]
00808E  784880     MOV.B W0, [W1]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
008090  2FFC00     MOV #0xFFC0, W0
008092  803424     MOV RPOR2, W4
008094  600084     AND W0, W4, W1
008096  A00001     BSET W1, #0
008098  883421     MOV W1, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
00809A  2FF801     MOV #0xFF80, W1
00809C  803685     MOV RPINR24, W5
00809E  608205     AND W1, W5, W4
0080A0  B303D4     IOR #0x3D, W4
0080A2  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
0080A4  B60686     AND RPOR3, WREG
0080A6  B300C0     IOR #0xC, W0
0080A8  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
0080AA  2C0FF0     MOV #0xC0FF, W0
0080AC  803426     MOV RPOR2, W6
0080AE  600286     AND W0, W6, W5
0080B0  20D004     MOV #0xD00, W4
0080B2  720205     IOR W4, W5, W4
0080B4  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
0080B6  803434     MOV RPOR3, W4
0080B8  600284     AND W0, W4, W5
0080BA  20B004     MOV #0xB00, W4
0080BC  720205     IOR W4, W5, W4
0080BE  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
0080C0  803575     MOV RPINR7, W5
0080C2  608205     AND W1, W5, W4
0080C4  B305F4     IOR #0x5F, W4
0080C6  883574     MOV W4, RPINR7
36:                    RPINR29bits.SCK3R=0x39;     //SCK3 input on pin 84
0080C8  280FF4     MOV #0x80FF, W4
0080CA  8036D5     MOV RPINR29, W5
0080CC  620305     AND W4, W5, W6
0080CE  239005     MOV #0x3900, W5
0080D0  728286     IOR W5, W6, W5
0080D2  8836D5     MOV W5, RPINR29
37:                    RPOR7bits.RP57R=0x20;       //SCK3 output on pin 84
0080D4  803476     MOV RPOR7, W6
0080D6  600286     AND W0, W6, W5
0080D8  A0D005     BSET W5, #13
0080DA  883475     MOV W5, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
0080DC  803485     MOV RPOR8, W5
0080DE  600305     AND W0, W5, W6
0080E0  21F005     MOV #0x1F00, W5
0080E2  728286     IOR W5, W6, W5
0080E4  883485     MOV W5, RPOR8
39:                    RPOR9bits.RP97R=0x21;       //SS3 on pin 88
0080E6  B60692     AND RPOR9, WREG
0080E8  221005     MOV #0x2100, W5
0080EA  728280     IOR W5, W0, W5
0080EC  883495     MOV W5, RPOR9
40:                    RPINR29bits.SDI3R=0x4C;     //SDI on pin 79, RPI76
0080EE  8036D6     MOV RPINR29, W6
0080F0  608006     AND W1, W6, W0
0080F2  B304C0     IOR #0x4C, W0
0080F4  8836D0     MOV W0, RPINR29
41:                    RPINR14bits.QEA1R=0x10;     //QEA on pin 22, RPI16
0080F6  8035E0     MOV RPINR14, W0
0080F8  608080     AND W1, W0, W1
0080FA  A04001     BSET W1, #4
0080FC  8835E1     MOV W1, RPINR14
42:                    RPINR14bits.QEB1R=0x1B;     //QEB on pin 21, RPI27
0080FE  8035E5     MOV RPINR14, W5
008100  620205     AND W4, W5, W4
008102  21B000     MOV #0x1B00, W0
008104  700004     IOR W0, W4, W0
008106  8835E0     MOV W0, RPINR14
43:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
008108  803A10     MOV OSCCON, W0
00810A  A06000     BSET W0, #6
00810C  207421     MOV #0x742, W1
00810E  784882     MOV.B W2, [W1]
008110  784883     MOV.B W3, [W1]
008112  784880     MOV.B W0, [W1]
44:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
45:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
008114  EB8000     SETM W0
008116  883B60     MOV W0, PMD7
008118  F8076C     PUSH PMD7
00811A  F9076A     POP PMD6
00811C  F8076A     PUSH PMD6
00811E  F90766     POP PMD4
008120  F80766     PUSH PMD4
008122  F90764     POP PMD3
008124  F80764     PUSH PMD3
008126  F90762     POP PMD2
008128  F80762     PUSH PMD2
00812A  F90760     POP PMD1
46:                    PMD1bits.AD1MD=0;
00812C  A90760     BCLR PMD1, #0
47:                    PMD1bits.SPI1MD=0;
00812E  A96760     BCLR PMD1, #3
48:                    PMD1bits.SPI2MD=0;
008130  A98760     BCLR PMD1, #4
49:                    PMD1bits.U1MD=0;
008132  A9A760     BCLR PMD1, #5
50:                    PMD1bits.U2MD=0;
008134  A9C760     BCLR PMD1, #6
51:                    PMD1bits.DCIMD=0;
008136  A90761     BCLR 0x761, #0
52:                    PMD1bits.T1MD=0;
008138  A96761     BCLR 0x761, #3
53:                    PMD1bits.T2MD=0;
00813A  A98761     BCLR 0x761, #4
54:                    PMD1bits.T3MD=0;
00813C  A9A761     BCLR 0x761, #5
55:                    PMD1bits.T4MD=0;
00813E  A9C761     BCLR 0x761, #6
56:                    PMD1bits.T5MD=0;
008140  A9E761     BCLR 0x761, #7
57:                    PMD3bits.PMPMD=0;
008142  A90765     BCLR 0x765, #0
58:                    PMD3bits.CMPMD=0;
008144  A94765     BCLR 0x765, #2
59:                    PMD6bits.SPI3MD=0;
008146  A9076A     BCLR PMD6, #0
60:                    PMD7bits.DMA0MD=0;
008148  A9876C     BCLR PMD7, #4
61:                    
62:                    /* Digital IO DIRECTION (1 = input) */
63:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
00814A  EF2E60     CLR TRISG
00814C  F80E60     PUSH TRISG
00814E  F90E50     POP TRISF
008150  F80E50     PUSH TRISF
008152  F90E40     POP TRISE
008154  F80E40     PUSH TRISE
008156  F90E30     POP TRISD
008158  F80E30     PUSH TRISD
00815A  F90E20     POP TRISC
00815C  F80E20     PUSH TRISC
00815E  F90E10     POP TRISB
008160  F80E10     PUSH TRISB
008162  F90E00     POP TRISA
64:                    TRISA=0x1E01; CNPUA=0x0801;
008164  21E011     MOV #0x1E01, W1
008166  887001     MOV W1, TRISA
008168  208011     MOV #0x801, W1
00816A  887051     MOV W1, CNPUA
65:                    TRISB=0x0000; CNPUB=0x0000;
00816C  EF2E10     CLR TRISB
00816E  EF2E1A     CLR CNPUB
66:                    TRISC=0x2087;
008170  220871     MOV #0x2087, W1
008172  887101     MOV W1, TRISC
67:                    TRISD=0x011E; CNPUD=0x001E;
008174  2011E1     MOV #0x11E, W1
008176  887181     MOV W1, TRISD
008178  2001E1     MOV #0x1E, W1
00817A  8871D1     MOV W1, CNPUD
68:                    TRISE=0x7300;
00817C  273001     MOV #0x7300, W1
00817E  887201     MOV W1, TRISE
69:                    TRISF=0x00F0; CNPUF=0x00F1;
008180  200F01     MOV #0xF0, W1
008182  887281     MOV W1, TRISF
008184  E80081     INC W1, W1
008186  8872D1     MOV W1, CNPUF
70:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
008188  887350     MOV W0, CNPUG
00818A  F80E6A     PUSH CNPUG
00818C  F90E60     POP TRISG
71:                    
72:                    /* DIGITAL OUTPUT LATCH */
73:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
00818E  EF2E64     CLR LATG
008190  F80E64     PUSH LATG
008192  F90E54     POP LATF
008194  F80E54     PUSH LATF
008196  F90E44     POP LATE
008198  F80E44     PUSH LATE
00819A  F90E34     POP LATD
00819C  F80E34     PUSH LATD
00819E  F90E24     POP LATC
0081A0  F80E24     PUSH LATC
0081A2  F90E14     POP LATB
0081A4  F80E14     PUSH LATB
0081A6  F90E04     POP LATA
74:                    LATA=0x0040;
0081A8  200400     MOV #0x40, W0
0081AA  887020     MOV W0, LATA
75:                    
76:                    /* ANALOG PINS (1 = analog) */
77:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
0081AC  EF2E6E     CLR ANSELG
0081AE  F80E6E     PUSH ANSELG
0081B0  F90E5E     POP ANSELF
0081B2  F80E5E     PUSH ANSELF
0081B4  F90E4E     POP ANSELE
0081B6  F80E4E     PUSH ANSELE
0081B8  F90E3E     POP ANSELD
0081BA  F80E3E     PUSH ANSELD
0081BC  F90E2E     POP ANSELC
0081BE  F80E2E     PUSH ANSELC
0081C0  F90E1E     POP ANSELB
0081C2  F80E1E     PUSH ANSELB
0081C4  F90E0E     POP ANSELA
78:                    ANSELCbits.ANSC0=1;     //AN6
0081C6  A80E2E     BSET ANSELC, #0
79:                    ANSELCbits.ANSC1=1;     //AN7
0081C8  A82E2E     BSET ANSELC, #1
80:                    ANSELCbits.ANSC2=1;     //AN8
0081CA  A84E2E     BSET ANSELC, #2
81:                    ANSELAbits.ANSA12=1;    //AN10 
0081CC  A88E0F     BSET 0xE0F, #4
82:                    ANSELEbits.ANSE8=1;     //AN21
0081CE  A80E4F     BSET 0xE4F, #0
83:                    ANSELEbits.ANSE9=1;     //AN20
0081D0  A82E4F     BSET 0xE4F, #1
84:                    
85:                    
86:                    
87:                }
0081D2  060000     RETURN
88:                
89:                void initUART1(void){
90:                    IFS0bits.U1TXIF = 0;        //clear flag
0081D4  A98801     BCLR 0x801, #4
91:                    IFS0bits.U1RXIF = 0;        //clear flag
0081D6  A96801     BCLR 0x801, #3
92:                    U1STA=0x1510;               //enable tx & rx
0081D8  215100     MOV #0x1510, W0
0081DA  881110     MOV W0, U1STA
93:                    U1BRG=BRGVAL;               //baud rate
0081DC  2004A0     MOV #0x4A, W0
0081DE  881140     MOV W0, U1BRG
94:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
0081E0  2FFF90     MOV #0xFFF9, W0
0081E2  B60220     AND U1MODE, WREG
0081E4  A01000     BSET W0, #1
0081E6  881100     MOV W0, U1MODE
95:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
0081E8  270000     MOV #0x7000, W0
0081EA  B72844     IOR IPC2
96:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
0081EC  200070     MOV #0x7, W0
0081EE  B72846     IOR IPC3
97:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
98:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
99:                    U1MODEbits.UARTEN = 1;      //start uart
0081F0  A8E221     BSET 0x221, #7
100:                   UART_ON = TRUE;
0081F2  EFF019     SETM.B UART_ON
101:                   
102:               }
0081F4  060000     RETURN
103:               
104:               void initADC1(void){ 
105:               
106:                   /* Assign MUXA inputs */
107:                   AD1CON1 = 0x04E4; // Enable 12-bit mode, auto-sample and auto-conversion
0081F6  204E40     MOV #0x4E4, W0
0081F8  881900     MOV W0, AD1CON1
108:                   AD1CON2 = 0x0408; // Sample alternately using channel scanning
0081FA  B10DC0     SUB #0xDC, W0
0081FC  881910     MOV W0, AD1CON2
109:                   AD1CON2bits.SMPI=(POTS/2)-1; // Sample 6 channels
0081FE  2FF830     MOV #0xFF83, W0
008200  B60322     AND AD1CON2, WREG
008202  B30140     IOR #0x14, W0
008204  881910     MOV W0, AD1CON2
110:                   AD1CON3 = 0x0F0F; // Sample for 15*TAD before converting
008206  20F0F0     MOV #0xF0F, W0
008208  881920     MOV W0, AD1CON3
111:                   AD1CON1bits.FORM=2;         //signed fractional format 
00820A  2FCFF0     MOV #0xFCFF, W0
00820C  B60320     AND AD1CON1, WREG
00820E  A09000     BSET W0, #9
008210  881900     MOV W0, AD1CON1
112:                   AD1CON3bits.ADCS=0x07;
008212  B3C070     MOV.B #0x7, W0
008214  B7E324     MOV.B WREG, AD1CON3
113:                   AD1CON3bits.SAMC=0x03;
008216  2E0FF0     MOV #0xE0FF, W0
008218  B60324     AND AD1CON3, WREG
00821A  B33000     IOR #0x300, W0
00821C  881920     MOV W0, AD1CON3
114:                   //select  AN6,7,8
115:                   AD1CSSLbits.CSS6=1; //AN6
00821E  A8C330     BSET AD1CSSL, #6
116:                   AD1CSSLbits.CSS7=1; //AN7
008220  A8E330     BSET AD1CSSL, #7
117:                   AD1CSSLbits.CSS8=1; //AN8
008222  A80331     BSET 0x331, #0
118:                   AD1CSSLbits.CSS10=1;//AN10
008224  A84331     BSET 0x331, #2
119:                   AD1CSSHbits.CSS20=1;//AN20
008226  A8832E     BSET AD1CSSH, #4
120:                   AD1CSSHbits.CSS21=1;//AN21
008228  A8A32E     BSET AD1CSSH, #5
121:                   //AD1CSSLbits.CSS9=1; //AN9
122:                   /* Enable ADC module and provide ADC stabilization delay */
123:                   AD1CON1bits.ADON = 1;
00822A  A8E321     BSET 0x321, #7
124:                   Delay_us(30);
00822C  2001E0     MOV #0x1E, W0
00822E  070269     RCALL Delay_us
125:               }
008230  060000     RETURN
126:               
127:               void initPMP(void){
128:                   /*
129:                    Data is clocked on falling edge of E
130:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
131:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
132:                    */
133:                   PMMODEbits.MODE=3;  //master mode 1 
008232  203000     MOV #0x300, W0
008234  B72602     IOR PMMODE
134:                   PMCONbits.PTWREN = 1;
008236  A82601     BSET 0x601, #1
135:                   PMCONbits.PTRDEN = 1;
008238  A80601     BSET 0x601, #0
136:                   PMCONbits.WRSP=1;   //write strobe active high
00823A  A82600     BSET PMCON, #1
137:                   PMCONbits.RDSP=1;   //read strobe active high
00823C  A80600     BSET PMCON, #0
138:               
139:                   PMMODEbits.WAITB = 0;
00823E  2FF3F0     MOV #0xFF3F, W0
008240  B62602     AND PMMODE
140:                   PMMODEbits.WAITM = 0xC;
008242  2FFC30     MOV #0xFFC3, W0
008244  B60602     AND PMMODE, WREG
008246  B30300     IOR #0x30, W0
008248  883010     MOV W0, PMMODE
141:                   PMMODEbits.WAITE = 0;
00824A  2FFFC0     MOV #0xFFFC, W0
00824C  B62602     AND PMMODE
142:                   LCD_RS=0;
00824E  A9EE45     BCLR 0xE45, #7
143:                   PMCONbits.PMPEN = 1;
008250  A8E601     BSET 0x601, #7
144:                   
145:                   /* INIT DEVICE */
146:                   Delay_us(40000);
008252  29C400     MOV #0x9C40, W0
008254  070256     RCALL Delay_us
147:                   lcdInit();
008256  07FEEC     RCALL lcdInit
148:                   
149:                   /* SETUP SCREEN */
150:                   //lcdSetupPots();
151:               }
008258  060000     RETURN
152:               
153:               
154:               //Description: Initializes timer for LED's UART and display
155:               //Prereq: initUART1()
156:               //Dependencies: _T1Interrupt(void)
157:               //Frequency: 15Hz
158:               void initT1(void){          //16 bit timer
159:                   TMR1 = 0x0000;          //clear timer 4
00825A  EF2100     CLR TMR1
160:                   T1CONbits.TCKPS = 3;    //prescale 1:256
00825C  200300     MOV #0x30, W0
00825E  B72104     IOR T1CON
161:                   T1CONbits.TCS = 0;      //use internal clock
008260  A92104     BCLR T1CON, #1
162:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
008262  A9C104     BCLR T1CON, #6
163:                   PR1 = Fcy/(256*Fdisp);    //period register
008264  246500     MOV #0x4650, W0
008266  880810     MOV W0, PR1
164:                   //PR1=0x7FFF;
165:               
166:                   T1CONbits.TON = 1;      //start timer
008268  A8E105     BSET 0x105, #7
167:               }
00826A  060000     RETURN
168:               
169:               //Description:  Initializes timer handles polling button input
170:               //Prereq: initADC1() 
171:               //Dependencies: _T2Interrupt(void)
172:               //Frequency: 512Hz
173:               void initT2(void){          //16/32 bit timer
174:                   TMR2 = 0x0000;          //clear timer 4
00826C  EF2106     CLR TMR2
175:                   T2CONbits.T32 = 0;      //16 bit mode
00826E  A96110     BCLR T2CON, #3
176:                   T2CONbits.TCKPS = 1;    //prescale 1:8
008270  2FFCF0     MOV #0xFFCF, W0
008272  B60110     AND T2CON, WREG
008274  A04000     BSET W0, #4
008276  880880     MOV W0, T2CON
177:                   T2CONbits.TCS = 0;      //use internal clock
008278  A92110     BCLR T2CON, #1
178:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
00827A  A9C110     BCLR T2CON, #6
179:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
00827C  283D60     MOV #0x83D6, W0
00827E  880860     MOV W0, PR2
180:               
181:                   T2CONbits.TON = 1;      //start timer
008280  A8E111     BSET 0x111, #7
182:               }
008282  060000     RETURN
183:               
184:               //Description: Initialize timer handling LCD sending
185:               //Dependencies: _T3Interrupt(void)
186:               //Frequency: 44.1kHz
187:               void initT3(void){          //16/32 bit timer
188:                   TMR3 = 0x0000;          //clear timer 3
008284  EF210A     CLR TMR3
189:                   T3CONbits.TCKPS = 1;    //prescale 8:1
008286  2FFCF0     MOV #0xFFCF, W0
008288  B60112     AND T3CON, WREG
00828A  A04000     BSET W0, #4
00828C  880890     MOV W0, T3CON
190:                   T3CONbits.TCS = 0;      //use internal clock
00828E  A92112     BCLR T3CON, #1
191:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
008290  A9C112     BCLR T3CON, #6
192:                   //PR3 = Fcy/(256*T3freq);           //period register
193:                   PR3 = 0x01D0;           //45uS initial delay
008292  201D00     MOV #0x1D0, W0
008294  880870     MOV W0, PR3
194:                   
195:                   T3CONbits.TON = 1;
008296  A8E113     BSET 0x113, #7
196:                   
197:               }
008298  060000     RETURN
198:               
199:               /*=============================================================================  
200:               Timer 5 is setup to time-out every 125 microseconds (8Khz Rate). As a result, the module 
201:               will stop sampling and trigger a conversion on every Timer3 time-out, i.e., Ts=125us. 
202:               =============================================================================*/
203:               void initT5() 
204:               {
205:                       TMR5 = 0x0000;
00829A  EF2118     CLR TMR5
206:                       PR5 = 4999;
00829C  213870     MOV #0x1387, W0
00829E  8808E0     MOV W0, PR5
207:                       T5CONbits.TCKPS = 2;    //prescale 8:1
0082A0  2FFCF0     MOV #0xFFCF, W0
0082A2  B60120     AND T5CON, WREG
0082A4  A05000     BSET W0, #5
0082A6  880900     MOV W0, T5CON
208:                       IFS1bits.T5IF = 0;
0082A8  A98803     BCLR 0x803, #4
209:                       IEC1bits.T5IE = 0;
0082AA  A98823     BCLR 0x823, #4
210:               
211:                       //Start Timer 3
212:                       T5CONbits.TON = 1;
0082AC  A8E121     BSET 0x121, #7
213:               
214:               }
0082AE  060000     RETURN
215:               
216:               //Description: Initializes & starts 16 bit DCI I2S DAC
217:               //Prereq: initSPI_ADC(void)
218:               //Dependencies: readDAC(void)
219:               void initDCI_DAC(void){
220:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
0082B0  2F0000     MOV #0xF000, W0
0082B2  B60284     AND DCICON3, WREG
0082B4  B30170     IOR #0x17, W0
0082B6  881420     MOV W0, DCICON3
221:                   DCICON1bits.COFSM=1;                //i2s mode
0082B8  2FFFC0     MOV #0xFFFC, W0
0082BA  B60280     AND DCICON1, WREG
0082BC  A00000     BSET W0, #0
0082BE  881400     MOV W0, DCICON1
222:                   DCICON1bits.CSCKE=1;                //sample on rising edge
0082C0  A82281     BSET 0x281, #1
223:                   DCICON2bits.WS=0xF;                 //16 bit data word
0082C2  2000F0     MOV #0xF, W0
0082C4  B72282     IOR DCICON2
224:                   DCICON2bits.COFSG=0;    //data frame has 1 word (per frame)
0082C6  2FE1F0     MOV #0xFE1F, W0
0082C8  B62282     AND DCICON2
225:                   DCICON1bits.DJST=0;     //align data
0082CA  A9A280     BCLR DCICON1, #5
226:                   DCICON2bits.BLEN=3;     //4 words buffer btwn interrupts
0082CC  20C000     MOV #0xC00, W0
0082CE  B72282     IOR DCICON2
227:                   
228:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
0082D0  A80288     BSET TSCON, #0
229:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
0082D2  A82288     BSET TSCON, #1
230:                   TSCONbits.TSE2 = 1;     // Transmit on Time Slot 2     
0082D4  A84288     BSET TSCON, #2
231:                   TSCONbits.TSE3 = 1;     // Transmit on Time Slot 3   
0082D6  A86288     BSET TSCON, #3
232:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
0082D8  A8028C     BSET RSCON, #0
233:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
0082DA  A8228C     BSET RSCON, #1
234:                   RSCONbits.RSE2 = 1;     // rcv on Time Slot 2     
0082DC  A8428C     BSET RSCON, #2
235:                   RSCONbits.RSE3 = 1;     // rcv on Time Slot 3 
0082DE  A8628C     BSET RSCON, #3
236:                   
237:               
238:                   
239:                   IPC15bits.DCIIP = 6;    // Interrput priority
0082E0  2FFF80     MOV #0xFFF8, W0
0082E2  B6085E     AND IPC15, WREG
0082E4  B30060     IOR #0x6, W0
0082E6  8842F0     MOV W0, IPC15
240:                   IFS3bits.DCIIF=0;
0082E8  A98807     BCLR 0x807, #4
241:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
0082EA  A88827     BSET 0x827, #4
242:                   
243:                   // Pre-load send registers.
244:                   TXBUF0=0;
0082EC  EF2298     CLR TXBUF0
245:                   TXBUF1=0;   
0082EE  EF229A     CLR TXBUF1
246:                   TXBUF2=0;
0082F0  EF229C     CLR TXBUF2
247:                   TXBUF3=0;
0082F2  EF229E     CLR TXBUF3
248:                   DCICON1bits.DCIEN=1;    //ENABLE
0082F4  A8E281     BSET 0x281, #7
249:                   // Stabilization delay
250:                   Delay_us(20);
0082F6  200140     MOV #0x14, W0
0082F8  070204     RCALL Delay_us
251:               }
0082FA  060000     RETURN
252:               
253:               void initDMA0(void){
254:                   unsigned long address;
255:                   
256:                   /*
257:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
258:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
259:                   DMA0PAD =  0X0608; // Point DMA to PMP
260:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
261:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
262:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
263:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
264:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
265:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
266:                   DMA0CONbits.CHEN=1; // Enable DMA
267:                   */
268:                   
269:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
0082FC  A9CB01     BCLR 0xB01, #6
270:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
0082FE  A8AB01     BSET 0xB01, #5
271:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
008300  2FFCF4     MOV #0xFFCF, W4
008302  20B000     MOV #0xB00, W0
008304  620810     AND W4, [W0], [W0]
272:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
008306  2FFFC3     MOV #0xFFFC, W3
008308  805801     MOV DMA0CON, W1
00830A  618001     AND W3, W1, W0
00830C  A01000     BSET W0, #1
00830E  885800     MOV W0, DMA0CON
273:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
008310  A98B01     BCLR 0xB01, #4
274:                   DMA0CONbits.NULLW = 0;
008312  A96B01     BCLR 0xB01, #3
275:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
008314  A9EB03     BCLR 0xB03, #7
276:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
008316  B3C3C2     MOV.B #0x3C, W2
008318  20B025     MOV #0xB02, W5
00831A  784A82     MOV.B W2, [W5]
277:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
00831C  27FFF0     MOV #0x7FFF, W0
00831E  2CE001     MOV #0xCE00, W1
008320  608080     AND W1, W0, W1
278:                   address +=__builtin_edspage(txBufferA) << 15;
008322  200016     MOV #0x1, W6
008324  DD334F     SL W6, #15, W6
008326  EB0380     CLR W7
008328  408306     ADD W1, W6, W6
00832A  4B83E0     ADDC W7, #0x0, W7
279:                   DMA0STAL = address & 0xFFFF;
00832C  885826     MOV W6, DMA0STAL
280:                   DMA0STAH = address >>16;
00832E  885837     MOV W7, DMA0STAH
281:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
008330  2CC001     MOV #0xCC00, W1
008332  608080     AND W1, W0, W1
282:                   address +=__builtin_edspage(txBufferB) << 15;
008334  200016     MOV #0x1, W6
008336  DD334F     SL W6, #15, W6
008338  EB0380     CLR W7
00833A  408306     ADD W1, W6, W6
00833C  4B83E0     ADDC W7, #0x0, W7
283:                   DMA0STBL = address & 0xFFFF;
00833E  885846     MOV W6, DMA0STBL
284:                   DMA0STBH = address >>16;
008340  885857     MOV W7, DMA0STBH
285:                   DMA0PAD = (int)&TXBUF0;
008342  202981     MOV #0x298, W1
008344  885861     MOV W1, DMA0PAD
286:                   DMA0CNT = STREAMBUF-1;
008346  200FF1     MOV #0xFF, W1
008348  885871     MOV W1, DMA0CNT
287:                   /* DMA 2 - DCI to DPSRAM*/
288:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
00834A  A9CB21     BCLR 0xB21, #6
289:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
00834C  A9AB21     BCLR 0xB21, #5
290:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
00834E  A98B21     BCLR 0xB21, #4
291:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
008350  A96B21     BCLR 0xB21, #3
292:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
008352  20B205     MOV #0xB20, W5
008354  620A95     AND W4, [W5], [W5]
293:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
008356  805904     MOV DMA2CON, W4
008358  618184     AND W3, W4, W3
00835A  A01003     BSET W3, #1
00835C  885903     MOV W3, DMA2CON
294:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
00835E  A9EB23     BCLR 0xB23, #7
295:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
008360  784182     MOV.B W2, W3
008362  20B225     MOV #0xB22, W5
008364  784A83     MOV.B W3, [W5]
296:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
008366  2CA004     MOV #0xCA00, W4
008368  620200     AND W4, W0, W4
297:                   address +=__builtin_edspage(rxBufferA) << 15;
00836A  200012     MOV #0x1, W2
00836C  DD114F     SL W2, #15, W2
00836E  EB0180     CLR W3
008370  420102     ADD W4, W2, W2
008372  4981E0     ADDC W3, #0x0, W3
298:                   DMA2STAL = address & 0xFFFF;
008374  885922     MOV W2, DMA2STAL
299:                   DMA2STAH = address >>16;
008376  885933     MOV W3, DMA2STAH
300:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
008378  2C8002     MOV #0xC800, W2
00837A  610000     AND W2, W0, W0
301:                   address +=__builtin_edspage(rxBufferB) << 15;
00837C  200012     MOV #0x1, W2
00837E  DD114F     SL W2, #15, W2
008380  EB0180     CLR W3
008382  400102     ADD W0, W2, W2
008384  4981E0     ADDC W3, #0x0, W3
302:                   DMA2STBL = address & 0xFFFF;
008386  885942     MOV W2, DMA2STBL
303:                   DMA2STBH = address >>16;
008388  885953     MOV W3, DMA2STBH
304:                   DMA2PAD = (int)&RXBUF0;
00838A  202900     MOV #0x290, W0
00838C  885960     MOV W0, DMA2PAD
305:                   DMA2CNT = STREAMBUF-1;
00838E  885971     MOV W1, DMA2CNT
306:                   _DMA2IP = 5;
008390  2FFF80     MOV #0xFFF8, W0
008392  B6084C     AND IPC6, WREG
008394  B30050     IOR #0x5, W0
008396  884260     MOV W0, IPC6
307:                   _DMA2IE = 1;
008398  A80823     BSET 0x823, #0
308:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
00839A  A8EB01     BSET 0xB01, #7
309:                   DMA2CONbits.CHEN = 1;
00839C  A8EB21     BSET 0xB21, #7
310:               }
00839E  060000     RETURN
311:               
312:               void initSPI3_MEM(void){
313:                   SS3=1;                     // Assert chip select (active low)
0083A0  A82E54     BSET LATF, #1
314:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
0083A2  A9680B     BCLR 0x80B, #3
315:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
0083A4  A9682B     BCLR 0x82B, #3
316:                   SPI3CON1bits.MSTEN=1;       //master mode
0083A6  A8A2A2     BSET SPI3CON1, #5
317:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
0083A8  A982A3     BCLR 0x2A3, #4
318:                   SPI3CON1bits.MODE16=0;      //8 bit
0083AA  A942A3     BCLR 0x2A3, #2
319:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
0083AC  A962A3     BCLR 0x2A3, #3
320:                   SPI3CON1bits.SSEN=1;        //use SS
0083AE  A8E2A2     BSET SPI3CON1, #7
321:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
0083B0  A9E2A5     BCLR 0x2A5, #7
322:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
0083B2  A902A4     BCLR SPI3CON2, #0
323:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
0083B4  2FFE33     MOV #0xFFE3, W3
0083B6  801300     MOV SPI2STAT, W0
0083B8  618080     AND W3, W0, W1
0083BA  B30141     IOR #0x14, W1
0083BC  881301     MOV W1, SPI2STAT
324:                   
325:                   SPI3CON1bits.SMP=1;         //data sampled at end of output time
0083BE  A822A3     BSET 0x2A3, #1
326:                   SPI3CON1bits.CKP=0;         //idle clock is low
0083C0  A9C2A2     BCLR SPI3CON1, #6
327:                   SPI3CON1bits.CKE=1;         //data changes from H to L
0083C2  A802A3     BSET 0x2A3, #0
328:                   
329:                   SPI3CON1bits.PPRE=3;        //1:1 primary prescale
0083C4  200030     MOV #0x3, W0
0083C6  B722A2     IOR SPI3CON1
330:                   SPI3CON1bits.SPRE=6;        //2:1 secondary
0083C8  801511     MOV SPI3CON1, W1
0083CA  618001     AND W3, W1, W0
0083CC  B30180     IOR #0x18, W0
0083CE  881510     MOV W0, SPI3CON1
331:                   
332:                   SPI3STATbits.SPIROV = 0;        // Clear SPI1 receive overflow flag if set
0083D0  A9C2A0     BCLR SPI3STAT, #6
333:                   //IPC22bits.SPI3IP = 3;         // Interrupt priority
334:                   //IFS5bits.SPI3IF = 0;          // Clear the Interrupt flag
335:                   //IEC5bits.SPI3IE = 0;          // Enable the interrupt
336:                   SPI3STATbits.SPIEN = 1;         //start SPI module
0083D2  A8E2A1     BSET 0x2A1, #7
337:                  
338:                   Delay_us(20);                       // Stabilization Delay
0083D4  200140     MOV #0x14, W0
0083D6  070195     RCALL Delay_us
339:                   
340:                   flashWriteReg(FLASH_WREN);
0083D8  B3C060     MOV.B #0x6, W0
0083DA  0704BC     RCALL flashWriteReg
341:                   /*
342:                   flashBulkErase();
343:                   while(flashStatusCheck()&1);
344:               
345:                   flashWritePage
346:                   while(flashStatusCheck()&1);
347:                   */
348:                   
349:                   flashRead(flash_readback, 256);     // READBACK
0083DC  201001     MOV #0x100, W1
0083DE  25E6E0     MOV #0x5E6E, W0
0083E0  07050D     RCALL flashRead
350:                   
351:               }
0083E2  060000     RETURN
352:               
353:               void initQEI_ENC(void){
354:                   QEI1CONbits.INTDIV=6;       // 1:64 prescaler
0083E4  2FF8F0     MOV #0xFF8F, W0
0083E6  B601C0     AND QEI1CON, WREG
0083E8  B30600     IOR #0x60, W0
0083EA  880E00     MOV W0, QEI1CON
355:                   QEI1IOCbits.FLTREN=1;       // Enable input filter
0083EC  A8C1C3     BSET 0x1C3, #6
356:                   QEI1CONbits.QEIEN=1;        // Enable Quad encoder inteface
0083EE  A8E1C1     BSET 0x1C1, #7
357:               }
0083F0  060000     RETURN
358:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/audio.c  ----------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[BUTTONS];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[POTS];
7:                 extern fractional pots_scaled[POTS];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                void processAudio(fractional *source, fractional *destination){
008B08  4787E4     ADD W15, #0x4, W15
008B0A  BE9F88     MOV.D W8, [W15++]
008B0C  BE9F8A     MOV.D W10, [W15++]
008B0E  BE9F8C     MOV.D W12, [W15++]
008B10  781F8E     MOV W14, [W15++]
008B12  F80022     PUSH ACCA
008B14  F80024     PUSH ACCAH
008B16  F80026     PUSH ACCAU
008B18  BE0400     MOV.D W0, W8
008B20  2FE002     MOV #0xFE00, W2
008B22  410108     ADD W2, W8, W2
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    volatile fractional sample;
38:                    int counter=(STREAMBUF-1);
39:                    
40:                    runFX(source, source);
008B1A  780088     MOV W8, W1
008B1C  780008     MOV W8, W0
008B1E  07FF61     RCALL runFX
41:                    
42:                
43:                    for(; counter>=0; counter--){
008BEA  540F82     SUB W8, W2, [W15]
008BEC  3AFFA3     BRA NZ, 0x8B34
44:                        sample=*source--; //!rw
008B34  780028     MOV [W8--], W0
008B36  9FB7D0     MOV W0, [W15-22]
45:                
46:                        if(kick_playing==TRUE&&kick_ptr<kick_max){
008B38  BFD02E     MOV.B kick_playing, WREG
008B3A  404FE1     ADD.B W0, #0x1, [W15]
008B3C  3A0011     BRA NZ, 0x8B60
008B3E  8789D4     MOV 0xF13A, W4
008B40  808187     MOV kick_ptr, W7
008B42  538F84     SUB W7, W4, [W15]
008B44  31000D     BRA C, 0x8B60
47:                            result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
008B26  27332E     MOV #0x7332, W14
008B46  97B3DF     MOV [W15-22], W7
008B48  78020E     MOV W14, W4
008B4A  C20113     MPY W4*W7, A
48:                            result1 = __builtin_add(result1,kick[kick_ptr++],0);
008B28  2C5DAD     MOV #0xC5DA, W13
008B4C  808180     MOV kick_ptr, W0
008B4E  400200     ADD W0, W0, W4
008B50  468204     ADD W13, W4, W4
008B52  780214     MOV [W4], W4
008B54  E80000     INC W0, W0
008B56  888180     MOV W0, kick_ptr
008B58  C90004     ADD W4, A
49:                            sample=__builtin_sac(result1, 0);
008B5A  CC0007     SAC A, W7
008B5C  9FB7D7     MOV W7, [W15-22]
008B5E  37000A     BRA 0x8B74
50:                        }
51:                        else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
008B24  268B65     MOV #0x68B6, W5
008B60  B3C01B     MOV.B #0x1, W11
008B62  15CF95     SUBR.B W11, [W5], [W15]
008B64  3A0007     BRA NZ, 0x8B74
008B66  404FE1     ADD.B W0, #0x1, [W15]
008B68  3A0005     BRA NZ, 0x8B74
008B6A  8789D0     MOV 0xF13A, W0
008B6C  E31030     CP kick_ptr
008B6E  3A0002     BRA NZ, 0x8B74
52:                            kick_playing=FALSE;
008B70  EF702E     CLR.B kick_playing
53:                            kick_ptr=0;
008B72  EF3030     CLR kick_ptr
54:                        }
55:                        /*
56:                        if(hat_playing==TRUE&&hat_ptr<hat_max){
57:                            result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
58:                            result1 = __builtin_add(result1,hat[hat_ptr++],0);
59:                            sample=__builtin_sac(result1, 0);
60:                        }
61:                        else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
62:                            hat_playing=FALSE;
63:                            hat_ptr=0;
64:                        }
65:                         */
66:                
67:                        if(snare_playing==TRUE&&snare_ptr<snare_max){
008B74  BFD032     MOV.B snare_playing, WREG
008B76  404FE1     ADD.B W0, #0x1, [W15]
008B78  3A0012     BRA NZ, 0x8B9E
008B7A  8789E4     MOV 0xF13C, W4
008B7C  8081A7     MOV snare_ptr, W7
008B7E  538F84     SUB W7, W4, [W15]
008B80  31000E     BRA C, 0x8B9E
68:                            result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
008B2C  26CCCC     MOV #0x6CCC, W12
008B82  97B3DF     MOV [W15-22], W7
008B84  78020C     MOV W12, W4
008B86  C20113     MPY W4*W7, A
69:                            result1 = __builtin_add(result1,snare[snare_ptr++],0);
008B88  8081A0     MOV snare_ptr, W0
008B8A  400200     ADD W0, W0, W4
008B8C  295027     MOV #0x9502, W7
008B8E  438204     ADD W7, W4, W4
008B90  780214     MOV [W4], W4
008B92  E80000     INC W0, W0
008B94  8881A0     MOV W0, snare_ptr
008B96  C90004     ADD W4, A
70:                            sample=__builtin_sac(result1, 0);
008B98  CC000B     SAC A, W11
008B9A  9FB7DB     MOV W11, [W15-22]
008B9C  37000A     BRA 0x8BB2
71:                        }
72:                        else if (pad[1]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
008B2A  E80185     INC W5, W3
008B9E  B3C014     MOV.B #0x1, W4
008BA0  124F93     SUBR.B W4, [W3], [W15]
008BA2  3A0007     BRA NZ, 0x8BB2
008BA4  404FE1     ADD.B W0, #0x1, [W15]
008BA6  3A0005     BRA NZ, 0x8BB2
008BA8  8789E0     MOV 0xF13C, W0
008BAA  E31034     CP snare_ptr
008BAC  3A0002     BRA NZ, 0x8BB2
73:                            snare_playing=FALSE;
008BAE  EF7032     CLR.B snare_playing
74:                            snare_ptr=0;
008BB0  EF3034     CLR snare_ptr
75:                        }
76:                
77:                
78:                        if (TEST_SIN==TRUE){
008BB2  BFD01A     MOV.B TEST_SIN, WREG
008BB4  404FE1     ADD.B W0, #0x1, [W15]
008BB6  3A000B     BRA NZ, 0x8BCE
79:                            i++;
008BB8  EC1010     INC i, WREG
008BBA  888080     MOV W0, i
80:                            if(i==1024)
008B2E  20400A     MOV #0x400, W10
008BBC  500F8A     SUB W0, W10, [W15]
008BBE  3A0001     BRA NZ, 0x8BC2
81:                                i=0;
008BC0  EF3010     CLR i
82:                            sample=sintab[i];
008BC2  808080     MOV i, W0
008BC4  400000     ADD W0, W0, W0
008BC6  2F1407     MOV #0xF140, W7
008BC8  438000     ADD W7, W0, W0
008BCA  780010     MOV [W0], W0
008BCC  9FB7D0     MOV W0, [W15-22]
83:                        }
84:                
85:                        //VOLUME CONTROL
86:                        if(pots[POT_VOLUME]==0x0007)
008B30  2607C1     MOV #0x607C, W1
008BCE  780211     MOV [W1], W4
008BD0  520FE7     SUB W4, #0x7, [W15]
008BD2  3A0003     BRA NZ, 0x8BDA
87:                            sample=0;
008BD4  EB0580     CLR W11
008BD6  9FB7DB     MOV W11, [W15-22]
008BD8  370006     BRA 0x8BE6
88:                        else if(pots[POT_VOLUME]>=0x7FF7);
008B32  27FF66     MOV #0x7FF6, W6
008BDA  520F86     SUB W4, W6, [W15]
008BDC  3C0004     BRA GT, 0x8BE6
89:                        else{
90:                            result1 =__builtin_mpy(sample,pots[POT_VOLUME], NULL, NULL, 0, NULL, NULL, 0);
008BDE  97B3DF     MOV [W15-22], W7
008BE0  C20113     MPY W4*W7, A
91:                            sample=__builtin_sac(result1, 0);
008BE2  CC000B     SAC A, W11
008BE4  9FB7DB     MOV W11, [W15-22]
92:                        }
93:                        
94:                        //return sample;
95:                        *destination--=sample; //rw
008BE6  97B05F     MOV [W15-22], W0
008BE8  781480     MOV W0, [W9--]
96:                    }
97:                }
008BEE  F90026     POP ACCAU
008BF0  F90024     POP ACCAH
008BF2  F90022     POP ACCA
008BF4  78074F     MOV [--W15], W14
008BF6  BE064F     MOV.D [--W15], W12
008BF8  BE054F     MOV.D [--W15], W10
008BFA  BE044F     MOV.D [--W15], W8
008BFC  B1004F     SUB #0x4, W15
008BFE  060000     RETURN
98:                
99:                void runFX(fractional *source, fractional *destination){
0089E2  FA0002     LNK #0x2
0089E4  BE9F88     MOV.D W8, [W15++]
0089E6  BE9F8A     MOV.D W10, [W15++]
0089E8  BE9F8C     MOV.D W12, [W15++]
0089EA  F80022     PUSH ACCA
0089EC  F80024     PUSH ACCAH
0089EE  F80026     PUSH ACCAU
0089F0  F80028     PUSH ACCB
0089F2  F8002A     PUSH ACCBH
0089F4  F8002C     PUSH ACCBU
0089F6  2FE003     MOV #0xFE00, W3
0089F8  418180     ADD W3, W0, W3
100:                   volatile register int result1 asm("A");
101:                   volatile register int result2 asm("B");
102:                   static fractional delayed_sample;
103:                   static fractional trem_mod; 
104:                   volatile fractional sample;
105:                   
106:                   
107:                   int *readPTR=source;
108:                   int *rewritePTR=destination;
109:                   
110:                   
111:                   int counter=(STREAMBUF-1);
112:                   for(; counter>=0; counter--){
008AEE  500F83     SUB W0, W3, [W15]
008AF0  3AFF8B     BRA NZ, 0x8A08
113:                       sample=*readPTR--; //!rw
008A08  780120     MOV [W0--], W2
008A0A  9FB7B2     MOV W2, [W15-26]
114:               
115:                       if(tremelo==TRUE){                                                          //TREMELO//
008A0C  2101B2     MOV #0x101B, W2
008A0E  784112     MOV.B [W2], W2
008A10  414FE1     ADD.B W2, #0x1, [W15]
008A12  3A002B     BRA NZ, 0x8A6A
116:                           if (trem_var<=pots[3]){
0089FA  26074D     MOV #0x6074, W13
008A14  808042     MOV trem_var, W2
008A16  110F9D     SUBR W2, [W13], [W15]
008A18  390012     BRA NC, 0x8A3E
117:                               trem_var++;
008A1A  E80102     INC W2, W2
008A1C  888042     MOV W2, trem_var
118:                               result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
008A1E  808022     MOV tremelo_ptr, W2
008A20  410102     ADD W2, W2, W2
008A22  440102     ADD W8, W2, W2
008A24  780592     MOV [W2], W11
008A26  808226     MOV 0x1044, W6
008A28  78038B     MOV W11, W7
008A2A  C60113     MPY W6*W7, A
119:                               trem_mod=__builtin_sac(result1, 0);
008A2C  CC0002     SAC A, W2
008A2E  888062     MOV W2, trem_mod
120:                               result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008A30  97B5BF     MOV [W15-26], W11
008A32  780302     MOV W2, W6
008A34  78038B     MOV W11, W7
008A36  C68113     MPY W6*W7, B
121:                               sample=__builtin_sac(result2, 0);
008A38  CC8002     SAC B, W2
008A3A  9FB7B2     MOV W2, [W15-26]
008A3C  370016     BRA 0x8A6A
122:                           }
123:                           else{
124:                               trem_var=0;
0089FC  EB0600     CLR W12
008A3E  88804C     MOV W12, trem_var
125:                               if(tremelo_ptr==1024)
0089FE  204009     MOV #0x400, W9
008A40  808026     MOV tremelo_ptr, W6
008A42  530F89     SUB W6, W9, [W15]
008A44  3A0001     BRA NZ, 0x8A48
126:                                   tremelo_ptr=0;
008A46  88802C     MOV W12, tremelo_ptr
127:                               result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
008A00  2F1408     MOV #0xF140, W8
008A48  808022     MOV tremelo_ptr, W2
008A4A  410582     ADD W2, W2, W11
008A4C  44058B     ADD W8, W11, W11
008A4E  78059B     MOV [W11], W11
008A50  E80102     INC W2, W2
008A52  888022     MOV W2, tremelo_ptr
008A54  808227     MOV 0x1044, W7
008A56  78030B     MOV W11, W6
008A58  C60113     MPY W6*W7, A
128:                               trem_mod=__builtin_sac(result1, 0);
008A5A  CC0002     SAC A, W2
008A5C  888062     MOV W2, trem_mod
129:                               result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008A5E  97B5BF     MOV [W15-26], W11
008A60  780382     MOV W2, W7
008A62  78030B     MOV W11, W6
008A64  C68113     MPY W6*W7, B
130:                               sample=__builtin_sac(result2, 0);
008A66  CC8007     SAC B, W7
008A68  9FB7B7     MOV W7, [W15-26]
131:                           }
132:                       }
133:                       if(looper==TRUE){                           //LOOPER// 
008A6A  2101C2     MOV #0x101C, W2
008A6C  784112     MOV.B [W2], W2
008A6E  414FE1     ADD.B W2, #0x1, [W15]
008A70  3A0019     BRA NZ, 0x8AA4
134:                           if(loop_lim>=LOOP_BUF_SIZE)
008A72  808012     MOV loop_lim, W2
008A74  510F84     SUB W2, W4, [W15]
008A76  360001     BRA LEU, 0x8A7A
135:                               loop_lim=LOOP_BUF_SIZE;
008A06  22710A     MOV #0x2710, W10
008A78  88801A     MOV W10, loop_lim
136:                           if(loop_ptr<loop_lim){
008A7A  808012     MOV loop_lim, W2
008A7C  808006     MOV loop_ptr, W6
008A7E  530F82     SUB W6, W2, [W15]
008A80  310008     BRA C, 0x8A92
137:                               sample = (loop[loop_ptr++]);
008A82  808002     MOV loop_ptr, W2
008A84  410582     ADD W2, W2, W11
008A86  42858B     ADD W5, W11, W11
008A88  78059B     MOV [W11], W11
008A8A  9FB7BB     MOV W11, [W15-26]
008A8C  E80102     INC W2, W2
008A8E  888002     MOV W2, loop_ptr
008A90  37001C     BRA 0x8ACA
138:                           }
139:                           else {
140:                               loop_ptr=0;
008A92  88800C     MOV W12, loop_ptr
141:                               sample = (loop[loop_ptr++]);
008A94  808002     MOV loop_ptr, W2
008A96  410582     ADD W2, W2, W11
008A98  42858B     ADD W5, W11, W11
008A9A  78059B     MOV [W11], W11
008A9C  9FB7BB     MOV W11, [W15-26]
008A9E  E80102     INC W2, W2
008AA0  888002     MOV W2, loop_ptr
008AA2  370013     BRA 0x8ACA
142:                           }
143:                       }                                                                           
144:                       else {                                      //buffer
145:                           if(loop_ptr<LOOP_BUF_SIZE)
008A02  2270F4     MOV #0x270F, W4
008AA4  808007     MOV loop_ptr, W7
008AA6  538F84     SUB W7, W4, [W15]
008AA8  3E0008     BRA GTU, 0x8ABA
146:                               loop[loop_ptr++]=sample;
008AAA  808002     MOV loop_ptr, W2
008AAC  410582     ADD W2, W2, W11
008AAE  42858B     ADD W5, W11, W11
008AB0  97B33F     MOV [W15-26], W6
008AB2  780D86     MOV W6, [W11]
008AB4  E80102     INC W2, W2
008AB6  888002     MOV W2, loop_ptr
008AB8  370008     BRA 0x8ACA
147:                           else {
148:                               loop_ptr=0;
008ABA  88800C     MOV W12, loop_ptr
149:                               loop[loop_ptr++]=sample;
008A04  2104E5     MOV #0x104E, W5
008ABC  808002     MOV loop_ptr, W2
008ABE  410582     ADD W2, W2, W11
008AC0  42858B     ADD W5, W11, W11
008AC2  97B3BF     MOV [W15-26], W7
008AC4  780D87     MOV W7, [W11]
008AC6  E80102     INC W2, W2
008AC8  888002     MOV W2, loop_ptr
150:                           }
151:                       }
152:               
153:                       //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
154:                       if(lpf==TRUE){
008ACA  2101D2     MOV #0x101D, W2
008ACC  784112     MOV.B [W2], W2
008ACE  414FE1     ADD.B W2, #0x1, [W15]
008AD0  3A000C     BRA NZ, 0x8AEA
155:                           result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
008AD2  97B13F     MOV [W15-26], W2
008AD4  80820B     MOV 0x1040, W11
008AD6  780302     MOV W2, W6
008AD8  78038B     MOV W11, W7
008ADA  C68113     MPY W6*W7, B
156:                           result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
008ADC  808212     MOV 0x1042, W2
008ADE  808076     MOV delayed_sample, W6
008AE0  780382     MOV W2, W7
008AE2  C68112     MAC W6*W7, B
157:                           delayed_sample=__builtin_sac(result2, 0);
008AE4  CC8002     SAC B, W2
008AE6  888072     MOV W2, delayed_sample
158:                           sample=delayed_sample;
008AE8  9FB7B2     MOV W2, [W15-26]
159:                       }
160:                       
161:                       *rewritePTR--=sample; //rw
008AEA  97B13F     MOV [W15-26], W2
008AEC  781082     MOV W2, [W1--]
162:                   }
163:               }
008AF2  F9002C     POP ACCBU
008AF4  F9002A     POP ACCBH
008AF6  F90028     POP ACCB
008AF8  F90026     POP ACCAU
008AFA  F90024     POP ACCAH
008AFC  F90022     POP ACCA
008AFE  BE064F     MOV.D [--W15], W12
008B00  BE054F     MOV.D [--W15], W10
008B02  BE044F     MOV.D [--W15], W8
008B04  FA8000     ULNK
008B06  060000     RETURN
164:               
165:               //test
