Disassembly Listing for sampler_0.49.2
Generated From:
C:/Users/ryan/Documents/seniorproject/ps-040/dist/default/production/ps-040.production.elf
Jan 29, 2018 1:55:04 AM

---  C:/Users/ryan/Documents/seniorproject/ps-040/utilitites.c  -----------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <libpic30.h>
4:                 #include <dsp.h>
5:                 #include <stdio.h>
6:                 #include <stdlib.h>
7:                 #include <math.h>
8:                 #include "common.h"
9:                 #include "sounds.h"
10:                #include "audio.h"
11:                #include "flash.h"
12:                #include "screens.h"
13:                #include "utilities.h"
14:                #include "devInits.h"
15:                
16:                
17:                //CONTROL VARIABLES//
18:                extern unsigned char pad[BUTTONS];
19:                extern fractional pots[POTS];
20:                extern fractional pots_scaled[POTS];
21:                extern unsigned char UART_ON; 
22:                extern enum screen state;
23:                
24:                //STATUS VARIABLES//
25:                extern unsigned char hard_clipped;
26:                extern unsigned char UART_EN;
27:                extern unsigned int cycle;
28:                extern unsigned char TEST_SIN;
29:                extern fractional sampin;
30:                extern fractional sampout;
31:                
32:                //FX FLAGS & VARS
33:                extern unsigned char tremelo, looper, lpf;
34:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
35:                extern unsigned int loop_lim;
36:                extern fractional lpf_alpha, lpf_inv_alpha;
37:                extern fractional tremelo_depth;
38:                extern unsigned char kick_playing, snare_playing;   
39:                extern unsigned char frame;
40:                
41:                void scanButtons(void){
42:                    static unsigned char pad_last[BUTTONS]={1};
43:                    int portrdG, portrdD, portrdF;
44:                
45:                    portrdG = PORTG;
007DB2  807313     MOV PORTG, W3
46:                    portrdD = PORTD;
007DB4  807191     MOV PORTD, W1
47:                    portrdF = PORTF;
007DB6  807292     MOV PORTF, W2
48:                    
49:                    pad[34]=(portrdF>>7)&1;     // Special function button
007DB8  DE9247     ASR W2, #7, W4
007DBA  624261     AND.B W4, #0x1, W4
007DBC  260C85     MOV #0x60C8, W5
007DBE  784A84     MOV.B W4, [W5]
50:                    
51:                    if(pad[34]){
007DC0  320033     BRA Z, 0x7E28
52:                        pad[6]=(portrdF>>6)&1;
007DC2  DE92C6     ASR W2, #6, W5
007DC4  260AC4     MOV #0x60AC, W4
007DC6  62CA61     AND.B W5, #0x1, [W4]
53:                        pad[5]=(portrdF>>5)&1;
007DC8  DE92C5     ASR W2, #5, W5
007DCA  E90204     DEC W4, W4
007DCC  62CA61     AND.B W5, #0x1, [W4]
54:                        pad[4]=(portrdF>>4)&1;
007DCE  DE9144     ASR W2, #4, W2
007DD0  E90204     DEC W4, W4
007DD2  614A61     AND.B W2, #0x1, [W4]
55:                        pad[0]=(portrdG)&1;
007DD4  520164     SUB W4, #0x4, W2
007DD6  61C961     AND.B W3, #0x1, [W2]
56:                        pad[1]=(portrdG>>1)&1;
007DD8  D18203     ASR W3, W4
007DDA  E80102     INC W2, W2
007DDC  624961     AND.B W4, #0x1, [W2]
57:                        pad[2]=(portrdG>>2)&1;
007DDE  DE9A42     ASR W3, #2, W4
007DE0  E80102     INC W2, W2
007DE2  624961     AND.B W4, #0x1, [W2]
58:                        pad[3]=(portrdG>>3)&1;
007DE4  DE9A43     ASR W3, #3, W4
007DE6  E80102     INC W2, W2
007DE8  624961     AND.B W4, #0x1, [W2]
59:                        pad[16]=(portrdG>>10)&1;    // Encoder button
007DEA  DE9A4A     ASR W3, #10, W4
007DEC  41016D     ADD W2, #0xD, W2
007DEE  624961     AND.B W4, #0x1, [W2]
60:                        pad[11]=(portrdG>>11)&1;
007DF0  DE9A4B     ASR W3, #11, W4
007DF2  510165     SUB W2, #0x5, W2
007DF4  624961     AND.B W4, #0x1, [W2]
61:                        pad[12]=(portrdG>>12)&1;
007DF6  DE9A4C     ASR W3, #12, W4
007DF8  E80102     INC W2, W2
007DFA  624961     AND.B W4, #0x1, [W2]
62:                        pad[13]=(portrdG>>13)&1;
007DFC  DE9A4D     ASR W3, #13, W4
007DFE  E80102     INC W2, W2
007E00  624961     AND.B W4, #0x1, [W2]
63:                        pad[14]=(portrdG>>14)&1;
007E02  DE984E     ASR W3, #14, W0
007E04  E80102     INC W2, W2
007E06  604961     AND.B W0, #0x1, [W2]
64:                        pad[15]=(portrdG>>15)&1;
007E08  DE19CF     LSR W3, #15, W3
007E0A  E80002     INC W2, W0
007E0C  784803     MOV.B W3, [W0]
65:                        pad[7]=(portrdD>>1)&1;
007E0E  D18101     ASR W1, W2
007E10  500068     SUB W0, #0x8, W0
007E12  614861     AND.B W2, #0x1, [W0]
66:                        pad[8]=(portrdD>>2)&1;
007E14  DE8942     ASR W1, #2, W2
007E16  E80000     INC W0, W0
007E18  614861     AND.B W2, #0x1, [W0]
67:                        pad[9]=(portrdD>>3)&1;
007E1A  DE8943     ASR W1, #3, W2
007E1C  E80000     INC W0, W0
007E1E  614861     AND.B W2, #0x1, [W0]
68:                        pad[10]=(portrdD>>4)&1;
007E20  DE88C4     ASR W1, #4, W1
007E22  E80000     INC W0, W0
007E24  60C861     AND.B W1, #0x1, [W0]
007E26  370032     BRA 0x7E8C
69:                    } else {
70:                        pad[23]=(portrdF>>6)&1;
007E28  DE92C6     ASR W2, #6, W5
007E2A  260BD4     MOV #0x60BD, W4
007E2C  62CA61     AND.B W5, #0x1, [W4]
71:                        pad[22]=(portrdF>>5)&1;
007E2E  DE92C5     ASR W2, #5, W5
007E30  E90204     DEC W4, W4
007E32  62CA61     AND.B W5, #0x1, [W4]
72:                        pad[21]=(portrdF>>4)&1;
007E34  DE9144     ASR W2, #4, W2
007E36  E90204     DEC W4, W4
007E38  614A61     AND.B W2, #0x1, [W4]
73:                        pad[17]=(portrdG)&1;
007E3A  520164     SUB W4, #0x4, W2
007E3C  61C961     AND.B W3, #0x1, [W2]
74:                        pad[18]=(portrdG>>1)&1;
007E3E  D18203     ASR W3, W4
007E40  E80102     INC W2, W2
007E42  624961     AND.B W4, #0x1, [W2]
75:                        pad[19]=(portrdG>>2)&1;
007E44  DE9A42     ASR W3, #2, W4
007E46  E80102     INC W2, W2
007E48  624961     AND.B W4, #0x1, [W2]
76:                        pad[20]=(portrdG>>3)&1;
007E4A  DE9A43     ASR W3, #3, W4
007E4C  E80102     INC W2, W2
007E4E  624961     AND.B W4, #0x1, [W2]
77:                        pad[33]=(portrdG>>10)&1;    // Encoder button
007E50  DE9A4A     ASR W3, #10, W4
007E52  41016D     ADD W2, #0xD, W2
007E54  624961     AND.B W4, #0x1, [W2]
78:                        pad[28]=(portrdG>>11)&1;
007E56  DE9A4B     ASR W3, #11, W4
007E58  510165     SUB W2, #0x5, W2
007E5A  624961     AND.B W4, #0x1, [W2]
79:                        pad[29]=(portrdG>>12)&1;
007E5C  DE9A4C     ASR W3, #12, W4
007E5E  E80102     INC W2, W2
007E60  624961     AND.B W4, #0x1, [W2]
80:                        pad[30]=(portrdG>>13)&1;
007E62  DE9A4D     ASR W3, #13, W4
007E64  E80102     INC W2, W2
007E66  624961     AND.B W4, #0x1, [W2]
81:                        pad[31]=(portrdG>>14)&1;
007E68  DE984E     ASR W3, #14, W0
007E6A  E80102     INC W2, W2
007E6C  604961     AND.B W0, #0x1, [W2]
82:                        pad[32]=(portrdG>>15)&1;
007E6E  DE19CF     LSR W3, #15, W3
007E70  E80002     INC W2, W0
007E72  784803     MOV.B W3, [W0]
83:                        pad[24]=(portrdD>>1)&1;
007E74  D18101     ASR W1, W2
007E76  500068     SUB W0, #0x8, W0
007E78  614861     AND.B W2, #0x1, [W0]
84:                        pad[25]=(portrdD>>2)&1;
007E7A  DE8942     ASR W1, #2, W2
007E7C  E80000     INC W0, W0
007E7E  614861     AND.B W2, #0x1, [W0]
85:                        pad[26]=(portrdD>>3)&1;
007E80  DE8943     ASR W1, #3, W2
007E82  E80000     INC W0, W0
007E84  614861     AND.B W2, #0x1, [W0]
86:                        pad[27]=(portrdD>>4)&1;
007E86  DE88C4     ASR W1, #4, W1
007E88  E80000     INC W0, W0
007E8A  60C861     AND.B W1, #0x1, [W0]
87:                    }
88:                
89:                   
90:                    
91:                    if(pad[13]==0&&pad_last[13]==1){                                              //TREMELO CONTROL
007E8C  260B30     MOV #0x60B3, W0
007E8E  784010     MOV.B [W0], W0
007E90  E00400     CP0.B W0
007E92  3A000C     BRA NZ, 0x7EAC
007E94  26D611     MOV #0x6D61, W1
007E96  B3C012     MOV.B #0x1, W2
007E98  114F91     SUBR.B W2, [W1], [W15]
007E9A  3A0008     BRA NZ, 0x7EAC
92:                        pad_last[13]=0;
007E9C  780001     MOV W1, W0
007E9E  EB4800     CLR.B [W0]
93:                        if(tremelo==FALSE)
007EA0  E2500D     CP0.B tremelo
007EA2  3A0002     BRA NZ, 0x7EA8
94:                            tremelo=TRUE;
007EA4  EFF00D     SETM.B tremelo
007EA6  370004     BRA 0x7EB0
95:                        else tremelo=FALSE;
007EA8  EF700D     CLR.B tremelo
007EAA  370002     BRA 0x7EB0
96:                    }
97:                    else{
98:                        pad_last[13]=pad[13];
007EAC  26D611     MOV #0x6D61, W1
007EAE  784880     MOV.B W0, [W1]
99:                    }
100:                   
101:                   if(pad[14]==0) looper=TRUE;
007EB0  260B40     MOV #0x60B4, W0
007EB2  E00410     CP0.B [W0]
007EB4  3A0002     BRA NZ, 0x7EBA
007EB6  EFF00E     SETM.B looper
007EB8  370001     BRA 0x7EBC
102:                   else looper=FALSE;
007EBA  EF700E     CLR.B looper
103:                  
104:                   if(pad[15]==0&&pad_last[15]==1){                                              //LPF CONTROL
007EBC  260B50     MOV #0x60B5, W0
007EBE  784010     MOV.B [W0], W0
007EC0  E00400     CP0.B W0
007EC2  3A000C     BRA NZ, 0x7EDC
007EC4  26D631     MOV #0x6D63, W1
007EC6  B3C012     MOV.B #0x1, W2
007EC8  114F91     SUBR.B W2, [W1], [W15]
007ECA  3A0008     BRA NZ, 0x7EDC
105:                       pad_last[15]=0;
007ECC  780001     MOV W1, W0
007ECE  EB4800     CLR.B [W0]
106:                       if(lpf==FALSE)
007ED0  E2500F     CP0.B lpf
007ED2  3A0002     BRA NZ, 0x7ED8
107:                           lpf=TRUE;
007ED4  EFF00F     SETM.B lpf
007ED6  370004     BRA 0x7EE0
108:                       else lpf=FALSE;
007ED8  EF700F     CLR.B lpf
007EDA  370002     BRA 0x7EE0
109:                   }
110:                   else{
111:                       pad_last[15]=pad[15];
007EDC  26D631     MOV #0x6D63, W1
007EDE  784880     MOV.B W0, [W1]
112:                   }
113:                   
114:                   
115:                   // SAMPLE TRIGGERS 
116:                   if(pad[0]==0&&kick_playing==FALSE){                                         //kick
007EE0  260A60     MOV #0x60A6, W0
007EE2  E00410     CP0.B [W0]
007EE4  3A0003     BRA NZ, 0x7EEC
007EE6  E25038     CP0.B kick_playing
007EE8  3A0001     BRA NZ, 0x7EEC
117:                       kick_playing=TRUE;
007EEA  EFF038     SETM.B kick_playing
118:                   }
119:                   /*
120:                   if(pad[2]==0&&hat_playing==FALSE){                                          //hat
121:                       hat_playing=TRUE;
122:                   }
123:                   */
124:                   if(pad[1]==0&&snare_playing==FALSE){                                        //snare
007EEC  260A70     MOV #0x60A7, W0
007EEE  E00410     CP0.B [W0]
007EF0  3A0003     BRA NZ, 0x7EF8
007EF2  E2503C     CP0.B snare_playing
007EF4  3A0001     BRA NZ, 0x7EF8
125:                       snare_playing=TRUE;
007EF6  EFF03C     SETM.B snare_playing
126:                   }
127:               }
007EF8  060000     RETURN
128:               
129:               void readPots(void){
007EFA  F80022     PUSH ACCA
007EFC  F80024     PUSH ACCAH
007EFE  F80026     PUSH ACCAU
130:                   volatile register int scaled asm("A");
131:                   _AD1IF = 0; // Clear conversion done status bit
007F00  A9A801     BCLR 0x801, #5
132:                   
133:                   if(pad[34]){
007F02  260C80     MOV #0x60C8, W0
007F04  E00410     CP0.B [W0]
007F06  320019     BRA Z, 0x7F3A
134:                       pots[0]=(ADC1BUF0>>1)|0x7;
007F08  801801     MOV ADC1BUF0, W1
007F0A  D10081     LSR W1, W1
007F0C  25E760     MOV #0x5E76, W0
007F0E  708867     IOR W1, #0x7, [W0]
135:                       pots[1]=(ADC1BUF1>>1)|0x7;
007F10  801811     MOV ADC1BUF1, W1
007F12  D10081     LSR W1, W1
007F14  E88000     INC2 W0, W0
007F16  708867     IOR W1, #0x7, [W0]
136:                       pots[2]=(ADC1BUF2>>1)|0x7;
007F18  801821     MOV ADC1BUF2, W1
007F1A  D10081     LSR W1, W1
007F1C  E88000     INC2 W0, W0
007F1E  708867     IOR W1, #0x7, [W0]
137:                       pots[3]=(ADC1BUF3>>1)|0x7;
007F20  801831     MOV ADC1BUF3, W1
007F22  D10081     LSR W1, W1
007F24  E88000     INC2 W0, W0
007F26  708867     IOR W1, #0x7, [W0]
138:                       pots[4]=(ADC1BUF4>>1)|0x7;
007F28  801841     MOV ADC1BUF4, W1
007F2A  D10081     LSR W1, W1
007F2C  E88000     INC2 W0, W0
007F2E  708867     IOR W1, #0x7, [W0]
139:                       pots[5]=(ADC1BUF5>>1)|0x7;
007F30  801851     MOV ADC1BUF5, W1
007F32  D10081     LSR W1, W1
007F34  E88000     INC2 W0, W0
007F36  708867     IOR W1, #0x7, [W0]
007F38  370018     BRA 0x7F6A
140:                   } else {
141:                       pots[6]=(ADC1BUF0>>1)|0x7;
007F3A  801801     MOV ADC1BUF0, W1
007F3C  D10081     LSR W1, W1
007F3E  25E820     MOV #0x5E82, W0
007F40  708867     IOR W1, #0x7, [W0]
142:                       pots[7]=(ADC1BUF1>>1)|0x7;
007F42  801811     MOV ADC1BUF1, W1
007F44  D10081     LSR W1, W1
007F46  E88000     INC2 W0, W0
007F48  708867     IOR W1, #0x7, [W0]
143:                       pots[8]=(ADC1BUF2>>1)|0x7;
007F4A  801821     MOV ADC1BUF2, W1
007F4C  D10081     LSR W1, W1
007F4E  E88000     INC2 W0, W0
007F50  708867     IOR W1, #0x7, [W0]
144:                       pots[9]=(ADC1BUF3>>1)|0x7;
007F52  801831     MOV ADC1BUF3, W1
007F54  D10081     LSR W1, W1
007F56  E88000     INC2 W0, W0
007F58  708867     IOR W1, #0x7, [W0]
145:                       pots[10]=(ADC1BUF4>>1)|0x7;
007F5A  801841     MOV ADC1BUF4, W1
007F5C  D10081     LSR W1, W1
007F5E  E88000     INC2 W0, W0
007F60  708867     IOR W1, #0x7, [W0]
146:                       pots[11]=(ADC1BUF5>>1)|0x7;
007F62  801851     MOV ADC1BUF5, W1
007F64  D10081     LSR W1, W1
007F66  E88000     INC2 W0, W0
007F68  708867     IOR W1, #0x7, [W0]
147:                   }
148:                   
149:                   loop_lim=pots_scaled[5];               //LOOPER CONTROL
007F6A  82F4C0     MOV 0x5E98, W0
007F6C  8880D0     MOV W0, loop_lim
150:                   if(pots[0]>=310){                      //LPF CONTROL
007F6E  82F3B0     MOV pots, W0
007F70  201351     MOV #0x135, W1
007F72  500F81     SUB W0, W1, [W15]
007F74  340004     BRA LE, 0x7F7E
151:                       lpf_alpha=pots[0];
007F76  888250     MOV W0, divtestb
152:                       lpf_inv_alpha=(32767-lpf_alpha); 
007F78  27FFF1     MOV #0x7FFF, W1
007F7A  508000     SUB W1, W0, W0
007F7C  888260     MOV W0, 0x104C
153:                   }
154:                   tremelo_depth=pots[1];
007F7E  82F3C5     MOV 0x5E78, W5
007F80  888275     MOV W5, 0x104E
155:                   
156:                   scaled=__builtin_mpy(pots[5],Q15(0.33), NULL, NULL, 0, NULL, NULL, 0);
007F82  82F404     MOV 0x5E80, W4
007F84  22A3D5     MOV #0x2A3D, W5
007F86  C00113     MPY W4*W5, A
157:                   pots_scaled[5]=__builtin_sac(scaled, 0);
007F88  25E980     MOV #0x5E98, W0
007F8A  CC0010     SAC A, [W0]
158:               }
007F8C  F90026     POP ACCAU
007F8E  F90024     POP ACCAH
007F90  F90022     POP ACCA
007F92  060000     RETURN
159:               
160:               void display(void){
161:                   IFS0bits.SPI1IF=0;
007F94  A94801     BCLR 0x801, #2
162:                   SPI1STATbits.SPIROV = 0;
007F96  A9C240     BCLR SPI1STAT, #6
163:                  
164:                   // Update ui state logic here
165:                   state = (ENCODERCNTL/4)+1;
007F98  800E30     MOV POS1CNTL, W0
007F9A  DE0042     LSR W0, #2, W0
007F9C  E80000     INC W0, W0
007F9E  888240     MOV W0, 0x1048
166:                   
167:                   // Update screen here
168:                   screenUpdate();
007FA0  0701B8     RCALL screenUpdate
169:                  
170:                  if(UART_ON==TRUE){
007FA2  BFD00B     MOV.B UART_ON, WREG
007FA4  404FE1     ADD.B W0, #0x1, [W15]
007FA6  3A0007     BRA NZ, 0x7FB6
171:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
172:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
173:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
174:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
007FA8  F85E7A     PUSH 0x5E7A
007FAA  F85E78     PUSH 0x5E78
007FAC  F85E76     PUSH pots
007FAE  2F6FE0     MOV #0xF6FE, W0
007FB0  781F80     MOV W0, [W15++]
007FB2  07C286     RCALL __printf_cdnopuxX
007FB4  5787E8     SUB W15, #0x8, W15
175:                       //printf("%d\r\n", sample);  //check input ADC
176:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
177:                   }
178:                  
179:                  SLED=~SLED;
007FB6  8072A0     MOV LATF, W0
007FB8  EA8000     COM W0, W0
007FBA  600061     AND W0, #0x1, W0
007FBC  8072A1     MOV LATF, W1
007FBE  A10001     BCLR W1, #0
007FC0  700081     IOR W0, W1, W1
007FC2  8872A1     MOV W1, LATF
180:               }
007FC4  060000     RETURN
181:               
182:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
183:                   /* This procedure loops back the received data to the*/
184:                   /* the codec output. The user application could process*/
185:                   /* this data as per application requirements.*/
186:                   int index;
187:                   for(index = 0;index < STREAMBUF;index ++)
007FC6  EB0100     CLR W2
007FC8  201003     MOV #0x100, W3
007FCC  E80102     INC W2, W2
007FCE  510F83     SUB W2, W3, [W15]
007FD0  3AFFFC     BRA NZ, 0x7FCA
188:                   {
189:                       targetBuffer[index] = sourceBuffer[index];
007FCA  7818B0     MOV [W0++], [W1++]
190:                   }
191:               }
007FD2  060000     RETURN
192:               
193:               //A blocking delay function. Not very accurate but good enough.
194:               void Delay_us(unsigned int delay)
195:               {
196:                   int i;
197:                   for (i = 0; i < delay; i++)
007FD4  E00000     CP0 W0
007FD6  320006     BRA Z, 0x7FE4
007FD8  EB0080     CLR W1
007FDE  E80081     INC W1, W1
007FE0  500F81     SUB W0, W1, [W15]
007FE2  3EFFFB     BRA GTU, 0x7FDA
198:                   {
199:                       __asm__ volatile ("repeat #50");
007FDA  090032     REPEAT #0x32
200:                       __asm__ volatile ("nop");
007FDC  000000     NOP
201:                   }
202:               }
007FE4  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/screens.c  --------------------------------------------
1:                 /*
2:                  * File:   screens.c
3:                  * Author: ryan
4:                  *
5:                  * Created on January 28, 2018, 11:17 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "common.h"
11:                #include "plcd.h"
12:                #include "dsp.h"
13:                #include "flash.h"
14:                
15:                extern unsigned char TEST_SIN;
16:                extern fractional pots[POTS];
17:                extern enum screen state, laststate;
18:                extern char flash_readback[512];
19:                
20:                void screenDebugAudio(){
21:                
22:                }
008196  060000     RETURN
23:                
24:                void screenDebugPots(void){
25:                    if(state!=laststate){
008198  808090     MOV laststate, W0
00819A  E31048     CP 0x1048
00819C  32002D     BRA Z, 0x81F8
26:                        // Setup here
27:                        lcdClearQ();
00819E  07FC99     RCALL lcdClearQ
28:                        lcdSetCursorQ(0,0);
0081A0  EB4080     CLR.B W1
0081A2  784001     MOV.B W1, W0
0081A4  07FCA1     RCALL lcdSetCursorQ
29:                        lcdWriteStringQ("1:");
0081A6  2F6D20     MOV #0xF6D2, W0
0081A8  07FCB3     RCALL lcdWriteStringQ
30:                        lcdSetCursorQ(8,0);
0081AA  EB4080     CLR.B W1
0081AC  B3C080     MOV.B #0x8, W0
0081AE  07FC9C     RCALL lcdSetCursorQ
31:                        lcdWriteStringQ("2:");
0081B0  2F6D50     MOV #0xF6D5, W0
0081B2  07FCAE     RCALL lcdWriteStringQ
32:                        lcdSetCursorQ(0,1);
0081B4  B3C011     MOV.B #0x1, W1
0081B6  EB4000     CLR.B W0
0081B8  07FC97     RCALL lcdSetCursorQ
33:                        lcdWriteStringQ("3:");
0081BA  2F6D80     MOV #0xF6D8, W0
0081BC  07FCA9     RCALL lcdWriteStringQ
34:                        lcdSetCursorQ(8,1);
0081BE  B3C011     MOV.B #0x1, W1
0081C0  B3C080     MOV.B #0x8, W0
0081C2  07FC92     RCALL lcdSetCursorQ
35:                        lcdWriteStringQ("4:");
0081C4  2F6DB0     MOV #0xF6DB, W0
0081C6  07FCA4     RCALL lcdWriteStringQ
36:                        lcdSetCursorQ(0,2);
0081C8  B3C021     MOV.B #0x2, W1
0081CA  EB4000     CLR.B W0
0081CC  07FC8D     RCALL lcdSetCursorQ
37:                        lcdWriteStringQ("5:");
0081CE  2F6DE0     MOV #0xF6DE, W0
0081D0  07FC9F     RCALL lcdWriteStringQ
38:                        lcdSetCursorQ(8,2);
0081D2  B3C021     MOV.B #0x2, W1
0081D4  B3C080     MOV.B #0x8, W0
0081D6  07FC88     RCALL lcdSetCursorQ
39:                        lcdWriteStringQ("6:");
0081D8  2F6E10     MOV #0xF6E1, W0
0081DA  07FC9A     RCALL lcdWriteStringQ
40:                        lcdSetCursorQ(11,3);
0081DC  B3C031     MOV.B #0x3, W1
0081DE  B3C0B0     MOV.B #0xB, W0
0081E0  07FC83     RCALL lcdSetCursorQ
41:                        if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
0081E2  BFD00C     MOV.B TEST_SIN, WREG
0081E4  404FE1     ADD.B W0, #0x1, [W15]
0081E6  3A0003     BRA NZ, 0x81EE
0081E8  2F6E40     MOV #0xF6E4, W0
0081EA  07FC92     RCALL lcdWriteStringQ
0081EC  370002     BRA 0x81F2
42:                        else lcdWriteStringQ("THRU");  
0081EE  2F6E90     MOV #0xF6E9, W0
0081F0  07FC8F     RCALL lcdWriteStringQ
43:                        lcdDrawPads(16);
0081F2  B3C100     MOV.B #0x10, W0
0081F4  07FCE0     RCALL lcdDrawPads
0081F6  37002B     BRA 0x824E
44:                    } else {
45:                        // Update here
46:                        lcdSetCursorQ(2,0);
0081F8  EB4080     CLR.B W1
0081FA  B3C020     MOV.B #0x2, W0
0081FC  07FC75     RCALL lcdSetCursorQ
47:                        lcdWriteWordQ(pots[0]);
0081FE  82F3B0     MOV pots, W0
008200  07FC97     RCALL lcdWriteWordQ
48:                        lcdSetCursorQ(10,0);
008202  EB4080     CLR.B W1
008204  B3C0A0     MOV.B #0xA, W0
008206  07FC70     RCALL lcdSetCursorQ
49:                        lcdWriteWordQ(pots[1]);
008208  82F3C0     MOV 0x5E78, W0
00820A  07FC92     RCALL lcdWriteWordQ
50:                        lcdSetCursorQ(2,1);
00820C  B3C011     MOV.B #0x1, W1
00820E  B3C020     MOV.B #0x2, W0
008210  07FC6B     RCALL lcdSetCursorQ
51:                        lcdWriteWordQ(pots[2]);
008212  82F3D0     MOV 0x5E7A, W0
008214  07FC8D     RCALL lcdWriteWordQ
52:                        lcdSetCursorQ(10,1);
008216  B3C011     MOV.B #0x1, W1
008218  B3C0A0     MOV.B #0xA, W0
00821A  07FC66     RCALL lcdSetCursorQ
53:                        lcdWriteWordQ(pots[3]);
00821C  82F3E0     MOV 0x5E7C, W0
00821E  07FC88     RCALL lcdWriteWordQ
54:                        lcdSetCursorQ(2,2);
008220  B3C021     MOV.B #0x2, W1
008222  784001     MOV.B W1, W0
008224  07FC61     RCALL lcdSetCursorQ
55:                        lcdWriteWordQ(pots[4]);
008226  82F3F0     MOV 0x5E7E, W0
008228  07FC83     RCALL lcdWriteWordQ
56:                        lcdSetCursorQ(10,2);
00822A  B3C021     MOV.B #0x2, W1
00822C  B3C0A0     MOV.B #0xA, W0
00822E  07FC5C     RCALL lcdSetCursorQ
57:                        lcdWriteWordQ(pots[5]);
008230  82F400     MOV 0x5E80, W0
008232  07FC7E     RCALL lcdWriteWordQ
58:                        lcdSetCursorQ(11,3);
008234  B3C031     MOV.B #0x3, W1
008236  B3C0B0     MOV.B #0xB, W0
008238  07FC57     RCALL lcdSetCursorQ
59:                        if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
00823A  BFD00C     MOV.B TEST_SIN, WREG
00823C  404FE1     ADD.B W0, #0x1, [W15]
00823E  3A0003     BRA NZ, 0x8246
008240  2F6E40     MOV #0xF6E4, W0
008242  07FC66     RCALL lcdWriteStringQ
008244  370002     BRA 0x824A
60:                        else lcdWriteStringQ("THRU");
008246  2F6E90     MOV #0xF6E9, W0
008248  07FC63     RCALL lcdWriteStringQ
61:                        lcdDrawPads(16);
00824A  B3C100     MOV.B #0x10, W0
00824C  07FCB4     RCALL lcdDrawPads
62:                    }
63:                }
00824E  060000     RETURN
64:                
65:                void screenFX(void){
66:                    if(state!=laststate){
008250  808090     MOV laststate, W0
008252  E31048     CP 0x1048
008254  32000C     BRA Z, 0x826E
67:                        //setup here
68:                        lcdClearQ();
008256  07FC3D     RCALL lcdClearQ
69:                        lcdSetCursorQ(0,0);
008258  EB4080     CLR.B W1
00825A  784001     MOV.B W1, W0
00825C  07FC45     RCALL lcdSetCursorQ
70:                        lcdWriteStringQ("FX1:");
00825E  2F6EE0     MOV #0xF6EE, W0
008260  07FC57     RCALL lcdWriteStringQ
71:                        lcdSetCursorQ(10,0);
008262  EB4080     CLR.B W1
008264  B3C0A0     MOV.B #0xA, W0
008266  07FC40     RCALL lcdSetCursorQ
72:                        lcdWriteStringQ("FX2:");
008268  2F6F30     MOV #0xF6F3, W0
00826A  07FC52     RCALL lcdWriteStringQ
00826C  370006     BRA 0x827A
73:                    } else {
74:                        //update here
75:                        lcdSetCursorQ(0,2);
00826E  B3C021     MOV.B #0x2, W1
008270  EB4000     CLR.B W0
008272  07FC3A     RCALL lcdSetCursorQ
76:                        lcdWriteDecimalQ(pots[0]>>8);
008274  82F3B0     MOV pots, W0
008276  DE8048     ASR W0, #8, W0
008278  07FC8B     RCALL lcdWriteDecimalQ
77:                    }
78:                }
00827A  060000     RETURN
79:                
80:                void screenDebugFlash(void){
00827C  781F88     MOV W8, [W15++]
81:                        if(state!=laststate){
00827E  808090     MOV laststate, W0
008280  E31048     CP 0x1048
008282  32003D     BRA Z, 0x82FE
82:                        //setup here
83:                        lcdClearQ();
008284  07FC26     RCALL lcdClearQ
84:                        lcdSetCursorQ(0,0);
008286  EB4080     CLR.B W1
008288  784001     MOV.B W1, W0
00828A  07FC2E     RCALL lcdSetCursorQ
85:                        lcdWriteWordQ(flash_readback[2]);
00828C  25EA80     MOV #0x5EA8, W0
00828E  FB0010     SE [W0], W0
008290  07FC4F     RCALL lcdWriteWordQ
86:                         lcdSetCursorQ(6,0);
008292  EB4080     CLR.B W1
008294  B3C060     MOV.B #0x6, W0
008296  07FC28     RCALL lcdSetCursorQ
87:                        lcdWriteWordQ(flash_readback[3]);
008298  25EA90     MOV #0x5EA9, W0
00829A  FB0010     SE [W0], W0
00829C  07FC49     RCALL lcdWriteWordQ
88:                         lcdSetCursorQ(12,0);
00829E  EB4080     CLR.B W1
0082A0  B3C0C0     MOV.B #0xC, W0
0082A2  07FC22     RCALL lcdSetCursorQ
89:                        lcdWriteWordQ(flash_readback[4]);
0082A4  25EAA0     MOV #0x5EAA, W0
0082A6  FB0010     SE [W0], W0
0082A8  07FC43     RCALL lcdWriteWordQ
90:                         lcdSetCursorQ(0,1);
0082AA  B3C011     MOV.B #0x1, W1
0082AC  EB4000     CLR.B W0
0082AE  07FC1C     RCALL lcdSetCursorQ
91:                        lcdWriteWordQ(flash_readback[5]);
0082B0  25EAB0     MOV #0x5EAB, W0
0082B2  FB0010     SE [W0], W0
0082B4  07FC3D     RCALL lcdWriteWordQ
92:                        lcdSetCursorQ(6,1);
0082B6  B3C011     MOV.B #0x1, W1
0082B8  B3C060     MOV.B #0x6, W0
0082BA  07FC16     RCALL lcdSetCursorQ
93:                        lcdWriteWordQ(flash_readback[6]);
0082BC  25EAC0     MOV #0x5EAC, W0
0082BE  FB0010     SE [W0], W0
0082C0  07FC37     RCALL lcdWriteWordQ
94:                         lcdSetCursorQ(12,1);
0082C2  B3C011     MOV.B #0x1, W1
0082C4  B3C0C0     MOV.B #0xC, W0
0082C6  07FC10     RCALL lcdSetCursorQ
95:                        lcdWriteWordQ(flash_readback[7]);
0082C8  25EAD0     MOV #0x5EAD, W0
0082CA  FB0010     SE [W0], W0
0082CC  07FC31     RCALL lcdWriteWordQ
96:                        lcdSetCursorQ(0,2);
0082CE  B3C021     MOV.B #0x2, W1
0082D0  EB4000     CLR.B W0
0082D2  07FC0A     RCALL lcdSetCursorQ
97:                        lcdWriteWordQ(flash_readback[8]);
0082D4  25EAE8     MOV #0x5EAE, W8
0082D6  FB0018     SE [W8], W0
0082D8  07FC2B     RCALL lcdWriteWordQ
98:                        lcdSetCursorQ(6,2);
0082DA  B3C021     MOV.B #0x2, W1
0082DC  B3C060     MOV.B #0x6, W0
0082DE  07FC04     RCALL lcdSetCursorQ
99:                        lcdWriteWordQ(flash_readback[9]);
0082E0  E80008     INC W8, W0
0082E2  FB0010     SE [W0], W0
0082E4  07FC25     RCALL lcdWriteWordQ
100:                        lcdSetCursorQ(12,2);
0082E6  B3C021     MOV.B #0x2, W1
0082E8  B3C0C0     MOV.B #0xC, W0
0082EA  07FBFE     RCALL lcdSetCursorQ
101:                       lcdWriteWordQ(flash_readback[10]);
0082EC  E88008     INC2 W8, W0
0082EE  FB0010     SE [W0], W0
0082F0  07FC1F     RCALL lcdWriteWordQ
102:                       lcdSetCursorQ(0,3);
0082F2  B3C031     MOV.B #0x3, W1
0082F4  EB4000     CLR.B W0
0082F6  07FBF8     RCALL lcdSetCursorQ
103:                       lcdWriteWordQ(flash_readback[8]);
0082F8  FB0018     SE [W8], W0
0082FA  07FC1A     RCALL lcdWriteWordQ
0082FC  370008     BRA 0x830E
104:                   } else {
105:                       //update here
106:                       lcdSetCursorQ(9,3);
0082FE  B3C031     MOV.B #0x3, W1
008300  B3C090     MOV.B #0x9, W0
008302  07FBF2     RCALL lcdSetCursorQ
107:                       lcdWriteStringQ("Stat:");
008304  2F6F80     MOV #0xF6F8, W0
008306  07FC04     RCALL lcdWriteStringQ
108:                       lcdWriteWordQ(flashStatusCheck());
008308  0700C2     RCALL flashStatusCheck
00830A  FB0000     SE W0, W0
00830C  07FC11     RCALL lcdWriteWordQ
109:                   }
110:               }
00830E  78044F     MOV [--W15], W8
008310  060000     RETURN
111:               
112:               void screenUpdate(void){
113:                   switch(state){
008312  808240     MOV 0x1048, W0
008314  500FE3     SUB W0, #0x3, [W15]
008316  320006     BRA Z, 0x8324
008318  500FE5     SUB W0, #0x5, [W15]
00831A  320006     BRA Z, 0x8328
00831C  500FE2     SUB W0, #0x2, [W15]
00831E  3A0005     BRA NZ, 0x832A
114:                       case start: break;
115:                       case scrnFX:            screenFX(); 
008320  07FF97     RCALL screenFX
116:                                               break;
008322  370003     BRA 0x832A
117:                       case debugscrnPOTS:     screenDebugPots();
008324  07FF39     RCALL screenDebugPots
118:                                               break;
008326  370001     BRA 0x832A
119:                       case debugscrnFLASH:    screenDebugFlash();
008328  07FFA9     RCALL screenDebugFlash
120:                                               break;
121:                                       
122:                       default: break;
123:                   }
124:                   
125:                   laststate=state;
00832A  F81048     PUSH 0x1048
00832C  F91012     POP laststate
126:               }
00832E  060000     RETURN
127:               
128:                   /*
129:                   lcdSetCursorQ(0,3);
130:                   if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
131:                       lcdWriteStringQ("CLIP");
132:                       hard_clipped=FALSE;  
133:                   }
134:                   else if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
135:                   else lcdWriteStringQ("THRU");
136:                    * 
137:                    *    lcdSetCursorQ(10,3);
138:                  lcdWriteWordQ(ENCODERCNTL);
139:                   */
140:               
141:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/routines.c  -------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
10:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
11:                extern unsigned int write_ptr, rw, frameReady;
12:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
13:                
14:                //misc.
15:                volatile fractional sampinA=0, sampinB=0;
16:                
17:                volatile int rxBufferIndicator = 0;
18:                fractional *ping, *pong;
19:                
20:                //Description: This interrupt triggers at the completion of DCI output
21:                //Dependancies: initSPI2(); 
22:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
000306  BE9F80     MOV.D W0, [W15++]
000308  BE9F82     MOV.D W2, [W15++]
00030A  781F84     MOV W4, [W15++]
00030C  F80032     PUSH DSRPAG
00030E  F80034     PUSH DSWPAG
000310  200010     MOV #0x1, W0
000312  8801A0     MOV W0, DSWPAG
000314  202000     MOV #0x200, W0
000316  880190     MOV W0, DSRPAG
000318  000000     NOP
23:                    static fractional sampoutA=0, sampoutB=0;
24:                    
25:                    int trashA=RXBUF0;
00031A  801480     MOV RXBUF0, W0
26:                    sampinA=RXBUF1;
00031C  F80292     PUSH RXBUF1
00031E  F9102A     POP sampinA
27:                    int trashB=RXBUF2;
000320  8014A0     MOV RXBUF2, W0
28:                    sampinB=RXBUF3;
000322  F80296     PUSH RXBUF3
000324  F9102C     POP sampinB
29:                    TXBUF0=TXBUF1=sampoutA;                                    //output buffered sample to DAC
000326  F81036     PUSH sampoutA
000328  F9029A     POP TXBUF1
00032A  F8029A     PUSH TXBUF1
00032C  F90298     POP TXBUF0
30:                    TXBUF2=TXBUF3=sampoutB;
00032E  F81034     PUSH _doclose
000330  F9029E     POP TXBUF3
000332  F8029E     PUSH TXBUF3
000334  F9029C     POP TXBUF2
31:                
32:                
33:                    
34:                    __builtin_btg(&sampinA, 15);                             //convert to Q1.15 compatible format
000336  2102A0     MOV #0x102A, W0
000338  A2F010     BTG [W0], #15
35:                    __builtin_btg(&sampinB, 15);                             //convert to Q1.15 compatible format
00033A  2102C0     MOV #0x102C, W0
00033C  A2F010     BTG [W0], #15
36:                    
37:                
38:                      
39:                    
40:                    if(write_ptr--==0){                       //reset pointer when out of bounds
00033E  808220     MOV 0x1044, W0
000340  E90080     DEC W0, W1
000342  888221     MOV W1, 0x1044
000344  E00000     CP0 W0
000346  3A0005     BRA NZ, 0x352
41:                        write_ptr=STREAMBUF-1;
000348  200FF0     MOV #0xFF, W0
00034A  888220     MOV W0, 0x1044
42:                        __builtin_btg(&rw,0);
00034C  AA1002     BTG rw, #0
43:                        frameReady=1;
00034E  200010     MOV #0x1, W0
000350  888020     MOV W0, frameReady
44:                    }
45:                   
46:                    if(rw){
000352  E21002     CP0 rw
000354  320014     BRA Z, 0x37E
47:                        streamB[write_ptr]=sampinA;
000356  808220     MOV 0x1044, W0
000358  266CA2     MOV #0x66CA, W2
00035A  400180     ADD W0, W0, W3
00035C  410083     ADD W2, W3, W1
00035E  808154     MOV sampinA, W4
000360  780884     MOV W4, [W1]
48:                        sampoutA=outputA[write_ptr--]; 
000362  260CA1     MOV #0x60CA, W1
000364  408183     ADD W1, W3, W3
000366  780193     MOV [W3], W3
000368  8881B3     MOV W3, sampoutA
00036A  E90000     DEC W0, W0
00036C  888220     MOV W0, 0x1044
49:                        streamB[write_ptr]=sampinB;
00036E  400000     ADD W0, W0, W0
000370  410100     ADD W2, W0, W2
000372  808163     MOV sampinB, W3
000374  780903     MOV W3, [W2]
50:                        sampoutB=outputA[write_ptr];
000376  408000     ADD W1, W0, W0
000378  780010     MOV [W0], W0
00037A  8881A0     MOV W0, _doclose
00037C  370013     BRA 0x3A4
51:                        
52:                    }
53:                    else {
54:                        streamA[write_ptr]=sampinA; 
00037E  808220     MOV 0x1044, W0
000380  264CA2     MOV #0x64CA, W2
000382  400180     ADD W0, W0, W3
000384  410083     ADD W2, W3, W1
000386  808154     MOV sampinA, W4
000388  780884     MOV W4, [W1]
55:                        sampoutA=outputB[write_ptr--];  
00038A  262CA1     MOV #0x62CA, W1
00038C  408183     ADD W1, W3, W3
00038E  780193     MOV [W3], W3
000390  8881B3     MOV W3, sampoutA
000392  E90000     DEC W0, W0
000394  888220     MOV W0, 0x1044
56:                        streamA[write_ptr]=sampinB; 
000396  400000     ADD W0, W0, W0
000398  410100     ADD W2, W0, W2
00039A  808163     MOV sampinB, W3
00039C  780903     MOV W3, [W2]
57:                        sampoutB=outputB[write_ptr];  
00039E  408000     ADD W1, W0, W0
0003A0  780010     MOV [W0], W0
0003A2  8881A0     MOV W0, _doclose
58:                    } 
59:                    
60:                    _DCIIF=0;
0003A4  A98807     BCLR 0x807, #4
61:                }
0003A6  F90034     POP DSWPAG
0003A8  F90032     POP DSRPAG
0003AA  78024F     MOV [--W15], W4
0003AC  BE014F     MOV.D [--W15], W2
0003AE  BE004F     MOV.D [--W15], W0
0003B0  064000     RETFIE
62:                
63:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003B2  F80036     PUSH RCOUNT
0003B4  BE9F80     MOV.D W0, [W15++]
0003B6  BE9F82     MOV.D W2, [W15++]
0003B8  BE9F84     MOV.D W4, [W15++]
0003BA  BE9F86     MOV.D W6, [W15++]
64:                    _DMA2IF = 0; /* Received one frame of data*/    
0003BC  A90803     BCLR 0x803, #0
65:                    
66:                    if(rxBufferIndicator == 0)
0003BE  E2102E     CP0 rxBufferIndicator
0003C0  3A0004     BRA NZ, 0x3CA
67:                    {
68:                         processRxData((int *)rxBufferA, (int*)txBufferA);
0003C2  2CE001     MOV #0xCE00, W1
0003C4  2CA000     MOV #0xCA00, W0
0003C6  073DFF     RCALL processRxData
0003C8  370003     BRA 0x3D0
69:                    }
70:                    else
71:                    {
72:                         processRxData((int *)rxBufferB, (int*)txBufferB);
0003CA  2CC001     MOV #0xCC00, W1
0003CC  2C8000     MOV #0xC800, W0
0003CE  073DFB     RCALL processRxData
73:                    }
74:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
0003D0  AA102E     BTG rxBufferIndicator, #0
75:                }
0003D2  BE034F     MOV.D [--W15], W6
0003D4  BE024F     MOV.D [--W15], W4
0003D6  BE014F     MOV.D [--W15], W2
0003D8  BE004F     MOV.D [--W15], W0
0003DA  F90036     POP RCOUNT
0003DC  064000     RETFIE
76:                
77:                /*
78:                //Description: This interrupt handles UART reception
79:                //Dependencies: initUART1();
80:                void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
81:                    unsigned char trash;
82:                    trash=U1RXREG;
83:                    printf("RECIEVED: %d\r\n", trash);
84:                    IFS0bits.U1RXIF = 0;            //clear flag, restart
85:                }
86:                
87:                //Description: This interrupt handles UART transmission
88:                //Dependencies: initUART1();
89:                void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
90:                    YLED=~YLED;
91:                    IFS0bits.U1TXIF = 0;            //clear flag, restart
92:                } 
93:                  
94:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
95:                    //SEG_SEL=1;
96:                    int trash=SPI3BUF;
97:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
98:                    IFS5bits.SPI3IF=0;
99:                    
100:               }
101:                */
---  C:/Users/ryan/Documents/seniorproject/ps-040/plcd.c  -----------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                #include "screens.h"
14:                
15:                extern unsigned char pad[BUTTONS];
16:                
17:                int  lcdBuf[LCDBUF+1]={0};
18:                int *lcdWritePtr=lcdBuf;
19:                int *lcdReadPtr=lcdBuf;
20:                
21:                
22:                void lcdWriteQ(unsigned char data){
23:                    *lcdWritePtr++=data|0x0000;
007AA8  FB8000     ZE W0, W0
007AAA  808281     MOV 0x1050, W1
007AAC  781880     MOV W0, [W1++]
007AAE  888281     MOV W1, 0x1050
24:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007AB0  26ACA0     MOV #0x6ACA, W0
007AB2  508F80     SUB W1, W0, [W15]
007AB4  3A0002     BRA NZ, 0x7ABA
25:                        lcdWritePtr=lcdBuf;
007AB6  B12000     SUB #0x200, W0
007AB8  888280     MOV W0, 0x1050
26:                }
007ABA  060000     RETURN
27:                
28:                void lcdCommandQ(unsigned char data){
29:                    *lcdWritePtr++=data|0x0100;     //flag for rs=1
007ABC  FB8000     ZE W0, W0
007ABE  808281     MOV 0x1050, W1
007AC0  A08000     BSET W0, #8
007AC2  781880     MOV W0, [W1++]
007AC4  888281     MOV W1, 0x1050
30:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007AC6  26ACA0     MOV #0x6ACA, W0
007AC8  508F80     SUB W1, W0, [W15]
007ACA  3A0002     BRA NZ, 0x7AD0
31:                        lcdWritePtr=lcdBuf;
007ACC  B12000     SUB #0x200, W0
007ACE  888280     MOV W0, 0x1050
32:                }
007AD0  060000     RETURN
33:                
34:                void lcdClearQ(void){
35:                    *lcdWritePtr++=LCD_CLEARDISPLAY|0x0300;     //flag for rs=1 & long delay
007AD2  808280     MOV 0x1050, W0
007AD4  203011     MOV #0x301, W1
007AD6  781801     MOV W1, [W0++]
007AD8  888280     MOV W0, 0x1050
36:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007ADA  26ACA1     MOV #0x6ACA, W1
007ADC  500F81     SUB W0, W1, [W15]
007ADE  3A0003     BRA NZ, 0x7AE6
37:                        lcdWritePtr=lcdBuf;
007AE0  2FE000     MOV #0xFE00, W0
007AE2  400001     ADD W0, W1, W0
007AE4  888280     MOV W0, 0x1050
38:                }
007AE6  060000     RETURN
39:                
40:                void lcdSetCursorQ(unsigned char col, unsigned char row) {
007AE8  784101     MOV.B W1, W2
41:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
42:                  if (row > 3) {
43:                    row = 3;
44:                  }
45:                  *lcdWritePtr++=(LCD_SETDDRAMADDR | (col + offsets[row]))|0x0100;  //flag for rs=0 
007AEA  808281     MOV 0x1050, W1
007AEC  514FE3     SUB.B W2, #0x3, [W15]
007AEE  360001     BRA LEU, 0x7AF2
007AF0  B3C032     MOV.B #0x3, W2
007AF2  FB8102     ZE W2, W2
007AF4  2F7163     MOV #0xF716, W3
007AF6  418102     ADD W3, W2, W2
007AF8  FB8112     ZE [W2], W2
007AFA  FB8000     ZE W0, W0
007AFC  410000     ADD W2, W0, W0
007AFE  201802     MOV #0x180, W2
007B00  701882     IOR W0, W2, [W1++]
007B02  888281     MOV W1, 0x1050
46:                    if(lcdWritePtr==&lcdBuf[LCDBUF]) 
007B04  26ACA0     MOV #0x6ACA, W0
007B06  508F80     SUB W1, W0, [W15]
007B08  3A0002     BRA NZ, 0x7B0E
47:                        lcdWritePtr=lcdBuf; 
007B0A  B12000     SUB #0x200, W0
007B0C  888280     MOV W0, 0x1050
48:                }
007B0E  060000     RETURN
49:                
50:                void lcdWriteStringQ(char *string) {
007B10  781F88     MOV W8, [W15++]
007B12  780400     MOV W0, W8
51:                    char *it = string;
52:                    for (; *it; it++) {
007B14  784018     MOV.B [W8], W0
007B16  E00400     CP0.B W0
007B18  320004     BRA Z, 0x7B22
007B1C  784058     MOV.B [++W8], W0
007B1E  E00400     CP0.B W0
007B20  3AFFFC     BRA NZ, 0x7B1A
53:                        lcdWriteQ(*it);
007B1A  07FFC6     RCALL lcdWriteQ
54:                  }
55:                }
007B22  78044F     MOV [--W15], W8
007B24  060000     RETURN
56:                
57:                void lcdCustomSymbols(void){
58:                    int i=0;
59:                    lcdCommandQ(0x40);
007B26  B3C400     MOV.B #0x40, W0
007B28  07FFC9     RCALL lcdCommandQ
60:                    Delay_us(200);
007B2A  200C80     MOV #0xC8, W0
007B2C  070253     RCALL Delay_us
61:                   // for(; i<8; i++)lcdWriteString(loadingOne[i]);
62:                    //lcdWriteString(loadingTwo);
63:                    //lcdWriteString(loadingThree);
64:                    //lcdWriteString(loadingFour);
65:                }
007B2E  060000     RETURN
66:                
67:                void lcdWriteWordQ(int word){
007B30  4787E6     ADD W15, #0x6, W15
007B32  781F88     MOV W8, [W15++]
007B34  781F8E     MOV W14, [W15++]
007B36  780400     MOV W0, W8
007B5A  200040     MOV #0x4, W0
68:                    int i;
69:                    char inchar[4];
70:                    
71:                    if(word<0) {
007B38  E00008     CP0 W8
007B3A  3D0004     BRA GE, 0x7B44
72:                        lcdWriteQ('-');
007B3C  B3C2D0     MOV.B #0x2D, W0
007B3E  07FFB4     RCALL lcdWriteQ
73:                        word=~word+1;
007B40  EA0408     NEG W8, W8
007B42  370002     BRA 0x7B48
74:                    }else lcdWriteQ(' ');
007B44  B3C200     MOV.B #0x20, W0
007B46  07FFB0     RCALL lcdWriteQ
75:                   
76:                   inchar[0] = word&0x000F; 
007B48  64406F     AND.B W8, #0xF, W0
77:                   if (inchar[0] > 9) 
007B4A  504FE9     SUB.B W0, #0x9, [W15]
007B4C  340003     BRA LE, 0x7B54
78:                       inchar[0]+=55;
007B4E  B04370     ADD.B #0x37, W0
007B50  9FFF80     MOV.B W0, [W15-8]
007B52  370002     BRA 0x7B58
79:                   else inchar[0]+=48;
007B54  B04300     ADD.B #0x30, W0
007B56  9FFF80     MOV.B W0, [W15-8]
007B58  578768     SUB W15, #0x8, W14
80:                   
81:                   for(i=1; i<4; i++){ 
007B74  500FF0     SUB W0, #0x10, [W15]
007B76  3AFFF2     BRA NZ, 0x7B5C
82:                      inchar[i] = ((word>>(i*4))&0x0000F); 
007B5C  DEC080     ASR W8, W0, W1
007B5E  60C0EF     AND.B W1, #0xF, W1
007B60  E8070E     INC W14, W14
007B62  784F01     MOV.B W1, [W14]
83:                      if (inchar[i] > 9) 
007B64  50CFE9     SUB.B W1, #0x9, [W15]
007B66  340003     BRA LE, 0x7B6E
84:                          inchar[i]+=55;
007B68  B3C373     MOV.B #0x37, W3
007B6A  40CF03     ADD.B W1, W3, [W14]
007B6C  370002     BRA 0x7B72
85:                      else inchar[i]+=48;
007B6E  B3C303     MOV.B #0x30, W3
007B70  40CF03     ADD.B W1, W3, [W14]
007B72  400064     ADD W0, #0x4, W0
86:                   } 
87:                   lcdWriteQ(inchar[3]);
007B78  97F83F     MOV.B [W15-5], W0
007B7A  07FF96     RCALL lcdWriteQ
88:                   lcdWriteQ(inchar[2]);
007B7C  97F82F     MOV.B [W15-6], W0
007B7E  07FF94     RCALL lcdWriteQ
89:                   lcdWriteQ(inchar[1]);
007B80  97F81F     MOV.B [W15-7], W0
007B82  07FF92     RCALL lcdWriteQ
90:                   lcdWriteQ(inchar[0]);
007B84  97F80F     MOV.B [W15-8], W0
007B86  07FF90     RCALL lcdWriteQ
91:                }
007B88  78074F     MOV [--W15], W14
007B8A  78044F     MOV [--W15], W8
007B8C  B1006F     SUB #0x6, W15
007B8E  060000     RETURN
92:                
93:                void lcdWriteDecimalQ(char word){
007B90  FA0004     LNK #0x4
94:                    char result[4];
95:                    char i = 3;
007B92  B3C035     MOV.B #0x3, W5
96:                    do {
97:                
98:                        result[i] = '0' + word % 10;
007B94  2000A2     MOV #0xA, W2
007B96  FB0185     SE W5, W3
007B98  FB0000     SE W0, W0
007B9A  090011     REPEAT #0x11
007B9C  D80002     DIV.SW W0, W2
007B9E  780201     MOV W1, W4
007BA0  B04304     ADD.B #0x30, W4
007BA2  784084     MOV.B W4, W1
007BA4  5181E4     SUB W3, #0x4, W3
007BA6  79F781     MOV.B W1, [W15+W3]
99:                        word /= 10;
100:                       i--;
007BA8  E94285     DEC.B W5, W5
101:                   }
102:                   while (word > 0);
007BAA  E00400     CP0.B W0
007BAC  3CFFF4     BRA GT, 0x7B96
103:                   lcdWriteStringQ(result);
007BAE  578064     SUB W15, #0x4, W0
007BB0  07FFAF     RCALL lcdWriteStringQ
104:               }
007BB2  FA8000     ULNK
007BB4  060000     RETURN
105:               
106:               //4x4 pad debug
107:               void lcdDrawPads(unsigned char col){
007BB6  BE9F88     MOV.D W8, [W15++]
007BB8  784480     MOV.B W0, W9
108:                   char block=0xFF;
007BC8  EBC400     SETM.B W8
109:                   if(!pad[34]||!pad[16]) block='*';
007BBA  B3C2A8     MOV.B #0x2A, W8
007BBC  260C80     MOV #0x60C8, W0
007BBE  E00410     CP0.B [W0]
007BC0  320004     BRA Z, 0x7BCA
007BC2  500072     SUB W0, #0x12, W0
007BC4  E00410     CP0.B [W0]
007BC6  320001     BRA Z, 0x7BCA
110:                   
111:                   lcdSetCursorQ(col, 0);
007BCA  EB4080     CLR.B W1
007BCC  784009     MOV.B W9, W0
007BCE  07FF8C     RCALL lcdSetCursorQ
112:                   if(!pad[12])lcdWriteStringQ(" "); else lcdWriteQ(block);
007BD0  260B20     MOV #0x60B2, W0
007BD2  E00410     CP0.B [W0]
007BD4  3A0003     BRA NZ, 0x7BDC
007BD6  2F7140     MOV #0xF714, W0
007BD8  07FF9B     RCALL lcdWriteStringQ
007BDA  370002     BRA 0x7BE0
007BDC  784008     MOV.B W8, W0
007BDE  07FF64     RCALL lcdWriteQ
113:                   if(!pad[13])lcdWriteStringQ(" "); else lcdWriteQ(block);
007BE0  260B30     MOV #0x60B3, W0
007BE2  E00410     CP0.B [W0]
007BE4  3A0003     BRA NZ, 0x7BEC
007BE6  2F7140     MOV #0xF714, W0
007BE8  07FF93     RCALL lcdWriteStringQ
007BEA  370002     BRA 0x7BF0
007BEC  784008     MOV.B W8, W0
007BEE  07FF5C     RCALL lcdWriteQ
114:                   if(!pad[14])lcdWriteStringQ(" "); else lcdWriteQ(block);
007BF0  260B40     MOV #0x60B4, W0
007BF2  E00410     CP0.B [W0]
007BF4  3A0003     BRA NZ, 0x7BFC
007BF6  2F7140     MOV #0xF714, W0
007BF8  07FF8B     RCALL lcdWriteStringQ
007BFA  370002     BRA 0x7C00
007BFC  784008     MOV.B W8, W0
007BFE  07FF54     RCALL lcdWriteQ
115:                   if(!pad[15])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C00  260B50     MOV #0x60B5, W0
007C02  E00410     CP0.B [W0]
007C04  3A0003     BRA NZ, 0x7C0C
007C06  2F7140     MOV #0xF714, W0
007C08  07FF83     RCALL lcdWriteStringQ
007C0A  370002     BRA 0x7C10
007C0C  784008     MOV.B W8, W0
007C0E  07FF4C     RCALL lcdWriteQ
116:                   lcdSetCursorQ(col, 1);
007C10  B3C011     MOV.B #0x1, W1
007C12  784009     MOV.B W9, W0
007C14  07FF69     RCALL lcdSetCursorQ
117:                   if(!pad[8])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C16  260AE0     MOV #0x60AE, W0
007C18  E00410     CP0.B [W0]
007C1A  3A0003     BRA NZ, 0x7C22
007C1C  2F7140     MOV #0xF714, W0
007C1E  07FF78     RCALL lcdWriteStringQ
007C20  370002     BRA 0x7C26
007C22  784008     MOV.B W8, W0
007C24  07FF41     RCALL lcdWriteQ
118:                   if(!pad[9])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C26  260AF0     MOV #0x60AF, W0
007C28  E00410     CP0.B [W0]
007C2A  3A0003     BRA NZ, 0x7C32
007C2C  2F7140     MOV #0xF714, W0
007C2E  07FF70     RCALL lcdWriteStringQ
007C30  370002     BRA 0x7C36
007C32  784008     MOV.B W8, W0
007C34  07FF39     RCALL lcdWriteQ
119:                   if(!pad[10])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C36  260B00     MOV #0x60B0, W0
007C38  E00410     CP0.B [W0]
007C3A  3A0003     BRA NZ, 0x7C42
007C3C  2F7140     MOV #0xF714, W0
007C3E  07FF68     RCALL lcdWriteStringQ
007C40  370002     BRA 0x7C46
007C42  784008     MOV.B W8, W0
007C44  07FF31     RCALL lcdWriteQ
120:                   if(!pad[11])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C46  260B10     MOV #0x60B1, W0
007C48  E00410     CP0.B [W0]
007C4A  3A0003     BRA NZ, 0x7C52
007C4C  2F7140     MOV #0xF714, W0
007C4E  07FF60     RCALL lcdWriteStringQ
007C50  370002     BRA 0x7C56
007C52  784008     MOV.B W8, W0
007C54  07FF29     RCALL lcdWriteQ
121:                   lcdSetCursorQ(col, 2);
007C56  B3C021     MOV.B #0x2, W1
007C58  784009     MOV.B W9, W0
007C5A  07FF46     RCALL lcdSetCursorQ
122:                   if(!pad[4])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C5C  260AA0     MOV #0x60AA, W0
007C5E  E00410     CP0.B [W0]
007C60  3A0003     BRA NZ, 0x7C68
007C62  2F7140     MOV #0xF714, W0
007C64  07FF55     RCALL lcdWriteStringQ
007C66  370002     BRA 0x7C6C
007C68  784008     MOV.B W8, W0
007C6A  07FF1E     RCALL lcdWriteQ
123:                   if(!pad[5])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C6C  260AB0     MOV #0x60AB, W0
007C6E  E00410     CP0.B [W0]
007C70  3A0003     BRA NZ, 0x7C78
007C72  2F7140     MOV #0xF714, W0
007C74  07FF4D     RCALL lcdWriteStringQ
007C76  370002     BRA 0x7C7C
007C78  784008     MOV.B W8, W0
007C7A  07FF16     RCALL lcdWriteQ
124:                   if(!pad[6])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C7C  260AC0     MOV #0x60AC, W0
007C7E  E00410     CP0.B [W0]
007C80  3A0003     BRA NZ, 0x7C88
007C82  2F7140     MOV #0xF714, W0
007C84  07FF45     RCALL lcdWriteStringQ
007C86  370002     BRA 0x7C8C
007C88  784008     MOV.B W8, W0
007C8A  07FF0E     RCALL lcdWriteQ
125:                   if(!pad[7])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C8C  260AD0     MOV #0x60AD, W0
007C8E  E00410     CP0.B [W0]
007C90  3A0003     BRA NZ, 0x7C98
007C92  2F7140     MOV #0xF714, W0
007C94  07FF3D     RCALL lcdWriteStringQ
007C96  370002     BRA 0x7C9C
007C98  784008     MOV.B W8, W0
007C9A  07FF06     RCALL lcdWriteQ
126:                   lcdSetCursorQ(col, 3);
007C9C  B3C031     MOV.B #0x3, W1
007C9E  784009     MOV.B W9, W0
007CA0  07FF23     RCALL lcdSetCursorQ
127:                   if(!pad[0])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CA2  260A60     MOV #0x60A6, W0
007CA4  E00410     CP0.B [W0]
007CA6  3A0003     BRA NZ, 0x7CAE
007CA8  2F7140     MOV #0xF714, W0
007CAA  07FF32     RCALL lcdWriteStringQ
007CAC  370002     BRA 0x7CB2
007CAE  784008     MOV.B W8, W0
007CB0  07FEFB     RCALL lcdWriteQ
128:                   if(!pad[1])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CB2  260A70     MOV #0x60A7, W0
007CB4  E00410     CP0.B [W0]
007CB6  3A0003     BRA NZ, 0x7CBE
007CB8  2F7140     MOV #0xF714, W0
007CBA  07FF2A     RCALL lcdWriteStringQ
007CBC  370002     BRA 0x7CC2
007CBE  784008     MOV.B W8, W0
007CC0  07FEF3     RCALL lcdWriteQ
129:                   if(!pad[2])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CC2  260A80     MOV #0x60A8, W0
007CC4  E00410     CP0.B [W0]
007CC6  3A0003     BRA NZ, 0x7CCE
007CC8  2F7140     MOV #0xF714, W0
007CCA  07FF22     RCALL lcdWriteStringQ
007CCC  370002     BRA 0x7CD2
007CCE  784008     MOV.B W8, W0
007CD0  07FEEB     RCALL lcdWriteQ
130:                   if(!pad[3])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CD2  260A90     MOV #0x60A9, W0
007CD4  E00410     CP0.B [W0]
007CD6  3A0003     BRA NZ, 0x7CDE
007CD8  2F7140     MOV #0xF714, W0
007CDA  07FF1A     RCALL lcdWriteStringQ
007CDC  370002     BRA 0x7CE2
007CDE  784008     MOV.B W8, W0
007CE0  07FEE3     RCALL lcdWriteQ
131:               }
007CE2  BE044F     MOV.D [--W15], W8
007CE4  060000     RETURN
132:               
133:               void lcdPoll(void){  
134:                   if(lcdWritePtr!=lcdReadPtr){   
007CE6  808290     MOV calcquot, W0
007CE8  E31050     CP 0x1050
007CEA  320018     BRA Z, 0x7D1C
135:                       if((*lcdReadPtr>>8)&1) LCD_RS=0;
007CEC  201001     MOV #0x100, W1
007CEE  608090     AND W1, [W0], W1
007CF0  320002     BRA Z, 0x7CF6
007CF2  A9EE45     BCLR 0xE45, #7
007CF4  370001     BRA 0x7CF8
136:                       else LCD_RS=1;
007CF6  A8EE45     BSET 0xE45, #7
137:                       if((*lcdReadPtr>>9)&1) PR3=0x2DF0; //2DF0 for ~1.3mS
007CF8  202001     MOV #0x200, W1
007CFA  608090     AND W1, [W0], W1
007CFC  320003     BRA Z, 0x7D04
007CFE  22DF01     MOV #0x2DF0, W1
007D00  880871     MOV W1, PR3
007D02  370002     BRA 0x7D08
138:                       else PR3=0x0120; //120 for ~40uS
007D04  201201     MOV #0x120, W1
007D06  880871     MOV W1, PR3
139:                       PMDIN1=(*lcdReadPtr++)&0x00FF;
007D08  200FF1     MOV #0xFF, W1
007D0A  6080B0     AND W1, [W0++], W1
007D0C  883041     MOV W1, PMDIN1
007D0E  888290     MOV W0, calcquot
140:                       if(lcdReadPtr==&lcdBuf[LCDBUF]) lcdReadPtr=lcdBuf;
007D10  26ACA1     MOV #0x6ACA, W1
007D12  500F81     SUB W0, W1, [W15]
007D14  3A0003     BRA NZ, 0x7D1C
007D16  2FE000     MOV #0xFE00, W0
007D18  400001     ADD W0, W1, W0
007D1A  888290     MOV W0, calcquot
141:                   } 
142:                   TMR3=0x0000; 
007D1C  EF210A     CLR TMR3
143:               }
007D1E  060000     RETURN
144:               
145:               //ALWAYS SENDS, blocks program
146:               void lcdBlockingSend(unsigned char data){
007D20  BE9F88     MOV.D W8, [W15++]
007D22  781F8A     MOV W10, [W15++]
007D24  784500     MOV.B W0, W10
147:                   while(PMMODEbits.BUSY)Delay_us(2);
007D26  E20602     CP0 PMMODE
007D28  3D0007     BRA GE, 0x7D38
007D2A  200028     MOV #0x2, W8
007D2C  280009     MOV #0x8000, W9
007D2E  780008     MOV W8, W0
007D30  070151     RCALL Delay_us
007D32  803011     MOV PMMODE, W1
007D34  648001     AND W9, W1, W0
007D36  3AFFFB     BRA NZ, 0x7D2E
148:                   PMDIN1=data; 
007D38  FB850A     ZE W10, W10
007D3A  88304A     MOV W10, PMDIN1
149:               }
007D3C  78054F     MOV [--W15], W10
007D3E  BE044F     MOV.D [--W15], W8
007D40  060000     RETURN
150:               //ALWAYS SENDS, blocks program
151:               void lcdBlockingClear(void){
007D42  BE9F88     MOV.D W8, [W15++]
152:                   while(PMMODEbits.BUSY)Delay_us(2);
007D44  E20602     CP0 PMMODE
007D46  3D0007     BRA GE, 0x7D56
007D48  200028     MOV #0x2, W8
007D4A  280009     MOV #0x8000, W9
007D4C  780008     MOV W8, W0
007D4E  070142     RCALL Delay_us
007D50  803011     MOV PMMODE, W1
007D52  648001     AND W9, W1, W0
007D54  3AFFFB     BRA NZ, 0x7D4C
153:                   PMDIN1=LCD_CLEARDISPLAY; 
007D56  200010     MOV #0x1, W0
007D58  883040     MOV W0, PMDIN1
154:               }
007D5A  BE044F     MOV.D [--W15], W8
007D5C  060000     RETURN
155:               
156:               //ALWAYS SENDS, blocks program
157:               void lcdBlockingReturn(void){
007D5E  BE9F88     MOV.D W8, [W15++]
158:                   while(PMMODEbits.BUSY)Delay_us(2);
007D60  E20602     CP0 PMMODE
007D62  3D0007     BRA GE, 0x7D72
007D64  200028     MOV #0x2, W8
007D66  280009     MOV #0x8000, W9
007D68  780008     MOV W8, W0
007D6A  070134     RCALL Delay_us
007D6C  803011     MOV PMMODE, W1
007D6E  648001     AND W9, W1, W0
007D70  3AFFFB     BRA NZ, 0x7D68
159:                   PMDIN1=LCD_RETURNHOME;
007D72  200020     MOV #0x2, W0
007D74  883040     MOV W0, PMDIN1
160:               }
007D76  BE044F     MOV.D [--W15], W8
007D78  060000     RETURN
161:               
162:               void lcdInit(void){
163:                   LCD_RS=0;
007D7A  A9EE45     BCLR 0xE45, #7
164:                   lcdBlockingSend(0x38);              //function set, 8 bits, 2 line disp, 5x8
007D7C  B3C380     MOV.B #0x38, W0
007D7E  07FFD0     RCALL lcdBlockingSend
165:                   Delay_us(4500);                //>4.1 mS required
007D80  211940     MOV #0x1194, W0
007D82  070128     RCALL Delay_us
166:                   lcdBlockingSend(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
007D84  B3C0C0     MOV.B #0xC, W0
007D86  07FFCC     RCALL lcdBlockingSend
167:                   Delay_us(4500);
007D88  211940     MOV #0x1194, W0
007D8A  070124     RCALL Delay_us
168:                   lcdBlockingClear();                    //Display Clear  
007D8C  07FFDA     RCALL lcdBlockingClear
169:                   Delay_us(1800);                //>1.64mS required
007D8E  207080     MOV #0x708, W0
007D90  070121     RCALL Delay_us
170:                   lcdBlockingSend(0x06);               // entry Mode Set
007D92  B3C060     MOV.B #0x6, W0
007D94  07FFC5     RCALL lcdBlockingSend
171:                   Delay_us(200);
007D96  200C80     MOV #0xC8, W0
007D98  07011D     RCALL Delay_us
172:                   lcdBlockingReturn();
007D9A  07FFE1     RCALL lcdBlockingReturn
173:                   Delay_us(1500);
007D9C  205DC0     MOV #0x5DC, W0
007D9E  07011A     RCALL Delay_us
174:                   
175:                   //lcdCustomSymbols();
176:                   Delay_us(200);
007DA0  200C80     MOV #0xC8, W0
007DA2  070118     RCALL Delay_us
177:                   lcdBlockingClear();                         //Display Clear  
007DA4  07FFCE     RCALL lcdBlockingClear
178:                   Delay_us(1500);
007DA6  205DC0     MOV #0x5DC, W0
007DA8  070115     RCALL Delay_us
179:                   lcdBlockingReturn();
007DAA  07FFD9     RCALL lcdBlockingReturn
180:                   Delay_us(200);
007DAC  200C80     MOV #0xC8, W0
007DAE  070112     RCALL Delay_us
181:               }
007DB0  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/main.c  -----------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 #include "plcd.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = OFF   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                unsigned char pad[BUTTONS];                                                                   //CONTROL VARIABLES//
22:                fractional pots[POTS]={0};
23:                fractional pots_scaled[POTS]={0};
24:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
25:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
26:                
27:                /* DMA BUFFERS */
28:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
29:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
31:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
32:                
33:                unsigned int bpm=0, rw=0, frameReady=0, write_ptr=STREAMBUF;
34:                unsigned int idle=0, cycle=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                               //STATUS VARIABLES//
37:                volatile unsigned char recording=TRUE;
38:                unsigned char UART_ON = FALSE;
39:                unsigned char TEST_SIN = FALSE;
40:                
41:                volatile unsigned char tremelo=FALSE;                                           //FX FLAGS//
42:                volatile unsigned char looper=FALSE;
43:                volatile unsigned char lpf=FALSE;
44:                
45:                volatile unsigned char frame=FALSE;
46:                int temp1, temp2;
47:                
48:                char flash_readback[512]={0};
49:                
50:                enum screen state = debugscrnPOTS;
51:                enum screen laststate = invalid;
52:                
53:                void initBuffer(void){
00859C  264C87     MOV #0x64C8, W7
00859E  266C86     MOV #0x66C8, W6
0085A0  2CDFE5     MOV #0xCDFE, W5
0085A2  2CBFE4     MOV #0xCBFE, W4
0085A4  2C9FE3     MOV #0xC9FE, W3
0085A6  2C7FE2     MOV #0xC7FE, W2
0085A8  201001     MOV #0x100, W1
0085BE  200232     MOV #0x23, W2
0085C0  410100     ADD W2, W0, W2
54:                    int i;
55:                    for(i=0; i<STREAMBUF; i++){
0085BA  3AFFF8     BRA NZ, 0x85AC
0085BC  260A50     MOV #0x60A5, W0
56:                        streamA[i]=0;
0085AA  EB0000     CLR W0
0085AC  782B80     MOV W0, [++W7]
57:                        streamB[i]=0;
0085AE  782B00     MOV W0, [++W6]
58:                        txBufferA[i]=0;
0085B0  782A80     MOV W0, [++W5]
59:                        txBufferB[i]=0;
0085B2  782A00     MOV W0, [++W4]
60:                        rxBufferA[i]=0;
0085B4  782980     MOV W0, [++W3]
61:                        rxBufferB[i]=0;
0085B6  782900     MOV W0, [++W2]
0085B8  E90081     DEC W1, W1
62:                    }
63:                    
64:                    for(i=0; i<BUTTONS; i++)
0085C6  500F82     SUB W0, W2, [W15]
0085C8  3AFFFD     BRA NZ, 0x85C4
65:                        pad[i]=1;
0085C2  B3C011     MOV.B #0x1, W1
0085C4  786801     MOV.B W1, [++W0]
66:                }
0085CA  060000     RETURN
67:                
68:                int main(void) {
0085CC  BE9F88     MOV.D W8, [W15++]
0085CE  BE9F8A     MOV.D W10, [W15++]
0085D0  BE9F8C     MOV.D W12, [W15++]
0085D2  781F8E     MOV W14, [W15++]
008602  2FE00A     MOV #0xFE00, W10
008604  450508     ADD W10, W8, W10
69:                    initPorts();                    //configure io device & adc 
0085D4  07F8A2     RCALL initPorts
70:                    //initUART1();                    //configure & enable UART
71:                    initBuffer();
0085D6  07FFE2     RCALL initBuffer
72:                    initADC1();                     //configure & enable internal ADC
0085D8  07F967     RCALL initADC1
73:                    initPMP();
0085DA  07F986     RCALL initPMP
74:                    //||||||||----
75:                    //initDMA0();
76:                    initDCI_DAC();                  //configure & enable DAC
0085DC  07F9C4     RCALL initDCI_DAC
77:                    initT1();                       //configure & start T1 
0085DE  07F998     RCALL initT1
78:                    initT2();                       //configure & start T2 
0085E0  07F9A0     RCALL initT2
79:                    initSPI3_MEM();                  //start segment display
0085E2  07FA39     RCALL initSPI3_MEM
80:                    //initCAP_BPM();                  //configure bpm capture
81:                    initT3();                       //configure & start T3 for lcd
0085E4  07F9AA     RCALL initT3
82:                    initQEI_ENC();
0085E6  07FA59     RCALL initQEI_ENC
83:                    //initT5();
84:                    fractional temp;
85:                    int writePtr;
86:                    fractional *ping, *pong;
87:                    
88:                    while(1){    
89:                        if(frameReady) {
0085F0  E21004     CP0 frameReady
0085F2  32001C     BRA Z, 0x862C
90:                            writePtr=STREAMBUF-1;
91:                            if(rw){
0085F4  E21002     CP0 rw
0085F6  320003     BRA Z, 0x85FE
92:                                ping = streamA+writePtr;
0085FA  266C88     MOV #0x66C8, W8
0085FC  370002     BRA 0x8602
93:                                pong = outputB+writePtr;
0085F8  264C89     MOV #0x64C8, W9
94:                            }else{
95:                                ping = streamB+writePtr;
0085EE  268C8E     MOV #0x68C8, W14
008600  78040E     MOV W14, W8
96:                                pong = outputA+writePtr;
0085EC  262C8D     MOV #0x62C8, W13
0085FE  78048D     MOV W13, W9
97:                            }
98:                            
99:                            for(; writePtr>=0; writePtr--){
008618  540F8A     SUB W8, W10, [W15]
00861A  3AFFF5     BRA NZ, 0x8606
100:                               temp=*ping--; //!rw
008606  780028     MOV [W8--], W0
101:                               if(temp<=-32766||temp>=32766)hard_clipped=TRUE;
0085E8  27FFDB     MOV #0x7FFD, W11
0085EA  EBC600     SETM.B W12
008608  40008B     ADD W0, W11, W1
00860A  408FE6     ADD W1, #0x6, [W15]
00860C  360002     BRA LEU, 0x8612
00860E  2100A1     MOV #0x100A, W1
008610  78488C     MOV.B W12, [W1]
102:                               temp=fx(temp);    //run fx on latest sample
008612  07FD4C     RCALL fx
103:                               *pong--=mixer(temp); //rw
008614  07FCE8     RCALL mixer
008616  781480     MOV W0, [W9--]
104:                               
105:                           }
106:                           temp = 8*idle/STREAMBUF;
107:                           cycle=STREAMBUF/(STREAMBUF-write_ptr);
00861C  201000     MOV #0x100, W0
00861E  808222     MOV 0x1044, W2
008620  500102     SUB W0, W2, W2
008622  090011     REPEAT #0x11
008624  D88002     DIV.UW W0, W2
008626  888040     MOV W0, cycle
108:                           idle=0;
008628  EF3006     CLR idle
109:                           frameReady=0;
00862A  EF3004     CLR frameReady
110:                       }
111:                       if(_T2IF){
00862C  ABE800     BTST IFS0, #7
00862E  320006     BRA Z, 0x863C
112:                           scanButtons();                   //read button matrix
008630  07FBC0     RCALL scanButtons
113:                           readPots();                     //read control pots
008632  07FC63     RCALL readPots
114:                           if(_AD1IF) readPots();
008634  ABA801     BTST 0x801, #5
008636  320001     BRA Z, 0x863A
008638  07FC60     RCALL readPots
115:                           _T2IF=0;
00863A  A9E800     BCLR IFS0, #7
116:                       }
117:                       if(_T1IF){
00863C  AB6800     BTST IFS0, #3
00863E  320002     BRA Z, 0x8644
118:                           display();
008640  07FCA9     RCALL display
119:                           _T1IF=0;
008642  A96800     BCLR IFS0, #3
120:                       }
121:                       if(_T3IF) {
008644  AB0801     BTST 0x801, #0
008646  32FFD4     BRA Z, 0x85F0
122:                           lcdPoll();
008648  07FB4E     RCALL lcdPoll
123:                           _T3IF=0;
00864A  A90801     BCLR 0x801, #0
00864C  37FFD1     BRA 0x85F0
124:                       }
125:                   }
126:                   return 0;
127:               }
128:               // example test 
---  C:/Users/ryan/Documents/seniorproject/ps-040/flash.c  ----------------------------------------------
1:                 /*
2:                  * File:   flash.c
3:                  * Author: root
4:                  *
5:                  * Created on January 28, 2018, 5:00 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "flash.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                char flashBuf[STREAMBUF*2];
15:                char receive;
16:                
17:                void flashWriteReg(char command) {
18:                    SS3=0;
008476  A92E54     BCLR LATF, #1
19:                    SPI3BUF=command;               //WEL=1 for write enable
008478  FB0000     SE W0, W0
00847A  881540     MOV W0, SPI3BUF
20:                    while(!_SPI3IF); _SPI3IF=0;
00847C  208001     MOV #0x800, W1
00847E  804052     MOV IFS5, W2
008480  608002     AND W1, W2, W0
008482  32FFFD     BRA Z, 0x847E
008484  A9680B     BCLR 0x80B, #3
21:                    receive=SPI3BUF;
008486  801540     MOV SPI3BUF, W0
008488  B7F054     MOV.B WREG, receive
22:                    SS3=1;
00848A  A82E54     BSET LATF, #1
23:                }
00848C  060000     RETURN
24:                
25:                char flashStatusCheck(void){
26:                    SS3=0;
00848E  A92E54     BCLR LATF, #1
27:                    SPI3BUF=FLASH_RDSR1;               //WEL=1 for write enable
008490  200050     MOV #0x5, W0
008492  881540     MOV W0, SPI3BUF
28:                    while(!_SPI3IF); _SPI3IF=0;
008494  208001     MOV #0x800, W1
008496  804052     MOV IFS5, W2
008498  608002     AND W1, W2, W0
00849A  32FFFD     BRA Z, 0x8496
00849C  A9680B     BCLR 0x80B, #3
29:                    receive=SPI3BUF;
00849E  801540     MOV SPI3BUF, W0
30:                    SPI3BUF=0x00;               //WEL=1 for write enable
0084A0  EF22A8     CLR SPI3BUF
31:                    while(!_SPI3IF); _SPI3IF=0;
0084A2  208001     MOV #0x800, W1
0084A4  804052     MOV IFS5, W2
0084A6  608002     AND W1, W2, W0
0084A8  32FFFD     BRA Z, 0x84A4
0084AA  A9680B     BCLR 0x80B, #3
32:                    receive=SPI3BUF;
0084AC  801540     MOV SPI3BUF, W0
0084AE  B7F054     MOV.B WREG, receive
33:                    SS3=1;
0084B0  A82E54     BSET LATF, #1
34:                    
35:                    return receive;
36:                }
0084B2  060000     RETURN
37:                
38:                void flashWritePage(int addressH, int addressL){
39:                    int i;
40:                    SS3=0;
0084B4  A92E54     BCLR LATF, #1
41:                    SPI3BUF=FLASH_PP;
0084B6  200022     MOV #0x2, W2
0084B8  881542     MOV W2, SPI3BUF
42:                    while(!_SPI3IF); _SPI3IF=0;
0084BA  208003     MOV #0x800, W3
0084BC  804054     MOV IFS5, W4
0084BE  618104     AND W3, W4, W2
0084C0  32FFFD     BRA Z, 0x84BC
0084C2  A9680B     BCLR 0x80B, #3
43:                    receive=SPI3BUF;
0084C4  801542     MOV SPI3BUF, W2
44:                    SPI3BUF=addressH&&0xFF;
0084C6  A7F000     BTSC W0, #15
0084C8  EA0000     NEG W0, W0
0084CA  EA0000     NEG W0, W0
0084CC  DE004F     LSR W0, #15, W0
0084CE  881540     MOV W0, SPI3BUF
45:                    while(!_SPI3IF); _SPI3IF=0;
0084D0  208002     MOV #0x800, W2
0084D2  804053     MOV IFS5, W3
0084D4  610003     AND W2, W3, W0
0084D6  32FFFD     BRA Z, 0x84D2
0084D8  A9680B     BCLR 0x80B, #3
46:                    receive=SPI3BUF;
0084DA  801540     MOV SPI3BUF, W0
47:                    SPI3BUF=(addressL&&0xFF00)>>8;
0084DC  EF22A8     CLR SPI3BUF
48:                    while(!_SPI3IF); _SPI3IF=0;
0084DE  208002     MOV #0x800, W2
0084E0  804054     MOV IFS5, W4
0084E2  610004     AND W2, W4, W0
0084E4  32FFFD     BRA Z, 0x84E0
0084E6  A9680B     BCLR 0x80B, #3
49:                    receive=SPI3BUF;
0084E8  801540     MOV SPI3BUF, W0
50:                    SPI3BUF=addressL&&0xFF;
0084EA  780001     MOV W1, W0
0084EC  A7F000     BTSC W0, #15
0084EE  EA0000     NEG W0, W0
0084F0  EA0000     NEG W0, W0
0084F2  DE004F     LSR W0, #15, W0
0084F4  881540     MOV W0, SPI3BUF
51:                    while(!_SPI3IF); _SPI3IF=0;
0084F6  208001     MOV #0x800, W1
0084F8  804052     MOV IFS5, W2
0084FA  608002     AND W1, W2, W0
0084FC  32FFFD     BRA Z, 0x84F8
0084FE  A9680B     BCLR 0x80B, #3
52:                    receive=SPI3BUF;
008500  801540     MOV SPI3BUF, W0
008502  202002     MOV #0x200, W2
53:                    
54:                    for(i=0; i<512;i++){    //write 512 bytes
008516  3AFFF8     BRA NZ, 0x8508
008518  B7F054     MOV.B WREG, receive
55:                        //send byte
56:                        SPI3BUF=0xAA;
008504  200AA3     MOV #0xAA, W3
008508  881543     MOV W3, SPI3BUF
57:                        while(!_SPI3IF); _SPI3IF=0;
008506  208001     MOV #0x800, W1
00850A  804054     MOV IFS5, W4
00850C  608004     AND W1, W4, W0
00850E  32FFFD     BRA Z, 0x850A
008510  A9680B     BCLR 0x80B, #3
58:                        receive=SPI3BUF;
008512  801540     MOV SPI3BUF, W0
008514  E90102     DEC W2, W2
59:                    }
60:                    SS3=1;
00851A  A82E54     BSET LATF, #1
61:                }
00851C  060000     RETURN
62:                
63:                void flashRead(char *array, int bytes){
00851E  BE9F88     MOV.D W8, [W15++]
008520  BE9F8A     MOV.D W10, [W15++]
008522  781F8C     MOV W12, [W15++]
008524  780581     MOV W1, W11
64:                    int i;
65:                    
66:                    SS3=0;
008526  A92E54     BCLR LATF, #1
67:                    SPI3BUF=FLASH_READ;
008528  200031     MOV #0x3, W1
00852A  881541     MOV W1, SPI3BUF
68:                    while(!_SPI3IF); _SPI3IF=0;
00852C  208002     MOV #0x800, W2
00852E  804053     MOV IFS5, W3
008530  610083     AND W2, W3, W1
008532  32FFFD     BRA Z, 0x852E
008534  A9680B     BCLR 0x80B, #3
69:                    receive=SPI3BUF;
008536  801541     MOV SPI3BUF, W1
70:                    SPI3BUF=0x00;
008538  EF22A8     CLR SPI3BUF
71:                    while(!_SPI3IF); _SPI3IF=0;
00853A  208002     MOV #0x800, W2
00853C  804053     MOV IFS5, W3
00853E  610083     AND W2, W3, W1
008540  32FFFD     BRA Z, 0x853C
008542  A9680B     BCLR 0x80B, #3
72:                    receive=SPI3BUF;
008544  801541     MOV SPI3BUF, W1
73:                    SPI3BUF=0x00;
008546  EF22A8     CLR SPI3BUF
74:                    while(!_SPI3IF); _SPI3IF=0;
008548  208002     MOV #0x800, W2
00854A  804053     MOV IFS5, W3
00854C  610083     AND W2, W3, W1
00854E  32FFFD     BRA Z, 0x854A
008550  A9680B     BCLR 0x80B, #3
75:                    receive=SPI3BUF;
008552  801541     MOV SPI3BUF, W1
76:                    SPI3BUF=0x00;
008554  EF22A8     CLR SPI3BUF
77:                    while(!_SPI3IF); _SPI3IF=0;
008556  208002     MOV #0x800, W2
008558  804053     MOV IFS5, W3
00855A  610083     AND W2, W3, W1
00855C  32FFFD     BRA Z, 0x8558
00855E  A9680B     BCLR 0x80B, #3
78:                    receive=SPI3BUF;
008560  801541     MOV SPI3BUF, W1
008562  784181     MOV.B W1, W3
008564  210542     MOV #0x1054, W2
008566  784903     MOV.B W3, [W2]
79:                    
80:                    for(i=0; i<bytes;i++){    //read 512 bytes
008568  E0000B     CP0 W11
00856A  340010     BRA LE, 0x858C
00856C  780500     MOV W0, W10
00856E  EB0480     CLR W9
008586  E80489     INC W9, W9
008588  558F89     SUB W11, W9, [W15]
00858A  3CFFF4     BRA GT, 0x8574
81:                        //receive byte
82:                        SPI3BUF=0x00;
008570  EB0600     CLR W12
008574  88154C     MOV W12, SPI3BUF
83:                        while(!_SPI3IF); _SPI3IF=0;
008572  208008     MOV #0x800, W8
008576  804051     MOV IFS5, W1
008578  640001     AND W8, W1, W0
00857A  32FFFD     BRA Z, 0x8576
00857C  A9680B     BCLR 0x80B, #3
84:                        Delay_us(1);
00857E  200010     MOV #0x1, W0
008580  07FD29     RCALL Delay_us
85:                        array[i]=SPI3BUF;
008582  801540     MOV SPI3BUF, W0
008584  785D00     MOV.B W0, [W10++]
86:                    }
87:                    SS3=1;
00858C  A82E54     BSET LATF, #1
88:                }
00858E  78064F     MOV [--W15], W12
008590  BE054F     MOV.D [--W15], W10
008592  BE044F     MOV.D [--W15], W8
008594  060000     RETURN
89:                
90:                void flashBulkErase(void) {
91:                    flashWriteReg(FLASH_FRMT);
008596  B3C600     MOV.B #0x60, W0
008598  07FF6E     RCALL flashWriteReg
92:                }
00859A  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/devInits.c  -------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 #include <xc.h>
5:                 #include <p33EP512GM310.h>
6:                 #include <libpic30.h>
7:                 #include "common.h"
8:                 #include "devInits.h"
9:                 #include "utilities.h"
10:                #include "plcd.h"
11:                #include "screens.h"
12:                #include "flash.h"
13:                #include "dsp.h"
14:                
15:                extern unsigned char UART_ON;
16:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
17:                
18:                extern char flash_readback[512];
19:                
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
00771A  2FF3F0     MOV #0xFF3F, W0
00771C  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
00771E  2FFE00     MOV #0xFFE0, W0
007720  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
007722  2FE000     MOV #0xFE00, W0
007724  B60746     AND PLLFBD, WREG
007726  B30490     IOR #0x49, W0
007728  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
00772A  200201     MOV #0x20, W1
00772C  803A12     MOV OSCCON, W2
00772E  608002     AND W1, W2, W0
007730  32FFFD     BRA Z, 0x772C
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
007732  803A10     MOV OSCCON, W0
007734  A16000     BCLR W0, #6
007736  200462     MOV #0x46, W2
007738  200573     MOV #0x57, W3
00773A  207421     MOV #0x742, W1
00773C  784882     MOV.B W2, [W1]
00773E  784883     MOV.B W3, [W1]
007740  784880     MOV.B W0, [W1]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
007742  2FFC00     MOV #0xFFC0, W0
007744  803424     MOV RPOR2, W4
007746  600084     AND W0, W4, W1
007748  A00001     BSET W1, #0
00774A  883421     MOV W1, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
00774C  2FF801     MOV #0xFF80, W1
00774E  803685     MOV RPINR24, W5
007750  608205     AND W1, W5, W4
007752  B303D4     IOR #0x3D, W4
007754  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
007756  B60686     AND RPOR3, WREG
007758  B300C0     IOR #0xC, W0
00775A  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
00775C  2C0FF0     MOV #0xC0FF, W0
00775E  803426     MOV RPOR2, W6
007760  600286     AND W0, W6, W5
007762  20D004     MOV #0xD00, W4
007764  720205     IOR W4, W5, W4
007766  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
007768  803434     MOV RPOR3, W4
00776A  600284     AND W0, W4, W5
00776C  20B004     MOV #0xB00, W4
00776E  720205     IOR W4, W5, W4
007770  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
007772  803575     MOV RPINR7, W5
007774  608205     AND W1, W5, W4
007776  B305F4     IOR #0x5F, W4
007778  883574     MOV W4, RPINR7
36:                    RPINR29bits.SCK3R=0x39;     //SCK3 input on pin 84
00777A  280FF4     MOV #0x80FF, W4
00777C  8036D5     MOV RPINR29, W5
00777E  620305     AND W4, W5, W6
007780  239005     MOV #0x3900, W5
007782  728286     IOR W5, W6, W5
007784  8836D5     MOV W5, RPINR29
37:                    RPOR7bits.RP57R=0x20;       //SCK3 output on pin 84
007786  803476     MOV RPOR7, W6
007788  600286     AND W0, W6, W5
00778A  A0D005     BSET W5, #13
00778C  883475     MOV W5, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
00778E  803485     MOV RPOR8, W5
007790  600305     AND W0, W5, W6
007792  21F005     MOV #0x1F00, W5
007794  728286     IOR W5, W6, W5
007796  883485     MOV W5, RPOR8
39:                    RPOR9bits.RP97R=0x21;       //SS3 on pin 88
007798  B60692     AND RPOR9, WREG
00779A  221005     MOV #0x2100, W5
00779C  728280     IOR W5, W0, W5
00779E  883495     MOV W5, RPOR9
40:                    RPINR29bits.SDI3R=0x4C;     //SDI on pin 79, RPI76
0077A0  8036D6     MOV RPINR29, W6
0077A2  608006     AND W1, W6, W0
0077A4  B304C0     IOR #0x4C, W0
0077A6  8836D0     MOV W0, RPINR29
41:                    RPINR14bits.QEA1R=0x10;     //QEA on pin 22, RPI16
0077A8  8035E0     MOV RPINR14, W0
0077AA  608080     AND W1, W0, W1
0077AC  A04001     BSET W1, #4
0077AE  8835E1     MOV W1, RPINR14
42:                    RPINR14bits.QEB1R=0x1B;     //QEB on pin 21, RPI27
0077B0  8035E5     MOV RPINR14, W5
0077B2  620205     AND W4, W5, W4
0077B4  21B000     MOV #0x1B00, W0
0077B6  700004     IOR W0, W4, W0
0077B8  8835E0     MOV W0, RPINR14
43:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
0077BA  803A10     MOV OSCCON, W0
0077BC  A06000     BSET W0, #6
0077BE  207421     MOV #0x742, W1
0077C0  784882     MOV.B W2, [W1]
0077C2  784883     MOV.B W3, [W1]
0077C4  784880     MOV.B W0, [W1]
44:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
45:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
0077C6  EB8000     SETM W0
0077C8  883B60     MOV W0, PMD7
0077CA  F8076C     PUSH PMD7
0077CC  F9076A     POP PMD6
0077CE  F8076A     PUSH PMD6
0077D0  F90766     POP PMD4
0077D2  F80766     PUSH PMD4
0077D4  F90764     POP PMD3
0077D6  F80764     PUSH PMD3
0077D8  F90762     POP PMD2
0077DA  F80762     PUSH PMD2
0077DC  F90760     POP PMD1
46:                    PMD1bits.AD1MD=0;
0077DE  A90760     BCLR PMD1, #0
47:                    PMD1bits.SPI1MD=0;
0077E0  A96760     BCLR PMD1, #3
48:                    PMD1bits.SPI2MD=0;
0077E2  A98760     BCLR PMD1, #4
49:                    PMD1bits.U1MD=0;
0077E4  A9A760     BCLR PMD1, #5
50:                    PMD1bits.U2MD=0;
0077E6  A9C760     BCLR PMD1, #6
51:                    PMD1bits.DCIMD=0;
0077E8  A90761     BCLR 0x761, #0
52:                    PMD1bits.T1MD=0;
0077EA  A96761     BCLR 0x761, #3
53:                    PMD1bits.T2MD=0;
0077EC  A98761     BCLR 0x761, #4
54:                    PMD1bits.T3MD=0;
0077EE  A9A761     BCLR 0x761, #5
55:                    PMD1bits.T4MD=0;
0077F0  A9C761     BCLR 0x761, #6
56:                    PMD1bits.T5MD=0;
0077F2  A9E761     BCLR 0x761, #7
57:                    PMD3bits.PMPMD=0;
0077F4  A90765     BCLR 0x765, #0
58:                    PMD3bits.CMPMD=0;
0077F6  A94765     BCLR 0x765, #2
59:                    PMD6bits.SPI3MD=0;
0077F8  A9076A     BCLR PMD6, #0
60:                    PMD7bits.DMA0MD=0;
0077FA  A9876C     BCLR PMD7, #4
61:                    
62:                    /* Digital IO DIRECTION (1 = input) */
63:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
0077FC  EF2E60     CLR TRISG
0077FE  F80E60     PUSH TRISG
007800  F90E50     POP TRISF
007802  F80E50     PUSH TRISF
007804  F90E40     POP TRISE
007806  F80E40     PUSH TRISE
007808  F90E30     POP TRISD
00780A  F80E30     PUSH TRISD
00780C  F90E20     POP TRISC
00780E  F80E20     PUSH TRISC
007810  F90E10     POP TRISB
007812  F80E10     PUSH TRISB
007814  F90E00     POP TRISA
64:                    TRISA=0x1E01; CNPUA=0x0801;
007816  21E011     MOV #0x1E01, W1
007818  887001     MOV W1, TRISA
00781A  208011     MOV #0x801, W1
00781C  887051     MOV W1, CNPUA
65:                    TRISB=0x0000; CNPUB=0x0000;
00781E  EF2E10     CLR TRISB
007820  EF2E1A     CLR CNPUB
66:                    TRISC=0x2087;
007822  220871     MOV #0x2087, W1
007824  887101     MOV W1, TRISC
67:                    TRISD=0x011E; CNPUD=0x001E;
007826  2011E1     MOV #0x11E, W1
007828  887181     MOV W1, TRISD
00782A  2001E1     MOV #0x1E, W1
00782C  8871D1     MOV W1, CNPUD
68:                    TRISE=0x7300;
00782E  273001     MOV #0x7300, W1
007830  887201     MOV W1, TRISE
69:                    TRISF=0x00F0; CNPUF=0x00F1;
007832  200F01     MOV #0xF0, W1
007834  887281     MOV W1, TRISF
007836  E80081     INC W1, W1
007838  8872D1     MOV W1, CNPUF
70:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
00783A  887350     MOV W0, CNPUG
00783C  F80E6A     PUSH CNPUG
00783E  F90E60     POP TRISG
71:                    
72:                    /* DIGITAL OUTPUT LATCH */
73:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
007840  EF2E64     CLR LATG
007842  F80E64     PUSH LATG
007844  F90E54     POP LATF
007846  F80E54     PUSH LATF
007848  F90E44     POP LATE
00784A  F80E44     PUSH LATE
00784C  F90E34     POP LATD
00784E  F80E34     PUSH LATD
007850  F90E24     POP LATC
007852  F80E24     PUSH LATC
007854  F90E14     POP LATB
007856  F80E14     PUSH LATB
007858  F90E04     POP LATA
74:                    LATA=0x0040;
00785A  200400     MOV #0x40, W0
00785C  887020     MOV W0, LATA
75:                    
76:                    /* ANALOG PINS (1 = analog) */
77:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
00785E  EF2E6E     CLR ANSELG
007860  F80E6E     PUSH ANSELG
007862  F90E5E     POP ANSELF
007864  F80E5E     PUSH ANSELF
007866  F90E4E     POP ANSELE
007868  F80E4E     PUSH ANSELE
00786A  F90E3E     POP ANSELD
00786C  F80E3E     PUSH ANSELD
00786E  F90E2E     POP ANSELC
007870  F80E2E     PUSH ANSELC
007872  F90E1E     POP ANSELB
007874  F80E1E     PUSH ANSELB
007876  F90E0E     POP ANSELA
78:                    ANSELCbits.ANSC0=1;     //AN6
007878  A80E2E     BSET ANSELC, #0
79:                    ANSELCbits.ANSC1=1;     //AN7
00787A  A82E2E     BSET ANSELC, #1
80:                    ANSELCbits.ANSC2=1;     //AN8
00787C  A84E2E     BSET ANSELC, #2
81:                    ANSELAbits.ANSA12=1;    //AN10 
00787E  A88E0F     BSET 0xE0F, #4
82:                    ANSELEbits.ANSE8=1;     //AN21
007880  A80E4F     BSET 0xE4F, #0
83:                    ANSELEbits.ANSE9=1;     //AN20
007882  A82E4F     BSET 0xE4F, #1
84:                    
85:                    
86:                    
87:                }
007884  060000     RETURN
88:                
89:                void initUART1(void){
90:                    IFS0bits.U1TXIF = 0;        //clear flag
007886  A98801     BCLR 0x801, #4
91:                    IFS0bits.U1RXIF = 0;        //clear flag
007888  A96801     BCLR 0x801, #3
92:                    U1STA=0x1510;               //enable tx & rx
00788A  215100     MOV #0x1510, W0
00788C  881110     MOV W0, U1STA
93:                    U1BRG=BRGVAL;               //baud rate
00788E  2004A0     MOV #0x4A, W0
007890  881140     MOV W0, U1BRG
94:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
007892  2FFF90     MOV #0xFFF9, W0
007894  B60220     AND U1MODE, WREG
007896  A01000     BSET W0, #1
007898  881100     MOV W0, U1MODE
95:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
00789A  270000     MOV #0x7000, W0
00789C  B72844     IOR IPC2
96:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
00789E  200070     MOV #0x7, W0
0078A0  B72846     IOR IPC3
97:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
98:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
99:                    U1MODEbits.UARTEN = 1;      //start uart
0078A2  A8E221     BSET 0x221, #7
100:                   UART_ON = TRUE;
0078A4  EFF00B     SETM.B UART_ON
101:                   
102:               }
0078A6  060000     RETURN
103:               
104:               void initADC1(void){ 
105:               
106:                   /* Assign MUXA inputs */
107:                   AD1CON1 = 0x04E4; // Enable 12-bit mode, auto-sample and auto-conversion
0078A8  204E40     MOV #0x4E4, W0
0078AA  881900     MOV W0, AD1CON1
108:                   AD1CON2 = 0x0408; // Sample alternately using channel scanning
0078AC  B10DC0     SUB #0xDC, W0
0078AE  881910     MOV W0, AD1CON2
109:                   AD1CON2bits.SMPI=POTS-1; // Sample 5 channels
0078B0  2FF830     MOV #0xFF83, W0
0078B2  B60322     AND AD1CON2, WREG
0078B4  B302C0     IOR #0x2C, W0
0078B6  881910     MOV W0, AD1CON2
110:                   AD1CON3 = 0x0F0F; // Sample for 15*TAD before converting
0078B8  20F0F0     MOV #0xF0F, W0
0078BA  881920     MOV W0, AD1CON3
111:                   AD1CON1bits.FORM=2;         //signed fractional format 
0078BC  2FCFF0     MOV #0xFCFF, W0
0078BE  B60320     AND AD1CON1, WREG
0078C0  A09000     BSET W0, #9
0078C2  881900     MOV W0, AD1CON1
112:                   AD1CON3bits.ADCS=0x3F;
0078C4  B3C3F0     MOV.B #0x3F, W0
0078C6  B7E324     MOV.B WREG, AD1CON3
113:                   AD1CON3bits.SAMC=0x0F;
0078C8  2E0FF1     MOV #0xE0FF, W1
0078CA  801920     MOV AD1CON3, W0
0078CC  608080     AND W1, W0, W1
0078CE  20F000     MOV #0xF00, W0
0078D0  700001     IOR W0, W1, W0
0078D2  881920     MOV W0, AD1CON3
114:                   //select  AN6,7,8
115:                   AD1CSSLbits.CSS6=1; //AN6
0078D4  A8C330     BSET AD1CSSL, #6
116:                   AD1CSSLbits.CSS7=1; //AN7
0078D6  A8E330     BSET AD1CSSL, #7
117:                   AD1CSSLbits.CSS8=1; //AN8
0078D8  A80331     BSET 0x331, #0
118:                   AD1CSSLbits.CSS10=1;//AN10
0078DA  A84331     BSET 0x331, #2
119:                   AD1CSSHbits.CSS20=1;//AN20
0078DC  A8832E     BSET AD1CSSH, #4
120:                   AD1CSSHbits.CSS21=1;//AN21
0078DE  A8A32E     BSET AD1CSSH, #5
121:                   //AD1CSSLbits.CSS9=1; //AN9
122:                   /* Enable ADC module and provide ADC stabilization delay */
123:                   AD1CON1bits.ADON = 1;
0078E0  A8E321     BSET 0x321, #7
124:                   Delay_us(30);
0078E2  2001E0     MOV #0x1E, W0
0078E4  070377     RCALL Delay_us
125:               }
0078E6  060000     RETURN
126:               
127:               void initPMP(void){
128:                   /*
129:                    Data is clocked on falling edge of E
130:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
131:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
132:                    */
133:                   PMMODEbits.MODE=3;  //master mode 1 
0078E8  203000     MOV #0x300, W0
0078EA  B72602     IOR PMMODE
134:                   PMCONbits.PTWREN = 1;
0078EC  A82601     BSET 0x601, #1
135:                   PMCONbits.PTRDEN = 1;
0078EE  A80601     BSET 0x601, #0
136:                   PMCONbits.WRSP=1;   //write strobe active high
0078F0  A82600     BSET PMCON, #1
137:                   PMCONbits.RDSP=1;   //read strobe active high
0078F2  A80600     BSET PMCON, #0
138:               
139:                   PMMODEbits.WAITB = 0;
0078F4  2FF3F0     MOV #0xFF3F, W0
0078F6  B62602     AND PMMODE
140:                   PMMODEbits.WAITM = 0xC;
0078F8  2FFC30     MOV #0xFFC3, W0
0078FA  B60602     AND PMMODE, WREG
0078FC  B30300     IOR #0x30, W0
0078FE  883010     MOV W0, PMMODE
141:                   PMMODEbits.WAITE = 0;
007900  2FFFC0     MOV #0xFFFC, W0
007902  B62602     AND PMMODE
142:                   LCD_RS=0;
007904  A9EE45     BCLR 0xE45, #7
143:                   PMCONbits.PMPEN = 1;
007906  A8E601     BSET 0x601, #7
144:                   
145:                   /* INIT DEVICE */
146:                   Delay_us(40000);
007908  29C400     MOV #0x9C40, W0
00790A  070364     RCALL Delay_us
147:                   lcdInit();
00790C  070236     RCALL lcdInit
148:                   
149:                   /* SETUP SCREEN */
150:                   //lcdSetupPots();
151:               }
00790E  060000     RETURN
152:               
153:               
154:               //Description: Initializes timer for LED's UART and display
155:               //Prereq: initUART1()
156:               //Dependencies: _T1Interrupt(void)
157:               //Frequency: 15Hz
158:               void initT1(void){          //16 bit timer
159:                   TMR1 = 0x0000;          //clear timer 4
007910  EF2100     CLR TMR1
160:                   T1CONbits.TCKPS = 3;    //prescale 1:256
007912  200300     MOV #0x30, W0
007914  B72104     IOR T1CON
161:                   T1CONbits.TCS = 0;      //use internal clock
007916  A92104     BCLR T1CON, #1
162:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
007918  A9C104     BCLR T1CON, #6
163:                   PR1 = Fcy/(256*Fdisp);    //period register
00791A  234BC0     MOV #0x34BC, W0
00791C  880810     MOV W0, PR1
164:                   //PR1=0x7FFF;
165:               
166:                   T1CONbits.TON = 1;      //start timer
00791E  A8E105     BSET 0x105, #7
167:               }
007920  060000     RETURN
168:               
169:               //Description:  Initializes timer handles polling button input
170:               //Prereq: initADC1() 
171:               //Dependencies: _T2Interrupt(void)
172:               //Frequency: 512Hz
173:               void initT2(void){          //16/32 bit timer
174:                   TMR2 = 0x0000;          //clear timer 4
007922  EF2106     CLR TMR2
175:                   T2CONbits.T32 = 0;      //16 bit mode
007924  A96110     BCLR T2CON, #3
176:                   T2CONbits.TCKPS = 1;    //prescale 1:8
007926  2FFCF0     MOV #0xFFCF, W0
007928  B60110     AND T2CON, WREG
00792A  A04000     BSET W0, #4
00792C  880880     MOV W0, T2CON
177:                   T2CONbits.TCS = 0;      //use internal clock
00792E  A92110     BCLR T2CON, #1
178:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
007930  A9C110     BCLR T2CON, #6
179:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
007932  283D60     MOV #0x83D6, W0
007934  880860     MOV W0, PR2
180:               
181:                   T2CONbits.TON = 1;      //start timer
007936  A8E111     BSET 0x111, #7
182:               }
007938  060000     RETURN
183:               
184:               //Description: Initialize timer handling LCD sending
185:               //Dependencies: _T3Interrupt(void)
186:               //Frequency: 44.1kHz
187:               void initT3(void){          //16/32 bit timer
188:                   TMR3 = 0x0000;          //clear timer 3
00793A  EF210A     CLR TMR3
189:                   T3CONbits.TCKPS = 1;    //prescale 8:1
00793C  2FFCF0     MOV #0xFFCF, W0
00793E  B60112     AND T3CON, WREG
007940  A04000     BSET W0, #4
007942  880890     MOV W0, T3CON
190:                   T3CONbits.TCS = 0;      //use internal clock
007944  A92112     BCLR T3CON, #1
191:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
007946  A9C112     BCLR T3CON, #6
192:                   //PR3 = Fcy/(256*T3freq);           //period register
193:                   PR3 = 0x01D0;           //45uS initial delay
007948  201D00     MOV #0x1D0, W0
00794A  880870     MOV W0, PR3
194:                   
195:                   T3CONbits.TON = 1;
00794C  A8E113     BSET 0x113, #7
196:                   
197:               }
00794E  060000     RETURN
198:               
199:               /*=============================================================================  
200:               Timer 5 is setup to time-out every 125 microseconds (8Khz Rate). As a result, the module 
201:               will stop sampling and trigger a conversion on every Timer3 time-out, i.e., Ts=125us. 
202:               =============================================================================*/
203:               void initT5() 
204:               {
205:                       TMR5 = 0x0000;
007950  EF2118     CLR TMR5
206:                       PR5 = 4999;
007952  213870     MOV #0x1387, W0
007954  8808E0     MOV W0, PR5
207:                       T5CONbits.TCKPS = 2;    //prescale 8:1
007956  2FFCF0     MOV #0xFFCF, W0
007958  B60120     AND T5CON, WREG
00795A  A05000     BSET W0, #5
00795C  880900     MOV W0, T5CON
208:                       IFS1bits.T5IF = 0;
00795E  A98803     BCLR 0x803, #4
209:                       IEC1bits.T5IE = 0;
007960  A98823     BCLR 0x823, #4
210:               
211:                       //Start Timer 3
212:                       T5CONbits.TON = 1;
007962  A8E121     BSET 0x121, #7
213:               
214:               }
007964  060000     RETURN
215:               
216:               //Description: Initializes & starts 16 bit DCI I2S DAC
217:               //Prereq: initSPI_ADC(void)
218:               //Dependencies: readDAC(void)
219:               void initDCI_DAC(void){
220:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
007966  2F0000     MOV #0xF000, W0
007968  B60284     AND DCICON3, WREG
00796A  B30170     IOR #0x17, W0
00796C  881420     MOV W0, DCICON3
221:                   DCICON1bits.COFSM=1;                //i2s mode
00796E  2FFFC0     MOV #0xFFFC, W0
007970  B60280     AND DCICON1, WREG
007972  A00000     BSET W0, #0
007974  881400     MOV W0, DCICON1
222:                   DCICON1bits.CSCKE=1;                //sample on rising edge
007976  A82281     BSET 0x281, #1
223:                   DCICON2bits.WS=0xF;                 //16 bit data word
007978  2000F0     MOV #0xF, W0
00797A  B72282     IOR DCICON2
224:                   DCICON2bits.COFSG=0;    //data frame has 1 word (per frame)
00797C  2FE1F0     MOV #0xFE1F, W0
00797E  B62282     AND DCICON2
225:                   DCICON1bits.DJST=0;     //align data
007980  A9A280     BCLR DCICON1, #5
226:                   DCICON2bits.BLEN=3;     //4 words buffer btwn interrupts
007982  20C000     MOV #0xC00, W0
007984  B72282     IOR DCICON2
227:                   
228:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
007986  A80288     BSET TSCON, #0
229:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
007988  A82288     BSET TSCON, #1
230:                   TSCONbits.TSE2 = 1;     // Transmit on Time Slot 2     
00798A  A84288     BSET TSCON, #2
231:                   TSCONbits.TSE3 = 1;     // Transmit on Time Slot 3   
00798C  A86288     BSET TSCON, #3
232:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
00798E  A8028C     BSET RSCON, #0
233:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
007990  A8228C     BSET RSCON, #1
234:                   RSCONbits.RSE2 = 1;     // rcv on Time Slot 2     
007992  A8428C     BSET RSCON, #2
235:                   RSCONbits.RSE3 = 1;     // rcv on Time Slot 3 
007994  A8628C     BSET RSCON, #3
236:                   
237:               
238:                   
239:                   IPC15bits.DCIIP = 6;    // Interrput priority
007996  2FFF80     MOV #0xFFF8, W0
007998  B6085E     AND IPC15, WREG
00799A  B30060     IOR #0x6, W0
00799C  8842F0     MOV W0, IPC15
240:                   IFS3bits.DCIIF=0;
00799E  A98807     BCLR 0x807, #4
241:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
0079A0  A88827     BSET 0x827, #4
242:                   
243:                   // Pre-load send registers.
244:                   TXBUF0=0;
0079A2  EF2298     CLR TXBUF0
245:                   TXBUF1=0;   
0079A4  EF229A     CLR TXBUF1
246:                   TXBUF2=0;
0079A6  EF229C     CLR TXBUF2
247:                   TXBUF3=0;
0079A8  EF229E     CLR TXBUF3
248:                   DCICON1bits.DCIEN=1;    //ENABLE
0079AA  A8E281     BSET 0x281, #7
249:                   // Stabilization delay
250:                   Delay_us(20);
0079AC  200140     MOV #0x14, W0
0079AE  070312     RCALL Delay_us
251:               }
0079B0  060000     RETURN
252:               
253:               void initDMA0(void){
254:                   unsigned long address;
255:                   
256:                   /*
257:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
258:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
259:                   DMA0PAD =  0X0608; // Point DMA to PMP
260:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
261:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
262:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
263:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
264:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
265:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
266:                   DMA0CONbits.CHEN=1; // Enable DMA
267:                   */
268:                   
269:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
0079B2  A9CB01     BCLR 0xB01, #6
270:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
0079B4  A8AB01     BSET 0xB01, #5
271:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
0079B6  2FFCF4     MOV #0xFFCF, W4
0079B8  20B000     MOV #0xB00, W0
0079BA  620810     AND W4, [W0], [W0]
272:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
0079BC  2FFFC3     MOV #0xFFFC, W3
0079BE  805801     MOV DMA0CON, W1
0079C0  618001     AND W3, W1, W0
0079C2  A01000     BSET W0, #1
0079C4  885800     MOV W0, DMA0CON
273:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
0079C6  A98B01     BCLR 0xB01, #4
274:                   DMA0CONbits.NULLW = 0;
0079C8  A96B01     BCLR 0xB01, #3
275:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
0079CA  A9EB03     BCLR 0xB03, #7
276:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
0079CC  B3C3C2     MOV.B #0x3C, W2
0079CE  20B025     MOV #0xB02, W5
0079D0  784A82     MOV.B W2, [W5]
277:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
0079D2  27FFF0     MOV #0x7FFF, W0
0079D4  2CE001     MOV #0xCE00, W1
0079D6  608080     AND W1, W0, W1
278:                   address +=__builtin_edspage(txBufferA) << 15;
0079D8  200016     MOV #0x1, W6
0079DA  DD334F     SL W6, #15, W6
0079DC  EB0380     CLR W7
0079DE  408306     ADD W1, W6, W6
0079E0  4B83E0     ADDC W7, #0x0, W7
279:                   DMA0STAL = address & 0xFFFF;
0079E2  885826     MOV W6, DMA0STAL
280:                   DMA0STAH = address >>16;
0079E4  885837     MOV W7, DMA0STAH
281:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
0079E6  2CC001     MOV #0xCC00, W1
0079E8  608080     AND W1, W0, W1
282:                   address +=__builtin_edspage(txBufferB) << 15;
0079EA  200016     MOV #0x1, W6
0079EC  DD334F     SL W6, #15, W6
0079EE  EB0380     CLR W7
0079F0  408306     ADD W1, W6, W6
0079F2  4B83E0     ADDC W7, #0x0, W7
283:                   DMA0STBL = address & 0xFFFF;
0079F4  885846     MOV W6, DMA0STBL
284:                   DMA0STBH = address >>16;
0079F6  885857     MOV W7, DMA0STBH
285:                   DMA0PAD = (int)&TXBUF0;
0079F8  202981     MOV #0x298, W1
0079FA  885861     MOV W1, DMA0PAD
286:                   DMA0CNT = STREAMBUF-1;
0079FC  200FF1     MOV #0xFF, W1
0079FE  885871     MOV W1, DMA0CNT
287:                   /* DMA 2 - DCI to DPSRAM*/
288:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
007A00  A9CB21     BCLR 0xB21, #6
289:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
007A02  A9AB21     BCLR 0xB21, #5
290:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
007A04  A98B21     BCLR 0xB21, #4
291:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
007A06  A96B21     BCLR 0xB21, #3
292:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
007A08  20B205     MOV #0xB20, W5
007A0A  620A95     AND W4, [W5], [W5]
293:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
007A0C  805904     MOV DMA2CON, W4
007A0E  618184     AND W3, W4, W3
007A10  A01003     BSET W3, #1
007A12  885903     MOV W3, DMA2CON
294:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
007A14  A9EB23     BCLR 0xB23, #7
295:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
007A16  784182     MOV.B W2, W3
007A18  20B225     MOV #0xB22, W5
007A1A  784A83     MOV.B W3, [W5]
296:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
007A1C  2CA004     MOV #0xCA00, W4
007A1E  620200     AND W4, W0, W4
297:                   address +=__builtin_edspage(rxBufferA) << 15;
007A20  200012     MOV #0x1, W2
007A22  DD114F     SL W2, #15, W2
007A24  EB0180     CLR W3
007A26  420102     ADD W4, W2, W2
007A28  4981E0     ADDC W3, #0x0, W3
298:                   DMA2STAL = address & 0xFFFF;
007A2A  885922     MOV W2, DMA2STAL
299:                   DMA2STAH = address >>16;
007A2C  885933     MOV W3, DMA2STAH
300:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
007A2E  2C8002     MOV #0xC800, W2
007A30  610000     AND W2, W0, W0
301:                   address +=__builtin_edspage(rxBufferB) << 15;
007A32  200012     MOV #0x1, W2
007A34  DD114F     SL W2, #15, W2
007A36  EB0180     CLR W3
007A38  400102     ADD W0, W2, W2
007A3A  4981E0     ADDC W3, #0x0, W3
302:                   DMA2STBL = address & 0xFFFF;
007A3C  885942     MOV W2, DMA2STBL
303:                   DMA2STBH = address >>16;
007A3E  885953     MOV W3, DMA2STBH
304:                   DMA2PAD = (int)&RXBUF0;
007A40  202900     MOV #0x290, W0
007A42  885960     MOV W0, DMA2PAD
305:                   DMA2CNT = STREAMBUF-1;
007A44  885971     MOV W1, DMA2CNT
306:                   _DMA2IP = 5;
007A46  2FFF80     MOV #0xFFF8, W0
007A48  B6084C     AND IPC6, WREG
007A4A  B30050     IOR #0x5, W0
007A4C  884260     MOV W0, IPC6
307:                   _DMA2IE = 1;
007A4E  A80823     BSET 0x823, #0
308:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
007A50  A8EB01     BSET 0xB01, #7
309:                   DMA2CONbits.CHEN = 1;
007A52  A8EB21     BSET 0xB21, #7
310:               }
007A54  060000     RETURN
311:               
312:               void initSPI3_MEM(void){
313:                   int i=0;
314:                   
315:                   SS3=1;                     // Assert chip select (active low)
007A56  A82E54     BSET LATF, #1
316:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
007A58  A9680B     BCLR 0x80B, #3
317:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
007A5A  A9682B     BCLR 0x82B, #3
318:                   SPI3CON1bits.MSTEN=1;       //master mode
007A5C  A8A2A2     BSET SPI3CON1, #5
319:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
007A5E  A982A3     BCLR 0x2A3, #4
320:                   SPI3CON1bits.MODE16=0;      //8 bit
007A60  A942A3     BCLR 0x2A3, #2
321:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
007A62  A962A3     BCLR 0x2A3, #3
322:                   SPI3CON1bits.SSEN=1;        //use SS
007A64  A8E2A2     BSET SPI3CON1, #7
323:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
007A66  A9E2A5     BCLR 0x2A5, #7
324:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
007A68  A902A4     BCLR SPI3CON2, #0
325:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
007A6A  2FFE33     MOV #0xFFE3, W3
007A6C  801300     MOV SPI2STAT, W0
007A6E  618080     AND W3, W0, W1
007A70  B30141     IOR #0x14, W1
007A72  881301     MOV W1, SPI2STAT
326:                   
327:                   SPI3CON1bits.SMP=1;         //data sampled at end of output time
007A74  A822A3     BSET 0x2A3, #1
328:                   SPI3CON1bits.CKP=0;         //idle clock is low
007A76  A9C2A2     BCLR SPI3CON1, #6
329:                   SPI3CON1bits.CKE=1;         //data changes from H to L
007A78  A802A3     BSET 0x2A3, #0
330:                   
331:                   SPI3CON1bits.PPRE=3;        //1:1 primary prescale
007A7A  200030     MOV #0x3, W0
007A7C  B722A2     IOR SPI3CON1
332:                   SPI3CON1bits.SPRE=6;        //2:1 secondary
007A7E  801511     MOV SPI3CON1, W1
007A80  618001     AND W3, W1, W0
007A82  B30180     IOR #0x18, W0
007A84  881510     MOV W0, SPI3CON1
333:                   
334:                   SPI3STATbits.SPIROV = 0;        // Clear SPI1 receive overflow flag if set
007A86  A9C2A0     BCLR SPI3STAT, #6
335:                   //IPC22bits.SPI3IP = 3;         // Interrupt priority
336:                   //IFS5bits.SPI3IF = 0;          // Clear the Interrupt flag
337:                   //IEC5bits.SPI3IE = 0;          // Enable the interrupt
338:                   SPI3STATbits.SPIEN = 1;         //start SPI module
007A88  A8E2A1     BSET 0x2A1, #7
339:                  
340:                   Delay_us(20);                       // Stabilization Delay
007A8A  200140     MOV #0x14, W0
007A8C  0702A3     RCALL Delay_us
341:                   
342:                   flashWriteReg(FLASH_WREN);
007A8E  B3C060     MOV.B #0x6, W0
007A90  0704F2     RCALL flashWriteReg
343:                   /*
344:                   flashBulkErase();
345:                   while(flashStatusCheck()&1);
346:               
347:                   flashWritePage
348:                   while(flashStatusCheck()&1);
349:                   */
350:                   
351:                   flashRead(flash_readback, 256);     // READBACK
007A92  201001     MOV #0x100, W1
007A94  25EA60     MOV #0x5EA6, W0
007A96  070543     RCALL flashRead
352:                   
353:               }
007A98  060000     RETURN
354:               
355:               void initQEI_ENC(void){
356:                   QEI1CONbits.INTDIV=6;       // 1:64 prescaler
007A9A  2FF8F0     MOV #0xFF8F, W0
007A9C  B601C0     AND QEI1CON, WREG
007A9E  B30600     IOR #0x60, W0
007AA0  880E00     MOV W0, QEI1CON
357:                   QEI1IOCbits.FLTREN=1;       // Enable input filter
007AA2  A8C1C3     BSET 0x1C3, #6
358:                   QEI1CONbits.QEIEN=1;        // Enable Quad encoder inteface
007AA4  A8E1C1     BSET 0x1C1, #7
359:               }
007AA6  060000     RETURN
360:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/audio.c  ----------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[8];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[4];
7:                 extern fractional pots_scaled[4];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                fractional mixer(fractional sample){
007FE6  F80022     PUSH ACCA
007FE8  F80024     PUSH ACCAH
007FEA  F80026     PUSH ACCAU
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    
38:                
39:                    if(kick_playing==TRUE&&kick_ptr<kick_max){
007FEC  210381     MOV #0x1038, W1
007FEE  784091     MOV.B [W1], W1
007FF0  40CFE1     ADD.B W1, #0x1, [W15]
007FF2  3A0011     BRA NZ, 0x8016
007FF4  877662     MOV 0xEECC, W2
007FF6  8081D3     MOV kick_ptr, W3
007FF8  518F82     SUB W3, W2, [W15]
007FFA  31000D     BRA C, 0x8016
40:                        result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
007FFC  780200     MOV W0, W4
007FFE  273325     MOV #0x7332, W5
008000  C00113     MPY W4*W5, A
41:                        result1 = __builtin_add(result1,kick[kick_ptr++],0);
008002  780003     MOV W3, W0
008004  400080     ADD W0, W0, W1
008006  2C36C2     MOV #0xC36C, W2
008008  410081     ADD W2, W1, W1
00800A  780091     MOV [W1], W1
00800C  E80000     INC W0, W0
00800E  8881D0     MOV W0, kick_ptr
008010  C90001     ADD W1, A
42:                        sample=__builtin_sac(result1, 0);
008012  CC0000     SAC A, W0
008014  37000C     BRA 0x802E
43:                    }
44:                    else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
008016  260A62     MOV #0x60A6, W2
008018  B3C013     MOV.B #0x1, W3
00801A  11CF92     SUBR.B W3, [W2], [W15]
00801C  3A0008     BRA NZ, 0x802E
00801E  40CFE1     ADD.B W1, #0x1, [W15]
008020  3A0006     BRA NZ, 0x802E
008022  877661     MOV 0xEECC, W1
008024  8081D4     MOV kick_ptr, W4
008026  520F81     SUB W4, W1, [W15]
008028  3A0002     BRA NZ, 0x802E
45:                        kick_playing=FALSE;
00802A  EF7038     CLR.B kick_playing
46:                        kick_ptr=0;
00802C  EF303A     CLR kick_ptr
47:                    }
48:                    /*
49:                    if(hat_playing==TRUE&&hat_ptr<hat_max){
50:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
51:                        result1 = __builtin_add(result1,hat[hat_ptr++],0);
52:                        sample=__builtin_sac(result1, 0);
53:                    }
54:                    else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
55:                        hat_playing=FALSE;
56:                        hat_ptr=0;
57:                    }
58:                     */
59:                
60:                    if(snare_playing==TRUE&&snare_ptr<snare_max){
00802E  2103C1     MOV #0x103C, W1
008030  784091     MOV.B [W1], W1
008032  40CFE1     ADD.B W1, #0x1, [W15]
008034  3A0011     BRA NZ, 0x8058
008036  877672     MOV 0xEECE, W2
008038  8081F5     MOV snare_ptr, W5
00803A  528F82     SUB W5, W2, [W15]
00803C  31000D     BRA C, 0x8058
61:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
00803E  780200     MOV W0, W4
008040  26CCC5     MOV #0x6CCC, W5
008042  C00113     MPY W4*W5, A
62:                        result1 = __builtin_add(result1,snare[snare_ptr++],0);
008044  8081F0     MOV snare_ptr, W0
008046  400080     ADD W0, W0, W1
008048  292942     MOV #0x9294, W2
00804A  410081     ADD W2, W1, W1
00804C  780091     MOV [W1], W1
00804E  E80000     INC W0, W0
008050  8881F0     MOV W0, snare_ptr
008052  C90001     ADD W1, A
63:                        sample=__builtin_sac(result1, 0);
008054  CC0000     SAC A, W0
008056  37000C     BRA 0x8070
64:                    }
65:                    else if (pad[1]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
008058  260A72     MOV #0x60A7, W2
00805A  B3C013     MOV.B #0x1, W3
00805C  11CF92     SUBR.B W3, [W2], [W15]
00805E  3A0008     BRA NZ, 0x8070
008060  40CFE1     ADD.B W1, #0x1, [W15]
008062  3A0006     BRA NZ, 0x8070
008064  877671     MOV 0xEECE, W1
008066  8081F4     MOV snare_ptr, W4
008068  520F81     SUB W4, W1, [W15]
00806A  3A0002     BRA NZ, 0x8070
66:                        snare_playing=FALSE;
00806C  EF703C     CLR.B snare_playing
67:                        snare_ptr=0;
00806E  EF303E     CLR snare_ptr
68:                    }
69:                    
70:                    
71:                    //VOLUME CONTROL
72:                    
73:                    if(pots[2]==0x0007)
008070  82F3D4     MOV 0x5E7A, W4
008072  520FE7     SUB W4, #0x7, [W15]
008074  320007     BRA Z, 0x8084
74:                        sample=0;
008084  EB0000     CLR W0
75:                    else if(pots[2]>=0x7FF7);
008076  27FF61     MOV #0x7FF6, W1
008078  520F81     SUB W4, W1, [W15]
00807A  3C0005     BRA GT, 0x8086
76:                    else{
77:                        result1 =__builtin_mpy(sample,pots[2], NULL, NULL, 0, NULL, NULL, 0);
00807C  780280     MOV W0, W5
00807E  C00113     MPY W4*W5, A
78:                        sample=__builtin_sac(result1, 0);
008080  CC0000     SAC A, W0
008082  370001     BRA 0x8086
79:                    }
80:                    
81:                    if (TEST_SIN==TRUE){
008086  2100C1     MOV #0x100C, W1
008088  784091     MOV.B [W1], W1
00808A  40CFE1     ADD.B W1, #0x1, [W15]
00808C  3A000B     BRA NZ, 0x80A4
82:                        i++;
00808E  EC1028     INC i, WREG
008090  888140     MOV W0, i
83:                        if(i==1024)
008092  204001     MOV #0x400, W1
008094  500F81     SUB W0, W1, [W15]
008096  3A0001     BRA NZ, 0x809A
84:                            i=0;
008098  EF3028     CLR i
85:                        return sintab[i];
00809A  808140     MOV i, W0
00809C  400000     ADD W0, W0, W0
00809E  2EED21     MOV #0xEED2, W1
0080A0  408000     ADD W1, W0, W0
0080A2  780010     MOV [W0], W0
86:                    }
87:                    else 
88:                        return sample;
89:                    
90:                }
0080A4  F90026     POP ACCAU
0080A6  F90024     POP ACCAH
0080A8  F90022     POP ACCA
0080AA  060000     RETURN
91:                
92:                fractional fx(fractional sample){
0080AC  F80022     PUSH ACCA
0080AE  F80024     PUSH ACCAH
0080B0  F80026     PUSH ACCAU
0080B2  F80028     PUSH ACCB
0080B4  F8002A     PUSH ACCBH
0080B6  F8002C     PUSH ACCBU
93:                    volatile register int result1 asm("A");
94:                    volatile register int result2 asm("B");
95:                    static fractional delayed_sample;
96:                    static fractional trem_mod;
97:                    if(tremelo==TRUE){                                                          //TREMELO//
0080B8  2100D1     MOV #0x100D, W1
0080BA  784091     MOV.B [W1], W1
0080BC  40CFE1     ADD.B W1, #0x1, [W15]
0080BE  3A0027     BRA NZ, 0x810E
98:                        if (trem_var<=pots[3]){
0080C0  808101     MOV trem_var, W1
0080C2  82F3E2     MOV 0x5E7C, W2
0080C4  510F81     SUB W2, W1, [W15]
0080C6  39000F     BRA NC, 0x80E6
99:                            trem_var++;
0080C8  E80081     INC W1, W1
0080CA  888101     MOV W1, trem_var
100:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
0080CC  8080E1     MOV tremelo_ptr, W1
0080CE  408081     ADD W1, W1, W1
0080D0  2EED22     MOV #0xEED2, W2
0080D2  410081     ADD W2, W1, W1
0080D4  780291     MOV [W1], W5
0080D6  808274     MOV 0x104E, W4
0080D8  C00113     MPY W4*W5, A
101:                           trem_mod=__builtin_sac(result1, 0);
0080DA  CC0004     SAC A, W4
0080DC  888124     MOV W4, trem_mod
102:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
0080DE  780280     MOV W0, W5
0080E0  C08113     MPY W4*W5, B
103:                           sample=__builtin_sac(result2, 0);
0080E2  CC8000     SAC B, W0
0080E4  370014     BRA 0x810E
104:                       }
105:                       else{
106:                           trem_var=0;
0080E6  EF3020     CLR trem_var
107:                           if(tremelo_ptr==1024)
0080E8  204001     MOV #0x400, W1
0080EA  8080E2     MOV tremelo_ptr, W2
0080EC  510F81     SUB W2, W1, [W15]
0080EE  3A0001     BRA NZ, 0x80F2
108:                               tremelo_ptr=0;
0080F0  EF301C     CLR tremelo_ptr
109:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
0080F2  8080E1     MOV tremelo_ptr, W1
0080F4  408101     ADD W1, W1, W2
0080F6  2EED23     MOV #0xEED2, W3
0080F8  418102     ADD W3, W2, W2
0080FA  780292     MOV [W2], W5
0080FC  E80081     INC W1, W1
0080FE  8880E1     MOV W1, tremelo_ptr
008100  808274     MOV 0x104E, W4
008102  C00113     MPY W4*W5, A
110:                           trem_mod=__builtin_sac(result1, 0);
008104  CC0004     SAC A, W4
008106  888124     MOV W4, trem_mod
111:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008108  780280     MOV W0, W5
00810A  C08113     MPY W4*W5, B
112:                           sample=__builtin_sac(result2, 0);
00810C  CC8000     SAC B, W0
113:                       }
114:                   }
115:                   if(looper==TRUE){                                                           //LOOPER// 
00810E  2100E1     MOV #0x100E, W1
008110  784091     MOV.B [W1], W1
008112  40CFE1     ADD.B W1, #0x1, [W15]
008114  3A0019     BRA NZ, 0x8148
116:                       if(loop_lim>=LOOP_BUF_SIZE)
008116  2270F0     MOV #0x270F, W0
008118  E3101A     CP loop_lim
00811A  360002     BRA LEU, 0x8120
117:                           loop_lim=LOOP_BUF_SIZE;
00811C  E80000     INC W0, W0
00811E  8880D0     MOV W0, loop_lim
118:                       if(loop_ptr<loop_lim){
008120  8080D0     MOV loop_lim, W0
008122  E31018     CP loop_ptr
008124  310008     BRA C, 0x8136
119:                           sample = (loop[loop_ptr++]);
008126  8080C1     MOV loop_ptr, W1
008128  408001     ADD W1, W1, W0
00812A  210562     MOV #0x1056, W2
00812C  410000     ADD W2, W0, W0
00812E  780010     MOV [W0], W0
008130  E80081     INC W1, W1
008132  8880C1     MOV W1, loop_ptr
008134  37001D     BRA 0x8170
120:                       }
121:                       else {
122:                           loop_ptr=0;
008136  EF3018     CLR loop_ptr
123:                           sample = (loop[loop_ptr++]);
008138  8080C1     MOV loop_ptr, W1
00813A  408001     ADD W1, W1, W0
00813C  210562     MOV #0x1056, W2
00813E  410000     ADD W2, W0, W0
008140  780010     MOV [W0], W0
008142  E80081     INC W1, W1
008144  8880C1     MOV W1, loop_ptr
008146  370014     BRA 0x8170
124:                       }
125:                   }                                                                           
126:                   else {                                                                      //buffer
127:                       if(loop_ptr<LOOP_BUF_SIZE)
008148  2270F1     MOV #0x270F, W1
00814A  8080C2     MOV loop_ptr, W2
00814C  510F81     SUB W2, W1, [W15]
00814E  3E0008     BRA GTU, 0x8160
128:                           loop[loop_ptr++]=sample;
008150  8080C1     MOV loop_ptr, W1
008152  408101     ADD W1, W1, W2
008154  210563     MOV #0x1056, W3
008156  418102     ADD W3, W2, W2
008158  780900     MOV W0, [W2]
00815A  E80081     INC W1, W1
00815C  8880C1     MOV W1, loop_ptr
00815E  370008     BRA 0x8170
129:                       else {
130:                           loop_ptr=0;
008160  EF3018     CLR loop_ptr
131:                           loop[loop_ptr++]=sample;
008162  8080C1     MOV loop_ptr, W1
008164  408101     ADD W1, W1, W2
008166  210563     MOV #0x1056, W3
008168  418102     ADD W3, W2, W2
00816A  780900     MOV W0, [W2]
00816C  E80081     INC W1, W1
00816E  8880C1     MOV W1, loop_ptr
132:                       }
133:                   }
134:                   
135:                                                                                               //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
136:                   if(lpf==TRUE){
008170  2100F1     MOV #0x100F, W1
008172  784091     MOV.B [W1], W1
008174  40CFE1     ADD.B W1, #0x1, [W15]
008176  3A0008     BRA NZ, 0x8188
137:                       result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
008178  808254     MOV divtestb, W4
00817A  780280     MOV W0, W5
00817C  C08113     MPY W4*W5, B
138:                       result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
00817E  808264     MOV 0x104C, W4
008180  808135     MOV delayed_sample, W5
008182  C08112     MAC W4*W5, B
139:                       delayed_sample=__builtin_sac(result2, 0);
008184  CC8000     SAC B, W0
008186  888130     MOV W0, delayed_sample
140:                       sample=delayed_sample;
141:                   }
142:                   return sample;
143:               }
008188  F9002C     POP ACCBU
00818A  F9002A     POP ACCBH
00818C  F90028     POP ACCB
00818E  F90026     POP ACCAU
008190  F90024     POP ACCAH
008192  F90022     POP ACCA
008194  060000     RETURN
144:               
145:               //test
