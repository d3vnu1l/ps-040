Disassembly Listing for sampler_0.49.2
Generated From:
C:/Users/ryan/Documents/seniorproject/ps-040/dist/default/production/ps-040.production.elf
Jan 22, 2018 11:14:08 AM

---  C:/Users/ryan/Documents/seniorproject/ps-040/utilitites.c  -----------------------------------------
1:                 #include "utilities.h"
2:                 #include <xc.h>
3:                 #include <p33EP512GM310.h>
4:                 #include <libpic30.h>
5:                 #include <dsp.h>
6:                 #include <stdio.h>
7:                 #include <stdlib.h>
8:                 #include <math.h>
9:                 #include "common.h"
10:                #include "sounds.h"
11:                #include "audio.h"
12:                #include "plcd.h"
13:                
14:                #include "devInits.h"
15:                
16:                
17:                //CONTROL VARIABLES//
18:                extern unsigned char pad[8];
19:                extern fractional pots[4];
20:                extern fractional pots_scaled[4];
21:                extern unsigned char UART_ON; 
22:                
23:                //STATUS VARIABLES//
24:                extern unsigned char hard_clipped;
25:                extern unsigned char UART_EN;
26:                extern unsigned int cycle;
27:                extern unsigned char TEST_SIN;
28:                extern fractional sampin;
29:                extern fractional sampout;
30:                
31:                
32:                //FX FLAGS & VARS
33:                extern unsigned char tremelo, looper, lpf;
34:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
35:                extern unsigned int loop_lim;
36:                extern fractional lpf_alpha, lpf_inv_alpha;
37:                extern fractional tremelo_depth;
38:                extern unsigned char kick_playing, snare_playing;   
39:                extern unsigned char frame;
40:                
41:                void scanMatrix(void){
42:                    static unsigned char pad_last[17]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
43:                    int portrdG, portrdD, portrdF;
44:                    //
45:                    portrdG = PORTG;
007E0C  807310     MOV PORTG, W0
46:                    portrdD = PORTD;
007E0E  807191     MOV PORTD, W1
47:                    portrdF = PORTF;
007E10  807292     MOV PORTF, W2
48:                    
49:                    int trash=SPI3BUF;
007E12  801543     MOV SPI3BUF, W3
50:                    SPI3BUF=0xAAAA;
007E14  2AAAA3     MOV #0xAAAA, W3
007E16  881543     MOV W3, SPI3BUF
51:                   
52:                    pad[0]=(portrdG)&1;
007E18  262403     MOV #0x6240, W3
007E1A  6049E1     AND.B W0, #0x1, [W3]
53:                    pad[1]=(portrdG>>1)&1;
007E1C  D18200     ASR W0, W4
007E1E  E80183     INC W3, W3
007E20  6249E1     AND.B W4, #0x1, [W3]
54:                    pad[2]=(portrdG>>2)&1;
007E22  DE8242     ASR W0, #2, W4
007E24  E80183     INC W3, W3
007E26  6249E1     AND.B W4, #0x1, [W3]
55:                    pad[3]=(portrdG>>3)&1;
007E28  DE8243     ASR W0, #3, W4
007E2A  E80183     INC W3, W3
007E2C  6249E1     AND.B W4, #0x1, [W3]
56:                    pad[11]=(portrdG>>11)&1;
007E2E  DE824B     ASR W0, #11, W4
007E30  4181E8     ADD W3, #0x8, W3
007E32  6249E1     AND.B W4, #0x1, [W3]
57:                    pad[12]=(portrdG>>12)&1;
007E34  DE824C     ASR W0, #12, W4
007E36  E80183     INC W3, W3
007E38  6249E1     AND.B W4, #0x1, [W3]
58:                    pad[13]=(portrdG>>13)&1;
007E3A  DE824D     ASR W0, #13, W4
007E3C  E80183     INC W3, W3
007E3E  6249E1     AND.B W4, #0x1, [W3]
59:                    pad[14]=(portrdG>>14)&1;
007E40  DE824E     ASR W0, #14, W4
007E42  E80183     INC W3, W3
007E44  6249E1     AND.B W4, #0x1, [W3]
60:                    pad[15]=(portrdG>>15)&1;
007E46  DE004F     LSR W0, #15, W0
007E48  E80183     INC W3, W3
007E4A  784980     MOV.B W0, [W3]
61:                    
62:                    pad[4]=(portrdF>>4)&1;
007E4C  DE91C4     ASR W2, #4, W3
007E4E  262440     MOV #0x6244, W0
007E50  61C861     AND.B W3, #0x1, [W0]
63:                    pad[5]=(portrdF>>5)&1;
007E52  DE91C5     ASR W2, #5, W3
007E54  E80000     INC W0, W0
007E56  61C861     AND.B W3, #0x1, [W0]
64:                    pad[6]=(portrdF>>6)&1;
007E58  DE91C6     ASR W2, #6, W3
007E5A  E80000     INC W0, W0
007E5C  61C861     AND.B W3, #0x1, [W0]
65:                    pad[16]=(portrdF>>7)&1;
007E5E  DE9147     ASR W2, #7, W2
007E60  40006A     ADD W0, #0xA, W0
007E62  614861     AND.B W2, #0x1, [W0]
66:                    
67:                    pad[7]=(portrdD>>1)&1;
007E64  D18001     ASR W1, W0
007E66  604061     AND.B W0, #0x1, W0
007E68  262472     MOV #0x6247, W2
007E6A  784900     MOV.B W0, [W2]
68:                    pad[8]=(portrdD>>2)&1;
007E6C  DE89C2     ASR W1, #2, W3
007E6E  E80102     INC W2, W2
007E70  61C961     AND.B W3, #0x1, [W2]
69:                    pad[9]=(portrdD>>3)&1;
007E72  DE89C3     ASR W1, #3, W3
007E74  E80102     INC W2, W2
007E76  61C961     AND.B W3, #0x1, [W2]
70:                    pad[10]=(portrdD>>4)&1;
007E78  DE88C4     ASR W1, #4, W1
007E7A  E80102     INC W2, W2
007E7C  60C961     AND.B W1, #0x1, [W2]
71:                   
72:                    
73:                    if(pad[7]==0&&pad_last[7]==1){                                              //TREMELO CONTROL
007E7E  E00400     CP0.B W0
007E80  3A0013     BRA NZ, 0x7EA8
007E82  262591     MOV #0x6259, W1
007E84  B3C012     MOV.B #0x1, W2
007E86  114F91     SUBR.B W2, [W1], [W15]
007E88  3A000F     BRA NZ, 0x7EA8
74:                        pad_last[7]=0;
007E8A  780001     MOV W1, W0
007E8C  EB4800     CLR.B [W0]
75:                        if(tremelo==FALSE)
007E8E  E2501F     CP0.B tremelo
007E90  3A0002     BRA NZ, 0x7E96
76:                            tremelo=TRUE;
007E92  EFF01F     SETM.B tremelo
007E94  370001     BRA 0x7E98
77:                        else tremelo=FALSE;
007E96  EF701F     CLR.B tremelo
78:                        TREMELO_LED=tremelo;
007E98  BFD01F     MOV.B tremelo, WREG
007E9A  DD004F     SL W0, #15, W0
007E9C  27FFF1     MOV #0x7FFF, W1
007E9E  8071A2     MOV LATD, W2
007EA0  608082     AND W1, W2, W1
007EA2  700081     IOR W0, W1, W1
007EA4  8871A1     MOV W1, LATD
007EA6  370002     BRA 0x7EAC
79:                    }
80:                    else{
81:                        pad_last[7]=pad[7];
007EA8  262591     MOV #0x6259, W1
007EAA  784880     MOV.B W0, [W1]
82:                    }
83:                    
84:                    if(pad[4]==0){                                                              //LOOPER CONTROL
007EAC  262440     MOV #0x6244, W0
007EAE  E00410     CP0.B [W0]
007EB0  3A0003     BRA NZ, 0x7EB8
85:                        looper=TRUE;
007EB2  EFF020     SETM.B looper
86:                        YLED=looper;
007EB4  A82E44     BSET LATE, #1
007EB6  370002     BRA 0x7EBC
87:                    }
88:                    else {
89:                        looper=FALSE;
007EB8  EF7020     CLR.B looper
90:                        YLED=looper;
007EBA  A92E44     BCLR LATE, #1
91:                    }
92:                   
93:                    if(pad[15]==0&&pad_last[15]==1){                                              //LPF CONTROL
007EBC  2624F0     MOV #0x624F, W0
007EBE  784010     MOV.B [W0], W0
007EC0  E00400     CP0.B W0
007EC2  3A000C     BRA NZ, 0x7EDC
007EC4  262611     MOV #0x6261, W1
007EC6  B3C012     MOV.B #0x1, W2
007EC8  114F91     SUBR.B W2, [W1], [W15]
007ECA  3A0008     BRA NZ, 0x7EDC
94:                        pad_last[15]=0;
007ECC  780001     MOV W1, W0
007ECE  EB4800     CLR.B [W0]
95:                        if(lpf==FALSE)
007ED0  E25021     CP0.B lpf
007ED2  3A0002     BRA NZ, 0x7ED8
96:                            lpf=TRUE;
007ED4  EFF021     SETM.B lpf
007ED6  370004     BRA 0x7EE0
97:                        else lpf=FALSE;
007ED8  EF7021     CLR.B lpf
007EDA  370002     BRA 0x7EE0
98:                    }
99:                    else{
100:                       pad_last[15]=pad[15];
007EDC  262611     MOV #0x6261, W1
007EDE  784880     MOV.B W0, [W1]
101:                   }
102:                   
103:                   
104:                   /* SAMPLE TRIGGERS */
105:                   if(pad[15]==0&&kick_playing==FALSE){                                         //kick
007EE0  2624F0     MOV #0x624F, W0
007EE2  E00410     CP0.B [W0]
007EE4  3A0003     BRA NZ, 0x7EEC
007EE6  E25036     CP0.B kick_playing
007EE8  3A0001     BRA NZ, 0x7EEC
106:                       kick_playing=TRUE;
007EEA  EFF036     SETM.B kick_playing
107:                   }
108:                   /*
109:                   if(pad[2]==0&&hat_playing==FALSE){                                          //hat
110:                       hat_playing=TRUE;
111:                   }
112:                   */
113:                   if(pad[2]==0&&snare_playing==FALSE){                                        //snare
007EEC  262420     MOV #0x6242, W0
007EEE  E00410     CP0.B [W0]
007EF0  3A0003     BRA NZ, 0x7EF8
007EF2  E2503A     CP0.B snare_playing
007EF4  3A0001     BRA NZ, 0x7EF8
114:                       snare_playing=TRUE;
007EF6  EFF03A     SETM.B snare_playing
115:                   }
116:                   
117:                   //lpf=TRUE;
118:                   
119:                   
120:               }
007EF8  060000     RETURN
121:               
122:               void readPots(void){
123:                   volatile register int scaled asm("A");
124:                   
125:                   AD1CON1bits.SAMP = 0;      // start sampling
007EFA  A92320     BCLR AD1CON1, #1
126:                   while (!_AD1IF);           //wait for conversions to complete
007EFC  220001     MOV #0x2000, W1
007EFE  804002     MOV IFS0, W2
007F00  608002     AND W1, W2, W0
007F02  32FFFD     BRA Z, 0x7EFE
127:                   _AD1IF = 0;                //clear status bit
007F04  A9A801     BCLR 0x801, #5
128:                   pots[0]=(ADC1BUF0>>1)+0x1F;
007F06  210000     MOV #0x1000, W0
007F08  801801     MOV ADC1BUF0, W1
007F0A  D10081     LSR W1, W1
007F0C  40887F     ADD W1, #0x1F, [W0]
129:                   pots[1]=(ADC1BUF1>>1)+0x1F;
007F0E  801811     MOV ADC1BUF1, W1
007F10  D10081     LSR W1, W1
007F12  4080FF     ADD W1, #0x1F, W1
007F14  980011     MOV W1, [W0+2]
130:                   pots[2]=(ADC1BUF2>>1)+0x1F;
007F16  801822     MOV ADC1BUF2, W2
007F18  D10102     LSR W2, W2
007F1A  41017F     ADD W2, #0x1F, W2
007F1C  980022     MOV W2, [W0+4]
131:                   pots[3]=(ADC1BUF3>>1)+0x1F;
007F1E  801832     MOV ADC1BUF3, W2
007F20  D10102     LSR W2, W2
007F22  41017F     ADD W2, #0x1F, W2
007F24  980032     MOV W2, [W0+6]
132:                   //pot scaling 
133:                   
134:                   if(pots[1]<=2048)
007F26  208000     MOV #0x800, W0
007F28  508F80     SUB W1, W0, [W15]
007F2A  3C0003     BRA GT, 0x7F32
135:                       pots_scaled[1]=8;
007F2C  200080     MOV #0x8, W0
007F2E  888050     MOV W0, 0x100A
007F30  370056     BRA 0x7FDE
136:                   else if(pots[1]<=4096)
007F32  210000     MOV #0x1000, W0
007F34  508F80     SUB W1, W0, [W15]
007F36  3C0003     BRA GT, 0x7F3E
137:                       pots_scaled[1]=12;
007F38  2000C0     MOV #0xC, W0
007F3A  888050     MOV W0, 0x100A
007F3C  370050     BRA 0x7FDE
138:                   else if(pots[1]<=6144)
007F3E  218000     MOV #0x1800, W0
007F40  508F80     SUB W1, W0, [W15]
007F42  3C0003     BRA GT, 0x7F4A
139:                       pots_scaled[1]=14;
007F44  2000E0     MOV #0xE, W0
007F46  888050     MOV W0, 0x100A
007F48  37004A     BRA 0x7FDE
140:                   else if(pots[1]<=8192)
007F4A  220000     MOV #0x2000, W0
007F4C  508F80     SUB W1, W0, [W15]
007F4E  3C0003     BRA GT, 0x7F56
141:                       pots_scaled[1]=16;
007F50  200100     MOV #0x10, W0
007F52  888050     MOV W0, 0x100A
007F54  370044     BRA 0x7FDE
142:                   else if(pots[1]<=10240)
007F56  228000     MOV #0x2800, W0
007F58  508F80     SUB W1, W0, [W15]
007F5A  3C0003     BRA GT, 0x7F62
143:                       pots_scaled[1]=19;
007F5C  200130     MOV #0x13, W0
007F5E  888050     MOV W0, 0x100A
007F60  37003E     BRA 0x7FDE
144:                   else if(pots[1]<=12288)
007F62  230000     MOV #0x3000, W0
007F64  508F80     SUB W1, W0, [W15]
007F66  3C0003     BRA GT, 0x7F6E
145:                       pots_scaled[1]=23;
007F68  200170     MOV #0x17, W0
007F6A  888050     MOV W0, 0x100A
007F6C  370038     BRA 0x7FDE
146:                   else if(pots[1]<=14336)
007F6E  238000     MOV #0x3800, W0
007F70  508F80     SUB W1, W0, [W15]
007F72  3C0003     BRA GT, 0x7F7A
147:                       pots_scaled[1]=28;
007F74  2001C0     MOV #0x1C, W0
007F76  888050     MOV W0, 0x100A
007F78  370032     BRA 0x7FDE
148:                   else if(pots[1]<=16384)
007F7A  240000     MOV #0x4000, W0
007F7C  508F80     SUB W1, W0, [W15]
007F7E  3C0003     BRA GT, 0x7F86
149:                       pots_scaled[1]=32;
007F80  200200     MOV #0x20, W0
007F82  888050     MOV W0, 0x100A
007F84  37002C     BRA 0x7FDE
150:                   else if(pots[1]<=18432)
007F86  248000     MOV #0x4800, W0
007F88  508F80     SUB W1, W0, [W15]
007F8A  3C0003     BRA GT, 0x7F92
151:                       pots_scaled[1]=36;
007F8C  200240     MOV #0x24, W0
007F8E  888050     MOV W0, 0x100A
007F90  370026     BRA 0x7FDE
152:                   else if(pots[1]<=20480)
007F92  250000     MOV #0x5000, W0
007F94  508F80     SUB W1, W0, [W15]
007F96  3C0003     BRA GT, 0x7F9E
153:                       pots_scaled[2]=40;
007F98  200280     MOV #0x28, W0
007F9A  888060     MOV W0, 0x100C
007F9C  370020     BRA 0x7FDE
154:                   else if(pots[1]<=22528)
007F9E  258000     MOV #0x5800, W0
007FA0  508F80     SUB W1, W0, [W15]
007FA2  3C0003     BRA GT, 0x7FAA
155:                       pots_scaled[2]=44;
007FA4  2002C0     MOV #0x2C, W0
007FA6  888060     MOV W0, 0x100C
007FA8  37001A     BRA 0x7FDE
156:                   else if(pots[1]<=24576)
007FAA  260000     MOV #0x6000, W0
007FAC  508F80     SUB W1, W0, [W15]
007FAE  3C0003     BRA GT, 0x7FB6
157:                       pots_scaled[1]=48;
007FB0  200300     MOV #0x30, W0
007FB2  888050     MOV W0, 0x100A
007FB4  370014     BRA 0x7FDE
158:                   else if(pots[1]<=26624)
007FB6  268000     MOV #0x6800, W0
007FB8  508F80     SUB W1, W0, [W15]
007FBA  3C0003     BRA GT, 0x7FC2
159:                       pots_scaled[1]=52;
007FBC  200340     MOV #0x34, W0
007FBE  888050     MOV W0, 0x100A
007FC0  37000E     BRA 0x7FDE
160:                   else if(pots[1]<=28672)
007FC2  270000     MOV #0x7000, W0
007FC4  508F80     SUB W1, W0, [W15]
007FC6  3C0003     BRA GT, 0x7FCE
161:                       pots_scaled[1]=56;
007FC8  200380     MOV #0x38, W0
007FCA  888050     MOV W0, 0x100A
007FCC  370008     BRA 0x7FDE
162:                   else if(pots[1]<=30720)
007FCE  278000     MOV #0x7800, W0
007FD0  508F80     SUB W1, W0, [W15]
007FD2  3C0003     BRA GT, 0x7FDA
163:                       pots_scaled[1]=60;
007FD4  2003C0     MOV #0x3C, W0
007FD6  888050     MOV W0, 0x100A
007FD8  370002     BRA 0x7FDE
164:                   else if(pots[1]<=32768)
165:                       pots_scaled[1]=64;
007FDA  200400     MOV #0x40, W0
007FDC  888050     MOV W0, 0x100A
166:                   else if(pots[1]<=34816)
167:                       pots_scaled[1]=68;
168:                   else 
169:                       pots_scaled[1]=72;
170:                    
171:                                                                                                
172:                   loop_lim=154*pots_scaled[1];                                                //LOOPER CONTROL
007FDE  2009A0     MOV #0x9A, W0
007FE0  808051     MOV 0x100A, W1
007FE2  B98880     MULW.SS W1, W0, W0
007FE4  888130     MOV W0, loop_lim
173:                   if(pots[1]>=310){                                                           //LPF CONTROL
007FE6  808010     MOV 0x1002, W0
007FE8  201351     MOV #0x135, W1
007FEA  500F81     SUB W0, W1, [W15]
007FEC  340004     BRA LE, 0x7FF6
174:                       lpf_alpha=pots[1];
007FEE  888260     MOV W0, 0x104C
175:                       lpf_inv_alpha=(32767-lpf_alpha); 
007FF0  27FFF1     MOV #0x7FFF, W1
007FF2  508000     SUB W1, W0, W0
007FF4  888270     MOV W0, 0x104E
176:                   }
177:                   //tremelo_depth=pots[4];
178:                           
179:               }
007FF6  060000     RETURN
180:               
181:               void display(void){
182:                   IFS0bits.SPI1IF=0;
007FF8  A94801     BCLR 0x801, #2
183:                   SPI1STATbits.SPIROV = 0;
007FFA  A9C240     BCLR SPI1STAT, #6
184:                   int trash = SPI1BUF;
007FFC  801240     MOV SPI1BUF, W0
185:                   SPI1BUF=0xFAAF;
007FFE  2FAAF0     MOV #0xFAAF, W0
008000  881240     MOV W0, SPI1BUF
186:                   
187:                   lcdDrawPads(16);
008002  B3C100     MOV.B #0x10, W0
008004  07FC73     RCALL lcdDrawPads
188:                  lcdSetCursorQ(2,2);
008006  B3C021     MOV.B #0x2, W1
008008  784001     MOV.B W1, W0
00800A  07FBD0     RCALL lcdSetCursorQ
189:                  lcdWriteWord(sampin);
00800C  808210     MOV sampin, W0
00800E  07FC3C     RCALL lcdWriteWord
190:                  lcdSetCursorQ(10,2);
008010  B3C021     MOV.B #0x2, W1
008012  B3C0A0     MOV.B #0xA, W0
008014  07FBCB     RCALL lcdSetCursorQ
191:                  lcdWriteWord(sampout);
008016  808220     MOV sampout, W0
008018  07FC37     RCALL lcdWriteWord
192:                  lcdSetCursorQ(4,3);
00801A  B3C031     MOV.B #0x3, W1
00801C  B3C040     MOV.B #0x4, W0
00801E  07FBC6     RCALL lcdSetCursorQ
193:                   if(pad[14])lcdWriteWord(cycle);
008020  2624E0     MOV #0x624E, W0
008022  E00410     CP0.B [W0]
008024  320002     BRA Z, 0x802A
008026  8080C0     MOV cycle, W0
008028  07FC2F     RCALL lcdWriteWord
194:               
195:                   lcdSetCursorQ(11,3);
00802A  B3C031     MOV.B #0x3, W1
00802C  B3C0B0     MOV.B #0xB, W0
00802E  07FBBE     RCALL lcdSetCursorQ
196:                   if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
008030  BFD01A     MOV.B hard_clipped, WREG
008032  404FE1     ADD.B W0, #0x1, [W15]
008034  3A0004     BRA NZ, 0x803E
197:                       lcdWriteStringQ("CLIP");
008036  2F74A0     MOV #0xF74A, W0
008038  07FBDE     RCALL lcdWriteStringQ
198:                       hard_clipped=FALSE;  
00803A  EF701A     CLR.B hard_clipped
00803C  370008     BRA 0x804E
199:                   }
200:                   else if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
00803E  BFD01E     MOV.B TEST_SIN, WREG
008040  404FE1     ADD.B W0, #0x1, [W15]
008042  3A0003     BRA NZ, 0x804A
008044  2F74F0     MOV #0xF74F, W0
008046  07FBD7     RCALL lcdWriteStringQ
008048  370002     BRA 0x804E
201:                   else lcdWriteStringQ("THRU");
00804A  2F7540     MOV #0xF754, W0
00804C  07FBD4     RCALL lcdWriteStringQ
202:                   
203:               
204:                   
205:                  if(UART_ON==TRUE){
00804E  BFD01D     MOV.B UART_ON, WREG
008050  404FE1     ADD.B W0, #0x1, [W15]
008052  3A000A     BRA NZ, 0x8068
206:                       //IC1CON2bits.TRIGSTAT = ~pad[4]; 
207:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
208:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
209:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
210:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
008054  210000     MOV #0x1000, W0
008056  9000A0     MOV [W0+4], W1
008058  781F81     MOV W1, [W15++]
00805A  900090     MOV [W0+2], W1
00805C  781F81     MOV W1, [W15++]
00805E  781F90     MOV [W0], [W15++]
008060  2F7590     MOV #0xF759, W0
008062  781F80     MOV W0, [W15++]
008064  07C24F     RCALL __printf_cdnopuxX
008066  5787E8     SUB W15, #0x8, W15
211:                       //printf("%d\r\n", sample);  //check input ADC
212:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
213:                   }
214:                  
215:                  SLED=~SLED;
008068  8072A0     MOV LATF, W0
00806A  EA8000     COM W0, W0
00806C  600061     AND W0, #0x1, W0
00806E  8072A1     MOV LATF, W1
008070  A10001     BCLR W1, #0
008072  700081     IOR W0, W1, W1
008074  8872A1     MOV W1, LATF
216:               }
008076  060000     RETURN
217:               
218:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
219:                   /* This procedure loops back the received data to the*/
220:                   /* the codec output. The user application could process*/
221:                   /* this data as per application requirements.*/
222:                   int index;
223:                   for(index = 0;index < STREAMBUF;index ++)
008078  EB0100     CLR W2
00807A  200403     MOV #0x40, W3
00807E  E80102     INC W2, W2
008080  510F83     SUB W2, W3, [W15]
008082  3AFFFC     BRA NZ, 0x807C
224:                   {
225:                       targetBuffer[index] = sourceBuffer[index];
00807C  7818B0     MOV [W0++], [W1++]
226:                   }
227:               }
008084  060000     RETURN
228:               
229:               //A blocking delay function. Not very accurate but good enough.
230:               void Delay_us(unsigned int delay)
231:               {
232:                   int i;
233:                   for (i = 0; i < delay; i++)
008086  E00000     CP0 W0
008088  320006     BRA Z, 0x8096
00808A  EB0080     CLR W1
008090  E80081     INC W1, W1
008092  500F81     SUB W0, W1, [W15]
008094  3EFFFB     BRA GTU, 0x808C
234:                   {
235:                       __asm__ volatile ("repeat #50");
00808C  090032     REPEAT #0x32
236:                       __asm__ volatile ("nop");
00808E  000000     NOP
237:                   }
238:               }
008096  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/routines.c  -------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern char pad[BUTTONS];
10:                extern fractional pots[4]; 
11:                extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
12:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
13:                extern unsigned int write_ptr, rw, frameReady;
14:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
15:                
16:                //STATUS VARIABLES
17:                extern unsigned char t1flag, t2flag, t3flag;
18:                
19:                //misc.
20:                volatile fractional sampin=0;
21:                volatile fractional sampout=0;
22:                volatile int rxBufferIndicator = 0;
23:                fractional *ping, *pong;
24:                
25:                //Description: This interrupt toggles status led, runs UART1 and handles display
26:                //Dependencies: initUART1();
27:                //Frequency: 60
28:                void __attribute__ ((interrupt, auto_psv)) _T1Interrupt(void){
000306  F80032     PUSH DSRPAG
000308  F80034     PUSH DSWPAG
00030A  781F88     MOV W8, [W15++]
00030C  200018     MOV #0x1, W8
00030E  8801A8     MOV W8, DSWPAG
000310  202008     MOV #0x200, W8
000312  880198     MOV W8, DSRPAG
000314  000000     NOP
000316  78044F     MOV [--W15], W8
29:                    t1flag=TRUE;
000318  EFF01B     SETM.B t1flag
30:                    IFS0bits.T1IF = 0;              //clear interrupt flag & restart
00031A  A96800     BCLR IFS0, #3
31:                }
00031C  F90034     POP DSWPAG
00031E  F90032     POP DSRPAG
000320  064000     RETFIE
32:                
33:                //Description: This interrupt handles polling button input
34:                //Dependencies: initADC1(); 
35:                //Frequency: 512Hz
36:                void __attribute__ ((interrupt, auto_psv)) _T2Interrupt(void){
000322  F80032     PUSH DSRPAG
000324  F80034     PUSH DSWPAG
000326  781F88     MOV W8, [W15++]
000328  200018     MOV #0x1, W8
00032A  8801A8     MOV W8, DSWPAG
00032C  202008     MOV #0x200, W8
00032E  880198     MOV W8, DSRPAG
000330  000000     NOP
000332  78044F     MOV [--W15], W8
37:                    t2flag=TRUE;
000334  EFF01C     SETM.B t2flag
38:                    IFS0bits.T2IF = 0;              //clear interrupt flag & restart
000336  A9E800     BCLR IFS0, #7
39:                }
000338  F90034     POP DSWPAG
00033A  F90032     POP DSRPAG
00033C  064000     RETFIE
40:                
41:                //Description: This interrupt triggers at the completion of DCI output
42:                //Dependancies: initSPI2(); 
43:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
00033E  BE9F80     MOV.D W0, [W15++]
000340  781F82     MOV W2, [W15++]
000342  F80032     PUSH DSRPAG
000344  F80034     PUSH DSWPAG
000346  200010     MOV #0x1, W0
000348  8801A0     MOV W0, DSWPAG
00034A  202000     MOV #0x200, W0
00034C  880190     MOV W0, DSRPAG
00034E  000000     NOP
44:                    TXBUF0=TXBUF1=sampout;                                    //output buffered sample to DAC
000350  F81044     PUSH sampout
000352  F9029A     POP TXBUF1
000354  F8029A     PUSH TXBUF1
000356  F90298     POP TXBUF0
45:                    sampin=RXBUF1;
000358  F80292     PUSH RXBUF1
00035A  F91042     POP sampin
46:                    __builtin_btg(&sampin, 15);                             //convert to Q1.15 compatible format
00035C  210420     MOV #0x1042, W0
00035E  A2F010     BTG [W0], #15
47:                    int trash=RXBUF0;
000360  801480     MOV RXBUF0, W0
48:                      
49:                    
50:                    if(write_ptr--==0){                       //reset pointer when out of bounds
000362  8082C0     MOV 0x1058, W0
000364  E90080     DEC W0, W1
000366  8882C1     MOV W1, 0x1058
000368  E00000     CP0 W0
00036A  3A0005     BRA NZ, 0x376
51:                        write_ptr=STREAMBUF-1;
00036C  2003F0     MOV #0x3F, W0
00036E  8882C0     MOV W0, 0x1058
52:                        __builtin_btg(&rw,0);
000370  AA1012     BTG rw, #0
53:                        frameReady=1;
000372  200010     MOV #0x1, W0
000374  8880A0     MOV W0, frameReady
54:                    }
55:                   
56:                    if(rw){
000376  E21012     CP0 rw
000378  32000B     BRA Z, 0x390
57:                        streamB[write_ptr]=sampin;
00037A  8082C0     MOV 0x1058, W0
00037C  400000     ADD W0, W0, W0
00037E  25FFC1     MOV #0x5FFC, W1
000380  408080     ADD W1, W0, W1
000382  808212     MOV sampin, W2
000384  780882     MOV W2, [W1]
58:                        sampout=outputA[write_ptr]; 
000386  25E7C1     MOV #0x5E7C, W1
000388  408000     ADD W1, W0, W0
00038A  780010     MOV [W0], W0
00038C  888220     MOV W0, sampout
00038E  37000A     BRA 0x3A4
59:                    }
60:                    else {
61:                        streamA[write_ptr]=sampin; 
000390  8082C0     MOV 0x1058, W0
000392  400000     ADD W0, W0, W0
000394  25F7C1     MOV #0x5F7C, W1
000396  408080     ADD W1, W0, W1
000398  808212     MOV sampin, W2
00039A  780882     MOV W2, [W1]
62:                        sampout=outputB[write_ptr];  
00039C  25EFC1     MOV #0x5EFC, W1
00039E  408000     ADD W1, W0, W0
0003A0  780010     MOV [W0], W0
0003A2  888220     MOV W0, sampout
63:                    }               //get input
64:                    
65:                    IFS3bits.DCIIF=0;
0003A4  A98807     BCLR 0x807, #4
66:                }
0003A6  F90034     POP DSWPAG
0003A8  F90032     POP DSRPAG
0003AA  78014F     MOV [--W15], W2
0003AC  BE004F     MOV.D [--W15], W0
0003AE  064000     RETFIE
67:                void __attribute__ ((interrupt, auto_psv)) _IC1Interrupt(void){
0003B0  BE9F80     MOV.D W0, [W15++]
0003B2  F80032     PUSH DSRPAG
0003B4  F80034     PUSH DSWPAG
0003B6  200010     MOV #0x1, W0
0003B8  8801A0     MOV W0, DSWPAG
0003BA  202000     MOV #0x200, W0
0003BC  880190     MOV W0, DSRPAG
0003BE  000000     NOP
68:                    IFS0bits.IC1IF=0;   
0003C0  A92800     BCLR IFS0, #1
69:                    //bpm=IC1BUF;
70:                    RLED=~RLED;
0003C2  807120     MOV LATC, W0
0003C4  EA8000     COM W0, W0
0003C6  600061     AND W0, #0x1, W0
0003C8  807121     MOV LATC, W1
0003CA  A10001     BCLR W1, #0
0003CC  700081     IOR W0, W1, W1
0003CE  887121     MOV W1, LATC
71:                }
0003D0  F90034     POP DSWPAG
0003D2  F90032     POP DSRPAG
0003D4  BE004F     MOV.D [--W15], W0
0003D6  064000     RETFIE
72:                
73:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
0003D8  781F80     MOV W0, [W15++]
0003DA  F80032     PUSH DSRPAG
0003DC  F80034     PUSH DSWPAG
0003DE  200010     MOV #0x1, W0
0003E0  8801A0     MOV W0, DSWPAG
0003E2  202000     MOV #0x200, W0
0003E4  880190     MOV W0, DSRPAG
0003E6  000000     NOP
74:                    //SEG_SEL=1;
75:                    int trash=SPI3BUF;
0003E8  801540     MOV SPI3BUF, W0
76:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
0003EA  A9C2A0     BCLR SPI3STAT, #6
77:                    IFS5bits.SPI3IF=0;
0003EC  A9680B     BCLR 0x80B, #3
78:                    
79:                }
0003EE  F90034     POP DSWPAG
0003F0  F90032     POP DSRPAG
0003F2  78004F     MOV [--W15], W0
0003F4  064000     RETFIE
80:                
81:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003F6  F80036     PUSH RCOUNT
0003F8  BE9F80     MOV.D W0, [W15++]
0003FA  BE9F82     MOV.D W2, [W15++]
0003FC  BE9F84     MOV.D W4, [W15++]
0003FE  BE9F86     MOV.D W6, [W15++]
82:                    _DMA2IF = 0; /* Received one frame of data*/    
000400  A90803     BCLR 0x803, #0
83:                    
84:                    if(rxBufferIndicator == 0)
000402  E21046     CP0 rxBufferIndicator
000404  3A0004     BRA NZ, 0x40E
85:                    {
86:                         processRxData((int *)rxBufferA, (int*)txBufferA);
000406  2CF801     MOV #0xCF80, W1
000408  2CE800     MOV #0xCE80, W0
00040A  073E36     RCALL processRxData
00040C  370003     BRA 0x414
87:                    }
88:                    else
89:                    {
90:                         processRxData((int *)rxBufferB, (int*)txBufferB);
00040E  2CF001     MOV #0xCF00, W1
000410  2CE000     MOV #0xCE00, W0
000412  073E32     RCALL processRxData
91:                    }
92:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
000414  AA1046     BTG rxBufferIndicator, #0
93:                }
000416  BE034F     MOV.D [--W15], W6
000418  BE024F     MOV.D [--W15], W4
00041A  BE014F     MOV.D [--W15], W2
00041C  BE004F     MOV.D [--W15], W0
00041E  F90036     POP RCOUNT
000420  064000     RETFIE
94:                
95:                
96:                /*
97:                //Description: This interrupt handles polling button input
98:                //Dependencies: initADC1(); 
99:                //Frequency: 44.1kHz
100:               
101:               
102:               void __attribute__ ((interrupt, auto_psv)) _SPI2Interrupt(void){
103:                   //GLED=~GLED;                                             //check half freq w/ RLED                                        //returns SS2 to idle state
104:                   SPI2STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
105:                   IFS2bits.SPI2IF = 0;                                    //reset flag & restart
106:               }
107:               //Description: This interrupt handles UART reception
108:               //Dependencies: initUART1();
109:               void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
110:                   unsigned char trash;
111:                   GLED=~GLED;
112:                   trash=U1RXREG;
113:                   printf("RECIEVED: %d\r\n", trash);
114:                   IFS0bits.U1RXIF = 0;            //clear flag, restart
115:               }
116:               
117:               //Description: This interrupt handles UART transmission
118:               //Dependencies: initUART1();
119:               void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
120:                   YLED=~YLED;
121:                   IFS0bits.U1TXIF = 0;            //clear flag, restart
122:               } 
123:                */
---  C:/Users/ryan/Documents/seniorproject/ps-040/plcd.c  -----------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                extern unsigned char TEST_SIN;
15:                extern unsigned char pad[BUTTONS];
16:                
17:                unsigned int statusReg = 0x0C;  //internal copy of pwr reg
18:                                                // 0b_0 0 0 0 - 1 D C B (display, cursor, blink)
19:                int  lcdBuf[LCDBUF]={0};
20:                int *lcdWritePtr=lcdBuf;
21:                int *lcdSendPtr=lcdBuf;
22:                
23:                
24:                void lcdWriteQ(unsigned char data){
25:                    *lcdWritePtr++=data|0x0000;
00776E  FB8000     ZE W0, W0
007770  8082A1     MOV 0x1054, W1
007772  781880     MOV W0, [W1++]
007774  8882A1     MOV W1, 0x1054
26:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007776  2617C0     MOV #0x617C, W0
007778  508F80     SUB W1, W0, [W15]
00777A  3A0002     BRA NZ, 0x7780
27:                        lcdWritePtr=lcdBuf;
00777C  B11000     SUB #0x100, W0
00777E  8882A0     MOV W0, 0x1054
28:                }
007780  060000     RETURN
29:                
30:                void lcdCommandQ(unsigned char data){
31:                    *lcdWritePtr++=data|0x0100;     //flag for rs=1
007782  FB8000     ZE W0, W0
007784  8082A1     MOV 0x1054, W1
007786  A08000     BSET W0, #8
007788  781880     MOV W0, [W1++]
00778A  8882A1     MOV W1, 0x1054
32:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
00778C  2617C0     MOV #0x617C, W0
00778E  508F80     SUB W1, W0, [W15]
007790  3A0002     BRA NZ, 0x7796
33:                        lcdWritePtr=lcdBuf;
007792  B11000     SUB #0x100, W0
007794  8882A0     MOV W0, 0x1054
34:                }
007796  060000     RETURN
35:                
36:                void lcdClearQ(void){
37:                    *lcdWritePtr++=(LCD_CLEARDISPLAY)|0x0300;  //flag for rs=0 & long delay
007798  8082A0     MOV 0x1054, W0
00779A  203011     MOV #0x301, W1
00779C  781801     MOV W1, [W0++]
00779E  8882A0     MOV W0, 0x1054
38:                }
0077A0  060000     RETURN
39:                
40:                void lcdReturnQ(void){
41:                    *lcdWritePtr++=(LCD_RETURNHOME)|0x0300;  //flag for rs=0 & long delay
0077A2  8082A0     MOV 0x1054, W0
0077A4  203021     MOV #0x302, W1
0077A6  781801     MOV W1, [W0++]
0077A8  8882A0     MOV W0, 0x1054
42:                }
0077AA  060000     RETURN
43:                
44:                void lcdSetCursorQ(unsigned char col, unsigned char row) {
45:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
46:                  if (row > 3) {
47:                    row = 3;
48:                  }
49:                
50:                  lcdCommandQ(LCD_SETDDRAMADDR | (col + offsets[row])); 
0077AC  50CFE3     SUB.B W1, #0x3, [W15]
0077AE  360001     BRA LEU, 0x77B2
0077B0  B3C031     MOV.B #0x3, W1
0077B2  FB8081     ZE W1, W1
0077B4  2F7452     MOV #0xF745, W2
0077B6  410081     ADD W2, W1, W1
0077B8  404011     ADD.B W0, [W1], W0
0077BA  A07400     BSET.B W0, #7
0077BC  07FFE2     RCALL lcdCommandQ
51:                }
0077BE  060000     RETURN
52:                
53:                void lcdPwrQ(signed int pwr){
54:                    //lcd soft power on/off, does not reset device
55:                    if(pwr)
0077C0  E00000     CP0 W0
0077C2  320003     BRA Z, 0x77CA
56:                        statusReg&=0x04;
0077C4  200040     MOV #0x4, W0
0077C6  B63052     AND 0x1052
0077C8  370001     BRA 0x77CC
57:                    else __builtin_btg(&statusReg, 2);
0077CA  AA5052     BTG 0x1052, #2
58:                    
59:                    lcdCommandQ(statusReg);
0077CC  BFD052     MOV.B 0x1052, WREG
0077CE  07FFD9     RCALL lcdCommandQ
60:                }
0077D0  060000     RETURN
61:                
62:                void lcdCursorEn(signed int pwr){
63:                    //cursor on / off
64:                    if(pwr)
0077D2  E00000     CP0 W0
0077D4  320003     BRA Z, 0x77DC
65:                        statusReg&=0x0A;
0077D6  2000A0     MOV #0xA, W0
0077D8  B63052     AND 0x1052
0077DA  370001     BRA 0x77DE
66:                    else __builtin_btg(&statusReg, 1);
0077DC  AA3052     BTG 0x1052, #1
67:                    
68:                    lcdCommandQ(statusReg);
0077DE  BFD052     MOV.B 0x1052, WREG
0077E0  07FFD0     RCALL lcdCommandQ
69:                }
0077E2  060000     RETURN
70:                
71:                void lcdCursorBlinkQ(signed int pwr){
72:                    if(pwr)
0077E4  E00000     CP0 W0
0077E6  320003     BRA Z, 0x77EE
73:                        statusReg&=0x09;
0077E8  200090     MOV #0x9, W0
0077EA  B63052     AND 0x1052
0077EC  370001     BRA 0x77F0
74:                    else __builtin_btg(&statusReg, 0);
0077EE  AA1052     BTG 0x1052, #0
75:                    
76:                    lcdCommandQ(statusReg);
0077F0  BFD052     MOV.B 0x1052, WREG
0077F2  07FFC7     RCALL lcdCommandQ
77:                }
0077F4  060000     RETURN
78:                
79:                void lcdWriteStringQ(char *string) {
0077F6  781F88     MOV W8, [W15++]
0077F8  780400     MOV W0, W8
80:                    char *it = string;
81:                    for (; *it; it++) {
0077FA  784018     MOV.B [W8], W0
0077FC  E00400     CP0.B W0
0077FE  320004     BRA Z, 0x7808
007802  784058     MOV.B [++W8], W0
007804  E00400     CP0.B W0
007806  3AFFFC     BRA NZ, 0x7800
82:                        lcdWriteQ(*it);
007800  07FFB6     RCALL lcdWriteQ
83:                  }
84:                }
007808  78044F     MOV [--W15], W8
00780A  060000     RETURN
85:                
86:                void lcdSetupPots(){
87:                    lcdSetCursorQ(0,0);
00780C  EB4080     CLR.B W1
00780E  784001     MOV.B W1, W0
007810  07FFCD     RCALL lcdSetCursorQ
88:                    lcdWriteStringQ("P1:");
007812  2F7160     MOV #0xF716, W0
007814  07FFF0     RCALL lcdWriteStringQ
89:                    lcdSetCursorQ(6,0);
007816  EB4080     CLR.B W1
007818  B3C060     MOV.B #0x6, W0
00781A  07FFC8     RCALL lcdSetCursorQ
90:                    lcdWriteStringQ("P2:");
00781C  2F71A0     MOV #0xF71A, W0
00781E  07FFEB     RCALL lcdWriteStringQ
91:                    lcdSetCursorQ(12,0);
007820  EB4080     CLR.B W1
007822  B3C0C0     MOV.B #0xC, W0
007824  07FFC3     RCALL lcdSetCursorQ
92:                    lcdWriteStringQ("P3:");
007826  2F71E0     MOV #0xF71E, W0
007828  07FFE6     RCALL lcdWriteStringQ
93:                    lcdSetCursorQ(0,1);
00782A  B3C011     MOV.B #0x1, W1
00782C  EB4000     CLR.B W0
00782E  07FFBE     RCALL lcdSetCursorQ
94:                    lcdWriteStringQ("P4:");
007830  2F7220     MOV #0xF722, W0
007832  07FFE1     RCALL lcdWriteStringQ
95:                    lcdSetCursorQ(6,1);
007834  B3C011     MOV.B #0x1, W1
007836  B3C060     MOV.B #0x6, W0
007838  07FFB9     RCALL lcdSetCursorQ
96:                    lcdWriteStringQ("P5:");
00783A  2F7260     MOV #0xF726, W0
00783C  07FFDC     RCALL lcdWriteStringQ
97:                    lcdSetCursorQ(12,1);
00783E  B3C011     MOV.B #0x1, W1
007840  B3C0C0     MOV.B #0xC, W0
007842  07FFB4     RCALL lcdSetCursorQ
98:                    lcdWriteStringQ("P6:");
007844  2F72A0     MOV #0xF72A, W0
007846  07FFD7     RCALL lcdWriteStringQ
99:                    lcdSetCursorQ(0,2);
007848  B3C021     MOV.B #0x2, W1
00784A  EB4000     CLR.B W0
00784C  07FFAF     RCALL lcdSetCursorQ
100:                   lcdWriteStringQ("I:");
00784E  2F72E0     MOV #0xF72E, W0
007850  07FFD2     RCALL lcdWriteStringQ
101:                   lcdSetCursorQ(8,2);
007852  B3C021     MOV.B #0x2, W1
007854  B3C080     MOV.B #0x8, W0
007856  07FFAA     RCALL lcdSetCursorQ
102:                   lcdWriteStringQ("O:");
007858  2F7310     MOV #0xF731, W0
00785A  07FFCD     RCALL lcdWriteStringQ
103:                   lcdSetCursorQ(0,3);
00785C  B3C031     MOV.B #0x3, W1
00785E  EB4000     CLR.B W0
007860  07FFA5     RCALL lcdSetCursorQ
104:                   lcdWriteStringQ("Cyc:");
007862  2F7340     MOV #0xF734, W0
007864  07FFC8     RCALL lcdWriteStringQ
105:                   lcdSetCursorQ(11,3);
007866  B3C031     MOV.B #0x3, W1
007868  B3C0B0     MOV.B #0xB, W0
00786A  07FFA0     RCALL lcdSetCursorQ
106:                   if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
00786C  BFD01E     MOV.B TEST_SIN, WREG
00786E  404FE1     ADD.B W0, #0x1, [W15]
007870  3A0003     BRA NZ, 0x7878
007872  2F7390     MOV #0xF739, W0
007874  07FFC0     RCALL lcdWriteStringQ
007876  370002     BRA 0x787C
107:                   else lcdWriteStringQ("THRU");
007878  2F73E0     MOV #0xF73E, W0
00787A  07FFBD     RCALL lcdWriteStringQ
108:                   
109:               }
00787C  060000     RETURN
110:               
111:               void lcdCustomSymbols(void){
112:                   int i=0;
113:                   lcdCommandQ(0x40);
00787E  B3C400     MOV.B #0x40, W0
007880  07FF80     RCALL lcdCommandQ
114:                   Delay_us(200);
007882  200C80     MOV #0xC8, W0
007884  070400     RCALL Delay_us
115:                  // for(; i<8; i++)lcdWriteString(loadingOne[i]);
116:                   //lcdWriteString(loadingTwo);
117:                   //lcdWriteString(loadingThree);
118:                   //lcdWriteString(loadingFour);
119:               }
007886  060000     RETURN
120:               
121:               void lcdWriteWord(int word){
007888  4787E6     ADD W15, #0x6, W15
00788A  781F88     MOV W8, [W15++]
00788C  781F8E     MOV W14, [W15++]
00788E  780400     MOV W0, W8
0078B2  200040     MOV #0x4, W0
122:                   int i;
123:                   char inchar[4];
124:                   
125:                   if(word<0) {
007890  E00008     CP0 W8
007892  3D0004     BRA GE, 0x789C
126:                       lcdWriteQ('-');
007894  B3C2D0     MOV.B #0x2D, W0
007896  07FF6B     RCALL lcdWriteQ
127:                       word=~word+1;
007898  EA0408     NEG W8, W8
00789A  370002     BRA 0x78A0
128:                   }else lcdWriteQ(' ');
00789C  B3C200     MOV.B #0x20, W0
00789E  07FF67     RCALL lcdWriteQ
129:                  
130:                  inchar[0] = word&0x000F; 
0078A0  64406F     AND.B W8, #0xF, W0
131:                  if (inchar[0] > 9) 
0078A2  504FE9     SUB.B W0, #0x9, [W15]
0078A4  340003     BRA LE, 0x78AC
132:                      inchar[0]+=55;
0078A6  B04370     ADD.B #0x37, W0
0078A8  9FFF80     MOV.B W0, [W15-8]
0078AA  370002     BRA 0x78B0
133:                  else inchar[0]+=48;
0078AC  B04300     ADD.B #0x30, W0
0078AE  9FFF80     MOV.B W0, [W15-8]
0078B0  578768     SUB W15, #0x8, W14
134:                  
135:                  for(i=1; i<4; i++){ 
0078CC  500FF0     SUB W0, #0x10, [W15]
0078CE  3AFFF2     BRA NZ, 0x78B4
136:                     inchar[i] = ((word>>(i*4))&0x0000F); 
0078B4  DEC080     ASR W8, W0, W1
0078B6  60C0EF     AND.B W1, #0xF, W1
0078B8  E8070E     INC W14, W14
0078BA  784F01     MOV.B W1, [W14]
137:                     if (inchar[i] > 9) 
0078BC  50CFE9     SUB.B W1, #0x9, [W15]
0078BE  340003     BRA LE, 0x78C6
138:                         inchar[i]+=55;
0078C0  B3C373     MOV.B #0x37, W3
0078C2  40CF03     ADD.B W1, W3, [W14]
0078C4  370002     BRA 0x78CA
139:                     else inchar[i]+=48;
0078C6  B3C303     MOV.B #0x30, W3
0078C8  40CF03     ADD.B W1, W3, [W14]
0078CA  400064     ADD W0, #0x4, W0
140:                  } 
141:                  lcdWriteQ(inchar[3]);
0078D0  97F83F     MOV.B [W15-5], W0
0078D2  07FF4D     RCALL lcdWriteQ
142:                  lcdWriteQ(inchar[2]);
0078D4  97F82F     MOV.B [W15-6], W0
0078D6  07FF4B     RCALL lcdWriteQ
143:                  lcdWriteQ(inchar[1]);
0078D8  97F81F     MOV.B [W15-7], W0
0078DA  07FF49     RCALL lcdWriteQ
144:                  lcdWriteQ(inchar[0]);
0078DC  97F80F     MOV.B [W15-8], W0
0078DE  07FF47     RCALL lcdWriteQ
145:               }
0078E0  78074F     MOV [--W15], W14
0078E2  78044F     MOV [--W15], W8
0078E4  B1006F     SUB #0x6, W15
0078E6  060000     RETURN
146:               
147:               void lcdVUvertical(unsigned char col, unsigned char row, int data){
148:                   lcdSetCursorQ(col,row);
0078E8  07FF61     RCALL lcdSetCursorQ
149:               }
0078EA  060000     RETURN
150:               
151:               //4x4 pad debug
152:               void lcdDrawPads(unsigned char col){
0078EC  781F88     MOV W8, [W15++]
0078EE  784400     MOV.B W0, W8
153:                   lcdSetCursorQ(col, 0);
0078F0  EB4080     CLR.B W1
0078F2  784008     MOV.B W8, W0
0078F4  07FF5B     RCALL lcdSetCursorQ
154:                   if(!pad[12])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
0078F6  2624C0     MOV #0x624C, W0
0078F8  E00410     CP0.B [W0]
0078FA  3A0003     BRA NZ, 0x7902
0078FC  2F7430     MOV #0xF743, W0
0078FE  07FF7B     RCALL lcdWriteStringQ
007900  370002     BRA 0x7906
007902  EBC000     SETM.B W0
007904  07FF34     RCALL lcdWriteQ
155:                   if(!pad[13])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
007906  2624D0     MOV #0x624D, W0
007908  E00410     CP0.B [W0]
00790A  3A0003     BRA NZ, 0x7912
00790C  2F7430     MOV #0xF743, W0
00790E  07FF73     RCALL lcdWriteStringQ
007910  370002     BRA 0x7916
007912  EBC000     SETM.B W0
007914  07FF2C     RCALL lcdWriteQ
156:                   if(!pad[14])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
007916  2624E0     MOV #0x624E, W0
007918  E00410     CP0.B [W0]
00791A  3A0003     BRA NZ, 0x7922
00791C  2F7430     MOV #0xF743, W0
00791E  07FF6B     RCALL lcdWriteStringQ
007920  370002     BRA 0x7926
007922  EBC000     SETM.B W0
007924  07FF24     RCALL lcdWriteQ
157:                   if(!pad[15])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
007926  2624F0     MOV #0x624F, W0
007928  E00410     CP0.B [W0]
00792A  3A0003     BRA NZ, 0x7932
00792C  2F7430     MOV #0xF743, W0
00792E  07FF63     RCALL lcdWriteStringQ
007930  370002     BRA 0x7936
007932  EBC000     SETM.B W0
007934  07FF1C     RCALL lcdWriteQ
158:                   lcdSetCursorQ(col, 1);
007936  B3C011     MOV.B #0x1, W1
007938  784008     MOV.B W8, W0
00793A  07FF38     RCALL lcdSetCursorQ
159:                   if(!pad[8])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
00793C  262480     MOV #0x6248, W0
00793E  E00410     CP0.B [W0]
007940  3A0003     BRA NZ, 0x7948
007942  2F7430     MOV #0xF743, W0
007944  07FF58     RCALL lcdWriteStringQ
007946  370002     BRA 0x794C
007948  EBC000     SETM.B W0
00794A  07FF11     RCALL lcdWriteQ
160:                   if(!pad[9])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
00794C  262490     MOV #0x6249, W0
00794E  E00410     CP0.B [W0]
007950  3A0003     BRA NZ, 0x7958
007952  2F7430     MOV #0xF743, W0
007954  07FF50     RCALL lcdWriteStringQ
007956  370002     BRA 0x795C
007958  EBC000     SETM.B W0
00795A  07FF09     RCALL lcdWriteQ
161:                   if(!pad[10])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
00795C  2624A0     MOV #0x624A, W0
00795E  E00410     CP0.B [W0]
007960  3A0003     BRA NZ, 0x7968
007962  2F7430     MOV #0xF743, W0
007964  07FF48     RCALL lcdWriteStringQ
007966  370002     BRA 0x796C
007968  EBC000     SETM.B W0
00796A  07FF01     RCALL lcdWriteQ
162:                   if(!pad[11])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
00796C  2624B0     MOV #0x624B, W0
00796E  E00410     CP0.B [W0]
007970  3A0003     BRA NZ, 0x7978
007972  2F7430     MOV #0xF743, W0
007974  07FF40     RCALL lcdWriteStringQ
007976  370002     BRA 0x797C
007978  EBC000     SETM.B W0
00797A  07FEF9     RCALL lcdWriteQ
163:                   lcdSetCursorQ(col, 2);
00797C  B3C021     MOV.B #0x2, W1
00797E  784008     MOV.B W8, W0
007980  07FF15     RCALL lcdSetCursorQ
164:                   if(!pad[4])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
007982  262440     MOV #0x6244, W0
007984  E00410     CP0.B [W0]
007986  3A0003     BRA NZ, 0x798E
007988  2F7430     MOV #0xF743, W0
00798A  07FF35     RCALL lcdWriteStringQ
00798C  370002     BRA 0x7992
00798E  EBC000     SETM.B W0
007990  07FEEE     RCALL lcdWriteQ
165:                   if(!pad[5])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
007992  262450     MOV #0x6245, W0
007994  E00410     CP0.B [W0]
007996  3A0003     BRA NZ, 0x799E
007998  2F7430     MOV #0xF743, W0
00799A  07FF2D     RCALL lcdWriteStringQ
00799C  370002     BRA 0x79A2
00799E  EBC000     SETM.B W0
0079A0  07FEE6     RCALL lcdWriteQ
166:                   if(!pad[6])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
0079A2  262460     MOV #0x6246, W0
0079A4  E00410     CP0.B [W0]
0079A6  3A0003     BRA NZ, 0x79AE
0079A8  2F7430     MOV #0xF743, W0
0079AA  07FF25     RCALL lcdWriteStringQ
0079AC  370002     BRA 0x79B2
0079AE  EBC000     SETM.B W0
0079B0  07FEDE     RCALL lcdWriteQ
167:                   if(!pad[7])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
0079B2  262470     MOV #0x6247, W0
0079B4  E00410     CP0.B [W0]
0079B6  3A0003     BRA NZ, 0x79BE
0079B8  2F7430     MOV #0xF743, W0
0079BA  07FF1D     RCALL lcdWriteStringQ
0079BC  370002     BRA 0x79C2
0079BE  EBC000     SETM.B W0
0079C0  07FED6     RCALL lcdWriteQ
168:                   lcdSetCursorQ(col, 3);
0079C2  B3C031     MOV.B #0x3, W1
0079C4  784008     MOV.B W8, W0
0079C6  07FEF2     RCALL lcdSetCursorQ
169:                   if(!pad[0])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
0079C8  262400     MOV #0x6240, W0
0079CA  E00410     CP0.B [W0]
0079CC  3A0003     BRA NZ, 0x79D4
0079CE  2F7430     MOV #0xF743, W0
0079D0  07FF12     RCALL lcdWriteStringQ
0079D2  370002     BRA 0x79D8
0079D4  EBC000     SETM.B W0
0079D6  07FECB     RCALL lcdWriteQ
170:                   if(!pad[1])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
0079D8  262410     MOV #0x6241, W0
0079DA  E00410     CP0.B [W0]
0079DC  3A0003     BRA NZ, 0x79E4
0079DE  2F7430     MOV #0xF743, W0
0079E0  07FF0A     RCALL lcdWriteStringQ
0079E2  370002     BRA 0x79E8
0079E4  EBC000     SETM.B W0
0079E6  07FEC3     RCALL lcdWriteQ
171:                   if(!pad[2])lcdWriteStringQ(" "); else {lcdWriteQ(0xFF);}
0079E8  262420     MOV #0x6242, W0
0079EA  E00410     CP0.B [W0]
0079EC  3A0003     BRA NZ, 0x79F4
0079EE  2F7430     MOV #0xF743, W0
0079F0  07FF02     RCALL lcdWriteStringQ
0079F2  370002     BRA 0x79F8
0079F4  EBC000     SETM.B W0
0079F6  07FEBB     RCALL lcdWriteQ
172:                   if(!pad[3])lcdWriteStringQ(" "); else lcdWriteQ(0xFF);
0079F8  262430     MOV #0x6243, W0
0079FA  E00410     CP0.B [W0]
0079FC  3A0003     BRA NZ, 0x7A04
0079FE  2F7430     MOV #0xF743, W0
007A00  07FEFA     RCALL lcdWriteStringQ
007A02  370002     BRA 0x7A08
007A04  EBC000     SETM.B W0
007A06  07FEB3     RCALL lcdWriteQ
173:               }
007A08  78044F     MOV [--W15], W8
007A0A  060000     RETURN
174:               
175:               void lcdPoll(void){  
176:                   if(lcdWritePtr!=lcdSendPtr){   
007A0C  8082B0     MOV 0x1056, W0
007A0E  E31054     CP 0x1054
007A10  320019     BRA Z, 0x7A44
177:                       if((*lcdSendPtr>>8)&1) LCD_RS=0;
007A12  201001     MOV #0x100, W1
007A14  608090     AND W1, [W0], W1
007A16  320002     BRA Z, 0x7A1C
007A18  A9EE45     BCLR 0xE45, #7
007A1A  370001     BRA 0x7A1E
178:                       else LCD_RS=1;
007A1C  A8EE45     BSET 0xE45, #7
179:                       PMDIN1=(*lcdSendPtr++)&0x00FF;
007A1E  200FF1     MOV #0xFF, W1
007A20  6080B0     AND W1, [W0++], W1
007A22  883041     MOV W1, PMDIN1
007A24  8882B0     MOV W0, 0x1056
180:                       if(lcdSendPtr==&lcdBuf[LCDBUF]) lcdSendPtr=lcdBuf;
007A26  2617C1     MOV #0x617C, W1
007A28  500F81     SUB W0, W1, [W15]
007A2A  3A0003     BRA NZ, 0x7A32
007A2C  2FF000     MOV #0xFF00, W0
007A2E  400001     ADD W0, W1, W0
007A30  8882B0     MOV W0, 0x1056
181:                       if((*lcdSendPtr>>9)&1)
007A32  202000     MOV #0x200, W0
007A34  8082B1     MOV 0x1056, W1
007A36  600011     AND W0, [W1], W0
007A38  320003     BRA Z, 0x7A40
182:                           PR3=0x2D00; //2D00 for ~1.3mS
007A3A  22D000     MOV #0x2D00, W0
007A3C  880870     MOV W0, PR3
007A3E  370002     BRA 0x7A44
183:                       else PR3=0x0120; //120 for ~40uS
007A40  201200     MOV #0x120, W0
007A42  880870     MOV W0, PR3
184:                   } 
185:                   TMR3=0x0000;
007A44  EF210A     CLR TMR3
186:                   IFS0bits.T3IF = 0;              //clear flag, restart
007A46  A90801     BCLR 0x801, #0
187:               }
007A48  060000     RETURN
188:               
189:               //ALWAYS SENDS, blocks program
190:               void lcdSend(unsigned char data){
007A4A  BE9F88     MOV.D W8, [W15++]
007A4C  781F8A     MOV W10, [W15++]
007A4E  784500     MOV.B W0, W10
191:                   while(PMMODEbits.BUSY)Delay_us(2);
007A50  E20602     CP0 PMMODE
007A52  3D0007     BRA GE, 0x7A62
007A54  200028     MOV #0x2, W8
007A56  280009     MOV #0x8000, W9
007A58  780008     MOV W8, W0
007A5A  070315     RCALL Delay_us
007A5C  803011     MOV PMMODE, W1
007A5E  648001     AND W9, W1, W0
007A60  3AFFFB     BRA NZ, 0x7A58
192:                   PMDIN1=data; 
007A62  FB850A     ZE W10, W10
007A64  88304A     MOV W10, PMDIN1
193:               }
007A66  78054F     MOV [--W15], W10
007A68  BE044F     MOV.D [--W15], W8
007A6A  060000     RETURN
194:               //ALWAYS SENDS, blocks program
195:               void lcdClear(void){
007A6C  BE9F88     MOV.D W8, [W15++]
196:                   while(PMMODEbits.BUSY)Delay_us(2);
007A6E  E20602     CP0 PMMODE
007A70  3D0007     BRA GE, 0x7A80
007A72  200028     MOV #0x2, W8
007A74  280009     MOV #0x8000, W9
007A76  780008     MOV W8, W0
007A78  070306     RCALL Delay_us
007A7A  803011     MOV PMMODE, W1
007A7C  648001     AND W9, W1, W0
007A7E  3AFFFB     BRA NZ, 0x7A76
197:                   PMDIN1=LCD_CLEARDISPLAY; 
007A80  200010     MOV #0x1, W0
007A82  883040     MOV W0, PMDIN1
198:               }
007A84  BE044F     MOV.D [--W15], W8
007A86  060000     RETURN
199:               
200:               //ALWAYS SENDS, blocks program
201:               void lcdReturn(void){
007A88  BE9F88     MOV.D W8, [W15++]
202:                   while(PMMODEbits.BUSY)Delay_us(2);
007A8A  E20602     CP0 PMMODE
007A8C  3D0007     BRA GE, 0x7A9C
007A8E  200028     MOV #0x2, W8
007A90  280009     MOV #0x8000, W9
007A92  780008     MOV W8, W0
007A94  0702F8     RCALL Delay_us
007A96  803011     MOV PMMODE, W1
007A98  648001     AND W9, W1, W0
007A9A  3AFFFB     BRA NZ, 0x7A92
203:                   PMDIN1=LCD_RETURNHOME;
007A9C  200020     MOV #0x2, W0
007A9E  883040     MOV W0, PMDIN1
204:               }
007AA0  BE044F     MOV.D [--W15], W8
007AA2  060000     RETURN
205:               
206:               void lcdInit(void){
207:                   LCD_RS=0;
007AA4  A9EE45     BCLR 0xE45, #7
208:                   lcdSend(0x38);              //function set, 8 bits, 2 line disp, 5x8
007AA6  B3C380     MOV.B #0x38, W0
007AA8  07FFD0     RCALL lcdSend
209:                   Delay_us(4500);                //>4.1 mS required
007AAA  211940     MOV #0x1194, W0
007AAC  0702EC     RCALL Delay_us
210:                   lcdSend(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
007AAE  B3C0C0     MOV.B #0xC, W0
007AB0  07FFCC     RCALL lcdSend
211:                   Delay_us(4500);
007AB2  211940     MOV #0x1194, W0
007AB4  0702E8     RCALL Delay_us
212:                   lcdClear();                    //Display Clear  
007AB6  07FFDA     RCALL lcdClear
213:                   Delay_us(1800);                //>1.64mS required
007AB8  207080     MOV #0x708, W0
007ABA  0702E5     RCALL Delay_us
214:                   lcdSend(0x06);               // entry Mode Set
007ABC  B3C060     MOV.B #0x6, W0
007ABE  07FFC5     RCALL lcdSend
215:                   Delay_us(200);
007AC0  200C80     MOV #0xC8, W0
007AC2  0702E1     RCALL Delay_us
216:                   lcdReturn();
007AC4  07FFE1     RCALL lcdReturn
217:                   Delay_us(1500);
007AC6  205DC0     MOV #0x5DC, W0
007AC8  0702DE     RCALL Delay_us
218:                   
219:                   //lcdCustomSymbols();
220:                   Delay_us(200);
007ACA  200C80     MOV #0xC8, W0
007ACC  0702DC     RCALL Delay_us
221:                   lcdClear();                         //Display Clear  
007ACE  07FFCE     RCALL lcdClear
222:                   Delay_us(1500);
007AD0  205DC0     MOV #0x5DC, W0
007AD2  0702D9     RCALL Delay_us
223:                   lcdReturn();
007AD4  07FFD9     RCALL lcdReturn
224:                   Delay_us(200);
007AD6  200C80     MOV #0xC8, W0
007AD8  0702D6     RCALL Delay_us
225:               }
007ADA  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/main.c  -----------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 //#include "fatfs/src/ff.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = OFF   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                unsigned char pad[BUTTONS]={1};                                                                   //CONTROL VARIABLES//
22:                fractional pots[4]={0};
23:                fractional pots_scaled[4]={0};
24:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
25:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
26:                
27:                /* DMA BUFFERS */
28:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
29:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
31:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
32:                
33:                unsigned int bpm=0, rw=0, frameReady=0, write_ptr=STREAMBUF;
34:                unsigned int idle=0, cycle=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                               //STATUS VARIABLES//
37:                volatile unsigned char t1flag=FALSE;
38:                volatile unsigned char t2flag=FALSE;
39:                volatile unsigned char recording=TRUE;
40:                unsigned char UART_ON = FALSE;
41:                unsigned char TEST_SIN = FALSE;
42:                
43:                volatile unsigned char tremelo=FALSE;                                           //FX FLAGS//
44:                volatile unsigned char looper=FALSE;
45:                volatile unsigned char lpf=FALSE;
46:                
47:                volatile unsigned char frame=FALSE;
48:                
49:                
50:                void initBuffer(void){
008372  25F7A7     MOV #0x5F7A, W7
008374  25FFA6     MOV #0x5FFA, W6
008376  2CF7E5     MOV #0xCF7E, W5
008378  2CEFE4     MOV #0xCEFE, W4
00837A  2CE7E3     MOV #0xCE7E, W3
00837C  2CDFE2     MOV #0xCDFE, W2
00837E  200401     MOV #0x40, W1
51:                    int i=0;
52:                    for(; i<STREAMBUF; i++){
008390  3AFFF8     BRA NZ, 0x8382
53:                        streamA[i]=0;
008380  EB0000     CLR W0
008382  782B80     MOV W0, [++W7]
54:                        streamB[i]=0;
008384  782B00     MOV W0, [++W6]
55:                        txBufferA[i]=0;
008386  782A80     MOV W0, [++W5]
56:                        txBufferB[i]=0;
008388  782A00     MOV W0, [++W4]
57:                        rxBufferA[i]=0;
00838A  782980     MOV W0, [++W3]
58:                        rxBufferB[i]=0;
00838C  782900     MOV W0, [++W2]
00838E  E90081     DEC W1, W1
59:                    }
60:                }
008392  060000     RETURN
61:                
62:                int main(void) {
008394  BE9F88     MOV.D W8, [W15++]
008396  BE9F8A     MOV.D W10, [W15++]
008398  BE9F8C     MOV.D W12, [W15++]
00839A  781F8E     MOV W14, [W15++]
0083C8  2FF80A     MOV #0xFF80, W10
0083CA  450508     ADD W10, W8, W10
63:                    initPorts();                    //configure io device & adc 
00839C  07FB9F     RCALL initPorts
64:                    //initUART1();                    //configure & enable UART
65:                    initBuffer();
00839E  07FFE9     RCALL initBuffer
66:                    initADC1();                     //configure & enable internal ADC
0083A0  07FC4D     RCALL initADC1
67:                    //initSPI1_MEM();
68:                    //initSPI2_ADC();                  //configure & enable SPI ADC !!!DEFUNCT!!!
69:                    initPMP();
0083A2  07FC5F     RCALL initPMP
70:                    //||||||||----
71:                    //initDMA0();
72:                    initDCI_DAC();                  //configure & enable DAC
0083A4  07FC9F     RCALL initDCI_DAC
73:                    initT1();                       //configure & start T1 
0083A6  07FC72     RCALL initT1
74:                    initT2();                       //configure & start T2 
0083A8  07FC80     RCALL initT2
75:                    initSPI3_MEM();                  //start segment display
0083AA  07FD0F     RCALL initSPI3_MEM
76:                
77:                    //initCAP_BPM();                  //configure bpm capture
78:                    initT3();                       //configure & start T3 for lcd
0083AC  07FC90     RCALL initT3
79:                    fractional temp;
80:                    int writePtr;
81:                    fractional *ping, *pong;
82:                    
83:                    while(1){    
84:                        if(frameReady) {
0083B6  E21014     CP0 frameReady
0083B8  32001C     BRA Z, 0x83F2
85:                            writePtr=STREAMBUF-1;
86:                            if(rw){
0083BA  E21012     CP0 rw
0083BC  320003     BRA Z, 0x83C4
87:                                ping = streamA+writePtr;
0083C0  25FFA8     MOV #0x5FFA, W8
0083C2  370002     BRA 0x83C8
88:                                pong = outputB+writePtr;
0083BE  25F7A9     MOV #0x5F7A, W9
89:                            }else{
90:                                ping = streamB+writePtr;
0083B4  2607AE     MOV #0x607A, W14
0083C6  78040E     MOV W14, W8
91:                                pong = outputA+writePtr;
0083B2  25EFAD     MOV #0x5EFA, W13
0083C4  78048D     MOV W13, W9
92:                            }
93:                            
94:                            for(; writePtr>=0; writePtr--){
0083DE  540F8A     SUB W8, W10, [W15]
0083E0  3AFFF5     BRA NZ, 0x83CC
95:                                temp=*ping--; //!rw
0083CC  780028     MOV [W8--], W0
96:                                if(temp<=-32766||temp>=32766)hard_clipped=TRUE;
0083AE  27FFDB     MOV #0x7FFD, W11
0083B0  EBC600     SETM.B W12
0083CE  40008B     ADD W0, W11, W1
0083D0  408FE6     ADD W1, #0x6, [W15]
0083D2  360002     BRA LEU, 0x83D8
0083D4  2101A1     MOV #0x101A, W1
0083D6  78488C     MOV.B W12, [W1]
97:                                temp=fx(temp);    //run fx on latest sample
0083D8  07FEB7     RCALL fx
98:                                *pong--=mixer(temp); //rw
0083DA  07FE5E     RCALL mixer
0083DC  781480     MOV W0, [W9--]
99:                                
100:                           }
101:                           temp = 8*idle/STREAMBUF;
102:                           cycle=STREAMBUF/(STREAMBUF-write_ptr);
0083E2  200400     MOV #0x40, W0
0083E4  8082C2     MOV 0x1058, W2
0083E6  500102     SUB W0, W2, W2
0083E8  090011     REPEAT #0x11
0083EA  D88002     DIV.UW W0, W2
0083EC  8880C0     MOV W0, cycle
103:                           idle=0;
0083EE  EF3016     CLR idle
104:                           frameReady=0;
0083F0  EF3014     CLR frameReady
105:                       }
106:                       if(t2flag==TRUE){
0083F2  BFD01C     MOV.B t2flag, WREG
0083F4  404FE1     ADD.B W0, #0x1, [W15]
0083F6  3A0003     BRA NZ, 0x83FE
107:                           scanMatrix();                   //read button matrix
0083F8  07FD09     RCALL scanMatrix
108:                           readPots();                     //read control pots
0083FA  07FD7F     RCALL readPots
109:                           t2flag=FALSE;
0083FC  EF701C     CLR.B t2flag
110:                       }
111:                       if(t1flag==TRUE){
0083FE  BFD01B     MOV.B t1flag, WREG
008400  404FE1     ADD.B W0, #0x1, [W15]
008402  3A0002     BRA NZ, 0x8408
112:                           display();
008404  07FDF9     RCALL display
113:                           t1flag=FALSE; 
008406  EF701B     CLR.B t1flag
114:                       }
115:                       if(IFS0bits.T3IF) lcdPoll();
008408  AB0801     BTST 0x801, #0
00840A  32FFD5     BRA Z, 0x83B6
00840C  07FAFF     RCALL lcdPoll
00840E  37FFD3     BRA 0x83B6
116:                   }
117:                   return 0;
118:               }
119:               // example test 
---  C:/Users/ryan/Documents/seniorproject/ps-040/devInits.c  -------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 
5:                 #include <xc.h>
6:                 #include <p33EP512GM310.h>
7:                 #include <libpic30.h>
8:                 #include "common.h"
9:                 #include "devInits.h"
10:                #include "utilities.h"
11:                #include "plcd.h"
12:                
13:                extern unsigned char UART_ON;
14:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
15:                 
16:                //Description: Responsible i/o, clock, & RP pin config setup
17:                //Prereq: NONE
18:                //Dependencies: NONE
19:                //*Note: This is ALWAYS the first function called in main*
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
007ADC  2FF3F0     MOV #0xFF3F, W0
007ADE  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
007AE0  2FFE00     MOV #0xFFE0, W0
007AE2  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
007AE4  2FE000     MOV #0xFE00, W0
007AE6  B60746     AND PLLFBD, WREG
007AE8  B30490     IOR #0x49, W0
007AEA  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
007AEC  200201     MOV #0x20, W1
007AEE  803A12     MOV OSCCON, W2
007AF0  608002     AND W1, W2, W0
007AF2  32FFFD     BRA Z, 0x7AEE
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
007AF4  803A10     MOV OSCCON, W0
007AF6  A16000     BCLR W0, #6
007AF8  200461     MOV #0x46, W1
007AFA  200572     MOV #0x57, W2
007AFC  207423     MOV #0x742, W3
007AFE  784981     MOV.B W1, [W3]
007B00  784982     MOV.B W2, [W3]
007B02  784980     MOV.B W0, [W3]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
007B04  2FFC00     MOV #0xFFC0, W0
007B06  803424     MOV RPOR2, W4
007B08  600184     AND W0, W4, W3
007B0A  A00003     BSET W3, #0
007B0C  883423     MOV W3, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
007B0E  2FF803     MOV #0xFF80, W3
007B10  803685     MOV RPINR24, W5
007B12  618205     AND W3, W5, W4
007B14  B303D4     IOR #0x3D, W4
007B16  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
007B18  B60686     AND RPOR3, WREG
007B1A  B300C0     IOR #0xC, W0
007B1C  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
007B1E  2C0FF0     MOV #0xC0FF, W0
007B20  803424     MOV RPOR2, W4
007B22  600284     AND W0, W4, W5
007B24  20D004     MOV #0xD00, W4
007B26  720205     IOR W4, W5, W4
007B28  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
007B2A  803434     MOV RPOR3, W4
007B2C  600284     AND W0, W4, W5
007B2E  20B004     MOV #0xB00, W4
007B30  720205     IOR W4, W5, W4
007B32  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
007B34  803575     MOV RPINR7, W5
007B36  618185     AND W3, W5, W3
007B38  B305F3     IOR #0x5F, W3
007B3A  883573     MOV W3, RPINR7
36:                    RPINR29bits.SCK3R=0x39;      //SCK3 input on pin 84
007B3C  280FF4     MOV #0x80FF, W4
007B3E  8036D3     MOV RPINR29, W3
007B40  620203     AND W4, W3, W4
007B42  239003     MOV #0x3900, W3
007B44  718184     IOR W3, W4, W3
007B46  8836D3     MOV W3, RPINR29
37:                    RPOR7bits.RP57R=0x20;        //SCK3 output on pin 84
007B48  803474     MOV RPOR7, W4
007B4A  600184     AND W0, W4, W3
007B4C  A0D003     BSET W3, #13
007B4E  883473     MOV W3, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
007B50  B60690     AND RPOR8, WREG
007B52  21F003     MOV #0x1F00, W3
007B54  718180     IOR W3, W0, W3
007B56  883483     MOV W3, RPOR8
39:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
007B58  803A10     MOV OSCCON, W0
007B5A  A06000     BSET W0, #6
007B5C  207423     MOV #0x742, W3
007B5E  784981     MOV.B W1, [W3]
007B60  784982     MOV.B W2, [W3]
007B62  784980     MOV.B W0, [W3]
40:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
41:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
007B64  EB8000     SETM W0
007B66  883B60     MOV W0, PMD7
007B68  F8076C     PUSH PMD7
007B6A  F9076A     POP PMD6
007B6C  F8076A     PUSH PMD6
007B6E  F90766     POP PMD4
007B70  F80766     PUSH PMD4
007B72  F90764     POP PMD3
007B74  F80764     PUSH PMD3
007B76  F90762     POP PMD2
007B78  F80762     PUSH PMD2
007B7A  F90760     POP PMD1
42:                    PMD1bits.AD1MD=0;
007B7C  A90760     BCLR PMD1, #0
43:                    PMD1bits.SPI1MD=0;
007B7E  A96760     BCLR PMD1, #3
44:                    PMD1bits.SPI2MD=0;
007B80  A98760     BCLR PMD1, #4
45:                    PMD1bits.U1MD=0;
007B82  A9A760     BCLR PMD1, #5
46:                    PMD1bits.U2MD=0;
007B84  A9C760     BCLR PMD1, #6
47:                    PMD1bits.DCIMD=0;
007B86  A90761     BCLR 0x761, #0
48:                    PMD1bits.T1MD=0;
007B88  A96761     BCLR 0x761, #3
49:                    PMD1bits.T2MD=0;
007B8A  A98761     BCLR 0x761, #4
50:                    PMD1bits.T3MD=0;
007B8C  A9A761     BCLR 0x761, #5
51:                    PMD1bits.T4MD=0;
007B8E  A9C761     BCLR 0x761, #6
52:                    PMD3bits.PMPMD=0;
007B90  A90765     BCLR 0x765, #0
53:                    PMD3bits.CMPMD=0;
007B92  A94765     BCLR 0x765, #2
54:                    PMD6bits.SPI3MD=0;
007B94  A9076A     BCLR PMD6, #0
55:                    PMD7bits.DMA0MD=0;
007B96  A9876C     BCLR PMD7, #4
56:                    
57:                    /* ANALOG PINS (1 = analog) */
58:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
007B98  EF2E6E     CLR ANSELG
007B9A  F80E6E     PUSH ANSELG
007B9C  F90E5E     POP ANSELF
007B9E  F80E5E     PUSH ANSELF
007BA0  F90E4E     POP ANSELE
007BA2  F80E4E     PUSH ANSELE
007BA4  F90E3E     POP ANSELD
007BA6  F80E3E     PUSH ANSELD
007BA8  F90E2E     POP ANSELC
007BAA  F80E2E     PUSH ANSELC
007BAC  F90E1E     POP ANSELB
007BAE  F80E1E     PUSH ANSELB
007BB0  F90E0E     POP ANSELA
59:                    ANSELBbits.ANSB0 = 1; // Ensure AN0/RB0 is analog
007BB2  A80E1E     BSET ANSELB, #0
60:                    ANSELBbits.ANSB1 = 1; // Ensure AN1/RB1 is analog
007BB4  A82E1E     BSET ANSELB, #1
61:                    ANSELBbits.ANSB2 = 1; // Ensure AN2/RB2 is analog
007BB6  A84E1E     BSET ANSELB, #2
62:                    ANSELBbits.ANSB3 = 1; // Ensure AN5/RB5 is analog
007BB8  A86E1E     BSET ANSELB, #3
63:                    
64:                    /* IO DIRECTION (1 = input) */
65:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
007BBA  EF2E60     CLR TRISG
007BBC  F80E60     PUSH TRISG
007BBE  F90E50     POP TRISF
007BC0  F80E50     PUSH TRISF
007BC2  F90E40     POP TRISE
007BC4  F80E40     PUSH TRISE
007BC6  F90E30     POP TRISD
007BC8  F80E30     PUSH TRISD
007BCA  F90E20     POP TRISC
007BCC  F80E20     PUSH TRISC
007BCE  F90E10     POP TRISB
007BD0  F80E10     PUSH TRISB
007BD2  F90E00     POP TRISA
66:                    TRISA=0x0603;
007BD4  206031     MOV #0x603, W1
007BD6  887001     MOV W1, TRISA
67:                    TRISB=0x0003;
007BD8  200031     MOV #0x3, W1
007BDA  887081     MOV W1, TRISB
68:                    TRISC=0x2080;
007BDC  220801     MOV #0x2080, W1
007BDE  887101     MOV W1, TRISC
69:                    TRISD=CNPUD=0x001E;
007BE0  2001E1     MOV #0x1E, W1
007BE2  8871D1     MOV W1, CNPUD
007BE4  F80E3A     PUSH CNPUD
007BE6  F90E30     POP TRISD
70:                    TRISE=0x7000;
007BE8  270001     MOV #0x7000, W1
007BEA  887201     MOV W1, TRISE
71:                    TRISF=CNPUF=0x00F0;
007BEC  200F01     MOV #0xF0, W1
007BEE  8872D1     MOV W1, CNPUF
007BF0  F80E5A     PUSH CNPUF
007BF2  F90E50     POP TRISF
72:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
007BF4  887350     MOV W0, CNPUG
007BF6  F80E6A     PUSH CNPUG
007BF8  F90E60     POP TRISG
73:                    
74:                    /* DIGITAL OUTPUT LATCH */
75:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
007BFA  EF2E64     CLR LATG
007BFC  F80E64     PUSH LATG
007BFE  F90E54     POP LATF
007C00  F80E54     PUSH LATF
007C02  F90E44     POP LATE
007C04  F80E44     PUSH LATE
007C06  F90E34     POP LATD
007C08  F80E34     PUSH LATD
007C0A  F90E24     POP LATC
007C0C  F80E24     PUSH LATC
007C0E  F90E14     POP LATB
007C10  F80E14     PUSH LATB
007C12  F90E04     POP LATA
76:                    LATA=0x0040;
007C14  200400     MOV #0x40, W0
007C16  887020     MOV W0, LATA
77:                    
78:                    
79:                    
80:                }
007C18  060000     RETURN
81:                
82:                //Description: Initializes UART1 device & interrupts
83:                //Prereq: NONE
84:                //Dependencies: NONE
85:                void initUART1(void){
86:                    IFS0bits.U1TXIF = 0;        //clear flag
007C1A  A98801     BCLR 0x801, #4
87:                    IFS0bits.U1RXIF = 0;        //clear flag
007C1C  A96801     BCLR 0x801, #3
88:                    U1STA=0x1510;               //enable tx & rx
007C1E  215100     MOV #0x1510, W0
007C20  881110     MOV W0, U1STA
89:                    U1BRG=BRGVAL;               //baud rate
007C22  2004A0     MOV #0x4A, W0
007C24  881140     MOV W0, U1BRG
90:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
007C26  2FFF90     MOV #0xFFF9, W0
007C28  B60220     AND U1MODE, WREG
007C2A  A01000     BSET W0, #1
007C2C  881100     MOV W0, U1MODE
91:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
007C2E  270000     MOV #0x7000, W0
007C30  B72844     IOR IPC2
92:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
007C32  200070     MOV #0x7, W0
007C34  B72846     IOR IPC3
93:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
94:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
95:                    U1MODEbits.UARTEN = 1;      //start uart
007C36  A8E221     BSET 0x221, #7
96:                    UART_ON = TRUE;
007C38  EFF01D     SETM.B UART_ON
97:                    
98:                }
007C3A  060000     RETURN
99:                
100:               //Description: Initializes onboard ADC 
101:               //Prereq: NONE
102:               //Dependencies: NONE
103:               void initADC1(void){
104:                   AD1CON1bits.ASAM = 1;       //enable simultaneous sample
007C3C  A84320     BSET AD1CON1, #2
105:                   AD1CON1bits.SIMSAM = 0;     //enable simultaneous sample
007C3E  A96320     BCLR AD1CON1, #3
106:                   AD1CON1bits.FORM=2;         //signed fractional format
007C40  2FCFF0     MOV #0xFCFF, W0
007C42  801902     MOV AD1CON1, W2
007C44  600082     AND W0, W2, W1
007C46  A09001     BSET W1, #9
007C48  881901     MOV W1, AD1CON1
107:                   AD1CON2bits.CHPS = 0b01;    //sample channels 0-3
007C4A  B60322     AND AD1CON2, WREG
007C4C  A08000     BSET W0, #8
007C4E  881910     MOV W0, AD1CON2
108:                   AD1CON3bits.ADCS = 0x3F;    //tad ~ 1us
007C50  B3C3F0     MOV.B #0x3F, W0
007C52  B7E324     MOV.B WREG, AD1CON3
109:                   //AD1CHS0bits.CH0SA = 0x03;   //ch0->an3 (no use an0)
110:                   AD1CHS0bits.CH0NA = 0; // Select Vref- for CH0 -ve input
007C54  A9E328     BCLR AD1CHS0, #7
111:                   AD1CHS123bits.CH123NA = 0; // Select Vref- for CH1/CH2/CH3 -ve input
007C56  2FFF90     MOV #0xFFF9, W0
007C58  B62326     AND AD1CHS123
112:                   AD1CON1bits.ADON = 1;       //start ADC module
007C5A  A8E321     BSET 0x321, #7
113:                   Delay_us(20);
007C5C  200140     MOV #0x14, W0
007C5E  070213     RCALL Delay_us
114:               }
007C60  060000     RETURN
115:               
116:               void initPMP(void){
117:                   /*
118:                    Data is clocked on falling edge of E
119:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
120:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
121:                    */
122:                   PMMODEbits.MODE=3;  //master mode 1 
007C62  203000     MOV #0x300, W0
007C64  B72602     IOR PMMODE
123:                   PMCONbits.PTWREN = 1;
007C66  A82601     BSET 0x601, #1
124:                   PMCONbits.PTRDEN = 1;
007C68  A80601     BSET 0x601, #0
125:                   PMCONbits.WRSP=1;   //write strobe active high
007C6A  A82600     BSET PMCON, #1
126:                   PMCONbits.RDSP=1;   //read strobe active high
007C6C  A80600     BSET PMCON, #0
127:               
128:                   PMMODEbits.WAITB = 0;
007C6E  2FF3F0     MOV #0xFF3F, W0
007C70  B62602     AND PMMODE
129:                   PMMODEbits.WAITM = 0xC;
007C72  2FFC30     MOV #0xFFC3, W0
007C74  B60602     AND PMMODE, WREG
007C76  B30300     IOR #0x30, W0
007C78  883010     MOV W0, PMMODE
130:                   PMMODEbits.WAITE = 0;
007C7A  2FFFC0     MOV #0xFFFC, W0
007C7C  B62602     AND PMMODE
131:                   LCD_RS=0;
007C7E  A9EE45     BCLR 0xE45, #7
132:                   PMCONbits.PMPEN = 1;
007C80  A8E601     BSET 0x601, #7
133:                   
134:                   /* INIT DEVICE */
135:                   Delay_us(40000);
007C82  29C400     MOV #0x9C40, W0
007C84  070200     RCALL Delay_us
136:                   lcdInit();
007C86  07FF0E     RCALL lcdInit
137:                   
138:                   /* SETUP SCREEN */
139:                   lcdSetupPots();
007C88  07FDC1     RCALL lcdSetupPots
140:               }
007C8A  060000     RETURN
141:               
142:               
143:               //Description: Initializes timer for LED's UART and display
144:               //Prereq: initUART1()
145:               //Dependencies: _T1Interrupt(void)
146:               //Frequency: 15Hz
147:               void initT1(void){          //16 bit timer
148:                   TMR1 = 0x0000;          //clear timer 4
007C8C  EF2100     CLR TMR1
149:                   T1CONbits.TCKPS = 3;    //prescale 1:256
007C8E  200300     MOV #0x30, W0
007C90  B72104     IOR T1CON
150:                   T1CONbits.TCS = 0;      //use internal clock
007C92  A92104     BCLR T1CON, #1
151:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
007C94  A9C104     BCLR T1CON, #6
152:                   PR1 = Fcy/(256*Fdisp);    //period register
007C96  246500     MOV #0x4650, W0
007C98  880810     MOV W0, PR1
153:                   //PR1=0x7FFF;
154:                   IFS0bits.T1IF = 0;      //clear timer 1 interrupt flag
007C9A  A96800     BCLR IFS0, #3
155:                   IEC0bits.T1IE = 1;      //enable timer 1 interrupt
007C9C  A86820     BSET IEC0, #3
156:                   IPC0bits.T1IP = 2;      //interrupt priority 2 (low)
007C9E  28FFF0     MOV #0x8FFF, W0
007CA0  B60840     AND IPC0, WREG
007CA2  A0D000     BSET W0, #13
007CA4  884200     MOV W0, IPC0
157:                   T1CONbits.TON = 1;      //start timer
007CA6  A8E105     BSET 0x105, #7
158:               }
007CA8  060000     RETURN
159:               
160:               //Description:  Initializes timer handles polling button input
161:               //Prereq: initADC1() 
162:               //Dependencies: _T2Interrupt(void)
163:               //Frequency: 512Hz
164:               void initT2(void){          //16/32 bit timer
165:                   TMR2 = 0x0000;          //clear timer 4
007CAA  EF2106     CLR TMR2
166:                   T2CONbits.T32 = 0;      //16 bit mode
007CAC  A96110     BCLR T2CON, #3
167:                   T2CONbits.TCKPS = 1;    //prescale 1:8
007CAE  2FFCF0     MOV #0xFFCF, W0
007CB0  B60110     AND T2CON, WREG
007CB2  A04000     BSET W0, #4
007CB4  880880     MOV W0, T2CON
168:                   T2CONbits.TCS = 0;      //use internal clock
007CB6  A92110     BCLR T2CON, #1
169:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
007CB8  A9C110     BCLR T2CON, #6
170:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
007CBA  241EB0     MOV #0x41EB, W0
007CBC  880860     MOV W0, PR2
171:                   IFS0bits.T2IF = 0;      //clear timer 2 interrupt flag
007CBE  A9E800     BCLR IFS0, #7
172:                   IEC0bits.T2IE = 1;      //enable timer 2 interrupt
007CC0  A8E820     BSET IEC0, #7
173:                   IPC1bits.T2IP = 2;      //interrupt priority 2 (low)
007CC2  28FFF0     MOV #0x8FFF, W0
007CC4  B60842     AND IPC1, WREG
007CC6  A0D000     BSET W0, #13
007CC8  884210     MOV W0, IPC1
174:                   T2CONbits.TON = 1;      //start timer
007CCA  A8E111     BSET 0x111, #7
175:               }
007CCC  060000     RETURN
176:               
177:               //Description: Initialize timer handling LCD sending
178:               //Dependencies: _T3Interrupt(void)
179:               //Frequency: 44.1kHz
180:               void initT3(void){          //16/32 bit timer
181:                   TMR3 = 0x0000;          //clear timer 3
007CCE  EF210A     CLR TMR3
182:                   T3CONbits.TCKPS = 1;    //prescale 8:1
007CD0  2FFCF0     MOV #0xFFCF, W0
007CD2  B60112     AND T3CON, WREG
007CD4  A04000     BSET W0, #4
007CD6  880890     MOV W0, T3CON
183:                   T3CONbits.TCS = 0;      //use internal clock
007CD8  A92112     BCLR T3CON, #1
184:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
007CDA  A9C112     BCLR T3CON, #6
185:                   //PR3 = Fcy/(256*T3freq);           //period register
186:                   PR3 = 0x01D0;           //45uS initial delay
007CDC  201D00     MOV #0x1D0, W0
007CDE  880870     MOV W0, PR3
187:                   
188:                   T3CONbits.TON = 1;
007CE0  A8E113     BSET 0x113, #7
189:                   
190:               }
007CE2  060000     RETURN
191:               
192:               //Description: Initializes & starts 16 bit DCI I2S DAC
193:               //Prereq: initSPI_ADC(void)
194:               //Dependencies: readDAC(void)
195:               void initDCI_DAC(void){
196:                   DCICON1bits.CSCKD=0;
007CE4  A94281     BCLR 0x281, #2
197:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
007CE6  2F0000     MOV #0xF000, W0
007CE8  B60284     AND DCICON3, WREG
007CEA  B30170     IOR #0x17, W0
007CEC  881420     MOV W0, DCICON3
198:                   DCICON1bits.COFSM=1;    //i2s mode
007CEE  2FFFC0     MOV #0xFFFC, W0
007CF0  B60280     AND DCICON1, WREG
007CF2  A00000     BSET W0, #0
007CF4  881400     MOV W0, DCICON1
199:                   DCICON1bits.CSCKE=1;    //sample on rising edge
007CF6  A82281     BSET 0x281, #1
200:                   DCICON2bits.WS=0xF;     //16 bit data word
007CF8  2000F0     MOV #0xF, W0
007CFA  B72282     IOR DCICON2
201:                   DCICON2bits.COFSG=0;    //data frame has 1 words
007CFC  2FE1F0     MOV #0xFE1F, W0
007CFE  B62282     AND DCICON2
202:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
007D00  A80288     BSET TSCON, #0
203:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
007D02  A82288     BSET TSCON, #1
204:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
007D04  A8028C     BSET RSCON, #0
205:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
007D06  A8228C     BSET RSCON, #1
206:                   DCICON1bits.DJST=0;     //align data
007D08  A9A280     BCLR DCICON1, #5
207:                   DCICON2bits.BLEN=1;     //2 words buffer btwn interrupts
007D0A  2F3FF0     MOV #0xF3FF, W0
007D0C  B60282     AND DCICON2, WREG
007D0E  A0A000     BSET W0, #10
007D10  881410     MOV W0, DCICON2
208:                   IPC15bits.DCIIP = 6;    // Interrput priority
007D12  2FFF80     MOV #0xFFF8, W0
007D14  B6085E     AND IPC15, WREG
007D16  B30060     IOR #0x6, W0
007D18  8842F0     MOV W0, IPC15
209:                   IFS3bits.DCIIF=0;
007D1A  A98807     BCLR 0x807, #4
210:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
007D1C  A88827     BSET 0x827, #4
211:                   TXBUF0=0;
007D1E  EF2298     CLR TXBUF0
212:                   TXBUF1=0;   
007D20  EF229A     CLR TXBUF1
213:                   DCICON1bits.DCIEN=1;    //ENABLE
007D22  A8E281     BSET 0x281, #7
214:               }
007D24  060000     RETURN
215:               
216:               void initDMA0(void){
217:                   unsigned long address;
218:                   
219:                   /*
220:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
221:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
222:                   DMA0PAD =  0X0608; // Point DMA to PMP
223:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
224:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
225:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
226:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
227:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
228:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
229:                   DMA0CONbits.CHEN=1; // Enable DMA
230:                   */
231:                   
232:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
007D26  A9CB01     BCLR 0xB01, #6
233:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
007D28  A8AB01     BSET 0xB01, #5
234:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
007D2A  2FFCF4     MOV #0xFFCF, W4
007D2C  20B000     MOV #0xB00, W0
007D2E  620810     AND W4, [W0], [W0]
235:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
007D30  2FFFC3     MOV #0xFFFC, W3
007D32  805801     MOV DMA0CON, W1
007D34  618001     AND W3, W1, W0
007D36  A01000     BSET W0, #1
007D38  885800     MOV W0, DMA0CON
236:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
007D3A  A98B01     BCLR 0xB01, #4
237:                   DMA0CONbits.NULLW = 0;
007D3C  A96B01     BCLR 0xB01, #3
238:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
007D3E  A9EB03     BCLR 0xB03, #7
239:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
007D40  B3C3C2     MOV.B #0x3C, W2
007D42  20B025     MOV #0xB02, W5
007D44  784A82     MOV.B W2, [W5]
240:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
007D46  27FFF0     MOV #0x7FFF, W0
007D48  2CF801     MOV #0xCF80, W1
007D4A  608080     AND W1, W0, W1
241:                   address +=__builtin_edspage(txBufferA) << 15;
007D4C  200016     MOV #0x1, W6
007D4E  DD334F     SL W6, #15, W6
007D50  EB0380     CLR W7
007D52  408306     ADD W1, W6, W6
007D54  4B83E0     ADDC W7, #0x0, W7
242:                   DMA0STAL = address & 0xFFFF;
007D56  885826     MOV W6, DMA0STAL
243:                   DMA0STAH = address >>16;
007D58  885837     MOV W7, DMA0STAH
244:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
007D5A  2CF001     MOV #0xCF00, W1
007D5C  608080     AND W1, W0, W1
245:                   address +=__builtin_edspage(txBufferB) << 15;
007D5E  200016     MOV #0x1, W6
007D60  DD334F     SL W6, #15, W6
007D62  EB0380     CLR W7
007D64  408306     ADD W1, W6, W6
007D66  4B83E0     ADDC W7, #0x0, W7
246:                   DMA0STBL = address & 0xFFFF;
007D68  885846     MOV W6, DMA0STBL
247:                   DMA0STBH = address >>16;
007D6A  885857     MOV W7, DMA0STBH
248:                   DMA0PAD = (int)&TXBUF0;
007D6C  202981     MOV #0x298, W1
007D6E  885861     MOV W1, DMA0PAD
249:                   DMA0CNT = STREAMBUF-1;
007D70  2003F1     MOV #0x3F, W1
007D72  885871     MOV W1, DMA0CNT
250:                   /* DMA 2 - DCI to DPSRAM*/
251:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
007D74  A9CB21     BCLR 0xB21, #6
252:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
007D76  A9AB21     BCLR 0xB21, #5
253:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
007D78  A98B21     BCLR 0xB21, #4
254:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
007D7A  A96B21     BCLR 0xB21, #3
255:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
007D7C  20B205     MOV #0xB20, W5
007D7E  620A95     AND W4, [W5], [W5]
256:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
007D80  805904     MOV DMA2CON, W4
007D82  618184     AND W3, W4, W3
007D84  A01003     BSET W3, #1
007D86  885903     MOV W3, DMA2CON
257:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
007D88  A9EB23     BCLR 0xB23, #7
258:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
007D8A  784182     MOV.B W2, W3
007D8C  20B225     MOV #0xB22, W5
007D8E  784A83     MOV.B W3, [W5]
259:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
007D90  2CE804     MOV #0xCE80, W4
007D92  620200     AND W4, W0, W4
260:                   address +=__builtin_edspage(rxBufferA) << 15;
007D94  200012     MOV #0x1, W2
007D96  DD114F     SL W2, #15, W2
007D98  EB0180     CLR W3
007D9A  420102     ADD W4, W2, W2
007D9C  4981E0     ADDC W3, #0x0, W3
261:                   DMA2STAL = address & 0xFFFF;
007D9E  885922     MOV W2, DMA2STAL
262:                   DMA2STAH = address >>16;
007DA0  885933     MOV W3, DMA2STAH
263:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
007DA2  2CE002     MOV #0xCE00, W2
007DA4  610000     AND W2, W0, W0
264:                   address +=__builtin_edspage(rxBufferB) << 15;
007DA6  200012     MOV #0x1, W2
007DA8  DD114F     SL W2, #15, W2
007DAA  EB0180     CLR W3
007DAC  400102     ADD W0, W2, W2
007DAE  4981E0     ADDC W3, #0x0, W3
265:                   DMA2STBL = address & 0xFFFF;
007DB0  885942     MOV W2, DMA2STBL
266:                   DMA2STBH = address >>16;
007DB2  885953     MOV W3, DMA2STBH
267:                   DMA2PAD = (int)&RXBUF0;
007DB4  202900     MOV #0x290, W0
007DB6  885960     MOV W0, DMA2PAD
268:                   DMA2CNT = STREAMBUF-1;
007DB8  885971     MOV W1, DMA2CNT
269:                   _DMA2IP = 5;
007DBA  2FFF80     MOV #0xFFF8, W0
007DBC  B6084C     AND IPC6, WREG
007DBE  B30050     IOR #0x5, W0
007DC0  884260     MOV W0, IPC6
270:                   _DMA2IE = 1;
007DC2  A80823     BSET 0x823, #0
271:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
007DC4  A8EB01     BSET 0xB01, #7
272:                   DMA2CONbits.CHEN = 1;
007DC6  A8EB21     BSET 0xB21, #7
273:               }
007DC8  060000     RETURN
274:               
275:               void initSPI3_MEM(void){
276:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
007DCA  A9680B     BCLR 0x80B, #3
277:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
007DCC  A9682B     BCLR 0x82B, #3
278:                   SPI3CON1bits.MSTEN=1;       //master mode
007DCE  A8A2A2     BSET SPI3CON1, #5
279:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
007DD0  A982A3     BCLR 0x2A3, #4
280:                   SPI3CON1bits.MODE16=1;      //16 bit
007DD2  A842A3     BSET 0x2A3, #2
281:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
007DD4  A962A3     BCLR 0x2A3, #3
282:                   SPI3CON1bits.SSEN=0;        //use SS
007DD6  A9E2A2     BCLR SPI3CON1, #7
283:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
007DD8  A9E2A5     BCLR 0x2A5, #7
284:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
007DDA  A902A4     BCLR SPI3CON2, #0
285:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
007DDC  2FFE30     MOV #0xFFE3, W0
007DDE  B60260     AND SPI2STAT, WREG
007DE0  B30140     IOR #0x14, W0
007DE2  881300     MOV W0, SPI2STAT
286:                   SPI3CON1bits.SMP=0;         //data sampled at end of output time
007DE4  A922A3     BCLR 0x2A3, #1
287:                   SPI3CON1bits.CKP=0;         //idle clock is low
007DE6  A9C2A2     BCLR SPI3CON1, #6
288:                   SPI3CON1bits.CKE=1;         //data changes from H to L
007DE8  A802A3     BSET 0x2A3, #0
289:                   SPI3CON1bits.PPRE=1;        //4:1 primary prescale
007DEA  2FFFC0     MOV #0xFFFC, W0
007DEC  B602A2     AND SPI3CON1, WREG
007DEE  A00000     BSET W0, #0
007DF0  881510     MOV W0, SPI3CON1
290:                   SPI3CON1bits.SPRE=7;        //1:1 secondary
007DF2  2001C0     MOV #0x1C, W0
007DF4  B722A2     IOR SPI3CON1
291:                   SPI3STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
007DF6  A9C2A0     BCLR SPI3STAT, #6
292:                   IPC22bits.SPI3IP = 3;        // Interrupt priority
007DF8  28FFF1     MOV #0x8FFF, W1
007DFA  804360     MOV IPC22, W0
007DFC  608080     AND W1, W0, W1
007DFE  230000     MOV #0x3000, W0
007E00  700001     IOR W0, W1, W0
007E02  884360     MOV W0, IPC22
293:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
007E04  A9680B     BCLR 0x80B, #3
294:                   IEC5bits.SPI3IE = 0;        // Enable the interrupt
007E06  A9682B     BCLR 0x82B, #3
295:                   SPI3STATbits.SPIEN = 1;     //start SPI module
007E08  A8E2A1     BSET 0x2A1, #7
296:               }
007E0A  060000     RETURN
297:               /*
298:               void initCAP_BPM(void){
299:                   IFS0bits.IC1IF=0;
300:                   IPC0bits.IC1IP=3;
301:                   IC1CON1bits.ICTSEL=0;   //Fp is clock source (7))
302:                   IC1CON1bits.ICM=2;      //capture every falling edge
303:                   IC1CON2bits.ICTRIG=1;
304:                   IC1CON2bits.SYNCSEL=0xD;
305:                   IEC0bits.IC1IE=1;
306:               }
307:               
308:               //Description: Initializes 16 bit SPI ADC 
309:               //Prereq: NONE
310:               //Dependencies: NONE
311:               void initSPI2_ADC(void){
312:                   //ADC_CONV=1;                 //prevent shift as per errata
313:                   PORTBbits.RB10=1;           //prevent shift as per errata
314:                   IFS2bits.SPI2IF = 0;        // Clear the Interrupt flag
315:                   IEC2bits.SPI2IE = 0;        // Disable the interrupt
316:                   SPI2CON1bits.MSTEN=1;       //master mode
317:                   SPI2CON1bits.DISSCK = 0;    //Internal serial clock is enabled
318:                   SPI2CON1bits.MODE16=1;      //16 bit
319:                   SPI2CON1bits.DISSDO=1;      //no SDO 
320:                   SPI2CON1bits.SSEN=0;        //no use SS
321:                   SPI2CON2bits.FRMEN=0;       //no enable framed mode
322:                   SPI2CON2bits.SPIBEN=1;      //enhanced buffer mode
323:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
324:                   SPI2CON1bits.SMP=1;         //data sampled at end of output time
325:                   SPI2CON1bits.CKP=1;         //idle clock is high
326:                   SPI2CON1bits.CKE=1;         //data changes from H to L
327:                   SPI2CON1bits.PPRE=2;        //4:1 primary prescale
328:                   SPI2CON1bits.SPRE=0;        //8:1 secondary
329:                   SPI2STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
330:                   IPC8bits.SPI2IP = 5;        // Interrupt priority
331:                   IFS2bits.SPI2IF = 0;        // Clear the Interrupt flag
332:                   IEC2bits.SPI2IE = 1;        // Enable the interrupt
333:                   SPI2STATbits.SPIEN = 1;     //start SPI module
334:               }
335:                * 
336:                * void initSPI1_MEM(void){
337:                   IFS0bits.SPI1IF = 0;        // Clear the Interrupt flag
338:                   IEC0bits.SPI1IE = 0;        // Disable the interrupt
339:                   SPI1CON1bits.MSTEN=1;       //master mode
340:                   SPI1CON1bits.DISSCK = 0;    //Internal serial clock is enabled
341:                   SPI1CON1bits.MODE16=1;      //16 bit
342:                   SPI1CON1bits.SSEN=0;        //no use SS
343:                   SPI1CON2bits.FRMEN=0;       //no enable framed mode
344:                   SPI1CON2bits.SPIBEN=0;      //enhanced buffer mode
345:                   SPI1STATbits.SISEL=5;       //interrupt when done sending
346:                   SPI1CON1bits.SMP=1;         //data sampled at end of output time
347:                   SPI1CON1bits.CKP=1;         //idle clock is high
348:                   SPI1CON1bits.CKE=1;         //data changes from H to L
349:                   SPI1CON1bits.PPRE=1;        //4:1 primary prescale
350:                   SPI1CON1bits.SPRE=1;        //8:1 secondary
351:                   SPI1STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
352:               
353:                   SPI1STATbits.SPIEN = 1;     //start SPI module
354:               }
355:               */
356:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/audio.c  ----------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[8];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[4];
7:                 extern fractional pots_scaled[4];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                fractional mixer(fractional sample){
008098  F80022     PUSH ACCA
00809A  F80024     PUSH ACCAH
00809C  F80026     PUSH ACCAU
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    
38:                
39:                    if(kick_playing==TRUE&&kick_ptr<kick_max){
00809E  210361     MOV #0x1036, W1
0080A0  784091     MOV.B [W1], W1
0080A2  40CFE1     ADD.B W1, #0x1, [W15]
0080A4  3A0011     BRA NZ, 0x80C8
0080A6  877882     MOV 0xEF10, W2
0080A8  8081C3     MOV kick_ptr, W3
0080AA  518F82     SUB W3, W2, [W15]
0080AC  31000D     BRA C, 0x80C8
40:                        result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
0080AE  780200     MOV W0, W4
0080B0  273325     MOV #0x7332, W5
0080B2  C00113     MPY W4*W5, A
41:                        result1 = __builtin_add(result1,kick[kick_ptr++],0);
0080B4  780003     MOV W3, W0
0080B6  400080     ADD W0, W0, W1
0080B8  2C3B02     MOV #0xC3B0, W2
0080BA  410081     ADD W2, W1, W1
0080BC  780091     MOV [W1], W1
0080BE  E80000     INC W0, W0
0080C0  8881C0     MOV W0, kick_ptr
0080C2  C90001     ADD W1, A
42:                        sample=__builtin_sac(result1, 0);
0080C4  CC0000     SAC A, W0
0080C6  37000C     BRA 0x80E0
43:                    }
44:                    else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
0080C8  262402     MOV #0x6240, W2
0080CA  B3C013     MOV.B #0x1, W3
0080CC  11CF92     SUBR.B W3, [W2], [W15]
0080CE  3A0008     BRA NZ, 0x80E0
0080D0  40CFE1     ADD.B W1, #0x1, [W15]
0080D2  3A0006     BRA NZ, 0x80E0
0080D4  877881     MOV 0xEF10, W1
0080D6  8081C4     MOV kick_ptr, W4
0080D8  520F81     SUB W4, W1, [W15]
0080DA  3A0002     BRA NZ, 0x80E0
45:                        kick_playing=FALSE;
0080DC  EF7036     CLR.B kick_playing
46:                        kick_ptr=0;
0080DE  EF3038     CLR kick_ptr
47:                    }
48:                    /*
49:                    if(hat_playing==TRUE&&hat_ptr<hat_max){
50:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
51:                        result1 = __builtin_add(result1,hat[hat_ptr++],0);
52:                        sample=__builtin_sac(result1, 0);
53:                    }
54:                    else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
55:                        hat_playing=FALSE;
56:                        hat_ptr=0;
57:                    }
58:                     */
59:                
60:                    if(snare_playing==TRUE&&snare_ptr<snare_max){
0080E0  2103A1     MOV #0x103A, W1
0080E2  784091     MOV.B [W1], W1
0080E4  40CFE1     ADD.B W1, #0x1, [W15]
0080E6  3A0011     BRA NZ, 0x810A
0080E8  877892     MOV 0xEF12, W2
0080EA  8081E5     MOV snare_ptr, W5
0080EC  528F82     SUB W5, W2, [W15]
0080EE  31000D     BRA C, 0x810A
61:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
0080F0  780200     MOV W0, W4
0080F2  26CCC5     MOV #0x6CCC, W5
0080F4  C00113     MPY W4*W5, A
62:                        result1 = __builtin_add(result1,snare[snare_ptr++],0);
0080F6  8081E0     MOV snare_ptr, W0
0080F8  400080     ADD W0, W0, W1
0080FA  292D82     MOV #0x92D8, W2
0080FC  410081     ADD W2, W1, W1
0080FE  780091     MOV [W1], W1
008100  E80000     INC W0, W0
008102  8881E0     MOV W0, snare_ptr
008104  C90001     ADD W1, A
63:                        sample=__builtin_sac(result1, 0);
008106  CC0000     SAC A, W0
008108  37000C     BRA 0x8122
64:                    }
65:                    else if (pad[2]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
00810A  262422     MOV #0x6242, W2
00810C  B3C013     MOV.B #0x1, W3
00810E  11CF92     SUBR.B W3, [W2], [W15]
008110  3A0008     BRA NZ, 0x8122
008112  40CFE1     ADD.B W1, #0x1, [W15]
008114  3A0006     BRA NZ, 0x8122
008116  877891     MOV 0xEF12, W1
008118  8081E4     MOV snare_ptr, W4
00811A  520F81     SUB W4, W1, [W15]
00811C  3A0002     BRA NZ, 0x8122
66:                        snare_playing=FALSE;
00811E  EF703A     CLR.B snare_playing
67:                        snare_ptr=0;
008120  EF303C     CLR snare_ptr
68:                    }
69:                    
70:                    
71:                    //VOLUME CONTROL
72:                    /*
73:                    if(pots[0]==0x001F)
74:                        sample=0;
75:                    else if(pots[0]>0xFFF0);
76:                    else{
77:                        result1 =__builtin_mpy(sample,pots[0], NULL, NULL, 0, NULL, NULL, 0);
78:                        sample=__builtin_sac(result1, 0);
79:                    }
80:                    */
81:                    if (TEST_SIN==TRUE){
008122  2101E1     MOV #0x101E, W1
008124  784091     MOV.B [W1], W1
008126  40CFE1     ADD.B W1, #0x1, [W15]
008128  3A000B     BRA NZ, 0x8140
82:                        i++;
00812A  EC1034     INC i, WREG
00812C  8881A0     MOV W0, i
83:                        if(i==1024)
00812E  204001     MOV #0x400, W1
008130  500F81     SUB W0, W1, [W15]
008132  3A0001     BRA NZ, 0x8136
84:                            i=0;
008134  EF3034     CLR i
85:                        return sintab[i];
008136  8081A0     MOV i, W0
008138  400000     ADD W0, W0, W0
00813A  2EF161     MOV #0xEF16, W1
00813C  408000     ADD W1, W0, W0
00813E  780010     MOV [W0], W0
86:                    }
87:                    else 
88:                        return sample;
89:                    
90:                }
008140  F90026     POP ACCAU
008142  F90024     POP ACCAH
008144  F90022     POP ACCA
008146  060000     RETURN
91:                
92:                fractional fx(fractional sample){
008148  F80022     PUSH ACCA
00814A  F80024     PUSH ACCAH
00814C  F80026     PUSH ACCAU
00814E  F80028     PUSH ACCB
008150  F8002A     PUSH ACCBH
008152  F8002C     PUSH ACCBU
93:                    volatile register int result1 asm("A");
94:                    volatile register int result2 asm("B");
95:                    static fractional delayed_sample;
96:                    static fractional trem_mod;
97:                    if(tremelo==TRUE){                                                          //TREMELO//
008154  2101F1     MOV #0x101F, W1
008156  784091     MOV.B [W1], W1
008158  40CFE1     ADD.B W1, #0x1, [W15]
00815A  3A0027     BRA NZ, 0x81AA
98:                        if (trem_var<=pots_scaled[1]){
00815C  808161     MOV trem_var, W1
00815E  808052     MOV 0x100A, W2
008160  510F81     SUB W2, W1, [W15]
008162  39000F     BRA NC, 0x8182
99:                            trem_var++;
008164  E80081     INC W1, W1
008166  888161     MOV W1, trem_var
100:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
008168  808141     MOV tremelo_ptr, W1
00816A  408081     ADD W1, W1, W1
00816C  2EF162     MOV #0xEF16, W2
00816E  410081     ADD W2, W1, W1
008170  780291     MOV [W1], W5
008172  808284     MOV 0x1050, W4
008174  C00113     MPY W4*W5, A
101:                           trem_mod=__builtin_sac(result1, 0);
008176  CC0004     SAC A, W4
008178  888184     MOV W4, trem_mod
102:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
00817A  780280     MOV W0, W5
00817C  C08113     MPY W4*W5, B
103:                           sample=__builtin_sac(result2, 0);
00817E  CC8000     SAC B, W0
008180  370014     BRA 0x81AA
104:                       }
105:                       else{
106:                           trem_var=0;
008182  EF302C     CLR trem_var
107:                           if(tremelo_ptr==1024)
008184  204001     MOV #0x400, W1
008186  808142     MOV tremelo_ptr, W2
008188  510F81     SUB W2, W1, [W15]
00818A  3A0001     BRA NZ, 0x818E
108:                               tremelo_ptr=0;
00818C  EF3028     CLR tremelo_ptr
109:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
00818E  808141     MOV tremelo_ptr, W1
008190  408101     ADD W1, W1, W2
008192  2EF163     MOV #0xEF16, W3
008194  418102     ADD W3, W2, W2
008196  780292     MOV [W2], W5
008198  E80081     INC W1, W1
00819A  888141     MOV W1, tremelo_ptr
00819C  808284     MOV 0x1050, W4
00819E  C00113     MPY W4*W5, A
110:                           trem_mod=__builtin_sac(result1, 0);
0081A0  CC0004     SAC A, W4
0081A2  888184     MOV W4, trem_mod
111:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
0081A4  780280     MOV W0, W5
0081A6  C08113     MPY W4*W5, B
112:                           sample=__builtin_sac(result2, 0);
0081A8  CC8000     SAC B, W0
113:                       }
114:                   }
115:                   if(looper==TRUE){                                                           //LOOPER// 
0081AA  210201     MOV #0x1020, W1
0081AC  784091     MOV.B [W1], W1
0081AE  40CFE1     ADD.B W1, #0x1, [W15]
0081B0  3A0019     BRA NZ, 0x81E4
116:                       if(loop_lim>=LOOP_BUF_SIZE)
0081B2  2270F0     MOV #0x270F, W0
0081B4  E31026     CP loop_lim
0081B6  360002     BRA LEU, 0x81BC
117:                           loop_lim=LOOP_BUF_SIZE;
0081B8  E80000     INC W0, W0
0081BA  888130     MOV W0, loop_lim
118:                       if(loop_ptr<loop_lim){
0081BC  808130     MOV loop_lim, W0
0081BE  E31024     CP loop_ptr
0081C0  310008     BRA C, 0x81D2
119:                           sample = (loop[loop_ptr++]);
0081C2  808121     MOV loop_ptr, W1
0081C4  408001     ADD W1, W1, W0
0081C6  2105C2     MOV #0x105C, W2
0081C8  410000     ADD W2, W0, W0
0081CA  780010     MOV [W0], W0
0081CC  E80081     INC W1, W1
0081CE  888121     MOV W1, loop_ptr
0081D0  37001D     BRA 0x820C
120:                       }
121:                       else {
122:                           loop_ptr=0;
0081D2  EF3024     CLR loop_ptr
123:                           sample = (loop[loop_ptr++]);
0081D4  808121     MOV loop_ptr, W1
0081D6  408001     ADD W1, W1, W0
0081D8  2105C2     MOV #0x105C, W2
0081DA  410000     ADD W2, W0, W0
0081DC  780010     MOV [W0], W0
0081DE  E80081     INC W1, W1
0081E0  888121     MOV W1, loop_ptr
0081E2  370014     BRA 0x820C
124:                       }
125:                   }                                                                           
126:                   else {                                                                      //buffer
127:                       if(loop_ptr<LOOP_BUF_SIZE)
0081E4  2270F1     MOV #0x270F, W1
0081E6  808122     MOV loop_ptr, W2
0081E8  510F81     SUB W2, W1, [W15]
0081EA  3E0008     BRA GTU, 0x81FC
128:                           loop[loop_ptr++]=sample;
0081EC  808121     MOV loop_ptr, W1
0081EE  408101     ADD W1, W1, W2
0081F0  2105C3     MOV #0x105C, W3
0081F2  418102     ADD W3, W2, W2
0081F4  780900     MOV W0, [W2]
0081F6  E80081     INC W1, W1
0081F8  888121     MOV W1, loop_ptr
0081FA  370008     BRA 0x820C
129:                       else {
130:                           loop_ptr=0;
0081FC  EF3024     CLR loop_ptr
131:                           loop[loop_ptr++]=sample;
0081FE  808121     MOV loop_ptr, W1
008200  408101     ADD W1, W1, W2
008202  2105C3     MOV #0x105C, W3
008204  418102     ADD W3, W2, W2
008206  780900     MOV W0, [W2]
008208  E80081     INC W1, W1
00820A  888121     MOV W1, loop_ptr
132:                       }
133:                   }
134:                   
135:                                                                                               //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
136:                   if(lpf==TRUE){
00820C  210211     MOV #0x1021, W1
00820E  784091     MOV.B [W1], W1
008210  40CFE1     ADD.B W1, #0x1, [W15]
008212  3A0008     BRA NZ, 0x8224
137:                       result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
008214  808264     MOV 0x104C, W4
008216  780280     MOV W0, W5
008218  C08113     MPY W4*W5, B
138:                       result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
00821A  808274     MOV 0x104E, W4
00821C  808195     MOV delayed_sample, W5
00821E  C08112     MAC W4*W5, B
139:                       delayed_sample=__builtin_sac(result2, 0);
008220  CC8000     SAC B, W0
008222  888190     MOV W0, delayed_sample
140:                       sample=delayed_sample;
141:                   }
142:                   return sample;
143:               }
008224  F9002C     POP ACCBU
008226  F9002A     POP ACCBH
008228  F90028     POP ACCB
00822A  F90026     POP ACCAU
00822C  F90024     POP ACCAH
00822E  F90022     POP ACCA
008230  060000     RETURN
144:               
145:               //test
