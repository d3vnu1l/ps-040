Disassembly Listing for sampler_0.49.2
Generated From:
C:/Users/ryan/Documents/seniorproject/ps-040/dist/default/production/ps-040.production.elf
Jan 29, 2018 10:20:15 AM

---  C:/Users/ryan/Documents/seniorproject/ps-040/utilitites.c  -----------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <libpic30.h>
4:                 #include <dsp.h>
5:                 #include <stdio.h>
6:                 #include <stdlib.h>
7:                 #include <math.h>
8:                 #include "common.h"
9:                 #include "sounds.h"
10:                #include "audio.h"
11:                #include "flash.h"
12:                #include "screens.h"
13:                #include "utilities.h"
14:                #include "devInits.h"
15:                
16:                
17:                //CONTROL VARIABLES//
18:                extern unsigned char pad[BUTTONS];
19:                extern fractional pots[POTS];
20:                extern char pots_percent[POTS];
21:                extern unsigned char UART_ON; 
22:                extern enum screen state;
23:                
24:                //STATUS VARIABLES//
25:                extern unsigned char hard_clipped;
26:                extern unsigned char UART_EN;
27:                extern unsigned int cycle;
28:                extern unsigned char TEST_SIN;
29:                extern fractional sampin;
30:                extern fractional sampout;
31:                
32:                //FX FLAGS & VARS
33:                extern unsigned char tremelo, looper, lpf;
34:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
35:                extern unsigned int loop_lim;
36:                extern fractional lpf_alpha, lpf_inv_alpha;
37:                extern fractional tremelo_depth;
38:                extern unsigned char kick_playing, snare_playing;   
39:                extern unsigned char frame;
40:                
41:                void scanButtons(void){
42:                    
43:                    static unsigned char pad_last[BUTTONS]={1};
44:                    int portrdG, portrdD, portrdF;
45:                
46:                    portrdG = PORTG;
007DD2  807313     MOV PORTG, W3
47:                    portrdD = PORTD;
007DD4  807191     MOV PORTD, W1
48:                    portrdF = PORTF;
007DD6  807292     MOV PORTF, W2
49:                    
50:                    pad[34]=(portrdF>>7)&1;     // Special function button
007DD8  DE9247     ASR W2, #7, W4
007DDA  624261     AND.B W4, #0x1, W4
007DDC  260BC5     MOV #0x60BC, W5
007DDE  784A84     MOV.B W4, [W5]
51:                    
52:                    if(pad[34]){
007DE0  320033     BRA Z, 0x7E48
53:                        pad[6]=(portrdF>>6)&1;
007DE2  DE92C6     ASR W2, #6, W5
007DE4  260A04     MOV #0x60A0, W4
007DE6  62CA61     AND.B W5, #0x1, [W4]
54:                        pad[5]=(portrdF>>5)&1;
007DE8  DE92C5     ASR W2, #5, W5
007DEA  E90204     DEC W4, W4
007DEC  62CA61     AND.B W5, #0x1, [W4]
55:                        pad[4]=(portrdF>>4)&1;
007DEE  DE9144     ASR W2, #4, W2
007DF0  E90204     DEC W4, W4
007DF2  614A61     AND.B W2, #0x1, [W4]
56:                        pad[0]=(portrdG)&1;
007DF4  520164     SUB W4, #0x4, W2
007DF6  61C961     AND.B W3, #0x1, [W2]
57:                        pad[1]=(portrdG>>1)&1;
007DF8  D18203     ASR W3, W4
007DFA  E80102     INC W2, W2
007DFC  624961     AND.B W4, #0x1, [W2]
58:                        pad[2]=(portrdG>>2)&1;
007DFE  DE9A42     ASR W3, #2, W4
007E00  E80102     INC W2, W2
007E02  624961     AND.B W4, #0x1, [W2]
59:                        pad[3]=(portrdG>>3)&1;
007E04  DE9A43     ASR W3, #3, W4
007E06  E80102     INC W2, W2
007E08  624961     AND.B W4, #0x1, [W2]
60:                        pad[16]=(portrdG>>10)&1;    // Encoder button
007E0A  DE9A4A     ASR W3, #10, W4
007E0C  41016D     ADD W2, #0xD, W2
007E0E  624961     AND.B W4, #0x1, [W2]
61:                        pad[11]=(portrdG>>11)&1;
007E10  DE9A4B     ASR W3, #11, W4
007E12  510165     SUB W2, #0x5, W2
007E14  624961     AND.B W4, #0x1, [W2]
62:                        pad[12]=(portrdG>>12)&1;
007E16  DE9A4C     ASR W3, #12, W4
007E18  E80102     INC W2, W2
007E1A  624961     AND.B W4, #0x1, [W2]
63:                        pad[13]=(portrdG>>13)&1;
007E1C  DE9A4D     ASR W3, #13, W4
007E1E  E80102     INC W2, W2
007E20  624961     AND.B W4, #0x1, [W2]
64:                        pad[14]=(portrdG>>14)&1;
007E22  DE984E     ASR W3, #14, W0
007E24  E80102     INC W2, W2
007E26  604961     AND.B W0, #0x1, [W2]
65:                        pad[15]=(portrdG>>15)&1;
007E28  DE19CF     LSR W3, #15, W3
007E2A  E80002     INC W2, W0
007E2C  784803     MOV.B W3, [W0]
66:                        pad[7]=(portrdD>>1)&1;
007E2E  D18101     ASR W1, W2
007E30  500068     SUB W0, #0x8, W0
007E32  614861     AND.B W2, #0x1, [W0]
67:                        pad[8]=(portrdD>>2)&1;
007E34  DE8942     ASR W1, #2, W2
007E36  E80000     INC W0, W0
007E38  614861     AND.B W2, #0x1, [W0]
68:                        pad[9]=(portrdD>>3)&1;
007E3A  DE8943     ASR W1, #3, W2
007E3C  E80000     INC W0, W0
007E3E  614861     AND.B W2, #0x1, [W0]
69:                        pad[10]=(portrdD>>4)&1;
007E40  DE88C4     ASR W1, #4, W1
007E42  E80000     INC W0, W0
007E44  60C861     AND.B W1, #0x1, [W0]
007E46  370032     BRA 0x7EAC
70:                    } else {
71:                        pad[23]=(portrdF>>6)&1;
007E48  DE92C6     ASR W2, #6, W5
007E4A  260B14     MOV #0x60B1, W4
007E4C  62CA61     AND.B W5, #0x1, [W4]
72:                        pad[22]=(portrdF>>5)&1;
007E4E  DE92C5     ASR W2, #5, W5
007E50  E90204     DEC W4, W4
007E52  62CA61     AND.B W5, #0x1, [W4]
73:                        pad[21]=(portrdF>>4)&1;
007E54  DE9144     ASR W2, #4, W2
007E56  E90204     DEC W4, W4
007E58  614A61     AND.B W2, #0x1, [W4]
74:                        pad[17]=(portrdG)&1;
007E5A  520164     SUB W4, #0x4, W2
007E5C  61C961     AND.B W3, #0x1, [W2]
75:                        pad[18]=(portrdG>>1)&1;
007E5E  D18203     ASR W3, W4
007E60  E80102     INC W2, W2
007E62  624961     AND.B W4, #0x1, [W2]
76:                        pad[19]=(portrdG>>2)&1;
007E64  DE9A42     ASR W3, #2, W4
007E66  E80102     INC W2, W2
007E68  624961     AND.B W4, #0x1, [W2]
77:                        pad[20]=(portrdG>>3)&1;
007E6A  DE9A43     ASR W3, #3, W4
007E6C  E80102     INC W2, W2
007E6E  624961     AND.B W4, #0x1, [W2]
78:                        pad[33]=(portrdG>>10)&1;    // Encoder button
007E70  DE9A4A     ASR W3, #10, W4
007E72  41016D     ADD W2, #0xD, W2
007E74  624961     AND.B W4, #0x1, [W2]
79:                        pad[28]=(portrdG>>11)&1;
007E76  DE9A4B     ASR W3, #11, W4
007E78  510165     SUB W2, #0x5, W2
007E7A  624961     AND.B W4, #0x1, [W2]
80:                        pad[29]=(portrdG>>12)&1;
007E7C  DE9A4C     ASR W3, #12, W4
007E7E  E80102     INC W2, W2
007E80  624961     AND.B W4, #0x1, [W2]
81:                        pad[30]=(portrdG>>13)&1;
007E82  DE9A4D     ASR W3, #13, W4
007E84  E80102     INC W2, W2
007E86  624961     AND.B W4, #0x1, [W2]
82:                        pad[31]=(portrdG>>14)&1;
007E88  DE984E     ASR W3, #14, W0
007E8A  E80102     INC W2, W2
007E8C  604961     AND.B W0, #0x1, [W2]
83:                        pad[32]=(portrdG>>15)&1;
007E8E  DE19CF     LSR W3, #15, W3
007E90  E80002     INC W2, W0
007E92  784803     MOV.B W3, [W0]
84:                        pad[24]=(portrdD>>1)&1;
007E94  D18101     ASR W1, W2
007E96  500068     SUB W0, #0x8, W0
007E98  614861     AND.B W2, #0x1, [W0]
85:                        pad[25]=(portrdD>>2)&1;
007E9A  DE8942     ASR W1, #2, W2
007E9C  E80000     INC W0, W0
007E9E  614861     AND.B W2, #0x1, [W0]
86:                        pad[26]=(portrdD>>3)&1;
007EA0  DE8943     ASR W1, #3, W2
007EA2  E80000     INC W0, W0
007EA4  614861     AND.B W2, #0x1, [W0]
87:                        pad[27]=(portrdD>>4)&1;
007EA6  DE88C4     ASR W1, #4, W1
007EA8  E80000     INC W0, W0
007EAA  60C861     AND.B W1, #0x1, [W0]
88:                    }
89:                
90:                   
91:                    
92:                    if(pad[13]==0&&pad_last[13]==1){                                              //TREMELO CONTROL
007EAC  260A70     MOV #0x60A7, W0
007EAE  784010     MOV.B [W0], W0
007EB0  E00400     CP0.B W0
007EB2  3A000C     BRA NZ, 0x7ECC
007EB4  277551     MOV #0x7755, W1
007EB6  B3C012     MOV.B #0x1, W2
007EB8  114F91     SUBR.B W2, [W1], [W15]
007EBA  3A0008     BRA NZ, 0x7ECC
93:                        pad_last[13]=0;
007EBC  780001     MOV W1, W0
007EBE  EB4800     CLR.B [W0]
94:                        if(tremelo==FALSE)
007EC0  E2500D     CP0.B tremelo
007EC2  3A0002     BRA NZ, 0x7EC8
95:                            tremelo=TRUE;
007EC4  EFF00D     SETM.B tremelo
007EC6  370004     BRA 0x7ED0
96:                        else tremelo=FALSE;
007EC8  EF700D     CLR.B tremelo
007ECA  370002     BRA 0x7ED0
97:                    }
98:                    else{
99:                        pad_last[13]=pad[13];
007ECC  277551     MOV #0x7755, W1
007ECE  784880     MOV.B W0, [W1]
100:                   }
101:                   
102:                   if(pad[14]==0) looper=TRUE;
007ED0  260A80     MOV #0x60A8, W0
007ED2  E00410     CP0.B [W0]
007ED4  3A0002     BRA NZ, 0x7EDA
007ED6  EFF00E     SETM.B looper
007ED8  370001     BRA 0x7EDC
103:                   else looper=FALSE;
007EDA  EF700E     CLR.B looper
104:                  
105:                   if(pad[15]==0&&pad_last[15]==1){                                              //LPF CONTROL
007EDC  260A90     MOV #0x60A9, W0
007EDE  784010     MOV.B [W0], W0
007EE0  E00400     CP0.B W0
007EE2  3A000C     BRA NZ, 0x7EFC
007EE4  277571     MOV #0x7757, W1
007EE6  B3C012     MOV.B #0x1, W2
007EE8  114F91     SUBR.B W2, [W1], [W15]
007EEA  3A0008     BRA NZ, 0x7EFC
106:                       pad_last[15]=0;
007EEC  780001     MOV W1, W0
007EEE  EB4800     CLR.B [W0]
107:                       if(lpf==FALSE)
007EF0  E2500F     CP0.B lpf
007EF2  3A0002     BRA NZ, 0x7EF8
108:                           lpf=TRUE;
007EF4  EFF00F     SETM.B lpf
007EF6  370004     BRA 0x7F00
109:                       else lpf=FALSE;
007EF8  EF700F     CLR.B lpf
007EFA  370002     BRA 0x7F00
110:                   }
111:                   else{
112:                       pad_last[15]=pad[15];
007EFC  277571     MOV #0x7757, W1
007EFE  784880     MOV.B W0, [W1]
113:                   }
114:                   
115:                   
116:                   // SAMPLE TRIGGERS 
117:                   if(pad[0]==0&&kick_playing==FALSE){                                         //kick
007F00  2609A0     MOV #0x609A, W0
007F02  E00410     CP0.B [W0]
007F04  3A0003     BRA NZ, 0x7F0C
007F06  E25038     CP0.B kick_playing
007F08  3A0001     BRA NZ, 0x7F0C
118:                       kick_playing=TRUE;
007F0A  EFF038     SETM.B kick_playing
119:                   }
120:                   /*
121:                   if(pad[2]==0&&hat_playing==FALSE){                                          //hat
122:                       hat_playing=TRUE;
123:                   }
124:                   */
125:                   if(pad[1]==0&&snare_playing==FALSE){                                        //snare
007F0C  2609B0     MOV #0x609B, W0
007F0E  E00410     CP0.B [W0]
007F10  3A0003     BRA NZ, 0x7F18
007F12  E2503C     CP0.B snare_playing
007F14  3A0001     BRA NZ, 0x7F18
126:                       snare_playing=TRUE;
007F16  EFF03C     SETM.B snare_playing
127:                   }
128:               }
007F18  060000     RETURN
129:               
130:               void readPots(void){
007F1A  F80022     PUSH ACCA
007F1C  F80024     PUSH ACCAH
007F1E  F80026     PUSH ACCAU
131:                   volatile register int scaled asm("A");
132:                   _AD1IF = 0; // Clear conversion done status bit
007F20  A9A801     BCLR 0x801, #5
133:                   
134:                   if(pad[34]){
007F22  260BC0     MOV #0x60BC, W0
007F24  E00410     CP0.B [W0]
007F26  320019     BRA Z, 0x7F5A
135:                       pots[0]=(ADC1BUF0>>1)|0x7;
007F28  801801     MOV ADC1BUF0, W1
007F2A  D10081     LSR W1, W1
007F2C  25E760     MOV #0x5E76, W0
007F2E  708867     IOR W1, #0x7, [W0]
136:                       pots[1]=(ADC1BUF1>>1)|0x7;
007F30  801811     MOV ADC1BUF1, W1
007F32  D10081     LSR W1, W1
007F34  E88000     INC2 W0, W0
007F36  708867     IOR W1, #0x7, [W0]
137:                       pots[2]=(ADC1BUF2>>1)|0x7;
007F38  801821     MOV ADC1BUF2, W1
007F3A  D10081     LSR W1, W1
007F3C  E88000     INC2 W0, W0
007F3E  708867     IOR W1, #0x7, [W0]
138:                       pots[3]=(ADC1BUF3>>1)|0x7;
007F40  801831     MOV ADC1BUF3, W1
007F42  D10081     LSR W1, W1
007F44  E88000     INC2 W0, W0
007F46  708867     IOR W1, #0x7, [W0]
139:                       pots[4]=(ADC1BUF4>>1)|0x7;
007F48  801841     MOV ADC1BUF4, W1
007F4A  D10081     LSR W1, W1
007F4C  E88000     INC2 W0, W0
007F4E  708867     IOR W1, #0x7, [W0]
140:                       pots[5]=(ADC1BUF5>>1)|0x7;
007F50  801851     MOV ADC1BUF5, W1
007F52  D10081     LSR W1, W1
007F54  E88000     INC2 W0, W0
007F56  708867     IOR W1, #0x7, [W0]
007F58  370018     BRA 0x7F8A
141:                   } else {
142:                       pots[6]=(ADC1BUF0>>1)|0x7;
007F5A  801801     MOV ADC1BUF0, W1
007F5C  D10081     LSR W1, W1
007F5E  25E820     MOV #0x5E82, W0
007F60  708867     IOR W1, #0x7, [W0]
143:                       pots[7]=(ADC1BUF1>>1)|0x7;
007F62  801811     MOV ADC1BUF1, W1
007F64  D10081     LSR W1, W1
007F66  E88000     INC2 W0, W0
007F68  708867     IOR W1, #0x7, [W0]
144:                       pots[8]=(ADC1BUF2>>1)|0x7;
007F6A  801821     MOV ADC1BUF2, W1
007F6C  D10081     LSR W1, W1
007F6E  E88000     INC2 W0, W0
007F70  708867     IOR W1, #0x7, [W0]
145:                       pots[9]=(ADC1BUF3>>1)|0x7;
007F72  801831     MOV ADC1BUF3, W1
007F74  D10081     LSR W1, W1
007F76  E88000     INC2 W0, W0
007F78  708867     IOR W1, #0x7, [W0]
146:                       pots[10]=(ADC1BUF4>>1)|0x7;
007F7A  801841     MOV ADC1BUF4, W1
007F7C  D10081     LSR W1, W1
007F7E  E88000     INC2 W0, W0
007F80  708867     IOR W1, #0x7, [W0]
147:                       pots[11]=(ADC1BUF5>>1)|0x7;
007F82  801851     MOV ADC1BUF5, W1
007F84  D10081     LSR W1, W1
007F86  E88000     INC2 W0, W0
007F88  708867     IOR W1, #0x7, [W0]
148:                   }
149:                   
150:                   loop_lim=pots_percent[5];               //LOOPER CONTROL
007F8A  25E930     MOV #0x5E93, W0
007F8C  FB0010     SE [W0], W0
007F8E  8880D0     MOV W0, loop_lim
151:                   if(pots[0]>=310){                      //LPF CONTROL
007F90  82F3B5     MOV pots, W5
007F92  201350     MOV #0x135, W0
007F94  528F80     SUB W5, W0, [W15]
007F96  340004     BRA LE, 0x7FA0
152:                       lpf_alpha=pots[0];
007F98  888255     MOV W5, divtestb
153:                       lpf_inv_alpha=(32767-lpf_alpha); 
007F9A  27FFF0     MOV #0x7FFF, W0
007F9C  500005     SUB W0, W5, W0
007F9E  888260     MOV W0, 0x104C
154:                   }
155:                   tremelo_depth=pots[1];
007FA0  25E780     MOV #0x5E78, W0
007FA2  780090     MOV [W0], W1
007FA4  888271     MOV W1, 0x104E
156:                   
157:                   /* Potentiometer scaling for fx or lcd display */
158:                   //scaled=__builtin_mpy(pots[5],Q15(0.33), NULL, NULL, 0, NULL, NULL, 0);
159:                   //pots_percent[5]=__builtin_sac(scaled, 0);
160:                   
161:                   scaled=__builtin_mpy(pots[0],POT_SCALAR100, NULL, NULL, 0, NULL, NULL, 0);
007FA6  264C94     MOV #0x64C9, W4
007FA8  C00113     MPY W4*W5, A
162:                   pots_percent[0]=__builtin_sac(scaled, 0);
007FAA  CC0002     SAC A, W2
007FAC  25E8E1     MOV #0x5E8E, W1
007FAE  784882     MOV.B W2, [W1]
163:                   scaled=__builtin_mpy(pots[1],POT_SCALAR100, NULL, NULL, 0, NULL, NULL, 0);
007FB0  780290     MOV [W0], W5
007FB2  C00113     MPY W4*W5, A
164:                   pots_percent[1]=__builtin_sac(scaled, 0);
007FB4  CC0001     SAC A, W1
007FB6  25E8F0     MOV #0x5E8F, W0
007FB8  784801     MOV.B W1, [W0]
165:                   scaled=__builtin_mpy(pots[2],POT_SCALAR100, NULL, NULL, 0, NULL, NULL, 0);
007FBA  82F3D5     MOV 0x5E7A, W5
007FBC  C00113     MPY W4*W5, A
166:                   pots_percent[2]=__builtin_sac(scaled, 0);
007FBE  CC0001     SAC A, W1
007FC0  E80000     INC W0, W0
007FC2  784801     MOV.B W1, [W0]
167:                   scaled=__builtin_mpy(pots[3],POT_SCALAR100, NULL, NULL, 0, NULL, NULL, 0);
007FC4  82F3E5     MOV 0x5E7C, W5
007FC6  C00113     MPY W4*W5, A
168:                   pots_percent[3]=__builtin_sac(scaled, 0);
007FC8  CC0001     SAC A, W1
007FCA  E80000     INC W0, W0
007FCC  784801     MOV.B W1, [W0]
169:                   scaled=__builtin_mpy(pots[4],POT_SCALAR100, NULL, NULL, 0, NULL, NULL, 0);
007FCE  82F3F5     MOV 0x5E7E, W5
007FD0  C00113     MPY W4*W5, A
170:                   pots_percent[4]=__builtin_sac(scaled, 0);
007FD2  CC0001     SAC A, W1
007FD4  E80000     INC W0, W0
007FD6  784801     MOV.B W1, [W0]
171:                   scaled=__builtin_mpy(pots[5],POT_SCALAR100, NULL, NULL, 0, NULL, NULL, 0);
007FD8  82F405     MOV 0x5E80, W5
007FDA  C00113     MPY W4*W5, A
172:                   pots_percent[5]=__builtin_sac(scaled, 0);
007FDC  CC0001     SAC A, W1
007FDE  E80000     INC W0, W0
007FE0  784801     MOV.B W1, [W0]
173:               }
007FE2  F90026     POP ACCAU
007FE4  F90024     POP ACCAH
007FE6  F90022     POP ACCA
007FE8  060000     RETURN
174:               
175:               void display(void){
176:                   IFS0bits.SPI1IF=0;
007FEA  A94801     BCLR 0x801, #2
177:                   SPI1STATbits.SPIROV = 0;
007FEC  A9C240     BCLR SPI1STAT, #6
178:                  
179:                   // Update ui state logic here
180:                   state = (ENCODERCNTL/4)+1;
007FEE  800E30     MOV POS1CNTL, W0
007FF0  DE0042     LSR W0, #2, W0
007FF2  E80000     INC W0, W0
007FF4  888240     MOV W0, 0x1048
181:                   
182:                   // Update screen here
183:                   screenUpdate();
007FF6  0701BE     RCALL screenUpdate
184:                  
185:                  if(UART_ON==TRUE){
007FF8  BFD00B     MOV.B UART_ON, WREG
007FFA  404FE1     ADD.B W0, #0x1, [W15]
007FFC  3A0007     BRA NZ, 0x800C
186:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
187:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
188:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
189:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
007FFE  F85E7A     PUSH 0x5E7A
008000  F85E78     PUSH 0x5E78
008002  F85E76     PUSH pots
008004  2F6FE0     MOV #0xF6FE, W0
008006  781F80     MOV W0, [W15++]
008008  07C25B     RCALL __printf_cdnopuxX
00800A  5787E8     SUB W15, #0x8, W15
190:                       //printf("%d\r\n", sample);  //check input ADC
191:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
192:                   }
193:                  
194:                  SLED=~SLED;
00800C  8072A0     MOV LATF, W0
00800E  EA8000     COM W0, W0
008010  600061     AND W0, #0x1, W0
008012  8072A1     MOV LATF, W1
008014  A10001     BCLR W1, #0
008016  700081     IOR W0, W1, W1
008018  8872A1     MOV W1, LATF
195:               }
00801A  060000     RETURN
196:               
197:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
198:                   /* This procedure loops back the received data to the*/
199:                   /* the codec output. The user application could process*/
200:                   /* this data as per application requirements.*/
201:                   int index;
202:                   for(index = 0;index < STREAMBUF;index ++)
00801C  EB0100     CLR W2
00801E  202003     MOV #0x200, W3
008022  E80102     INC W2, W2
008024  510F83     SUB W2, W3, [W15]
008026  3AFFFC     BRA NZ, 0x8020
203:                   {
204:                       targetBuffer[index] = sourceBuffer[index];
008020  7818B0     MOV [W0++], [W1++]
205:                   }
206:               }
008028  060000     RETURN
207:               
208:               //A blocking delay function. Not very accurate but good enough.
209:               void Delay_us(unsigned int delay)
210:               {
211:                   int i;
212:                   for (i = 0; i < delay; i++)
00802A  E00000     CP0 W0
00802C  320006     BRA Z, 0x803A
00802E  EB0080     CLR W1
008034  E80081     INC W1, W1
008036  500F81     SUB W0, W1, [W15]
008038  3EFFFB     BRA GTU, 0x8030
213:                   {
214:                       __asm__ volatile ("repeat #50");
008030  090032     REPEAT #0x32
215:                       __asm__ volatile ("nop");
008032  000000     NOP
216:                   }
217:               }
00803A  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/screens.c  --------------------------------------------
1:                 /*
2:                  * File:   screens.c
3:                  * Author: ryan
4:                  *
5:                  * Created on January 28, 2018, 11:17 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "common.h"
11:                #include "plcd.h"
12:                #include "dsp.h"
13:                #include "flash.h"
14:                
15:                extern unsigned char TEST_SIN;
16:                extern fractional pots[POTS];
17:                extern char pots_percent[POTS];
18:                extern enum screen state, laststate;
19:                extern char flash_readback[512];
20:                
21:                void screenDebugAudio(){
22:                
23:                }
0081EC  060000     RETURN
24:                
25:                void screenDebugPots(void){
26:                    if(state!=laststate){
0081EE  808090     MOV laststate, W0
0081F0  E31048     CP 0x1048
0081F2  32002D     BRA Z, 0x824E
27:                        // Setup here
28:                        lcdClearQ();
0081F4  07FC6F     RCALL lcdClearQ
29:                        lcdSetCursorQ(0,0);
0081F6  EB4080     CLR.B W1
0081F8  784001     MOV.B W1, W0
0081FA  07FC77     RCALL lcdSetCursorQ
30:                        lcdWriteStringQ("1:");
0081FC  2F6D20     MOV #0xF6D2, W0
0081FE  07FC89     RCALL lcdWriteStringQ
31:                        lcdSetCursorQ(8,0);
008200  EB4080     CLR.B W1
008202  B3C080     MOV.B #0x8, W0
008204  07FC72     RCALL lcdSetCursorQ
32:                        lcdWriteStringQ("2:");
008206  2F6D50     MOV #0xF6D5, W0
008208  07FC84     RCALL lcdWriteStringQ
33:                        lcdSetCursorQ(0,1);
00820A  B3C011     MOV.B #0x1, W1
00820C  EB4000     CLR.B W0
00820E  07FC6D     RCALL lcdSetCursorQ
34:                        lcdWriteStringQ("3:");
008210  2F6D80     MOV #0xF6D8, W0
008212  07FC7F     RCALL lcdWriteStringQ
35:                        lcdSetCursorQ(8,1);
008214  B3C011     MOV.B #0x1, W1
008216  B3C080     MOV.B #0x8, W0
008218  07FC68     RCALL lcdSetCursorQ
36:                        lcdWriteStringQ("4:");
00821A  2F6DB0     MOV #0xF6DB, W0
00821C  07FC7A     RCALL lcdWriteStringQ
37:                        lcdSetCursorQ(0,2);
00821E  B3C021     MOV.B #0x2, W1
008220  EB4000     CLR.B W0
008222  07FC63     RCALL lcdSetCursorQ
38:                        lcdWriteStringQ("5:");
008224  2F6DE0     MOV #0xF6DE, W0
008226  07FC75     RCALL lcdWriteStringQ
39:                        lcdSetCursorQ(8,2);
008228  B3C021     MOV.B #0x2, W1
00822A  B3C080     MOV.B #0x8, W0
00822C  07FC5E     RCALL lcdSetCursorQ
40:                        lcdWriteStringQ("6:");
00822E  2F6E10     MOV #0xF6E1, W0
008230  07FC70     RCALL lcdWriteStringQ
41:                        lcdSetCursorQ(11,3);
008232  B3C031     MOV.B #0x3, W1
008234  B3C0B0     MOV.B #0xB, W0
008236  07FC59     RCALL lcdSetCursorQ
42:                        if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
008238  BFD00C     MOV.B TEST_SIN, WREG
00823A  404FE1     ADD.B W0, #0x1, [W15]
00823C  3A0003     BRA NZ, 0x8244
00823E  2F6E40     MOV #0xF6E4, W0
008240  07FC68     RCALL lcdWriteStringQ
008242  370002     BRA 0x8248
43:                        else lcdWriteStringQ("THRU");  
008244  2F6E90     MOV #0xF6E9, W0
008246  07FC65     RCALL lcdWriteStringQ
44:                        lcdDrawPads(16);
008248  B3C100     MOV.B #0x10, W0
00824A  07FCC5     RCALL lcdDrawPads
00824C  370031     BRA 0x82B0
45:                    } else {
46:                        // Update here
47:                        lcdSetCursorQ(2,0);
00824E  EB4080     CLR.B W1
008250  B3C020     MOV.B #0x2, W0
008252  07FC4B     RCALL lcdSetCursorQ
48:                        lcdWriteDecimalQ(pots_percent[0]&0xFF);
008254  25E8E0     MOV #0x5E8E, W0
008256  784010     MOV.B [W0], W0
008258  07FC9C     RCALL lcdWriteDecimalQ
49:                        lcdSetCursorQ(10,0);
00825A  EB4080     CLR.B W1
00825C  B3C0A0     MOV.B #0xA, W0
00825E  07FC45     RCALL lcdSetCursorQ
50:                        lcdWriteWordQ(pots_percent[1]);
008260  25E8F0     MOV #0x5E8F, W0
008262  FB0010     SE [W0], W0
008264  07FC66     RCALL lcdWriteWordQ
51:                        lcdSetCursorQ(2,1);
008266  B3C011     MOV.B #0x1, W1
008268  B3C020     MOV.B #0x2, W0
00826A  07FC3F     RCALL lcdSetCursorQ
52:                        lcdWriteDecimalQ(pots_percent[2]);
00826C  25E900     MOV #0x5E90, W0
00826E  784010     MOV.B [W0], W0
008270  07FC90     RCALL lcdWriteDecimalQ
53:                        lcdSetCursorQ(10,1);
008272  B3C011     MOV.B #0x1, W1
008274  B3C0A0     MOV.B #0xA, W0
008276  07FC39     RCALL lcdSetCursorQ
54:                        lcdWriteWordQ(pots_percent[3]);
008278  25E910     MOV #0x5E91, W0
00827A  FB0010     SE [W0], W0
00827C  07FC5A     RCALL lcdWriteWordQ
55:                        lcdSetCursorQ(2,2);
00827E  B3C021     MOV.B #0x2, W1
008280  784001     MOV.B W1, W0
008282  07FC33     RCALL lcdSetCursorQ
56:                        lcdWriteDecimalQ(pots_percent[4]);
008284  25E920     MOV #0x5E92, W0
008286  784010     MOV.B [W0], W0
008288  07FC84     RCALL lcdWriteDecimalQ
57:                        lcdSetCursorQ(10,2);
00828A  B3C021     MOV.B #0x2, W1
00828C  B3C0A0     MOV.B #0xA, W0
00828E  07FC2D     RCALL lcdSetCursorQ
58:                        lcdWriteWordQ(pots_percent[5]);
008290  25E930     MOV #0x5E93, W0
008292  FB0010     SE [W0], W0
008294  07FC4E     RCALL lcdWriteWordQ
59:                        lcdSetCursorQ(11,3);
008296  B3C031     MOV.B #0x3, W1
008298  B3C0B0     MOV.B #0xB, W0
00829A  07FC27     RCALL lcdSetCursorQ
60:                        if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
00829C  BFD00C     MOV.B TEST_SIN, WREG
00829E  404FE1     ADD.B W0, #0x1, [W15]
0082A0  3A0003     BRA NZ, 0x82A8
0082A2  2F6E40     MOV #0xF6E4, W0
0082A4  07FC36     RCALL lcdWriteStringQ
0082A6  370002     BRA 0x82AC
61:                        else lcdWriteStringQ("THRU");
0082A8  2F6E90     MOV #0xF6E9, W0
0082AA  07FC33     RCALL lcdWriteStringQ
62:                        lcdDrawPads(16);
0082AC  B3C100     MOV.B #0x10, W0
0082AE  07FC93     RCALL lcdDrawPads
63:                    }
64:                }
0082B0  060000     RETURN
65:                
66:                void screenFX(void){
67:                    if(state!=laststate){
0082B2  808090     MOV laststate, W0
0082B4  E31048     CP 0x1048
0082B6  32000C     BRA Z, 0x82D0
68:                        //setup here
69:                        lcdClearQ();
0082B8  07FC0D     RCALL lcdClearQ
70:                        lcdSetCursorQ(0,0);
0082BA  EB4080     CLR.B W1
0082BC  784001     MOV.B W1, W0
0082BE  07FC15     RCALL lcdSetCursorQ
71:                        lcdWriteStringQ("FX1:");
0082C0  2F6EE0     MOV #0xF6EE, W0
0082C2  07FC27     RCALL lcdWriteStringQ
72:                        lcdSetCursorQ(10,0);
0082C4  EB4080     CLR.B W1
0082C6  B3C0A0     MOV.B #0xA, W0
0082C8  07FC10     RCALL lcdSetCursorQ
73:                        lcdWriteStringQ("FX2:");
0082CA  2F6F30     MOV #0xF6F3, W0
0082CC  07FC22     RCALL lcdWriteStringQ
0082CE  370006     BRA 0x82DC
74:                    } else {
75:                        //update here
76:                        lcdSetCursorQ(0,2);
0082D0  B3C021     MOV.B #0x2, W1
0082D2  EB4000     CLR.B W0
0082D4  07FC0A     RCALL lcdSetCursorQ
77:                        lcdWriteDecimalQ(pots_percent[0]);
0082D6  25E8E0     MOV #0x5E8E, W0
0082D8  784010     MOV.B [W0], W0
0082DA  07FC5B     RCALL lcdWriteDecimalQ
78:                    }
79:                }
0082DC  060000     RETURN
80:                
81:                void screenDebugFlash(void){
0082DE  781F88     MOV W8, [W15++]
82:                        if(state!=laststate){
0082E0  808090     MOV laststate, W0
0082E2  E31048     CP 0x1048
0082E4  32003D     BRA Z, 0x8360
83:                        //setup here
84:                        lcdClearQ();
0082E6  07FBF6     RCALL lcdClearQ
85:                        lcdSetCursorQ(0,0);
0082E8  EB4080     CLR.B W1
0082EA  784001     MOV.B W1, W0
0082EC  07FBFE     RCALL lcdSetCursorQ
86:                        lcdWriteWordQ(flash_readback[2]);
0082EE  25E9C0     MOV #0x5E9C, W0
0082F0  FB0010     SE [W0], W0
0082F2  07FC1F     RCALL lcdWriteWordQ
87:                         lcdSetCursorQ(6,0);
0082F4  EB4080     CLR.B W1
0082F6  B3C060     MOV.B #0x6, W0
0082F8  07FBF8     RCALL lcdSetCursorQ
88:                        lcdWriteWordQ(flash_readback[3]);
0082FA  25E9D0     MOV #0x5E9D, W0
0082FC  FB0010     SE [W0], W0
0082FE  07FC19     RCALL lcdWriteWordQ
89:                         lcdSetCursorQ(12,0);
008300  EB4080     CLR.B W1
008302  B3C0C0     MOV.B #0xC, W0
008304  07FBF2     RCALL lcdSetCursorQ
90:                        lcdWriteWordQ(flash_readback[4]);
008306  25E9E0     MOV #0x5E9E, W0
008308  FB0010     SE [W0], W0
00830A  07FC13     RCALL lcdWriteWordQ
91:                         lcdSetCursorQ(0,1);
00830C  B3C011     MOV.B #0x1, W1
00830E  EB4000     CLR.B W0
008310  07FBEC     RCALL lcdSetCursorQ
92:                        lcdWriteWordQ(flash_readback[5]);
008312  25E9F0     MOV #0x5E9F, W0
008314  FB0010     SE [W0], W0
008316  07FC0D     RCALL lcdWriteWordQ
93:                        lcdSetCursorQ(6,1);
008318  B3C011     MOV.B #0x1, W1
00831A  B3C060     MOV.B #0x6, W0
00831C  07FBE6     RCALL lcdSetCursorQ
94:                        lcdWriteWordQ(flash_readback[6]);
00831E  25EA00     MOV #0x5EA0, W0
008320  FB0010     SE [W0], W0
008322  07FC07     RCALL lcdWriteWordQ
95:                         lcdSetCursorQ(12,1);
008324  B3C011     MOV.B #0x1, W1
008326  B3C0C0     MOV.B #0xC, W0
008328  07FBE0     RCALL lcdSetCursorQ
96:                        lcdWriteWordQ(flash_readback[7]);
00832A  25EA10     MOV #0x5EA1, W0
00832C  FB0010     SE [W0], W0
00832E  07FC01     RCALL lcdWriteWordQ
97:                        lcdSetCursorQ(0,2);
008330  B3C021     MOV.B #0x2, W1
008332  EB4000     CLR.B W0
008334  07FBDA     RCALL lcdSetCursorQ
98:                        lcdWriteWordQ(flash_readback[8]);
008336  25EA28     MOV #0x5EA2, W8
008338  FB0018     SE [W8], W0
00833A  07FBFB     RCALL lcdWriteWordQ
99:                        lcdSetCursorQ(6,2);
00833C  B3C021     MOV.B #0x2, W1
00833E  B3C060     MOV.B #0x6, W0
008340  07FBD4     RCALL lcdSetCursorQ
100:                       lcdWriteWordQ(flash_readback[9]);
008342  E80008     INC W8, W0
008344  FB0010     SE [W0], W0
008346  07FBF5     RCALL lcdWriteWordQ
101:                        lcdSetCursorQ(12,2);
008348  B3C021     MOV.B #0x2, W1
00834A  B3C0C0     MOV.B #0xC, W0
00834C  07FBCE     RCALL lcdSetCursorQ
102:                       lcdWriteWordQ(flash_readback[10]);
00834E  E88008     INC2 W8, W0
008350  FB0010     SE [W0], W0
008352  07FBEF     RCALL lcdWriteWordQ
103:                       lcdSetCursorQ(0,3);
008354  B3C031     MOV.B #0x3, W1
008356  EB4000     CLR.B W0
008358  07FBC8     RCALL lcdSetCursorQ
104:                       lcdWriteWordQ(flash_readback[8]);
00835A  FB0018     SE [W8], W0
00835C  07FBEA     RCALL lcdWriteWordQ
00835E  370008     BRA 0x8370
105:                   } else {
106:                       //update here
107:                       lcdSetCursorQ(9,3);
008360  B3C031     MOV.B #0x3, W1
008362  B3C090     MOV.B #0x9, W0
008364  07FBC2     RCALL lcdSetCursorQ
108:                       lcdWriteStringQ("Stat:");
008366  2F6F80     MOV #0xF6F8, W0
008368  07FBD4     RCALL lcdWriteStringQ
109:                       lcdWriteWordQ(flashStatusCheck());
00836A  0700C2     RCALL flashStatusCheck
00836C  FB0000     SE W0, W0
00836E  07FBE1     RCALL lcdWriteWordQ
110:                   }
111:               }
008370  78044F     MOV [--W15], W8
008372  060000     RETURN
112:               
113:               void screenUpdate(void){
114:                   switch(state){
008374  808240     MOV 0x1048, W0
008376  500FE3     SUB W0, #0x3, [W15]
008378  320006     BRA Z, 0x8386
00837A  500FE5     SUB W0, #0x5, [W15]
00837C  320006     BRA Z, 0x838A
00837E  500FE2     SUB W0, #0x2, [W15]
008380  3A0005     BRA NZ, 0x838C
115:                       case start: break;
116:                       case scrnFX:            screenFX(); 
008382  07FF97     RCALL screenFX
117:                                               break;
008384  370003     BRA 0x838C
118:                       case debugscrnPOTS:     screenDebugPots();
008386  07FF33     RCALL screenDebugPots
119:                                               break;
008388  370001     BRA 0x838C
120:                       case debugscrnFLASH:    screenDebugFlash();
00838A  07FFA9     RCALL screenDebugFlash
121:                                               break;
122:                                       
123:                       default: break;
124:                   }
125:                   
126:                   laststate=state;
00838C  F81048     PUSH 0x1048
00838E  F91012     POP laststate
127:               }
008390  060000     RETURN
128:               
129:                   /*
130:                   lcdSetCursorQ(0,3);
131:                   if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
132:                       lcdWriteStringQ("CLIP");
133:                       hard_clipped=FALSE;  
134:                   }
135:                   else if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
136:                   else lcdWriteStringQ("THRU");
137:                    * 
138:                    *    lcdSetCursorQ(10,3);
139:                  lcdWriteWordQ(ENCODERCNTL);
140:                   */
141:               
142:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/routines.c  -------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
10:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
11:                extern unsigned int write_ptr, rw, frameReady;
12:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
13:                
14:                //misc.
15:                volatile fractional sampinA=0, sampinB=0;
16:                
17:                volatile int rxBufferIndicator = 0;
18:                fractional *ping, *pong;
19:                
20:                //Description: This interrupt triggers at the completion of DCI output
21:                //Dependancies: initSPI2(); 
22:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
000306  BE9F80     MOV.D W0, [W15++]
000308  BE9F82     MOV.D W2, [W15++]
00030A  781F84     MOV W4, [W15++]
00030C  F80032     PUSH DSRPAG
00030E  F80034     PUSH DSWPAG
000310  200010     MOV #0x1, W0
000312  8801A0     MOV W0, DSWPAG
000314  202000     MOV #0x200, W0
000316  880190     MOV W0, DSRPAG
000318  000000     NOP
23:                    static fractional sampoutA=0, sampoutB=0;
24:                    
25:                    int trashA=RXBUF0;
00031A  801480     MOV RXBUF0, W0
26:                    sampinA=RXBUF1;
00031C  F80292     PUSH RXBUF1
00031E  F9102A     POP sampinA
27:                    int trashB=RXBUF2;
000320  8014A0     MOV RXBUF2, W0
28:                    sampinB=RXBUF3;
000322  F80296     PUSH RXBUF3
000324  F9102C     POP sampinB
29:                    TXBUF0=TXBUF1=sampoutA;                                    //output buffered sample to DAC
000326  F81036     PUSH sampoutA
000328  F9029A     POP TXBUF1
00032A  F8029A     PUSH TXBUF1
00032C  F90298     POP TXBUF0
30:                    TXBUF2=TXBUF3=sampoutB;
00032E  F81034     PUSH _doclose
000330  F9029E     POP TXBUF3
000332  F8029E     PUSH TXBUF3
000334  F9029C     POP TXBUF2
31:                
32:                
33:                    
34:                    __builtin_btg(&sampinA, 15);                             //convert to Q1.15 compatible format
000336  2102A0     MOV #0x102A, W0
000338  A2F010     BTG [W0], #15
35:                    __builtin_btg(&sampinB, 15);                             //convert to Q1.15 compatible format
00033A  2102C0     MOV #0x102C, W0
00033C  A2F010     BTG [W0], #15
36:                    
37:                
38:                      
39:                    
40:                    if(write_ptr--==0){                       //reset pointer when out of bounds
00033E  808220     MOV 0x1044, W0
000340  E90080     DEC W0, W1
000342  888221     MOV W1, 0x1044
000344  E00000     CP0 W0
000346  3A0005     BRA NZ, 0x352
41:                        write_ptr=STREAMBUF-1;
000348  201FF0     MOV #0x1FF, W0
00034A  888220     MOV W0, 0x1044
42:                        __builtin_btg(&rw,0);
00034C  AA1002     BTG rw, #0
43:                        frameReady=1;
00034E  200010     MOV #0x1, W0
000350  888020     MOV W0, frameReady
44:                    }
45:                   
46:                    if(rw){
000352  E21002     CP0 rw
000354  320014     BRA Z, 0x37E
47:                        streamB[write_ptr]=sampinA;
000356  808220     MOV 0x1044, W0
000358  26CBE2     MOV #0x6CBE, W2
00035A  400180     ADD W0, W0, W3
00035C  410083     ADD W2, W3, W1
00035E  808154     MOV sampinA, W4
000360  780884     MOV W4, [W1]
48:                        sampoutA=outputA[write_ptr--]; 
000362  260BE1     MOV #0x60BE, W1
000364  408183     ADD W1, W3, W3
000366  780193     MOV [W3], W3
000368  8881B3     MOV W3, sampoutA
00036A  E90000     DEC W0, W0
00036C  888220     MOV W0, 0x1044
49:                        streamB[write_ptr]=sampinB;
00036E  400000     ADD W0, W0, W0
000370  410100     ADD W2, W0, W2
000372  808163     MOV sampinB, W3
000374  780903     MOV W3, [W2]
50:                        sampoutB=outputA[write_ptr];
000376  408000     ADD W1, W0, W0
000378  780010     MOV [W0], W0
00037A  8881A0     MOV W0, _doclose
00037C  370013     BRA 0x3A4
51:                        
52:                    }
53:                    else {
54:                        streamA[write_ptr]=sampinA; 
00037E  808220     MOV 0x1044, W0
000380  268BE2     MOV #0x68BE, W2
000382  400180     ADD W0, W0, W3
000384  410083     ADD W2, W3, W1
000386  808154     MOV sampinA, W4
000388  780884     MOV W4, [W1]
55:                        sampoutA=outputB[write_ptr--];  
00038A  264BE1     MOV #0x64BE, W1
00038C  408183     ADD W1, W3, W3
00038E  780193     MOV [W3], W3
000390  8881B3     MOV W3, sampoutA
000392  E90000     DEC W0, W0
000394  888220     MOV W0, 0x1044
56:                        streamA[write_ptr]=sampinB; 
000396  400000     ADD W0, W0, W0
000398  410100     ADD W2, W0, W2
00039A  808163     MOV sampinB, W3
00039C  780903     MOV W3, [W2]
57:                        sampoutB=outputB[write_ptr];  
00039E  408000     ADD W1, W0, W0
0003A0  780010     MOV [W0], W0
0003A2  8881A0     MOV W0, _doclose
58:                    } 
59:                    
60:                    _DCIIF=0;
0003A4  A98807     BCLR 0x807, #4
61:                }
0003A6  F90034     POP DSWPAG
0003A8  F90032     POP DSRPAG
0003AA  78024F     MOV [--W15], W4
0003AC  BE014F     MOV.D [--W15], W2
0003AE  BE004F     MOV.D [--W15], W0
0003B0  064000     RETFIE
62:                
63:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003B2  F80036     PUSH RCOUNT
0003B4  BE9F80     MOV.D W0, [W15++]
0003B6  BE9F82     MOV.D W2, [W15++]
0003B8  BE9F84     MOV.D W4, [W15++]
0003BA  BE9F86     MOV.D W6, [W15++]
64:                    _DMA2IF = 0; /* Received one frame of data*/    
0003BC  A90803     BCLR 0x803, #0
65:                    
66:                    if(rxBufferIndicator == 0)
0003BE  E2102E     CP0 rxBufferIndicator
0003C0  3A0004     BRA NZ, 0x3CA
67:                    {
68:                         processRxData((int *)rxBufferA, (int*)txBufferA);
0003C2  2CC001     MOV #0xCC00, W1
0003C4  2C4000     MOV #0xC400, W0
0003C6  073E2A     RCALL processRxData
0003C8  370003     BRA 0x3D0
69:                    }
70:                    else
71:                    {
72:                         processRxData((int *)rxBufferB, (int*)txBufferB);
0003CA  2C8001     MOV #0xC800, W1
0003CC  2C0000     MOV #0xC000, W0
0003CE  073E26     RCALL processRxData
73:                    }
74:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
0003D0  AA102E     BTG rxBufferIndicator, #0
75:                }
0003D2  BE034F     MOV.D [--W15], W6
0003D4  BE024F     MOV.D [--W15], W4
0003D6  BE014F     MOV.D [--W15], W2
0003D8  BE004F     MOV.D [--W15], W0
0003DA  F90036     POP RCOUNT
0003DC  064000     RETFIE
76:                
77:                /*
78:                //Description: This interrupt handles UART reception
79:                //Dependencies: initUART1();
80:                void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
81:                    unsigned char trash;
82:                    trash=U1RXREG;
83:                    printf("RECIEVED: %d\r\n", trash);
84:                    IFS0bits.U1RXIF = 0;            //clear flag, restart
85:                }
86:                
87:                //Description: This interrupt handles UART transmission
88:                //Dependencies: initUART1();
89:                void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
90:                    YLED=~YLED;
91:                    IFS0bits.U1TXIF = 0;            //clear flag, restart
92:                } 
93:                  
94:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
95:                    //SEG_SEL=1;
96:                    int trash=SPI3BUF;
97:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
98:                    IFS5bits.SPI3IF=0;
99:                    
100:               }
101:                */
---  C:/Users/ryan/Documents/seniorproject/ps-040/plcd.c  -----------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                #include "screens.h"
14:                
15:                extern unsigned char pad[BUTTONS];
16:                
17:                int  lcdBuf[LCDBUF+1]={0};
18:                int *lcdWritePtr=lcdBuf;
19:                int *lcdReadPtr=lcdBuf;
20:                
21:                
22:                void lcdWriteQ(unsigned char data){
23:                    *lcdWritePtr++=data|0x0000;
007AAA  FB8000     ZE W0, W0
007AAC  808281     MOV 0x1050, W1
007AAE  781880     MOV W0, [W1++]
007AB0  888281     MOV W1, 0x1050
24:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007AB2  276BE0     MOV #0x76BE, W0
007AB4  508F80     SUB W1, W0, [W15]
007AB6  3A0002     BRA NZ, 0x7ABC
25:                        lcdWritePtr=lcdBuf;
007AB8  B12000     SUB #0x200, W0
007ABA  888280     MOV W0, 0x1050
26:                }
007ABC  060000     RETURN
27:                
28:                void lcdCommandQ(unsigned char data){
29:                    *lcdWritePtr++=data|0x0100;     //flag for rs=1
007ABE  FB8000     ZE W0, W0
007AC0  808281     MOV 0x1050, W1
007AC2  A08000     BSET W0, #8
007AC4  781880     MOV W0, [W1++]
007AC6  888281     MOV W1, 0x1050
30:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007AC8  276BE0     MOV #0x76BE, W0
007ACA  508F80     SUB W1, W0, [W15]
007ACC  3A0002     BRA NZ, 0x7AD2
31:                        lcdWritePtr=lcdBuf;
007ACE  B12000     SUB #0x200, W0
007AD0  888280     MOV W0, 0x1050
32:                }
007AD2  060000     RETURN
33:                
34:                void lcdClearQ(void){
35:                    *lcdWritePtr++=LCD_CLEARDISPLAY|0x0300;     //flag for rs=1 & long delay
007AD4  808280     MOV 0x1050, W0
007AD6  203011     MOV #0x301, W1
007AD8  781801     MOV W1, [W0++]
007ADA  888280     MOV W0, 0x1050
36:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007ADC  276BE1     MOV #0x76BE, W1
007ADE  500F81     SUB W0, W1, [W15]
007AE0  3A0003     BRA NZ, 0x7AE8
37:                        lcdWritePtr=lcdBuf;
007AE2  2FE000     MOV #0xFE00, W0
007AE4  400001     ADD W0, W1, W0
007AE6  888280     MOV W0, 0x1050
38:                }
007AE8  060000     RETURN
39:                
40:                void lcdSetCursorQ(unsigned char col, unsigned char row) {
007AEA  784101     MOV.B W1, W2
41:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
42:                  if (row > 3) {
43:                    row = 3;
44:                  }
45:                  *lcdWritePtr++=(LCD_SETDDRAMADDR | (col + offsets[row]))|0x0100;  //flag for rs=0 
007AEC  808281     MOV 0x1050, W1
007AEE  514FE3     SUB.B W2, #0x3, [W15]
007AF0  360001     BRA LEU, 0x7AF4
007AF2  B3C032     MOV.B #0x3, W2
007AF4  FB8102     ZE W2, W2
007AF6  2F7183     MOV #0xF718, W3
007AF8  418102     ADD W3, W2, W2
007AFA  FB8112     ZE [W2], W2
007AFC  FB8000     ZE W0, W0
007AFE  410000     ADD W2, W0, W0
007B00  201802     MOV #0x180, W2
007B02  701882     IOR W0, W2, [W1++]
007B04  888281     MOV W1, 0x1050
46:                    if(lcdWritePtr==&lcdBuf[LCDBUF]) 
007B06  276BE0     MOV #0x76BE, W0
007B08  508F80     SUB W1, W0, [W15]
007B0A  3A0002     BRA NZ, 0x7B10
47:                        lcdWritePtr=lcdBuf; 
007B0C  B12000     SUB #0x200, W0
007B0E  888280     MOV W0, 0x1050
48:                }
007B10  060000     RETURN
49:                
50:                void lcdWriteStringQ(char *string) {
007B12  781F88     MOV W8, [W15++]
007B14  780400     MOV W0, W8
51:                    char *it = string;
52:                    for (; *it; it++) {
007B16  784018     MOV.B [W8], W0
007B18  E00400     CP0.B W0
007B1A  320004     BRA Z, 0x7B24
007B1E  784058     MOV.B [++W8], W0
007B20  E00400     CP0.B W0
007B22  3AFFFC     BRA NZ, 0x7B1C
53:                        lcdWriteQ(*it);
007B1C  07FFC6     RCALL lcdWriteQ
54:                  }
55:                }
007B24  78044F     MOV [--W15], W8
007B26  060000     RETURN
56:                
57:                void lcdCustomSymbols(void){
58:                    int i=0;
59:                    lcdCommandQ(0x40);
007B28  B3C400     MOV.B #0x40, W0
007B2A  07FFC9     RCALL lcdCommandQ
60:                    Delay_us(200);
007B2C  200C80     MOV #0xC8, W0
007B2E  07027D     RCALL Delay_us
61:                   // for(; i<8; i++)lcdWriteString(loadingOne[i]);
62:                    //lcdWriteString(loadingTwo);
63:                    //lcdWriteString(loadingThree);
64:                    //lcdWriteString(loadingFour);
65:                }
007B30  060000     RETURN
66:                
67:                void lcdWriteWordQ(int word){
007B32  4787E6     ADD W15, #0x6, W15
007B34  781F88     MOV W8, [W15++]
007B36  781F8E     MOV W14, [W15++]
007B38  780400     MOV W0, W8
007B5C  200040     MOV #0x4, W0
68:                    int i;
69:                    char inchar[4];
70:                    
71:                    if(word<0) {
007B3A  E00008     CP0 W8
007B3C  3D0004     BRA GE, 0x7B46
72:                        lcdWriteQ('-');
007B3E  B3C2D0     MOV.B #0x2D, W0
007B40  07FFB4     RCALL lcdWriteQ
73:                        word=~word+1;
007B42  EA0408     NEG W8, W8
007B44  370002     BRA 0x7B4A
74:                    }else lcdWriteQ(' ');
007B46  B3C200     MOV.B #0x20, W0
007B48  07FFB0     RCALL lcdWriteQ
75:                   
76:                   inchar[0] = word&0x000F; 
007B4A  64406F     AND.B W8, #0xF, W0
77:                   if (inchar[0] > 9) 
007B4C  504FE9     SUB.B W0, #0x9, [W15]
007B4E  340003     BRA LE, 0x7B56
78:                       inchar[0]+=55;
007B50  B04370     ADD.B #0x37, W0
007B52  9FFF80     MOV.B W0, [W15-8]
007B54  370002     BRA 0x7B5A
79:                   else inchar[0]+=48;
007B56  B04300     ADD.B #0x30, W0
007B58  9FFF80     MOV.B W0, [W15-8]
007B5A  578768     SUB W15, #0x8, W14
80:                   
81:                   for(i=1; i<4; i++){ 
007B76  500FF0     SUB W0, #0x10, [W15]
007B78  3AFFF2     BRA NZ, 0x7B5E
82:                      inchar[i] = ((word>>(i*4))&0x0000F); 
007B5E  DEC080     ASR W8, W0, W1
007B60  60C0EF     AND.B W1, #0xF, W1
007B62  E8070E     INC W14, W14
007B64  784F01     MOV.B W1, [W14]
83:                      if (inchar[i] > 9) 
007B66  50CFE9     SUB.B W1, #0x9, [W15]
007B68  340003     BRA LE, 0x7B70
84:                          inchar[i]+=55;
007B6A  B3C373     MOV.B #0x37, W3
007B6C  40CF03     ADD.B W1, W3, [W14]
007B6E  370002     BRA 0x7B74
85:                      else inchar[i]+=48;
007B70  B3C303     MOV.B #0x30, W3
007B72  40CF03     ADD.B W1, W3, [W14]
007B74  400064     ADD W0, #0x4, W0
86:                   } 
87:                   lcdWriteQ(inchar[3]);
007B7A  97F83F     MOV.B [W15-5], W0
007B7C  07FF96     RCALL lcdWriteQ
88:                   lcdWriteQ(inchar[2]);
007B7E  97F82F     MOV.B [W15-6], W0
007B80  07FF94     RCALL lcdWriteQ
89:                   lcdWriteQ(inchar[1]);
007B82  97F81F     MOV.B [W15-7], W0
007B84  07FF92     RCALL lcdWriteQ
90:                   lcdWriteQ(inchar[0]);
007B86  97F80F     MOV.B [W15-8], W0
007B88  07FF90     RCALL lcdWriteQ
91:                }
007B8A  78074F     MOV [--W15], W14
007B8C  78044F     MOV [--W15], W8
007B8E  B1006F     SUB #0x6, W15
007B90  060000     RETURN
92:                
93:                void lcdWriteDecimalQ(char word){
007B92  FA0004     LNK #0x4
007B94  BE9F88     MOV.D W8, [W15++]
007BC6  5784E5     SUB W15, #0x5, W9
94:                    char result[4];
95:                    char i = 3;
007B96  B3C035     MOV.B #0x3, W5
96:                    do {
97:                
98:                        result[i] = '0' + word % 10;
007B98  2000A2     MOV #0xA, W2
007B9A  FB0185     SE W5, W3
007B9C  FB0000     SE W0, W0
007B9E  090011     REPEAT #0x11
007BA0  D80002     DIV.SW W0, W2
007BA2  780201     MOV W1, W4
007BA4  B04304     ADD.B #0x30, W4
007BA6  784084     MOV.B W4, W1
007BA8  5181E8     SUB W3, #0x8, W3
007BAA  79F781     MOV.B W1, [W15+W3]
99:                        word /= 10;
100:                       i--;
007BAC  E94285     DEC.B W5, W5
101:                   }
102:                   while (word > 0);
007BAE  E00400     CP0.B W0
007BB0  3CFFF4     BRA GT, 0x7B9A
103:                   while (i>=0) result[i--] = "0"; 
007BB2  E00405     CP0.B W5
007BB4  350007     BRA LT, 0x7BC4
007BB6  2F7142     MOV #0xF714, W2
007BB8  FB0005     SE W5, W0
007BBA  500068     SUB W0, #0x8, W0
007BBC  787782     MOV.B W2, [W15+W0]
007BBE  E94285     DEC.B W5, W5
007BC0  42CFE1     ADD.B W5, #0x1, [W15]
007BC2  3AFFFA     BRA NZ, 0x7BB8
007BC4  578469     SUB W15, #0x9, W8
104:                   
105:                   for (i=0; i<4; i++) {
007BCC  540F89     SUB W8, W9, [W15]
007BCE  3AFFFC     BRA NZ, 0x7BC8
106:                       lcdWriteQ(result[i]);
007BC8  784058     MOV.B [++W8], W0
007BCA  07FF6F     RCALL lcdWriteQ
107:                   }
108:               }
007BD0  BE044F     MOV.D [--W15], W8
007BD2  FA8000     ULNK
007BD4  060000     RETURN
109:               
110:               //4x4 pad debug
111:               void lcdDrawPads(unsigned char col){
007BD6  BE9F88     MOV.D W8, [W15++]
007BD8  784480     MOV.B W0, W9
112:                   char block=0xFF;
007BE8  EBC400     SETM.B W8
113:                   if(!pad[34]||!pad[16]) block='*';
007BDA  B3C2A8     MOV.B #0x2A, W8
007BDC  260BC0     MOV #0x60BC, W0
007BDE  E00410     CP0.B [W0]
007BE0  320004     BRA Z, 0x7BEA
007BE2  500072     SUB W0, #0x12, W0
007BE4  E00410     CP0.B [W0]
007BE6  320001     BRA Z, 0x7BEA
114:                   
115:                   lcdSetCursorQ(col, 0);
007BEA  EB4080     CLR.B W1
007BEC  784009     MOV.B W9, W0
007BEE  07FF7D     RCALL lcdSetCursorQ
116:                   if(!pad[12])lcdWriteStringQ(" "); else lcdWriteQ(block);
007BF0  260A60     MOV #0x60A6, W0
007BF2  E00410     CP0.B [W0]
007BF4  3A0003     BRA NZ, 0x7BFC
007BF6  2F7160     MOV #0xF716, W0
007BF8  07FF8C     RCALL lcdWriteStringQ
007BFA  370002     BRA 0x7C00
007BFC  784008     MOV.B W8, W0
007BFE  07FF55     RCALL lcdWriteQ
117:                   if(!pad[13])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C00  260A70     MOV #0x60A7, W0
007C02  E00410     CP0.B [W0]
007C04  3A0003     BRA NZ, 0x7C0C
007C06  2F7160     MOV #0xF716, W0
007C08  07FF84     RCALL lcdWriteStringQ
007C0A  370002     BRA 0x7C10
007C0C  784008     MOV.B W8, W0
007C0E  07FF4D     RCALL lcdWriteQ
118:                   if(!pad[14])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C10  260A80     MOV #0x60A8, W0
007C12  E00410     CP0.B [W0]
007C14  3A0003     BRA NZ, 0x7C1C
007C16  2F7160     MOV #0xF716, W0
007C18  07FF7C     RCALL lcdWriteStringQ
007C1A  370002     BRA 0x7C20
007C1C  784008     MOV.B W8, W0
007C1E  07FF45     RCALL lcdWriteQ
119:                   if(!pad[15])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C20  260A90     MOV #0x60A9, W0
007C22  E00410     CP0.B [W0]
007C24  3A0003     BRA NZ, 0x7C2C
007C26  2F7160     MOV #0xF716, W0
007C28  07FF74     RCALL lcdWriteStringQ
007C2A  370002     BRA 0x7C30
007C2C  784008     MOV.B W8, W0
007C2E  07FF3D     RCALL lcdWriteQ
120:                   lcdSetCursorQ(col, 1);
007C30  B3C011     MOV.B #0x1, W1
007C32  784009     MOV.B W9, W0
007C34  07FF5A     RCALL lcdSetCursorQ
121:                   if(!pad[8])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C36  260A20     MOV #0x60A2, W0
007C38  E00410     CP0.B [W0]
007C3A  3A0003     BRA NZ, 0x7C42
007C3C  2F7160     MOV #0xF716, W0
007C3E  07FF69     RCALL lcdWriteStringQ
007C40  370002     BRA 0x7C46
007C42  784008     MOV.B W8, W0
007C44  07FF32     RCALL lcdWriteQ
122:                   if(!pad[9])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C46  260A30     MOV #0x60A3, W0
007C48  E00410     CP0.B [W0]
007C4A  3A0003     BRA NZ, 0x7C52
007C4C  2F7160     MOV #0xF716, W0
007C4E  07FF61     RCALL lcdWriteStringQ
007C50  370002     BRA 0x7C56
007C52  784008     MOV.B W8, W0
007C54  07FF2A     RCALL lcdWriteQ
123:                   if(!pad[10])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C56  260A40     MOV #0x60A4, W0
007C58  E00410     CP0.B [W0]
007C5A  3A0003     BRA NZ, 0x7C62
007C5C  2F7160     MOV #0xF716, W0
007C5E  07FF59     RCALL lcdWriteStringQ
007C60  370002     BRA 0x7C66
007C62  784008     MOV.B W8, W0
007C64  07FF22     RCALL lcdWriteQ
124:                   if(!pad[11])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C66  260A50     MOV #0x60A5, W0
007C68  E00410     CP0.B [W0]
007C6A  3A0003     BRA NZ, 0x7C72
007C6C  2F7160     MOV #0xF716, W0
007C6E  07FF51     RCALL lcdWriteStringQ
007C70  370002     BRA 0x7C76
007C72  784008     MOV.B W8, W0
007C74  07FF1A     RCALL lcdWriteQ
125:                   lcdSetCursorQ(col, 2);
007C76  B3C021     MOV.B #0x2, W1
007C78  784009     MOV.B W9, W0
007C7A  07FF37     RCALL lcdSetCursorQ
126:                   if(!pad[4])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C7C  2609E0     MOV #0x609E, W0
007C7E  E00410     CP0.B [W0]
007C80  3A0003     BRA NZ, 0x7C88
007C82  2F7160     MOV #0xF716, W0
007C84  07FF46     RCALL lcdWriteStringQ
007C86  370002     BRA 0x7C8C
007C88  784008     MOV.B W8, W0
007C8A  07FF0F     RCALL lcdWriteQ
127:                   if(!pad[5])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C8C  2609F0     MOV #0x609F, W0
007C8E  E00410     CP0.B [W0]
007C90  3A0003     BRA NZ, 0x7C98
007C92  2F7160     MOV #0xF716, W0
007C94  07FF3E     RCALL lcdWriteStringQ
007C96  370002     BRA 0x7C9C
007C98  784008     MOV.B W8, W0
007C9A  07FF07     RCALL lcdWriteQ
128:                   if(!pad[6])lcdWriteStringQ(" "); else lcdWriteQ(block);
007C9C  260A00     MOV #0x60A0, W0
007C9E  E00410     CP0.B [W0]
007CA0  3A0003     BRA NZ, 0x7CA8
007CA2  2F7160     MOV #0xF716, W0
007CA4  07FF36     RCALL lcdWriteStringQ
007CA6  370002     BRA 0x7CAC
007CA8  784008     MOV.B W8, W0
007CAA  07FEFF     RCALL lcdWriteQ
129:                   if(!pad[7])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CAC  260A10     MOV #0x60A1, W0
007CAE  E00410     CP0.B [W0]
007CB0  3A0003     BRA NZ, 0x7CB8
007CB2  2F7160     MOV #0xF716, W0
007CB4  07FF2E     RCALL lcdWriteStringQ
007CB6  370002     BRA 0x7CBC
007CB8  784008     MOV.B W8, W0
007CBA  07FEF7     RCALL lcdWriteQ
130:                   lcdSetCursorQ(col, 3);
007CBC  B3C031     MOV.B #0x3, W1
007CBE  784009     MOV.B W9, W0
007CC0  07FF14     RCALL lcdSetCursorQ
131:                   if(!pad[0])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CC2  2609A0     MOV #0x609A, W0
007CC4  E00410     CP0.B [W0]
007CC6  3A0003     BRA NZ, 0x7CCE
007CC8  2F7160     MOV #0xF716, W0
007CCA  07FF23     RCALL lcdWriteStringQ
007CCC  370002     BRA 0x7CD2
007CCE  784008     MOV.B W8, W0
007CD0  07FEEC     RCALL lcdWriteQ
132:                   if(!pad[1])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CD2  2609B0     MOV #0x609B, W0
007CD4  E00410     CP0.B [W0]
007CD6  3A0003     BRA NZ, 0x7CDE
007CD8  2F7160     MOV #0xF716, W0
007CDA  07FF1B     RCALL lcdWriteStringQ
007CDC  370002     BRA 0x7CE2
007CDE  784008     MOV.B W8, W0
007CE0  07FEE4     RCALL lcdWriteQ
133:                   if(!pad[2])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CE2  2609C0     MOV #0x609C, W0
007CE4  E00410     CP0.B [W0]
007CE6  3A0003     BRA NZ, 0x7CEE
007CE8  2F7160     MOV #0xF716, W0
007CEA  07FF13     RCALL lcdWriteStringQ
007CEC  370002     BRA 0x7CF2
007CEE  784008     MOV.B W8, W0
007CF0  07FEDC     RCALL lcdWriteQ
134:                   if(!pad[3])lcdWriteStringQ(" "); else lcdWriteQ(block);
007CF2  2609D0     MOV #0x609D, W0
007CF4  E00410     CP0.B [W0]
007CF6  3A0003     BRA NZ, 0x7CFE
007CF8  2F7160     MOV #0xF716, W0
007CFA  07FF0B     RCALL lcdWriteStringQ
007CFC  370002     BRA 0x7D02
007CFE  784008     MOV.B W8, W0
007D00  07FED4     RCALL lcdWriteQ
135:               }
007D02  BE044F     MOV.D [--W15], W8
007D04  060000     RETURN
136:               
137:               void lcdPoll(void){  
138:                   if(lcdWritePtr!=lcdReadPtr){   
007D06  808290     MOV calcquot, W0
007D08  E31050     CP 0x1050
007D0A  320018     BRA Z, 0x7D3C
139:                       if((*lcdReadPtr>>8)&1) LCD_RS=0;
007D0C  201001     MOV #0x100, W1
007D0E  608090     AND W1, [W0], W1
007D10  320002     BRA Z, 0x7D16
007D12  A9EE45     BCLR 0xE45, #7
007D14  370001     BRA 0x7D18
140:                       else LCD_RS=1;
007D16  A8EE45     BSET 0xE45, #7
141:                       if((*lcdReadPtr>>9)&1) PR3=0x2DF0; //2DF0 for ~1.3mS
007D18  202001     MOV #0x200, W1
007D1A  608090     AND W1, [W0], W1
007D1C  320003     BRA Z, 0x7D24
007D1E  22DF01     MOV #0x2DF0, W1
007D20  880871     MOV W1, PR3
007D22  370002     BRA 0x7D28
142:                       else PR3=0x0120; //120 for ~40uS
007D24  201201     MOV #0x120, W1
007D26  880871     MOV W1, PR3
143:                       PMDIN1=(*lcdReadPtr++)&0x00FF;
007D28  200FF1     MOV #0xFF, W1
007D2A  6080B0     AND W1, [W0++], W1
007D2C  883041     MOV W1, PMDIN1
007D2E  888290     MOV W0, calcquot
144:                       if(lcdReadPtr==&lcdBuf[LCDBUF]) lcdReadPtr=lcdBuf;
007D30  276BE1     MOV #0x76BE, W1
007D32  500F81     SUB W0, W1, [W15]
007D34  3A0003     BRA NZ, 0x7D3C
007D36  2FE000     MOV #0xFE00, W0
007D38  400001     ADD W0, W1, W0
007D3A  888290     MOV W0, calcquot
145:                   } 
146:                   TMR3=0x0000; 
007D3C  EF210A     CLR TMR3
147:               }
007D3E  060000     RETURN
148:               
149:               //ALWAYS SENDS, blocks program
150:               void lcdBlockingSend(unsigned char data){
007D40  BE9F88     MOV.D W8, [W15++]
007D42  781F8A     MOV W10, [W15++]
007D44  784500     MOV.B W0, W10
151:                   while(PMMODEbits.BUSY)Delay_us(2);
007D46  E20602     CP0 PMMODE
007D48  3D0007     BRA GE, 0x7D58
007D4A  200028     MOV #0x2, W8
007D4C  280009     MOV #0x8000, W9
007D4E  780008     MOV W8, W0
007D50  07016C     RCALL Delay_us
007D52  803011     MOV PMMODE, W1
007D54  648001     AND W9, W1, W0
007D56  3AFFFB     BRA NZ, 0x7D4E
152:                   PMDIN1=data; 
007D58  FB850A     ZE W10, W10
007D5A  88304A     MOV W10, PMDIN1
153:               }
007D5C  78054F     MOV [--W15], W10
007D5E  BE044F     MOV.D [--W15], W8
007D60  060000     RETURN
154:               //ALWAYS SENDS, blocks program
155:               void lcdBlockingClear(void){
007D62  BE9F88     MOV.D W8, [W15++]
156:                   while(PMMODEbits.BUSY)Delay_us(2);
007D64  E20602     CP0 PMMODE
007D66  3D0007     BRA GE, 0x7D76
007D68  200028     MOV #0x2, W8
007D6A  280009     MOV #0x8000, W9
007D6C  780008     MOV W8, W0
007D6E  07015D     RCALL Delay_us
007D70  803011     MOV PMMODE, W1
007D72  648001     AND W9, W1, W0
007D74  3AFFFB     BRA NZ, 0x7D6C
157:                   PMDIN1=LCD_CLEARDISPLAY; 
007D76  200010     MOV #0x1, W0
007D78  883040     MOV W0, PMDIN1
158:               }
007D7A  BE044F     MOV.D [--W15], W8
007D7C  060000     RETURN
159:               
160:               //ALWAYS SENDS, blocks program
161:               void lcdBlockingReturn(void){
007D7E  BE9F88     MOV.D W8, [W15++]
162:                   while(PMMODEbits.BUSY)Delay_us(2);
007D80  E20602     CP0 PMMODE
007D82  3D0007     BRA GE, 0x7D92
007D84  200028     MOV #0x2, W8
007D86  280009     MOV #0x8000, W9
007D88  780008     MOV W8, W0
007D8A  07014F     RCALL Delay_us
007D8C  803011     MOV PMMODE, W1
007D8E  648001     AND W9, W1, W0
007D90  3AFFFB     BRA NZ, 0x7D88
163:                   PMDIN1=LCD_RETURNHOME;
007D92  200020     MOV #0x2, W0
007D94  883040     MOV W0, PMDIN1
164:               }
007D96  BE044F     MOV.D [--W15], W8
007D98  060000     RETURN
165:               
166:               void lcdInit(void){
167:                   LCD_RS=0;
007D9A  A9EE45     BCLR 0xE45, #7
168:                   lcdBlockingSend(0x38);              //function set, 8 bits, 2 line disp, 5x8
007D9C  B3C380     MOV.B #0x38, W0
007D9E  07FFD0     RCALL lcdBlockingSend
169:                   Delay_us(4500);                //>4.1 mS required
007DA0  211940     MOV #0x1194, W0
007DA2  070143     RCALL Delay_us
170:                   lcdBlockingSend(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
007DA4  B3C0C0     MOV.B #0xC, W0
007DA6  07FFCC     RCALL lcdBlockingSend
171:                   Delay_us(4500);
007DA8  211940     MOV #0x1194, W0
007DAA  07013F     RCALL Delay_us
172:                   lcdBlockingClear();                    //Display Clear  
007DAC  07FFDA     RCALL lcdBlockingClear
173:                   Delay_us(1800);                //>1.64mS required
007DAE  207080     MOV #0x708, W0
007DB0  07013C     RCALL Delay_us
174:                   lcdBlockingSend(0x06);               // entry Mode Set
007DB2  B3C060     MOV.B #0x6, W0
007DB4  07FFC5     RCALL lcdBlockingSend
175:                   Delay_us(200);
007DB6  200C80     MOV #0xC8, W0
007DB8  070138     RCALL Delay_us
176:                   lcdBlockingReturn();
007DBA  07FFE1     RCALL lcdBlockingReturn
177:                   Delay_us(1500);
007DBC  205DC0     MOV #0x5DC, W0
007DBE  070135     RCALL Delay_us
178:                   
179:                   //lcdCustomSymbols();
180:                   Delay_us(200);
007DC0  200C80     MOV #0xC8, W0
007DC2  070133     RCALL Delay_us
181:                   lcdBlockingClear();                         //Display Clear  
007DC4  07FFCE     RCALL lcdBlockingClear
182:                   Delay_us(1500);
007DC6  205DC0     MOV #0x5DC, W0
007DC8  070130     RCALL Delay_us
183:                   lcdBlockingReturn();
007DCA  07FFD9     RCALL lcdBlockingReturn
184:                   Delay_us(200);
007DCC  200C80     MOV #0xC8, W0
007DCE  07012D     RCALL Delay_us
185:               }
007DD0  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/main.c  -----------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 #include "plcd.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = OFF   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                unsigned char pad[BUTTONS];                                                                   //CONTROL VARIABLES//
22:                fractional pots[POTS]={0};
23:                char pots_percent[POTS]={0};
24:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
25:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
26:                
27:                /* DMA BUFFERS */
28:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
29:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
31:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
32:                
33:                unsigned int bpm=0, rw=0, frameReady=0, write_ptr=STREAMBUF;
34:                unsigned int idle=0, cycle=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                               //STATUS VARIABLES//
37:                volatile unsigned char recording=TRUE;
38:                unsigned char UART_ON = FALSE;
39:                unsigned char TEST_SIN = FALSE;
40:                
41:                volatile unsigned char tremelo=FALSE;                                           //FX FLAGS//
42:                volatile unsigned char looper=FALSE;
43:                volatile unsigned char lpf=FALSE;
44:                
45:                volatile unsigned char frame=FALSE;
46:                int temp1, temp2;
47:                
48:                char flash_readback[512]={0};
49:                
50:                enum screen state = debugscrnPOTS;
51:                enum screen laststate = invalid;
52:                
53:                void initBuffer(void){
0085FE  268BC7     MOV #0x68BC, W7
008600  26CBC6     MOV #0x6CBC, W6
008602  2CBFE5     MOV #0xCBFE, W5
008604  2C7FE4     MOV #0xC7FE, W4
008606  2C3FE3     MOV #0xC3FE, W3
008608  2BFFE2     MOV #0xBFFE, W2
00860A  202001     MOV #0x200, W1
008620  200232     MOV #0x23, W2
008622  410100     ADD W2, W0, W2
54:                    int i;
55:                    for(i=0; i<STREAMBUF; i++){
00861C  3AFFF8     BRA NZ, 0x860E
00861E  260990     MOV #0x6099, W0
56:                        streamA[i]=0;
00860C  EB0000     CLR W0
00860E  782B80     MOV W0, [++W7]
57:                        streamB[i]=0;
008610  782B00     MOV W0, [++W6]
58:                        txBufferA[i]=0;
008612  782A80     MOV W0, [++W5]
59:                        txBufferB[i]=0;
008614  782A00     MOV W0, [++W4]
60:                        rxBufferA[i]=0;
008616  782980     MOV W0, [++W3]
61:                        rxBufferB[i]=0;
008618  782900     MOV W0, [++W2]
00861A  E90081     DEC W1, W1
62:                    }
63:                    
64:                    for(i=0; i<BUTTONS; i++)
008628  500F82     SUB W0, W2, [W15]
00862A  3AFFFD     BRA NZ, 0x8626
65:                        pad[i]=1;
008624  B3C011     MOV.B #0x1, W1
008626  786801     MOV.B W1, [++W0]
66:                }
00862C  060000     RETURN
67:                
68:                int main(void) {
00862E  BE9F88     MOV.D W8, [W15++]
008630  BE9F8A     MOV.D W10, [W15++]
008632  BE9F8C     MOV.D W12, [W15++]
008634  781F8E     MOV W14, [W15++]
00864A  2FC00D     MOV #0xFC00, W13
008664  44050D     ADD W8, W13, W10
69:                    initPorts();                    //configure io device & adc 
008636  07F872     RCALL initPorts
70:                    //initUART1();                    //configure & enable UART
71:                    initBuffer();
008638  07FFE2     RCALL initBuffer
72:                    initADC1();                     //configure & enable internal ADC
00863A  07F937     RCALL initADC1
73:                    initPMP();
00863C  07F956     RCALL initPMP
74:                    //||||||||----
75:                    //initDMA0();
76:                    initDCI_DAC();                  //configure & enable DAC
00863E  07F994     RCALL initDCI_DAC
77:                    initT1();                       //configure & start T1 
008640  07F968     RCALL initT1
78:                    initT2();                       //configure & start T2 
008642  07F970     RCALL initT2
79:                    initSPI3_MEM();                  //start segment display
008644  07FA09     RCALL initSPI3_MEM
80:                    //initCAP_BPM();                  //configure bpm capture
81:                    initT3();                       //configure & start T3 for lcd
008646  07F97A     RCALL initT3
82:                    initQEI_ENC();
008648  07FA29     RCALL initQEI_ENC
83:                    //initT5();
84:                    fractional temp;
85:                    int writePtr;
86:                    fractional *ping, *pong;
87:                    
88:                    while(1){    
89:                        if(frameReady) {
008652  E21004     CP0 frameReady
008654  32001B     BRA Z, 0x868C
90:                            writePtr=STREAMBUF-1;
91:                            if(rw){
008656  E21002     CP0 rw
008658  320003     BRA Z, 0x8660
92:                                ping = streamA+writePtr;
00865C  26CBC8     MOV #0x6CBC, W8
00865E  370002     BRA 0x8664
93:                                pong = outputB+writePtr;
00865A  268BC9     MOV #0x68BC, W9
94:                            }else{
95:                                ping = streamB+writePtr;
008662  270BC8     MOV #0x70BC, W8
96:                                pong = outputA+writePtr;
008650  264BCE     MOV #0x64BC, W14
008660  78048E     MOV W14, W9
97:                            }
98:                            
99:                            for(; writePtr>=0; writePtr--){
008678  540F8A     SUB W8, W10, [W15]
00867A  3AFFF5     BRA NZ, 0x8666
100:                               temp=*ping--; //!rw
008666  780028     MOV [W8--], W0
101:                               if(temp<=-32766||temp>=32766)hard_clipped=TRUE;
00864C  27FFDB     MOV #0x7FFD, W11
00864E  EBC600     SETM.B W12
008668  40008B     ADD W0, W11, W1
00866A  408FE6     ADD W1, #0x6, [W15]
00866C  360002     BRA LEU, 0x8672
00866E  2100A1     MOV #0x100A, W1
008670  78488C     MOV.B W12, [W1]
102:                               temp=fx(temp);    //run fx on latest sample
008672  07FD47     RCALL fx
103:                               *pong--=mixer(temp); //rw
008674  07FCE3     RCALL mixer
008676  781480     MOV W0, [W9--]
104:                               
105:                           }
106:                           temp = 8*idle/STREAMBUF;
107:                           cycle=STREAMBUF/(STREAMBUF-write_ptr);
00867C  202000     MOV #0x200, W0
00867E  808222     MOV 0x1044, W2
008680  500102     SUB W0, W2, W2
008682  090011     REPEAT #0x11
008684  D88002     DIV.UW W0, W2
008686  888040     MOV W0, cycle
108:                           idle=0;
008688  EF3006     CLR idle
109:                           frameReady=0;
00868A  EF3004     CLR frameReady
110:                       }
111:                       if(_T2IF){
00868C  ABE800     BTST IFS0, #7
00868E  320006     BRA Z, 0x869C
112:                           scanButtons();                   //read button matrix
008690  07FBA0     RCALL scanButtons
113:                           readPots();                     //read control pots
008692  07FC43     RCALL readPots
114:                           if(_AD1IF) readPots();
008694  ABA801     BTST 0x801, #5
008696  320001     BRA Z, 0x869A
008698  07FC40     RCALL readPots
115:                           _T2IF=0;
00869A  A9E800     BCLR IFS0, #7
116:                       }
117:                       if(_T1IF){
00869C  AB6800     BTST IFS0, #3
00869E  320002     BRA Z, 0x86A4
118:                           display();
0086A0  07FCA4     RCALL display
119:                           _T1IF=0;
0086A2  A96800     BCLR IFS0, #3
120:                       }
121:                       if(_T3IF) {
0086A4  AB0801     BTST 0x801, #0
0086A6  32FFD5     BRA Z, 0x8652
122:                           lcdPoll();
0086A8  07FB2E     RCALL lcdPoll
123:                           _T3IF=0;
0086AA  A90801     BCLR 0x801, #0
0086AC  37FFD2     BRA 0x8652
124:                       }
125:                   }
126:                   return 0;
127:               }
128:               // example test 
---  C:/Users/ryan/Documents/seniorproject/ps-040/flash.c  ----------------------------------------------
1:                 /*
2:                  * File:   flash.c
3:                  * Author: root
4:                  *
5:                  * Created on January 28, 2018, 5:00 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "flash.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                char flashBuf[STREAMBUF*2];
15:                char receive;
16:                
17:                void flashWriteReg(char command) {
18:                    SS3=0;
0084D8  A92E54     BCLR LATF, #1
19:                    SPI3BUF=command;               //WEL=1 for write enable
0084DA  FB0000     SE W0, W0
0084DC  881540     MOV W0, SPI3BUF
20:                    while(!_SPI3IF); _SPI3IF=0;
0084DE  208001     MOV #0x800, W1
0084E0  804052     MOV IFS5, W2
0084E2  608002     AND W1, W2, W0
0084E4  32FFFD     BRA Z, 0x84E0
0084E6  A9680B     BCLR 0x80B, #3
21:                    receive=SPI3BUF;
0084E8  801540     MOV SPI3BUF, W0
0084EA  B7F054     MOV.B WREG, receive
22:                    SS3=1;
0084EC  A82E54     BSET LATF, #1
23:                }
0084EE  060000     RETURN
24:                
25:                char flashStatusCheck(void){
26:                    SS3=0;
0084F0  A92E54     BCLR LATF, #1
27:                    SPI3BUF=FLASH_RDSR1;               //WEL=1 for write enable
0084F2  200050     MOV #0x5, W0
0084F4  881540     MOV W0, SPI3BUF
28:                    while(!_SPI3IF); _SPI3IF=0;
0084F6  208001     MOV #0x800, W1
0084F8  804052     MOV IFS5, W2
0084FA  608002     AND W1, W2, W0
0084FC  32FFFD     BRA Z, 0x84F8
0084FE  A9680B     BCLR 0x80B, #3
29:                    receive=SPI3BUF;
008500  801540     MOV SPI3BUF, W0
30:                    SPI3BUF=0x00;               //WEL=1 for write enable
008502  EF22A8     CLR SPI3BUF
31:                    while(!_SPI3IF); _SPI3IF=0;
008504  208001     MOV #0x800, W1
008506  804052     MOV IFS5, W2
008508  608002     AND W1, W2, W0
00850A  32FFFD     BRA Z, 0x8506
00850C  A9680B     BCLR 0x80B, #3
32:                    receive=SPI3BUF;
00850E  801540     MOV SPI3BUF, W0
008510  B7F054     MOV.B WREG, receive
33:                    SS3=1;
008512  A82E54     BSET LATF, #1
34:                    
35:                    return receive;
36:                }
008514  060000     RETURN
37:                
38:                void flashWritePage(int addressH, int addressL){
39:                    int i;
40:                    SS3=0;
008516  A92E54     BCLR LATF, #1
41:                    SPI3BUF=FLASH_PP;
008518  200022     MOV #0x2, W2
00851A  881542     MOV W2, SPI3BUF
42:                    while(!_SPI3IF); _SPI3IF=0;
00851C  208003     MOV #0x800, W3
00851E  804054     MOV IFS5, W4
008520  618104     AND W3, W4, W2
008522  32FFFD     BRA Z, 0x851E
008524  A9680B     BCLR 0x80B, #3
43:                    receive=SPI3BUF;
008526  801542     MOV SPI3BUF, W2
44:                    SPI3BUF=addressH&&0xFF;
008528  A7F000     BTSC W0, #15
00852A  EA0000     NEG W0, W0
00852C  EA0000     NEG W0, W0
00852E  DE004F     LSR W0, #15, W0
008530  881540     MOV W0, SPI3BUF
45:                    while(!_SPI3IF); _SPI3IF=0;
008532  208002     MOV #0x800, W2
008534  804053     MOV IFS5, W3
008536  610003     AND W2, W3, W0
008538  32FFFD     BRA Z, 0x8534
00853A  A9680B     BCLR 0x80B, #3
46:                    receive=SPI3BUF;
00853C  801540     MOV SPI3BUF, W0
47:                    SPI3BUF=(addressL&&0xFF00)>>8;
00853E  EF22A8     CLR SPI3BUF
48:                    while(!_SPI3IF); _SPI3IF=0;
008540  208002     MOV #0x800, W2
008542  804054     MOV IFS5, W4
008544  610004     AND W2, W4, W0
008546  32FFFD     BRA Z, 0x8542
008548  A9680B     BCLR 0x80B, #3
49:                    receive=SPI3BUF;
00854A  801540     MOV SPI3BUF, W0
50:                    SPI3BUF=addressL&&0xFF;
00854C  780001     MOV W1, W0
00854E  A7F000     BTSC W0, #15
008550  EA0000     NEG W0, W0
008552  EA0000     NEG W0, W0
008554  DE004F     LSR W0, #15, W0
008556  881540     MOV W0, SPI3BUF
51:                    while(!_SPI3IF); _SPI3IF=0;
008558  208001     MOV #0x800, W1
00855A  804052     MOV IFS5, W2
00855C  608002     AND W1, W2, W0
00855E  32FFFD     BRA Z, 0x855A
008560  A9680B     BCLR 0x80B, #3
52:                    receive=SPI3BUF;
008562  801540     MOV SPI3BUF, W0
008564  202002     MOV #0x200, W2
53:                    
54:                    for(i=0; i<512;i++){    //write 512 bytes
008578  3AFFF8     BRA NZ, 0x856A
00857A  B7F054     MOV.B WREG, receive
55:                        //send byte
56:                        SPI3BUF=0xAA;
008566  200AA3     MOV #0xAA, W3
00856A  881543     MOV W3, SPI3BUF
57:                        while(!_SPI3IF); _SPI3IF=0;
008568  208001     MOV #0x800, W1
00856C  804054     MOV IFS5, W4
00856E  608004     AND W1, W4, W0
008570  32FFFD     BRA Z, 0x856C
008572  A9680B     BCLR 0x80B, #3
58:                        receive=SPI3BUF;
008574  801540     MOV SPI3BUF, W0
008576  E90102     DEC W2, W2
59:                    }
60:                    SS3=1;
00857C  A82E54     BSET LATF, #1
61:                }
00857E  060000     RETURN
62:                
63:                void flashRead(char *array, int bytes){
008580  BE9F88     MOV.D W8, [W15++]
008582  BE9F8A     MOV.D W10, [W15++]
008584  781F8C     MOV W12, [W15++]
008586  780581     MOV W1, W11
64:                    int i;
65:                    
66:                    SS3=0;
008588  A92E54     BCLR LATF, #1
67:                    SPI3BUF=FLASH_READ;
00858A  200031     MOV #0x3, W1
00858C  881541     MOV W1, SPI3BUF
68:                    while(!_SPI3IF); _SPI3IF=0;
00858E  208002     MOV #0x800, W2
008590  804053     MOV IFS5, W3
008592  610083     AND W2, W3, W1
008594  32FFFD     BRA Z, 0x8590
008596  A9680B     BCLR 0x80B, #3
69:                    receive=SPI3BUF;
008598  801541     MOV SPI3BUF, W1
70:                    SPI3BUF=0x00;
00859A  EF22A8     CLR SPI3BUF
71:                    while(!_SPI3IF); _SPI3IF=0;
00859C  208002     MOV #0x800, W2
00859E  804053     MOV IFS5, W3
0085A0  610083     AND W2, W3, W1
0085A2  32FFFD     BRA Z, 0x859E
0085A4  A9680B     BCLR 0x80B, #3
72:                    receive=SPI3BUF;
0085A6  801541     MOV SPI3BUF, W1
73:                    SPI3BUF=0x00;
0085A8  EF22A8     CLR SPI3BUF
74:                    while(!_SPI3IF); _SPI3IF=0;
0085AA  208002     MOV #0x800, W2
0085AC  804053     MOV IFS5, W3
0085AE  610083     AND W2, W3, W1
0085B0  32FFFD     BRA Z, 0x85AC
0085B2  A9680B     BCLR 0x80B, #3
75:                    receive=SPI3BUF;
0085B4  801541     MOV SPI3BUF, W1
76:                    SPI3BUF=0x00;
0085B6  EF22A8     CLR SPI3BUF
77:                    while(!_SPI3IF); _SPI3IF=0;
0085B8  208002     MOV #0x800, W2
0085BA  804053     MOV IFS5, W3
0085BC  610083     AND W2, W3, W1
0085BE  32FFFD     BRA Z, 0x85BA
0085C0  A9680B     BCLR 0x80B, #3
78:                    receive=SPI3BUF;
0085C2  801541     MOV SPI3BUF, W1
0085C4  784181     MOV.B W1, W3
0085C6  210542     MOV #0x1054, W2
0085C8  784903     MOV.B W3, [W2]
79:                    
80:                    for(i=0; i<bytes;i++){    //read 512 bytes
0085CA  E0000B     CP0 W11
0085CC  340010     BRA LE, 0x85EE
0085CE  780500     MOV W0, W10
0085D0  EB0480     CLR W9
0085E8  E80489     INC W9, W9
0085EA  558F89     SUB W11, W9, [W15]
0085EC  3CFFF4     BRA GT, 0x85D6
81:                        //receive byte
82:                        SPI3BUF=0x00;
0085D2  EB0600     CLR W12
0085D6  88154C     MOV W12, SPI3BUF
83:                        while(!_SPI3IF); _SPI3IF=0;
0085D4  208008     MOV #0x800, W8
0085D8  804051     MOV IFS5, W1
0085DA  640001     AND W8, W1, W0
0085DC  32FFFD     BRA Z, 0x85D8
0085DE  A9680B     BCLR 0x80B, #3
84:                        Delay_us(1);
0085E0  200010     MOV #0x1, W0
0085E2  07FD23     RCALL Delay_us
85:                        array[i]=SPI3BUF;
0085E4  801540     MOV SPI3BUF, W0
0085E6  785D00     MOV.B W0, [W10++]
86:                    }
87:                    SS3=1;
0085EE  A82E54     BSET LATF, #1
88:                }
0085F0  78064F     MOV [--W15], W12
0085F2  BE054F     MOV.D [--W15], W10
0085F4  BE044F     MOV.D [--W15], W8
0085F6  060000     RETURN
89:                
90:                void flashBulkErase(void) {
91:                    flashWriteReg(FLASH_FRMT);
0085F8  B3C600     MOV.B #0x60, W0
0085FA  07FF6E     RCALL flashWriteReg
92:                }
0085FC  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/devInits.c  -------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 #include <xc.h>
5:                 #include <p33EP512GM310.h>
6:                 #include <libpic30.h>
7:                 #include "common.h"
8:                 #include "devInits.h"
9:                 #include "utilities.h"
10:                #include "plcd.h"
11:                #include "screens.h"
12:                #include "flash.h"
13:                #include "dsp.h"
14:                
15:                extern unsigned char UART_ON;
16:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
17:                
18:                extern char flash_readback[512];
19:                
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
00771C  2FF3F0     MOV #0xFF3F, W0
00771E  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
007720  2FFE00     MOV #0xFFE0, W0
007722  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
007724  2FE000     MOV #0xFE00, W0
007726  B60746     AND PLLFBD, WREG
007728  B30490     IOR #0x49, W0
00772A  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
00772C  200201     MOV #0x20, W1
00772E  803A12     MOV OSCCON, W2
007730  608002     AND W1, W2, W0
007732  32FFFD     BRA Z, 0x772E
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
007734  803A10     MOV OSCCON, W0
007736  A16000     BCLR W0, #6
007738  200462     MOV #0x46, W2
00773A  200573     MOV #0x57, W3
00773C  207421     MOV #0x742, W1
00773E  784882     MOV.B W2, [W1]
007740  784883     MOV.B W3, [W1]
007742  784880     MOV.B W0, [W1]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
007744  2FFC00     MOV #0xFFC0, W0
007746  803424     MOV RPOR2, W4
007748  600084     AND W0, W4, W1
00774A  A00001     BSET W1, #0
00774C  883421     MOV W1, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
00774E  2FF801     MOV #0xFF80, W1
007750  803685     MOV RPINR24, W5
007752  608205     AND W1, W5, W4
007754  B303D4     IOR #0x3D, W4
007756  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
007758  B60686     AND RPOR3, WREG
00775A  B300C0     IOR #0xC, W0
00775C  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
00775E  2C0FF0     MOV #0xC0FF, W0
007760  803426     MOV RPOR2, W6
007762  600286     AND W0, W6, W5
007764  20D004     MOV #0xD00, W4
007766  720205     IOR W4, W5, W4
007768  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
00776A  803434     MOV RPOR3, W4
00776C  600284     AND W0, W4, W5
00776E  20B004     MOV #0xB00, W4
007770  720205     IOR W4, W5, W4
007772  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
007774  803575     MOV RPINR7, W5
007776  608205     AND W1, W5, W4
007778  B305F4     IOR #0x5F, W4
00777A  883574     MOV W4, RPINR7
36:                    RPINR29bits.SCK3R=0x39;     //SCK3 input on pin 84
00777C  280FF4     MOV #0x80FF, W4
00777E  8036D5     MOV RPINR29, W5
007780  620305     AND W4, W5, W6
007782  239005     MOV #0x3900, W5
007784  728286     IOR W5, W6, W5
007786  8836D5     MOV W5, RPINR29
37:                    RPOR7bits.RP57R=0x20;       //SCK3 output on pin 84
007788  803476     MOV RPOR7, W6
00778A  600286     AND W0, W6, W5
00778C  A0D005     BSET W5, #13
00778E  883475     MOV W5, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
007790  803485     MOV RPOR8, W5
007792  600305     AND W0, W5, W6
007794  21F005     MOV #0x1F00, W5
007796  728286     IOR W5, W6, W5
007798  883485     MOV W5, RPOR8
39:                    RPOR9bits.RP97R=0x21;       //SS3 on pin 88
00779A  B60692     AND RPOR9, WREG
00779C  221005     MOV #0x2100, W5
00779E  728280     IOR W5, W0, W5
0077A0  883495     MOV W5, RPOR9
40:                    RPINR29bits.SDI3R=0x4C;     //SDI on pin 79, RPI76
0077A2  8036D6     MOV RPINR29, W6
0077A4  608006     AND W1, W6, W0
0077A6  B304C0     IOR #0x4C, W0
0077A8  8836D0     MOV W0, RPINR29
41:                    RPINR14bits.QEA1R=0x10;     //QEA on pin 22, RPI16
0077AA  8035E0     MOV RPINR14, W0
0077AC  608080     AND W1, W0, W1
0077AE  A04001     BSET W1, #4
0077B0  8835E1     MOV W1, RPINR14
42:                    RPINR14bits.QEB1R=0x1B;     //QEB on pin 21, RPI27
0077B2  8035E5     MOV RPINR14, W5
0077B4  620205     AND W4, W5, W4
0077B6  21B000     MOV #0x1B00, W0
0077B8  700004     IOR W0, W4, W0
0077BA  8835E0     MOV W0, RPINR14
43:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
0077BC  803A10     MOV OSCCON, W0
0077BE  A06000     BSET W0, #6
0077C0  207421     MOV #0x742, W1
0077C2  784882     MOV.B W2, [W1]
0077C4  784883     MOV.B W3, [W1]
0077C6  784880     MOV.B W0, [W1]
44:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
45:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
0077C8  EB8000     SETM W0
0077CA  883B60     MOV W0, PMD7
0077CC  F8076C     PUSH PMD7
0077CE  F9076A     POP PMD6
0077D0  F8076A     PUSH PMD6
0077D2  F90766     POP PMD4
0077D4  F80766     PUSH PMD4
0077D6  F90764     POP PMD3
0077D8  F80764     PUSH PMD3
0077DA  F90762     POP PMD2
0077DC  F80762     PUSH PMD2
0077DE  F90760     POP PMD1
46:                    PMD1bits.AD1MD=0;
0077E0  A90760     BCLR PMD1, #0
47:                    PMD1bits.SPI1MD=0;
0077E2  A96760     BCLR PMD1, #3
48:                    PMD1bits.SPI2MD=0;
0077E4  A98760     BCLR PMD1, #4
49:                    PMD1bits.U1MD=0;
0077E6  A9A760     BCLR PMD1, #5
50:                    PMD1bits.U2MD=0;
0077E8  A9C760     BCLR PMD1, #6
51:                    PMD1bits.DCIMD=0;
0077EA  A90761     BCLR 0x761, #0
52:                    PMD1bits.T1MD=0;
0077EC  A96761     BCLR 0x761, #3
53:                    PMD1bits.T2MD=0;
0077EE  A98761     BCLR 0x761, #4
54:                    PMD1bits.T3MD=0;
0077F0  A9A761     BCLR 0x761, #5
55:                    PMD1bits.T4MD=0;
0077F2  A9C761     BCLR 0x761, #6
56:                    PMD1bits.T5MD=0;
0077F4  A9E761     BCLR 0x761, #7
57:                    PMD3bits.PMPMD=0;
0077F6  A90765     BCLR 0x765, #0
58:                    PMD3bits.CMPMD=0;
0077F8  A94765     BCLR 0x765, #2
59:                    PMD6bits.SPI3MD=0;
0077FA  A9076A     BCLR PMD6, #0
60:                    PMD7bits.DMA0MD=0;
0077FC  A9876C     BCLR PMD7, #4
61:                    
62:                    /* Digital IO DIRECTION (1 = input) */
63:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
0077FE  EF2E60     CLR TRISG
007800  F80E60     PUSH TRISG
007802  F90E50     POP TRISF
007804  F80E50     PUSH TRISF
007806  F90E40     POP TRISE
007808  F80E40     PUSH TRISE
00780A  F90E30     POP TRISD
00780C  F80E30     PUSH TRISD
00780E  F90E20     POP TRISC
007810  F80E20     PUSH TRISC
007812  F90E10     POP TRISB
007814  F80E10     PUSH TRISB
007816  F90E00     POP TRISA
64:                    TRISA=0x1E01; CNPUA=0x0801;
007818  21E011     MOV #0x1E01, W1
00781A  887001     MOV W1, TRISA
00781C  208011     MOV #0x801, W1
00781E  887051     MOV W1, CNPUA
65:                    TRISB=0x0000; CNPUB=0x0000;
007820  EF2E10     CLR TRISB
007822  EF2E1A     CLR CNPUB
66:                    TRISC=0x2087;
007824  220871     MOV #0x2087, W1
007826  887101     MOV W1, TRISC
67:                    TRISD=0x011E; CNPUD=0x001E;
007828  2011E1     MOV #0x11E, W1
00782A  887181     MOV W1, TRISD
00782C  2001E1     MOV #0x1E, W1
00782E  8871D1     MOV W1, CNPUD
68:                    TRISE=0x7300;
007830  273001     MOV #0x7300, W1
007832  887201     MOV W1, TRISE
69:                    TRISF=0x00F0; CNPUF=0x00F1;
007834  200F01     MOV #0xF0, W1
007836  887281     MOV W1, TRISF
007838  E80081     INC W1, W1
00783A  8872D1     MOV W1, CNPUF
70:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
00783C  887350     MOV W0, CNPUG
00783E  F80E6A     PUSH CNPUG
007840  F90E60     POP TRISG
71:                    
72:                    /* DIGITAL OUTPUT LATCH */
73:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
007842  EF2E64     CLR LATG
007844  F80E64     PUSH LATG
007846  F90E54     POP LATF
007848  F80E54     PUSH LATF
00784A  F90E44     POP LATE
00784C  F80E44     PUSH LATE
00784E  F90E34     POP LATD
007850  F80E34     PUSH LATD
007852  F90E24     POP LATC
007854  F80E24     PUSH LATC
007856  F90E14     POP LATB
007858  F80E14     PUSH LATB
00785A  F90E04     POP LATA
74:                    LATA=0x0040;
00785C  200400     MOV #0x40, W0
00785E  887020     MOV W0, LATA
75:                    
76:                    /* ANALOG PINS (1 = analog) */
77:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
007860  EF2E6E     CLR ANSELG
007862  F80E6E     PUSH ANSELG
007864  F90E5E     POP ANSELF
007866  F80E5E     PUSH ANSELF
007868  F90E4E     POP ANSELE
00786A  F80E4E     PUSH ANSELE
00786C  F90E3E     POP ANSELD
00786E  F80E3E     PUSH ANSELD
007870  F90E2E     POP ANSELC
007872  F80E2E     PUSH ANSELC
007874  F90E1E     POP ANSELB
007876  F80E1E     PUSH ANSELB
007878  F90E0E     POP ANSELA
78:                    ANSELCbits.ANSC0=1;     //AN6
00787A  A80E2E     BSET ANSELC, #0
79:                    ANSELCbits.ANSC1=1;     //AN7
00787C  A82E2E     BSET ANSELC, #1
80:                    ANSELCbits.ANSC2=1;     //AN8
00787E  A84E2E     BSET ANSELC, #2
81:                    ANSELAbits.ANSA12=1;    //AN10 
007880  A88E0F     BSET 0xE0F, #4
82:                    ANSELEbits.ANSE8=1;     //AN21
007882  A80E4F     BSET 0xE4F, #0
83:                    ANSELEbits.ANSE9=1;     //AN20
007884  A82E4F     BSET 0xE4F, #1
84:                    
85:                    
86:                    
87:                }
007886  060000     RETURN
88:                
89:                void initUART1(void){
90:                    IFS0bits.U1TXIF = 0;        //clear flag
007888  A98801     BCLR 0x801, #4
91:                    IFS0bits.U1RXIF = 0;        //clear flag
00788A  A96801     BCLR 0x801, #3
92:                    U1STA=0x1510;               //enable tx & rx
00788C  215100     MOV #0x1510, W0
00788E  881110     MOV W0, U1STA
93:                    U1BRG=BRGVAL;               //baud rate
007890  2004A0     MOV #0x4A, W0
007892  881140     MOV W0, U1BRG
94:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
007894  2FFF90     MOV #0xFFF9, W0
007896  B60220     AND U1MODE, WREG
007898  A01000     BSET W0, #1
00789A  881100     MOV W0, U1MODE
95:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
00789C  270000     MOV #0x7000, W0
00789E  B72844     IOR IPC2
96:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
0078A0  200070     MOV #0x7, W0
0078A2  B72846     IOR IPC3
97:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
98:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
99:                    U1MODEbits.UARTEN = 1;      //start uart
0078A4  A8E221     BSET 0x221, #7
100:                   UART_ON = TRUE;
0078A6  EFF00B     SETM.B UART_ON
101:                   
102:               }
0078A8  060000     RETURN
103:               
104:               void initADC1(void){ 
105:               
106:                   /* Assign MUXA inputs */
107:                   AD1CON1 = 0x04E4; // Enable 12-bit mode, auto-sample and auto-conversion
0078AA  204E40     MOV #0x4E4, W0
0078AC  881900     MOV W0, AD1CON1
108:                   AD1CON2 = 0x0408; // Sample alternately using channel scanning
0078AE  B10DC0     SUB #0xDC, W0
0078B0  881910     MOV W0, AD1CON2
109:                   AD1CON2bits.SMPI=POTS-1; // Sample 5 channels
0078B2  2FF830     MOV #0xFF83, W0
0078B4  B60322     AND AD1CON2, WREG
0078B6  B302C0     IOR #0x2C, W0
0078B8  881910     MOV W0, AD1CON2
110:                   AD1CON3 = 0x0F0F; // Sample for 15*TAD before converting
0078BA  20F0F0     MOV #0xF0F, W0
0078BC  881920     MOV W0, AD1CON3
111:                   AD1CON1bits.FORM=2;         //signed fractional format 
0078BE  2FCFF0     MOV #0xFCFF, W0
0078C0  B60320     AND AD1CON1, WREG
0078C2  A09000     BSET W0, #9
0078C4  881900     MOV W0, AD1CON1
112:                   AD1CON3bits.ADCS=0x3F;
0078C6  B3C3F0     MOV.B #0x3F, W0
0078C8  B7E324     MOV.B WREG, AD1CON3
113:                   AD1CON3bits.SAMC=0x0F;
0078CA  2E0FF1     MOV #0xE0FF, W1
0078CC  801920     MOV AD1CON3, W0
0078CE  608080     AND W1, W0, W1
0078D0  20F000     MOV #0xF00, W0
0078D2  700001     IOR W0, W1, W0
0078D4  881920     MOV W0, AD1CON3
114:                   //select  AN6,7,8
115:                   AD1CSSLbits.CSS6=1; //AN6
0078D6  A8C330     BSET AD1CSSL, #6
116:                   AD1CSSLbits.CSS7=1; //AN7
0078D8  A8E330     BSET AD1CSSL, #7
117:                   AD1CSSLbits.CSS8=1; //AN8
0078DA  A80331     BSET 0x331, #0
118:                   AD1CSSLbits.CSS10=1;//AN10
0078DC  A84331     BSET 0x331, #2
119:                   AD1CSSHbits.CSS20=1;//AN20
0078DE  A8832E     BSET AD1CSSH, #4
120:                   AD1CSSHbits.CSS21=1;//AN21
0078E0  A8A32E     BSET AD1CSSH, #5
121:                   //AD1CSSLbits.CSS9=1; //AN9
122:                   /* Enable ADC module and provide ADC stabilization delay */
123:                   AD1CON1bits.ADON = 1;
0078E2  A8E321     BSET 0x321, #7
124:                   Delay_us(30);
0078E4  2001E0     MOV #0x1E, W0
0078E6  0703A1     RCALL Delay_us
125:               }
0078E8  060000     RETURN
126:               
127:               void initPMP(void){
128:                   /*
129:                    Data is clocked on falling edge of E
130:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
131:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
132:                    */
133:                   PMMODEbits.MODE=3;  //master mode 1 
0078EA  203000     MOV #0x300, W0
0078EC  B72602     IOR PMMODE
134:                   PMCONbits.PTWREN = 1;
0078EE  A82601     BSET 0x601, #1
135:                   PMCONbits.PTRDEN = 1;
0078F0  A80601     BSET 0x601, #0
136:                   PMCONbits.WRSP=1;   //write strobe active high
0078F2  A82600     BSET PMCON, #1
137:                   PMCONbits.RDSP=1;   //read strobe active high
0078F4  A80600     BSET PMCON, #0
138:               
139:                   PMMODEbits.WAITB = 0;
0078F6  2FF3F0     MOV #0xFF3F, W0
0078F8  B62602     AND PMMODE
140:                   PMMODEbits.WAITM = 0xC;
0078FA  2FFC30     MOV #0xFFC3, W0
0078FC  B60602     AND PMMODE, WREG
0078FE  B30300     IOR #0x30, W0
007900  883010     MOV W0, PMMODE
141:                   PMMODEbits.WAITE = 0;
007902  2FFFC0     MOV #0xFFFC, W0
007904  B62602     AND PMMODE
142:                   LCD_RS=0;
007906  A9EE45     BCLR 0xE45, #7
143:                   PMCONbits.PMPEN = 1;
007908  A8E601     BSET 0x601, #7
144:                   
145:                   /* INIT DEVICE */
146:                   Delay_us(40000);
00790A  29C400     MOV #0x9C40, W0
00790C  07038E     RCALL Delay_us
147:                   lcdInit();
00790E  070245     RCALL lcdInit
148:                   
149:                   /* SETUP SCREEN */
150:                   //lcdSetupPots();
151:               }
007910  060000     RETURN
152:               
153:               
154:               //Description: Initializes timer for LED's UART and display
155:               //Prereq: initUART1()
156:               //Dependencies: _T1Interrupt(void)
157:               //Frequency: 15Hz
158:               void initT1(void){          //16 bit timer
159:                   TMR1 = 0x0000;          //clear timer 4
007912  EF2100     CLR TMR1
160:                   T1CONbits.TCKPS = 3;    //prescale 1:256
007914  200300     MOV #0x30, W0
007916  B72104     IOR T1CON
161:                   T1CONbits.TCS = 0;      //use internal clock
007918  A92104     BCLR T1CON, #1
162:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
00791A  A9C104     BCLR T1CON, #6
163:                   PR1 = Fcy/(256*Fdisp);    //period register
00791C  246500     MOV #0x4650, W0
00791E  880810     MOV W0, PR1
164:                   //PR1=0x7FFF;
165:               
166:                   T1CONbits.TON = 1;      //start timer
007920  A8E105     BSET 0x105, #7
167:               }
007922  060000     RETURN
168:               
169:               //Description:  Initializes timer handles polling button input
170:               //Prereq: initADC1() 
171:               //Dependencies: _T2Interrupt(void)
172:               //Frequency: 512Hz
173:               void initT2(void){          //16/32 bit timer
174:                   TMR2 = 0x0000;          //clear timer 4
007924  EF2106     CLR TMR2
175:                   T2CONbits.T32 = 0;      //16 bit mode
007926  A96110     BCLR T2CON, #3
176:                   T2CONbits.TCKPS = 1;    //prescale 1:8
007928  2FFCF0     MOV #0xFFCF, W0
00792A  B60110     AND T2CON, WREG
00792C  A04000     BSET W0, #4
00792E  880880     MOV W0, T2CON
177:                   T2CONbits.TCS = 0;      //use internal clock
007930  A92110     BCLR T2CON, #1
178:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
007932  A9C110     BCLR T2CON, #6
179:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
007934  207AC0     MOV #0x7AC, W0
007936  880860     MOV W0, PR2
180:               
181:                   T2CONbits.TON = 1;      //start timer
007938  A8E111     BSET 0x111, #7
182:               }
00793A  060000     RETURN
183:               
184:               //Description: Initialize timer handling LCD sending
185:               //Dependencies: _T3Interrupt(void)
186:               //Frequency: 44.1kHz
187:               void initT3(void){          //16/32 bit timer
188:                   TMR3 = 0x0000;          //clear timer 3
00793C  EF210A     CLR TMR3
189:                   T3CONbits.TCKPS = 1;    //prescale 8:1
00793E  2FFCF0     MOV #0xFFCF, W0
007940  B60112     AND T3CON, WREG
007942  A04000     BSET W0, #4
007944  880890     MOV W0, T3CON
190:                   T3CONbits.TCS = 0;      //use internal clock
007946  A92112     BCLR T3CON, #1
191:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
007948  A9C112     BCLR T3CON, #6
192:                   //PR3 = Fcy/(256*T3freq);           //period register
193:                   PR3 = 0x01D0;           //45uS initial delay
00794A  201D00     MOV #0x1D0, W0
00794C  880870     MOV W0, PR3
194:                   
195:                   T3CONbits.TON = 1;
00794E  A8E113     BSET 0x113, #7
196:                   
197:               }
007950  060000     RETURN
198:               
199:               /*=============================================================================  
200:               Timer 5 is setup to time-out every 125 microseconds (8Khz Rate). As a result, the module 
201:               will stop sampling and trigger a conversion on every Timer3 time-out, i.e., Ts=125us. 
202:               =============================================================================*/
203:               void initT5() 
204:               {
205:                       TMR5 = 0x0000;
007952  EF2118     CLR TMR5
206:                       PR5 = 4999;
007954  213870     MOV #0x1387, W0
007956  8808E0     MOV W0, PR5
207:                       T5CONbits.TCKPS = 2;    //prescale 8:1
007958  2FFCF0     MOV #0xFFCF, W0
00795A  B60120     AND T5CON, WREG
00795C  A05000     BSET W0, #5
00795E  880900     MOV W0, T5CON
208:                       IFS1bits.T5IF = 0;
007960  A98803     BCLR 0x803, #4
209:                       IEC1bits.T5IE = 0;
007962  A98823     BCLR 0x823, #4
210:               
211:                       //Start Timer 3
212:                       T5CONbits.TON = 1;
007964  A8E121     BSET 0x121, #7
213:               
214:               }
007966  060000     RETURN
215:               
216:               //Description: Initializes & starts 16 bit DCI I2S DAC
217:               //Prereq: initSPI_ADC(void)
218:               //Dependencies: readDAC(void)
219:               void initDCI_DAC(void){
220:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
007968  2F0000     MOV #0xF000, W0
00796A  B60284     AND DCICON3, WREG
00796C  B30170     IOR #0x17, W0
00796E  881420     MOV W0, DCICON3
221:                   DCICON1bits.COFSM=1;                //i2s mode
007970  2FFFC0     MOV #0xFFFC, W0
007972  B60280     AND DCICON1, WREG
007974  A00000     BSET W0, #0
007976  881400     MOV W0, DCICON1
222:                   DCICON1bits.CSCKE=1;                //sample on rising edge
007978  A82281     BSET 0x281, #1
223:                   DCICON2bits.WS=0xF;                 //16 bit data word
00797A  2000F0     MOV #0xF, W0
00797C  B72282     IOR DCICON2
224:                   DCICON2bits.COFSG=0;    //data frame has 1 word (per frame)
00797E  2FE1F0     MOV #0xFE1F, W0
007980  B62282     AND DCICON2
225:                   DCICON1bits.DJST=0;     //align data
007982  A9A280     BCLR DCICON1, #5
226:                   DCICON2bits.BLEN=3;     //4 words buffer btwn interrupts
007984  20C000     MOV #0xC00, W0
007986  B72282     IOR DCICON2
227:                   
228:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
007988  A80288     BSET TSCON, #0
229:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
00798A  A82288     BSET TSCON, #1
230:                   TSCONbits.TSE2 = 1;     // Transmit on Time Slot 2     
00798C  A84288     BSET TSCON, #2
231:                   TSCONbits.TSE3 = 1;     // Transmit on Time Slot 3   
00798E  A86288     BSET TSCON, #3
232:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
007990  A8028C     BSET RSCON, #0
233:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
007992  A8228C     BSET RSCON, #1
234:                   RSCONbits.RSE2 = 1;     // rcv on Time Slot 2     
007994  A8428C     BSET RSCON, #2
235:                   RSCONbits.RSE3 = 1;     // rcv on Time Slot 3 
007996  A8628C     BSET RSCON, #3
236:                   
237:               
238:                   
239:                   IPC15bits.DCIIP = 6;    // Interrput priority
007998  2FFF80     MOV #0xFFF8, W0
00799A  B6085E     AND IPC15, WREG
00799C  B30060     IOR #0x6, W0
00799E  8842F0     MOV W0, IPC15
240:                   IFS3bits.DCIIF=0;
0079A0  A98807     BCLR 0x807, #4
241:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
0079A2  A88827     BSET 0x827, #4
242:                   
243:                   // Pre-load send registers.
244:                   TXBUF0=0;
0079A4  EF2298     CLR TXBUF0
245:                   TXBUF1=0;   
0079A6  EF229A     CLR TXBUF1
246:                   TXBUF2=0;
0079A8  EF229C     CLR TXBUF2
247:                   TXBUF3=0;
0079AA  EF229E     CLR TXBUF3
248:                   DCICON1bits.DCIEN=1;    //ENABLE
0079AC  A8E281     BSET 0x281, #7
249:                   // Stabilization delay
250:                   Delay_us(20);
0079AE  200140     MOV #0x14, W0
0079B0  07033C     RCALL Delay_us
251:               }
0079B2  060000     RETURN
252:               
253:               void initDMA0(void){
254:                   unsigned long address;
255:                   
256:                   /*
257:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
258:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
259:                   DMA0PAD =  0X0608; // Point DMA to PMP
260:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
261:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
262:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
263:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
264:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
265:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
266:                   DMA0CONbits.CHEN=1; // Enable DMA
267:                   */
268:                   
269:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
0079B4  A9CB01     BCLR 0xB01, #6
270:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
0079B6  A8AB01     BSET 0xB01, #5
271:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
0079B8  2FFCF4     MOV #0xFFCF, W4
0079BA  20B000     MOV #0xB00, W0
0079BC  620810     AND W4, [W0], [W0]
272:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
0079BE  2FFFC3     MOV #0xFFFC, W3
0079C0  805801     MOV DMA0CON, W1
0079C2  618001     AND W3, W1, W0
0079C4  A01000     BSET W0, #1
0079C6  885800     MOV W0, DMA0CON
273:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
0079C8  A98B01     BCLR 0xB01, #4
274:                   DMA0CONbits.NULLW = 0;
0079CA  A96B01     BCLR 0xB01, #3
275:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
0079CC  A9EB03     BCLR 0xB03, #7
276:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
0079CE  B3C3C2     MOV.B #0x3C, W2
0079D0  20B025     MOV #0xB02, W5
0079D2  784A82     MOV.B W2, [W5]
277:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
0079D4  27FFF0     MOV #0x7FFF, W0
0079D6  2CC001     MOV #0xCC00, W1
0079D8  608080     AND W1, W0, W1
278:                   address +=__builtin_edspage(txBufferA) << 15;
0079DA  200016     MOV #0x1, W6
0079DC  DD334F     SL W6, #15, W6
0079DE  EB0380     CLR W7
0079E0  408306     ADD W1, W6, W6
0079E2  4B83E0     ADDC W7, #0x0, W7
279:                   DMA0STAL = address & 0xFFFF;
0079E4  885826     MOV W6, DMA0STAL
280:                   DMA0STAH = address >>16;
0079E6  885837     MOV W7, DMA0STAH
281:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
0079E8  2C8001     MOV #0xC800, W1
0079EA  608080     AND W1, W0, W1
282:                   address +=__builtin_edspage(txBufferB) << 15;
0079EC  200016     MOV #0x1, W6
0079EE  DD334F     SL W6, #15, W6
0079F0  EB0380     CLR W7
0079F2  408306     ADD W1, W6, W6
0079F4  4B83E0     ADDC W7, #0x0, W7
283:                   DMA0STBL = address & 0xFFFF;
0079F6  885846     MOV W6, DMA0STBL
284:                   DMA0STBH = address >>16;
0079F8  885857     MOV W7, DMA0STBH
285:                   DMA0PAD = (int)&TXBUF0;
0079FA  202981     MOV #0x298, W1
0079FC  885861     MOV W1, DMA0PAD
286:                   DMA0CNT = STREAMBUF-1;
0079FE  201FF1     MOV #0x1FF, W1
007A00  885871     MOV W1, DMA0CNT
287:                   /* DMA 2 - DCI to DPSRAM*/
288:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
007A02  A9CB21     BCLR 0xB21, #6
289:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
007A04  A9AB21     BCLR 0xB21, #5
290:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
007A06  A98B21     BCLR 0xB21, #4
291:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
007A08  A96B21     BCLR 0xB21, #3
292:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
007A0A  20B205     MOV #0xB20, W5
007A0C  620A95     AND W4, [W5], [W5]
293:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
007A0E  805904     MOV DMA2CON, W4
007A10  618184     AND W3, W4, W3
007A12  A01003     BSET W3, #1
007A14  885903     MOV W3, DMA2CON
294:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
007A16  A9EB23     BCLR 0xB23, #7
295:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
007A18  784182     MOV.B W2, W3
007A1A  20B225     MOV #0xB22, W5
007A1C  784A83     MOV.B W3, [W5]
296:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
007A1E  2C4004     MOV #0xC400, W4
007A20  620200     AND W4, W0, W4
297:                   address +=__builtin_edspage(rxBufferA) << 15;
007A22  200012     MOV #0x1, W2
007A24  DD114F     SL W2, #15, W2
007A26  EB0180     CLR W3
007A28  420102     ADD W4, W2, W2
007A2A  4981E0     ADDC W3, #0x0, W3
298:                   DMA2STAL = address & 0xFFFF;
007A2C  885922     MOV W2, DMA2STAL
299:                   DMA2STAH = address >>16;
007A2E  885933     MOV W3, DMA2STAH
300:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
007A30  2C0002     MOV #0xC000, W2
007A32  610000     AND W2, W0, W0
301:                   address +=__builtin_edspage(rxBufferB) << 15;
007A34  200012     MOV #0x1, W2
007A36  DD114F     SL W2, #15, W2
007A38  EB0180     CLR W3
007A3A  400102     ADD W0, W2, W2
007A3C  4981E0     ADDC W3, #0x0, W3
302:                   DMA2STBL = address & 0xFFFF;
007A3E  885942     MOV W2, DMA2STBL
303:                   DMA2STBH = address >>16;
007A40  885953     MOV W3, DMA2STBH
304:                   DMA2PAD = (int)&RXBUF0;
007A42  202900     MOV #0x290, W0
007A44  885960     MOV W0, DMA2PAD
305:                   DMA2CNT = STREAMBUF-1;
007A46  885971     MOV W1, DMA2CNT
306:                   _DMA2IP = 5;
007A48  2FFF80     MOV #0xFFF8, W0
007A4A  B6084C     AND IPC6, WREG
007A4C  B30050     IOR #0x5, W0
007A4E  884260     MOV W0, IPC6
307:                   _DMA2IE = 1;
007A50  A80823     BSET 0x823, #0
308:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
007A52  A8EB01     BSET 0xB01, #7
309:                   DMA2CONbits.CHEN = 1;
007A54  A8EB21     BSET 0xB21, #7
310:               }
007A56  060000     RETURN
311:               
312:               void initSPI3_MEM(void){
313:                   int i=0;
314:                   
315:                   SS3=1;                     // Assert chip select (active low)
007A58  A82E54     BSET LATF, #1
316:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
007A5A  A9680B     BCLR 0x80B, #3
317:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
007A5C  A9682B     BCLR 0x82B, #3
318:                   SPI3CON1bits.MSTEN=1;       //master mode
007A5E  A8A2A2     BSET SPI3CON1, #5
319:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
007A60  A982A3     BCLR 0x2A3, #4
320:                   SPI3CON1bits.MODE16=0;      //8 bit
007A62  A942A3     BCLR 0x2A3, #2
321:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
007A64  A962A3     BCLR 0x2A3, #3
322:                   SPI3CON1bits.SSEN=1;        //use SS
007A66  A8E2A2     BSET SPI3CON1, #7
323:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
007A68  A9E2A5     BCLR 0x2A5, #7
324:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
007A6A  A902A4     BCLR SPI3CON2, #0
325:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
007A6C  2FFE33     MOV #0xFFE3, W3
007A6E  801300     MOV SPI2STAT, W0
007A70  618080     AND W3, W0, W1
007A72  B30141     IOR #0x14, W1
007A74  881301     MOV W1, SPI2STAT
326:                   
327:                   SPI3CON1bits.SMP=1;         //data sampled at end of output time
007A76  A822A3     BSET 0x2A3, #1
328:                   SPI3CON1bits.CKP=0;         //idle clock is low
007A78  A9C2A2     BCLR SPI3CON1, #6
329:                   SPI3CON1bits.CKE=1;         //data changes from H to L
007A7A  A802A3     BSET 0x2A3, #0
330:                   
331:                   SPI3CON1bits.PPRE=3;        //1:1 primary prescale
007A7C  200030     MOV #0x3, W0
007A7E  B722A2     IOR SPI3CON1
332:                   SPI3CON1bits.SPRE=6;        //2:1 secondary
007A80  801511     MOV SPI3CON1, W1
007A82  618001     AND W3, W1, W0
007A84  B30180     IOR #0x18, W0
007A86  881510     MOV W0, SPI3CON1
333:                   
334:                   SPI3STATbits.SPIROV = 0;        // Clear SPI1 receive overflow flag if set
007A88  A9C2A0     BCLR SPI3STAT, #6
335:                   //IPC22bits.SPI3IP = 3;         // Interrupt priority
336:                   //IFS5bits.SPI3IF = 0;          // Clear the Interrupt flag
337:                   //IEC5bits.SPI3IE = 0;          // Enable the interrupt
338:                   SPI3STATbits.SPIEN = 1;         //start SPI module
007A8A  A8E2A1     BSET 0x2A1, #7
339:                  
340:                   Delay_us(20);                       // Stabilization Delay
007A8C  200140     MOV #0x14, W0
007A8E  0702CD     RCALL Delay_us
341:                   
342:                   flashWriteReg(FLASH_WREN);
007A90  B3C060     MOV.B #0x6, W0
007A92  070522     RCALL flashWriteReg
343:                   /*
344:                   flashBulkErase();
345:                   while(flashStatusCheck()&1);
346:               
347:                   flashWritePage
348:                   while(flashStatusCheck()&1);
349:                   */
350:                   
351:                   flashRead(flash_readback, 256);     // READBACK
007A94  201001     MOV #0x100, W1
007A96  25E9A0     MOV #0x5E9A, W0
007A98  070573     RCALL flashRead
352:                   
353:               }
007A9A  060000     RETURN
354:               
355:               void initQEI_ENC(void){
356:                   QEI1CONbits.INTDIV=6;       // 1:64 prescaler
007A9C  2FF8F0     MOV #0xFF8F, W0
007A9E  B601C0     AND QEI1CON, WREG
007AA0  B30600     IOR #0x60, W0
007AA2  880E00     MOV W0, QEI1CON
357:                   QEI1IOCbits.FLTREN=1;       // Enable input filter
007AA4  A8C1C3     BSET 0x1C3, #6
358:                   QEI1CONbits.QEIEN=1;        // Enable Quad encoder inteface
007AA6  A8E1C1     BSET 0x1C1, #7
359:               }
007AA8  060000     RETURN
360:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/audio.c  ----------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[8];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[4];
7:                 extern fractional pots_percent[4];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                fractional mixer(fractional sample){
00803C  F80022     PUSH ACCA
00803E  F80024     PUSH ACCAH
008040  F80026     PUSH ACCAU
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    
38:                
39:                    if(kick_playing==TRUE&&kick_ptr<kick_max){
008042  210381     MOV #0x1038, W1
008044  784091     MOV.B [W1], W1
008046  40CFE1     ADD.B W1, #0x1, [W15]
008048  3A0011     BRA NZ, 0x806C
00804A  877662     MOV 0xEECC, W2
00804C  8081D3     MOV kick_ptr, W3
00804E  518F82     SUB W3, W2, [W15]
008050  31000D     BRA C, 0x806C
40:                        result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
008052  780200     MOV W0, W4
008054  273325     MOV #0x7332, W5
008056  C00113     MPY W4*W5, A
41:                        result1 = __builtin_add(result1,kick[kick_ptr++],0);
008058  780003     MOV W3, W0
00805A  400080     ADD W0, W0, W1
00805C  2C36C2     MOV #0xC36C, W2
00805E  410081     ADD W2, W1, W1
008060  780091     MOV [W1], W1
008062  E80000     INC W0, W0
008064  8881D0     MOV W0, kick_ptr
008066  C90001     ADD W1, A
42:                        sample=__builtin_sac(result1, 0);
008068  CC0000     SAC A, W0
00806A  37000C     BRA 0x8084
43:                    }
44:                    else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
00806C  2609A2     MOV #0x609A, W2
00806E  B3C013     MOV.B #0x1, W3
008070  11CF92     SUBR.B W3, [W2], [W15]
008072  3A0008     BRA NZ, 0x8084
008074  40CFE1     ADD.B W1, #0x1, [W15]
008076  3A0006     BRA NZ, 0x8084
008078  877661     MOV 0xEECC, W1
00807A  8081D4     MOV kick_ptr, W4
00807C  520F81     SUB W4, W1, [W15]
00807E  3A0002     BRA NZ, 0x8084
45:                        kick_playing=FALSE;
008080  EF7038     CLR.B kick_playing
46:                        kick_ptr=0;
008082  EF303A     CLR kick_ptr
47:                    }
48:                    /*
49:                    if(hat_playing==TRUE&&hat_ptr<hat_max){
50:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
51:                        result1 = __builtin_add(result1,hat[hat_ptr++],0);
52:                        sample=__builtin_sac(result1, 0);
53:                    }
54:                    else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
55:                        hat_playing=FALSE;
56:                        hat_ptr=0;
57:                    }
58:                     */
59:                
60:                    if(snare_playing==TRUE&&snare_ptr<snare_max){
008084  2103C1     MOV #0x103C, W1
008086  784091     MOV.B [W1], W1
008088  40CFE1     ADD.B W1, #0x1, [W15]
00808A  3A0011     BRA NZ, 0x80AE
00808C  877672     MOV 0xEECE, W2
00808E  8081F5     MOV snare_ptr, W5
008090  528F82     SUB W5, W2, [W15]
008092  31000D     BRA C, 0x80AE
61:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
008094  780200     MOV W0, W4
008096  26CCC5     MOV #0x6CCC, W5
008098  C00113     MPY W4*W5, A
62:                        result1 = __builtin_add(result1,snare[snare_ptr++],0);
00809A  8081F0     MOV snare_ptr, W0
00809C  400080     ADD W0, W0, W1
00809E  292942     MOV #0x9294, W2
0080A0  410081     ADD W2, W1, W1
0080A2  780091     MOV [W1], W1
0080A4  E80000     INC W0, W0
0080A6  8881F0     MOV W0, snare_ptr
0080A8  C90001     ADD W1, A
63:                        sample=__builtin_sac(result1, 0);
0080AA  CC0000     SAC A, W0
0080AC  37000C     BRA 0x80C6
64:                    }
65:                    else if (pad[1]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
0080AE  2609B2     MOV #0x609B, W2
0080B0  B3C013     MOV.B #0x1, W3
0080B2  11CF92     SUBR.B W3, [W2], [W15]
0080B4  3A0008     BRA NZ, 0x80C6
0080B6  40CFE1     ADD.B W1, #0x1, [W15]
0080B8  3A0006     BRA NZ, 0x80C6
0080BA  877671     MOV 0xEECE, W1
0080BC  8081F4     MOV snare_ptr, W4
0080BE  520F81     SUB W4, W1, [W15]
0080C0  3A0002     BRA NZ, 0x80C6
66:                        snare_playing=FALSE;
0080C2  EF703C     CLR.B snare_playing
67:                        snare_ptr=0;
0080C4  EF303E     CLR snare_ptr
68:                    }
69:                    
70:                    
71:                    //VOLUME CONTROL
72:                    
73:                    if(pots[2]==0x0007)
0080C6  82F3D4     MOV 0x5E7A, W4
0080C8  520FE7     SUB W4, #0x7, [W15]
0080CA  320007     BRA Z, 0x80DA
74:                        sample=0;
0080DA  EB0000     CLR W0
75:                    else if(pots[2]>=0x7FF7);
0080CC  27FF61     MOV #0x7FF6, W1
0080CE  520F81     SUB W4, W1, [W15]
0080D0  3C0005     BRA GT, 0x80DC
76:                    else{
77:                        result1 =__builtin_mpy(sample,pots[2], NULL, NULL, 0, NULL, NULL, 0);
0080D2  780280     MOV W0, W5
0080D4  C00113     MPY W4*W5, A
78:                        sample=__builtin_sac(result1, 0);
0080D6  CC0000     SAC A, W0
0080D8  370001     BRA 0x80DC
79:                    }
80:                    
81:                    if (TEST_SIN==TRUE){
0080DC  2100C1     MOV #0x100C, W1
0080DE  784091     MOV.B [W1], W1
0080E0  40CFE1     ADD.B W1, #0x1, [W15]
0080E2  3A000B     BRA NZ, 0x80FA
82:                        i++;
0080E4  EC1028     INC i, WREG
0080E6  888140     MOV W0, i
83:                        if(i==1024)
0080E8  204001     MOV #0x400, W1
0080EA  500F81     SUB W0, W1, [W15]
0080EC  3A0001     BRA NZ, 0x80F0
84:                            i=0;
0080EE  EF3028     CLR i
85:                        return sintab[i];
0080F0  808140     MOV i, W0
0080F2  400000     ADD W0, W0, W0
0080F4  2EED21     MOV #0xEED2, W1
0080F6  408000     ADD W1, W0, W0
0080F8  780010     MOV [W0], W0
86:                    }
87:                    else 
88:                        return sample;
89:                    
90:                }
0080FA  F90026     POP ACCAU
0080FC  F90024     POP ACCAH
0080FE  F90022     POP ACCA
008100  060000     RETURN
91:                
92:                fractional fx(fractional sample){
008102  F80022     PUSH ACCA
008104  F80024     PUSH ACCAH
008106  F80026     PUSH ACCAU
008108  F80028     PUSH ACCB
00810A  F8002A     PUSH ACCBH
00810C  F8002C     PUSH ACCBU
93:                    volatile register int result1 asm("A");
94:                    volatile register int result2 asm("B");
95:                    static fractional delayed_sample;
96:                    static fractional trem_mod;
97:                    if(tremelo==TRUE){                                                          //TREMELO//
00810E  2100D1     MOV #0x100D, W1
008110  784091     MOV.B [W1], W1
008112  40CFE1     ADD.B W1, #0x1, [W15]
008114  3A0027     BRA NZ, 0x8164
98:                        if (trem_var<=pots[3]){
008116  808101     MOV trem_var, W1
008118  82F3E2     MOV 0x5E7C, W2
00811A  510F81     SUB W2, W1, [W15]
00811C  39000F     BRA NC, 0x813C
99:                            trem_var++;
00811E  E80081     INC W1, W1
008120  888101     MOV W1, trem_var
100:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
008122  8080E1     MOV tremelo_ptr, W1
008124  408081     ADD W1, W1, W1
008126  2EED22     MOV #0xEED2, W2
008128  410081     ADD W2, W1, W1
00812A  780291     MOV [W1], W5
00812C  808274     MOV 0x104E, W4
00812E  C00113     MPY W4*W5, A
101:                           trem_mod=__builtin_sac(result1, 0);
008130  CC0004     SAC A, W4
008132  888124     MOV W4, trem_mod
102:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
008134  780280     MOV W0, W5
008136  C08113     MPY W4*W5, B
103:                           sample=__builtin_sac(result2, 0);
008138  CC8000     SAC B, W0
00813A  370014     BRA 0x8164
104:                       }
105:                       else{
106:                           trem_var=0;
00813C  EF3020     CLR trem_var
107:                           if(tremelo_ptr==1024)
00813E  204001     MOV #0x400, W1
008140  8080E2     MOV tremelo_ptr, W2
008142  510F81     SUB W2, W1, [W15]
008144  3A0001     BRA NZ, 0x8148
108:                               tremelo_ptr=0;
008146  EF301C     CLR tremelo_ptr
109:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
008148  8080E1     MOV tremelo_ptr, W1
00814A  408101     ADD W1, W1, W2
00814C  2EED23     MOV #0xEED2, W3
00814E  418102     ADD W3, W2, W2
008150  780292     MOV [W2], W5
008152  E80081     INC W1, W1
008154  8880E1     MOV W1, tremelo_ptr
008156  808274     MOV 0x104E, W4
008158  C00113     MPY W4*W5, A
110:                           trem_mod=__builtin_sac(result1, 0);
00815A  CC0004     SAC A, W4
00815C  888124     MOV W4, trem_mod
111:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
00815E  780280     MOV W0, W5
008160  C08113     MPY W4*W5, B
112:                           sample=__builtin_sac(result2, 0);
008162  CC8000     SAC B, W0
113:                       }
114:                   }
115:                   if(looper==TRUE){                                                           //LOOPER// 
008164  2100E1     MOV #0x100E, W1
008166  784091     MOV.B [W1], W1
008168  40CFE1     ADD.B W1, #0x1, [W15]
00816A  3A0019     BRA NZ, 0x819E
116:                       if(loop_lim>=LOOP_BUF_SIZE)
00816C  2270F0     MOV #0x270F, W0
00816E  E3101A     CP loop_lim
008170  360002     BRA LEU, 0x8176
117:                           loop_lim=LOOP_BUF_SIZE;
008172  E80000     INC W0, W0
008174  8880D0     MOV W0, loop_lim
118:                       if(loop_ptr<loop_lim){
008176  8080D0     MOV loop_lim, W0
008178  E31018     CP loop_ptr
00817A  310008     BRA C, 0x818C
119:                           sample = (loop[loop_ptr++]);
00817C  8080C1     MOV loop_ptr, W1
00817E  408001     ADD W1, W1, W0
008180  210562     MOV #0x1056, W2
008182  410000     ADD W2, W0, W0
008184  780010     MOV [W0], W0
008186  E80081     INC W1, W1
008188  8880C1     MOV W1, loop_ptr
00818A  37001D     BRA 0x81C6
120:                       }
121:                       else {
122:                           loop_ptr=0;
00818C  EF3018     CLR loop_ptr
123:                           sample = (loop[loop_ptr++]);
00818E  8080C1     MOV loop_ptr, W1
008190  408001     ADD W1, W1, W0
008192  210562     MOV #0x1056, W2
008194  410000     ADD W2, W0, W0
008196  780010     MOV [W0], W0
008198  E80081     INC W1, W1
00819A  8880C1     MOV W1, loop_ptr
00819C  370014     BRA 0x81C6
124:                       }
125:                   }                                                                           
126:                   else {                                                                      //buffer
127:                       if(loop_ptr<LOOP_BUF_SIZE)
00819E  2270F1     MOV #0x270F, W1
0081A0  8080C2     MOV loop_ptr, W2
0081A2  510F81     SUB W2, W1, [W15]
0081A4  3E0008     BRA GTU, 0x81B6
128:                           loop[loop_ptr++]=sample;
0081A6  8080C1     MOV loop_ptr, W1
0081A8  408101     ADD W1, W1, W2
0081AA  210563     MOV #0x1056, W3
0081AC  418102     ADD W3, W2, W2
0081AE  780900     MOV W0, [W2]
0081B0  E80081     INC W1, W1
0081B2  8880C1     MOV W1, loop_ptr
0081B4  370008     BRA 0x81C6
129:                       else {
130:                           loop_ptr=0;
0081B6  EF3018     CLR loop_ptr
131:                           loop[loop_ptr++]=sample;
0081B8  8080C1     MOV loop_ptr, W1
0081BA  408101     ADD W1, W1, W2
0081BC  210563     MOV #0x1056, W3
0081BE  418102     ADD W3, W2, W2
0081C0  780900     MOV W0, [W2]
0081C2  E80081     INC W1, W1
0081C4  8880C1     MOV W1, loop_ptr
132:                       }
133:                   }
134:                   
135:                                                                                               //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
136:                   if(lpf==TRUE){
0081C6  2100F1     MOV #0x100F, W1
0081C8  784091     MOV.B [W1], W1
0081CA  40CFE1     ADD.B W1, #0x1, [W15]
0081CC  3A0008     BRA NZ, 0x81DE
137:                       result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
0081CE  808254     MOV divtestb, W4
0081D0  780280     MOV W0, W5
0081D2  C08113     MPY W4*W5, B
138:                       result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
0081D4  808264     MOV 0x104C, W4
0081D6  808135     MOV delayed_sample, W5
0081D8  C08112     MAC W4*W5, B
139:                       delayed_sample=__builtin_sac(result2, 0);
0081DA  CC8000     SAC B, W0
0081DC  888130     MOV W0, delayed_sample
140:                       sample=delayed_sample;
141:                   }
142:                   return sample;
143:               }
0081DE  F9002C     POP ACCBU
0081E0  F9002A     POP ACCBH
0081E2  F90028     POP ACCB
0081E4  F90026     POP ACCAU
0081E6  F90024     POP ACCAH
0081E8  F90022     POP ACCA
0081EA  060000     RETURN
144:               
145:               //test
