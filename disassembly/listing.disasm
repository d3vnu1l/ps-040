Disassembly Listing for sampler_0.49.2
Generated From:
C:/Users/ryan/Documents/seniorproject/ps-040/dist/default/production/ps-040.production.elf
Jan 18, 2018 9:48:57 PM

---  C:/Users/ryan/Documents/seniorproject/ps-040/utilitites.c  -----------------------------------------
1:                 #include "utilities.h"
2:                 #include <xc.h>
3:                 #include <p33EP512GM310.h>
4:                 #include <libpic30.h>
5:                 #include <dsp.h>
6:                 #include <stdio.h>
7:                 #include <stdlib.h>
8:                 #include <math.h>
9:                 #include "common.h"
10:                #include "sounds.h"
11:                #include "audio.h"
12:                #include "plcd.h"
13:                
14:                #include "devInits.h"
15:                
16:                
17:                //CONTROL VARIABLES//
18:                extern unsigned char pad[8];
19:                extern fractional pots[4];
20:                extern fractional pots_scaled[4];
21:                extern unsigned char UART_ON; 
22:                
23:                //STATUS VARIABLES//
24:                extern unsigned char hard_clipped;
25:                extern unsigned char UART_EN;
26:                extern unsigned int cycle;
27:                
28:                extern fractional sampin;
29:                extern fractional sampout;
30:                
31:                
32:                //FX FLAGS & VARS
33:                extern unsigned char tremelo, looper, lpf;
34:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
35:                extern unsigned int loop_lim;
36:                extern fractional lpf_alpha, lpf_inv_alpha;
37:                extern fractional tremelo_depth;
38:                extern unsigned char kick_playing, snare_playing;   
39:                
40:                void scanMatrix(void){
41:                    static unsigned char pad_last[17]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
42:                    int portrdG, portrdD, portrdF;
43:                    //
44:                    portrdG = PORTG;
0077FC  807310     MOV PORTG, W0
45:                    portrdD = PORTD;
0077FE  807191     MOV PORTD, W1
46:                    portrdF = PORTF;
007800  807292     MOV PORTF, W2
47:                    
48:                   
49:                    pad[0]=(PORTG)&1;
007802  807314     MOV PORTG, W4
007804  269883     MOV #0x6988, W3
007806  6249E1     AND.B W4, #0x1, [W3]
50:                    pad[1]=(PORTG>>1)&1;
007808  807314     MOV PORTG, W4
00780A  D10204     LSR W4, W4
00780C  E80183     INC W3, W3
00780E  6249E1     AND.B W4, #0x1, [W3]
51:                    pad[2]=(PORTG>>2)&1;
007810  807314     MOV PORTG, W4
007812  DE2242     LSR W4, #2, W4
007814  E80183     INC W3, W3
007816  6249E1     AND.B W4, #0x1, [W3]
52:                    pad[3]=(portrdG>>3)&1;
007818  DE8243     ASR W0, #3, W4
00781A  E80183     INC W3, W3
00781C  6249E1     AND.B W4, #0x1, [W3]
53:                    pad[11]=(portrdG>>11)&1;
00781E  DE824B     ASR W0, #11, W4
007820  4181E8     ADD W3, #0x8, W3
007822  6249E1     AND.B W4, #0x1, [W3]
54:                    pad[12]=(portrdG>>12)&1;
007824  DE824C     ASR W0, #12, W4
007826  E80183     INC W3, W3
007828  6249E1     AND.B W4, #0x1, [W3]
55:                    pad[13]=(portrdG>>13)&1;
00782A  DE824D     ASR W0, #13, W4
00782C  E80183     INC W3, W3
00782E  6249E1     AND.B W4, #0x1, [W3]
56:                    pad[14]=(portrdG>>14)&1;
007830  DE824E     ASR W0, #14, W4
007832  E80183     INC W3, W3
007834  6249E1     AND.B W4, #0x1, [W3]
57:                    pad[15]=(portrdG>>15)&1;
007836  DE004F     LSR W0, #15, W0
007838  E80183     INC W3, W3
00783A  784980     MOV.B W0, [W3]
58:                    
59:                    pad[4]=(portrdF>>4)&1;
00783C  DE91C4     ASR W2, #4, W3
00783E  2698C0     MOV #0x698C, W0
007840  61C861     AND.B W3, #0x1, [W0]
60:                    pad[5]=(portrdF>>5)&1;
007842  DE91C5     ASR W2, #5, W3
007844  E80000     INC W0, W0
007846  61C861     AND.B W3, #0x1, [W0]
61:                    pad[6]=(portrdF>>6)&1;
007848  DE91C6     ASR W2, #6, W3
00784A  E80000     INC W0, W0
00784C  61C861     AND.B W3, #0x1, [W0]
62:                    pad[16]=(portrdF>>7)&1;
00784E  DE9147     ASR W2, #7, W2
007850  40006A     ADD W0, #0xA, W0
007852  614861     AND.B W2, #0x1, [W0]
63:                    
64:                    pad[7]=(portrdD>>1)&1;
007854  D18001     ASR W1, W0
007856  604061     AND.B W0, #0x1, W0
007858  2698F2     MOV #0x698F, W2
00785A  784900     MOV.B W0, [W2]
65:                    pad[8]=(portrdD>>2)&1;
00785C  DE89C2     ASR W1, #2, W3
00785E  E80102     INC W2, W2
007860  61C961     AND.B W3, #0x1, [W2]
66:                    pad[9]=(portrdD>>3)&1;
007862  DE89C3     ASR W1, #3, W3
007864  E80102     INC W2, W2
007866  61C961     AND.B W3, #0x1, [W2]
67:                    pad[10]=(portrdD>>4)&1;
007868  DE88C4     ASR W1, #4, W1
00786A  E80102     INC W2, W2
00786C  60C961     AND.B W1, #0x1, [W2]
68:                    
69:                
70:                    
71:                   
72:                    
73:                    
74:                    if(pad[7]==0&&pad_last[7]==1){                                              //TREMELO CONTROL
00786E  E00400     CP0.B W0
007870  3A0013     BRA NZ, 0x7898
007872  269A11     MOV #0x69A1, W1
007874  B3C012     MOV.B #0x1, W2
007876  114F91     SUBR.B W2, [W1], [W15]
007878  3A000F     BRA NZ, 0x7898
75:                        pad_last[7]=0;
00787A  780001     MOV W1, W0
00787C  EB4800     CLR.B [W0]
76:                        if(tremelo==FALSE)
00787E  E2501F     CP0.B tremelo
007880  3A0002     BRA NZ, 0x7886
77:                            tremelo=TRUE;
007882  EFF01F     SETM.B tremelo
007884  370001     BRA 0x7888
78:                        else tremelo=FALSE;
007886  EF701F     CLR.B tremelo
79:                        TREMELO_LED=tremelo;
007888  BFD01F     MOV.B tremelo, WREG
00788A  DD004F     SL W0, #15, W0
00788C  27FFF1     MOV #0x7FFF, W1
00788E  8071A2     MOV LATD, W2
007890  608082     AND W1, W2, W1
007892  700081     IOR W0, W1, W1
007894  8871A1     MOV W1, LATD
007896  370002     BRA 0x789C
80:                    }
81:                    else{
82:                        pad_last[7]=pad[7];
007898  269A11     MOV #0x69A1, W1
00789A  784880     MOV.B W0, [W1]
83:                    }
84:                    
85:                    if(pad[4]==0){                                                              //LOOPER CONTROL
00789C  2698C0     MOV #0x698C, W0
00789E  E00410     CP0.B [W0]
0078A0  3A0003     BRA NZ, 0x78A8
86:                        looper=TRUE;
0078A2  EFF020     SETM.B looper
87:                        YLED=looper;
0078A4  A82E44     BSET LATE, #1
0078A6  370002     BRA 0x78AC
88:                    }
89:                    else {
90:                        looper=FALSE;
0078A8  EF7020     CLR.B looper
91:                        YLED=looper;
0078AA  A92E44     BCLR LATE, #1
92:                    }
93:                   
94:                    if(pad[15]==0&&pad_last[15]==1){                                              //LPF CONTROL
0078AC  269970     MOV #0x6997, W0
0078AE  784010     MOV.B [W0], W0
0078B0  E00400     CP0.B W0
0078B2  3A000C     BRA NZ, 0x78CC
0078B4  269A91     MOV #0x69A9, W1
0078B6  B3C012     MOV.B #0x1, W2
0078B8  114F91     SUBR.B W2, [W1], [W15]
0078BA  3A0008     BRA NZ, 0x78CC
95:                        pad_last[15]=0;
0078BC  780001     MOV W1, W0
0078BE  EB4800     CLR.B [W0]
96:                        if(lpf==FALSE)
0078C0  E25021     CP0.B lpf
0078C2  3A0002     BRA NZ, 0x78C8
97:                            lpf=TRUE;
0078C4  EFF021     SETM.B lpf
0078C6  370004     BRA 0x78D0
98:                        else lpf=FALSE;
0078C8  EF7021     CLR.B lpf
0078CA  370002     BRA 0x78D0
99:                    }
100:                   else{
101:                       pad_last[15]=pad[15];
0078CC  269A91     MOV #0x69A9, W1
0078CE  784880     MOV.B W0, [W1]
102:                   }
103:                   
104:                   
105:                   /* SAMPLE TRIGGERS */
106:                   if(pad[15]==0&&kick_playing==FALSE){                                         //kick
0078D0  269970     MOV #0x6997, W0
0078D2  E00410     CP0.B [W0]
0078D4  3A0003     BRA NZ, 0x78DC
0078D6  E2503E     CP0.B kick_playing
0078D8  3A0001     BRA NZ, 0x78DC
107:                       kick_playing=TRUE;
0078DA  EFF03E     SETM.B kick_playing
108:                   }
109:                   /*
110:                   if(pad[2]==0&&hat_playing==FALSE){                                          //hat
111:                       hat_playing=TRUE;
112:                   }
113:                   */
114:                   if(pad[2]==0&&snare_playing==FALSE){                                        //snare
0078DC  2698A0     MOV #0x698A, W0
0078DE  E00410     CP0.B [W0]
0078E0  3A0003     BRA NZ, 0x78E8
0078E2  E25042     CP0.B snare_playing
0078E4  3A0001     BRA NZ, 0x78E8
115:                       snare_playing=TRUE;
0078E6  EFF042     SETM.B snare_playing
116:                   }
117:                   
118:                   //lpf=TRUE;
119:                   
120:                   
121:               }
0078E8  060000     RETURN
122:               
123:               void readPots(void){
124:                   volatile register int scaled asm("A");
125:                   
126:                   AD1CON1bits.SAMP = 0;      // start sampling
0078EA  A92320     BCLR AD1CON1, #1
127:                   while (!_AD1IF);           //wait for conversions to complete
0078EC  220001     MOV #0x2000, W1
0078EE  804002     MOV IFS0, W2
0078F0  608002     AND W1, W2, W0
0078F2  32FFFD     BRA Z, 0x78EE
128:                   _AD1IF = 0;                //clear status bit
0078F4  A9A801     BCLR 0x801, #5
129:                   pots[0]=(ADC1BUF0>>1)+0x1F;
0078F6  210000     MOV #0x1000, W0
0078F8  801801     MOV ADC1BUF0, W1
0078FA  D10081     LSR W1, W1
0078FC  40887F     ADD W1, #0x1F, [W0]
130:                   pots[1]=(ADC1BUF1>>1)+0x1F;
0078FE  801811     MOV ADC1BUF1, W1
007900  D10081     LSR W1, W1
007902  4080FF     ADD W1, #0x1F, W1
007904  980011     MOV W1, [W0+2]
131:                   pots[2]=(ADC1BUF2>>1)+0x1F;
007906  801822     MOV ADC1BUF2, W2
007908  D10102     LSR W2, W2
00790A  41017F     ADD W2, #0x1F, W2
00790C  980022     MOV W2, [W0+4]
132:                   pots[3]=(ADC1BUF3>>1)+0x1F;
00790E  801832     MOV ADC1BUF3, W2
007910  D10102     LSR W2, W2
007912  41017F     ADD W2, #0x1F, W2
007914  980032     MOV W2, [W0+6]
133:                   //pot scaling 
134:                   
135:                   if(pots[1]<=2048)
007916  208000     MOV #0x800, W0
007918  508F80     SUB W1, W0, [W15]
00791A  3C0003     BRA GT, 0x7922
136:                       pots_scaled[1]=8;
00791C  200080     MOV #0x8, W0
00791E  888050     MOV W0, 0x100A
007920  370056     BRA 0x79CE
137:                   else if(pots[1]<=4096)
007922  210000     MOV #0x1000, W0
007924  508F80     SUB W1, W0, [W15]
007926  3C0003     BRA GT, 0x792E
138:                       pots_scaled[1]=12;
007928  2000C0     MOV #0xC, W0
00792A  888050     MOV W0, 0x100A
00792C  370050     BRA 0x79CE
139:                   else if(pots[1]<=6144)
00792E  218000     MOV #0x1800, W0
007930  508F80     SUB W1, W0, [W15]
007932  3C0003     BRA GT, 0x793A
140:                       pots_scaled[1]=14;
007934  2000E0     MOV #0xE, W0
007936  888050     MOV W0, 0x100A
007938  37004A     BRA 0x79CE
141:                   else if(pots[1]<=8192)
00793A  220000     MOV #0x2000, W0
00793C  508F80     SUB W1, W0, [W15]
00793E  3C0003     BRA GT, 0x7946
142:                       pots_scaled[1]=16;
007940  200100     MOV #0x10, W0
007942  888050     MOV W0, 0x100A
007944  370044     BRA 0x79CE
143:                   else if(pots[1]<=10240)
007946  228000     MOV #0x2800, W0
007948  508F80     SUB W1, W0, [W15]
00794A  3C0003     BRA GT, 0x7952
144:                       pots_scaled[1]=19;
00794C  200130     MOV #0x13, W0
00794E  888050     MOV W0, 0x100A
007950  37003E     BRA 0x79CE
145:                   else if(pots[1]<=12288)
007952  230000     MOV #0x3000, W0
007954  508F80     SUB W1, W0, [W15]
007956  3C0003     BRA GT, 0x795E
146:                       pots_scaled[1]=23;
007958  200170     MOV #0x17, W0
00795A  888050     MOV W0, 0x100A
00795C  370038     BRA 0x79CE
147:                   else if(pots[1]<=14336)
00795E  238000     MOV #0x3800, W0
007960  508F80     SUB W1, W0, [W15]
007962  3C0003     BRA GT, 0x796A
148:                       pots_scaled[1]=28;
007964  2001C0     MOV #0x1C, W0
007966  888050     MOV W0, 0x100A
007968  370032     BRA 0x79CE
149:                   else if(pots[1]<=16384)
00796A  240000     MOV #0x4000, W0
00796C  508F80     SUB W1, W0, [W15]
00796E  3C0003     BRA GT, 0x7976
150:                       pots_scaled[1]=32;
007970  200200     MOV #0x20, W0
007972  888050     MOV W0, 0x100A
007974  37002C     BRA 0x79CE
151:                   else if(pots[1]<=18432)
007976  248000     MOV #0x4800, W0
007978  508F80     SUB W1, W0, [W15]
00797A  3C0003     BRA GT, 0x7982
152:                       pots_scaled[1]=36;
00797C  200240     MOV #0x24, W0
00797E  888050     MOV W0, 0x100A
007980  370026     BRA 0x79CE
153:                   else if(pots[1]<=20480)
007982  250000     MOV #0x5000, W0
007984  508F80     SUB W1, W0, [W15]
007986  3C0003     BRA GT, 0x798E
154:                       pots_scaled[2]=40;
007988  200280     MOV #0x28, W0
00798A  888060     MOV W0, 0x100C
00798C  370020     BRA 0x79CE
155:                   else if(pots[1]<=22528)
00798E  258000     MOV #0x5800, W0
007990  508F80     SUB W1, W0, [W15]
007992  3C0003     BRA GT, 0x799A
156:                       pots_scaled[2]=44;
007994  2002C0     MOV #0x2C, W0
007996  888060     MOV W0, 0x100C
007998  37001A     BRA 0x79CE
157:                   else if(pots[1]<=24576)
00799A  260000     MOV #0x6000, W0
00799C  508F80     SUB W1, W0, [W15]
00799E  3C0003     BRA GT, 0x79A6
158:                       pots_scaled[1]=48;
0079A0  200300     MOV #0x30, W0
0079A2  888050     MOV W0, 0x100A
0079A4  370014     BRA 0x79CE
159:                   else if(pots[1]<=26624)
0079A6  268000     MOV #0x6800, W0
0079A8  508F80     SUB W1, W0, [W15]
0079AA  3C0003     BRA GT, 0x79B2
160:                       pots_scaled[1]=52;
0079AC  200340     MOV #0x34, W0
0079AE  888050     MOV W0, 0x100A
0079B0  37000E     BRA 0x79CE
161:                   else if(pots[1]<=28672)
0079B2  270000     MOV #0x7000, W0
0079B4  508F80     SUB W1, W0, [W15]
0079B6  3C0003     BRA GT, 0x79BE
162:                       pots_scaled[1]=56;
0079B8  200380     MOV #0x38, W0
0079BA  888050     MOV W0, 0x100A
0079BC  370008     BRA 0x79CE
163:                   else if(pots[1]<=30720)
0079BE  278000     MOV #0x7800, W0
0079C0  508F80     SUB W1, W0, [W15]
0079C2  3C0003     BRA GT, 0x79CA
164:                       pots_scaled[1]=60;
0079C4  2003C0     MOV #0x3C, W0
0079C6  888050     MOV W0, 0x100A
0079C8  370002     BRA 0x79CE
165:                   else if(pots[1]<=32768)
166:                       pots_scaled[1]=64;
0079CA  200400     MOV #0x40, W0
0079CC  888050     MOV W0, 0x100A
167:                   else if(pots[1]<=34816)
168:                       pots_scaled[1]=68;
169:                   else 
170:                       pots_scaled[1]=72;
171:                    
172:                                                                                                
173:                   loop_lim=154*pots_scaled[1];                                                //LOOPER CONTROL
0079CE  2009A0     MOV #0x9A, W0
0079D0  808051     MOV 0x100A, W1
0079D2  B98880     MULW.SS W1, W0, W0
0079D4  888120     MOV W0, loop_lim
174:                   if(pots[1]>=310){                                                           //LPF CONTROL
0079D6  808010     MOV 0x1002, W0
0079D8  201351     MOV #0x135, W1
0079DA  500F81     SUB W0, W1, [W15]
0079DC  340004     BRA LE, 0x79E6
175:                       lpf_alpha=pots[1];
0079DE  888230     MOV W0, 0x1046
176:                       lpf_inv_alpha=(32767-lpf_alpha); 
0079E0  27FFF1     MOV #0x7FFF, W1
0079E2  508000     SUB W1, W0, W0
0079E4  888240     MOV W0, 0x1048
177:                   }
178:                   //tremelo_depth=pots[4];
179:                           
180:               }
0079E6  060000     RETURN
181:               
182:               void display(void){
183:                   lcdDrawPads(16);
0079E8  B3C100     MOV.B #0x10, W0
0079EA  07FCDF     RCALL lcdDrawPads
184:                   
185:                  lcdSetCursor(2,2);
0079EC  B3C021     MOV.B #0x2, W1
0079EE  784001     MOV.B W1, W0
0079F0  07FC10     RCALL lcdSetCursor
186:                  lcdWriteWord(sampin);
0079F2  8081A0     MOV sampin, W0
0079F4  07FC9E     RCALL lcdWriteWord
187:                  lcdSetCursor(10,2);
0079F6  B3C021     MOV.B #0x2, W1
0079F8  B3C0A0     MOV.B #0xA, W0
0079FA  07FC0B     RCALL lcdSetCursor
188:                  lcdWriteWord(sampout);
0079FC  8081B0     MOV sampout, W0
0079FE  07FC99     RCALL lcdWriteWord
189:                   lcdSetCursor(4,3);
007A00  B3C031     MOV.B #0x3, W1
007A02  B3C040     MOV.B #0x4, W0
007A04  07FC06     RCALL lcdSetCursor
190:                   if(pad[14])lcdWriteWord(cycle);
007A06  269960     MOV #0x6996, W0
007A08  E00410     CP0.B [W0]
007A0A  320002     BRA Z, 0x7A10
007A0C  8080C0     MOV cycle, W0
007A0E  07FC91     RCALL lcdWriteWord
191:                
192:                  
193:                  if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
007A10  BFD01A     MOV.B hard_clipped, WREG
007A12  404FE1     ADD.B W0, #0x1, [W15]
007A14  3A0003     BRA NZ, 0x7A1C
194:                       HARD_CLIP_LED=1;
007A16  A82E24     BSET LATC, #1
195:                       hard_clipped=FALSE;
007A18  EF701A     CLR.B hard_clipped
007A1A  370001     BRA 0x7A1E
196:                   }  else HARD_CLIP_LED=0;
007A1C  A92E24     BCLR LATC, #1
197:                   
198:                  if(UART_ON==TRUE){
007A1E  BFD01D     MOV.B UART_ON, WREG
007A20  404FE1     ADD.B W0, #0x1, [W15]
007A22  3A000A     BRA NZ, 0x7A38
199:                       //IC1CON2bits.TRIGSTAT = ~pad[4]; 
200:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
201:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
202:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
203:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
007A24  210000     MOV #0x1000, W0
007A26  9000A0     MOV [W0+4], W1
007A28  781F81     MOV W1, [W15++]
007A2A  900090     MOV [W0+2], W1
007A2C  781F81     MOV W1, [W15++]
007A2E  781F90     MOV [W0], [W15++]
007A30  2F1D00     MOV #0xF1D0, W0
007A32  781F80     MOV W0, [W15++]
007A34  07C567     RCALL __printf_cdnopuxX
007A36  5787E8     SUB W15, #0x8, W15
204:                       //printf("%d\r\n", sample);  //check input ADC
205:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
206:                   }
207:                  
208:                  SLED=~SLED;
007A38  8072A0     MOV LATF, W0
007A3A  EA8000     COM W0, W0
007A3C  600061     AND W0, #0x1, W0
007A3E  8072A1     MOV LATF, W1
007A40  A10001     BCLR W1, #0
007A42  700081     IOR W0, W1, W1
007A44  8872A1     MOV W1, LATF
209:               }
007A46  060000     RETURN
210:               
211:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
212:                   /* This procedure loops back the received data to the*/
213:                   /* the codec output. The user application could process*/
214:                   /* this data as per application requirements.*/
215:                   int index;
216:                   for(index = 0;index < STREAMBUF;index ++)
007A48  EB0100     CLR W2
007A4A  200403     MOV #0x40, W3
007A4E  E80102     INC W2, W2
007A50  510F83     SUB W2, W3, [W15]
007A52  3AFFFC     BRA NZ, 0x7A4C
217:                   {
218:                       targetBuffer[index] = sourceBuffer[index];
007A4C  7818B0     MOV [W0++], [W1++]
219:                   }
220:               }
007A54  060000     RETURN
221:               
222:               //A blocking delay function. Not very accurate but good enough.
223:               void Delay_us(unsigned int delay)
224:               {
225:                   int i;
226:                   for (i = 0; i < delay; i++)
007A56  E00000     CP0 W0
007A58  320006     BRA Z, 0x7A66
007A5A  EB0080     CLR W1
007A60  E80081     INC W1, W1
007A62  500F81     SUB W0, W1, [W15]
007A64  3EFFFB     BRA GTU, 0x7A5C
227:                   {
228:                       __asm__ volatile ("repeat #50");
007A5C  090032     REPEAT #0x32
229:                       __asm__ volatile ("nop");
007A5E  000000     NOP
230:                   }
231:               }
007A66  060000     RETURN
---  C:/Users/ryan/Documents/seniorproject/ps-040/routines.c  -------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern char pad[BUTTONS];
10:                extern fractional pots[4]; 
11:                extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
12:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
13:                extern unsigned int write_ptr, rw, frameReady;
14:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
15:                
16:                //STATUS VARIABLES
17:                extern unsigned char t1flag, t2flag;
18:                
19:                //misc.
20:                volatile fractional sampin=0;
21:                volatile fractional sampout=0;
22:                volatile int rxBufferIndicator = 0;
23:                unsigned int write_ptr=STREAMBUF;
24:                fractional *ping, *pong;
25:                
26:                //Description: This interrupt toggles status led, runs UART1 and handles display
27:                //Dependencies: initUART1();
28:                //Frequency: 60
29:                void __attribute__ ((interrupt, auto_psv)) _T1Interrupt(void){
000306  F80032     PUSH DSRPAG
000308  F80034     PUSH DSWPAG
00030A  781F88     MOV W8, [W15++]
00030C  200018     MOV #0x1, W8
00030E  8801A8     MOV W8, DSWPAG
000310  202008     MOV #0x200, W8
000312  880198     MOV W8, DSRPAG
000314  000000     NOP
000316  78044F     MOV [--W15], W8
30:                    t1flag=TRUE;
000318  EFF01B     SETM.B t1flag
31:                    IFS0bits.T1IF = 0;              //clear interrupt flag & restart
00031A  A96800     BCLR IFS0, #3
32:                }
00031C  F90034     POP DSWPAG
00031E  F90032     POP DSRPAG
000320  064000     RETFIE
33:                
34:                //Description: This interrupt handles polling button input
35:                //Dependencies: initADC1(); 
36:                //Frequency: 512Hz
37:                void __attribute__ ((interrupt, auto_psv)) _T2Interrupt(void){
000322  F80032     PUSH DSRPAG
000324  F80034     PUSH DSWPAG
000326  781F88     MOV W8, [W15++]
000328  200018     MOV #0x1, W8
00032A  8801A8     MOV W8, DSWPAG
00032C  202008     MOV #0x200, W8
00032E  880198     MOV W8, DSRPAG
000330  000000     NOP
000332  78044F     MOV [--W15], W8
38:                    t2flag=TRUE;
000334  EFF01C     SETM.B t2flag
39:                    IFS0bits.T2IF = 0;              //clear interrupt flag & restart
000336  A9E800     BCLR IFS0, #7
40:                }
000338  F90034     POP DSWPAG
00033A  F90032     POP DSRPAG
00033C  064000     RETFIE
41:                
42:                //Description: This interrupt triggers at the completion of DCI output
43:                //Dependancies: initSPI2(); 
44:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
00033E  BE9F80     MOV.D W0, [W15++]
000340  781F82     MOV W2, [W15++]
000342  F80032     PUSH DSRPAG
000344  F80034     PUSH DSWPAG
000346  200010     MOV #0x1, W0
000348  8801A0     MOV W0, DSWPAG
00034A  202000     MOV #0x200, W0
00034C  880190     MOV W0, DSRPAG
00034E  000000     NOP
45:                    TXBUF0=TXBUF1=sampout;                                    //output buffered sample to DAC
000350  F81036     PUSH sampout
000352  F9029A     POP TXBUF1
000354  F8029A     PUSH TXBUF1
000356  F90298     POP TXBUF0
46:                    sampin=RXBUF1;
000358  F80292     PUSH RXBUF1
00035A  F91034     POP sampin
47:                    __builtin_btg(&sampin, 15);                             //convert to Q1.15 compatible format
00035C  210340     MOV #0x1034, W0
00035E  A2F010     BTG [W0], #15
48:                    int trash=RXBUF0;
000360  801480     MOV RXBUF0, W0
49:                      
50:                    
51:                    if(write_ptr--==0){                       //reset pointer when out of bounds
000362  808270     MOV 0x104E, W0
000364  E90080     DEC W0, W1
000366  888271     MOV W1, 0x104E
000368  E00000     CP0 W0
00036A  3A0005     BRA NZ, 0x376
52:                        write_ptr=STREAMBUF-1;
00036C  2003F0     MOV #0x3F, W0
00036E  888270     MOV W0, 0x104E
53:                        __builtin_btg(&rw,0);
000370  AA1012     BTG rw, #0
54:                        frameReady=1;
000372  200010     MOV #0x1, W0
000374  8880A0     MOV W0, frameReady
55:                    }
56:                   
57:                    if(rw){
000376  E21012     CP0 rw
000378  32000B     BRA Z, 0x390
58:                        streamB[write_ptr]=sampin;
00037A  808270     MOV 0x104E, W0
00037C  400000     ADD W0, W0, W0
00037E  267F41     MOV #0x67F4, W1
000380  408080     ADD W1, W0, W1
000382  8081A2     MOV sampin, W2
000384  780882     MOV W2, [W1]
59:                        sampout=outputA[write_ptr]; 
000386  266741     MOV #0x6674, W1
000388  408000     ADD W1, W0, W0
00038A  780010     MOV [W0], W0
00038C  8881B0     MOV W0, sampout
00038E  37000A     BRA 0x3A4
60:                    }
61:                    else {
62:                        streamA[write_ptr]=sampin; 
000390  808270     MOV 0x104E, W0
000392  400000     ADD W0, W0, W0
000394  267741     MOV #0x6774, W1
000396  408080     ADD W1, W0, W1
000398  8081A2     MOV sampin, W2
00039A  780882     MOV W2, [W1]
63:                        sampout=outputB[write_ptr];  
00039C  266F41     MOV #0x66F4, W1
00039E  408000     ADD W1, W0, W0
0003A0  780010     MOV [W0], W0
0003A2  8881B0     MOV W0, sampout
64:                    }               //get input
65:                    
66:                    IFS3bits.DCIIF=0;
0003A4  A98807     BCLR 0x807, #4
67:                }
0003A6  F90034     POP DSWPAG
0003A8  F90032     POP DSRPAG
0003AA  78014F     MOV [--W15], W2
0003AC  BE004F     MOV.D [--W15], W0
0003AE  064000     RETFIE
68:                void __attribute__ ((interrupt, auto_psv)) _IC1Interrupt(void){
0003B0  BE9F80     MOV.D W0, [W15++]
0003B2  F80032     PUSH DSRPAG
0003B4  F80034     PUSH DSWPAG
0003B6  200010     MOV #0x1, W0
0003B8  8801A0     MOV W0, DSWPAG
0003BA  202000     MOV #0x200, W0
0003BC  880190     MOV W0, DSRPAG
0003BE  000000     NOP
69:                    IFS0bits.IC1IF=0;   
0003C0  A92800     BCLR IFS0, #1
70:                    //bpm=IC1BUF;
71:                    RLED=~RLED;
0003C2  807120     MOV LATC, W0
0003C4  EA8000     COM W0, W0
0003C6  600061     AND W0, #0x1, W0
0003C8  807121     MOV LATC, W1
0003CA  A10001     BCLR W1, #0
0003CC  700081     IOR W0, W1, W1
0003CE  887121     MOV W1, LATC
72:                }
0003D0  F90034     POP DSWPAG
0003D2  F90032     POP DSRPAG
0003D4  BE004F     MOV.D [--W15], W0
0003D6  064000     RETFIE
73:                
74:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
0003D8  781F80     MOV W0, [W15++]
0003DA  F80032     PUSH DSRPAG
0003DC  F80034     PUSH DSWPAG
0003DE  200010     MOV #0x1, W0
0003E0  8801A0     MOV W0, DSWPAG
0003E2  202000     MOV #0x200, W0
0003E4  880190     MOV W0, DSRPAG
0003E6  000000     NOP
75:                    //SEG_SEL=1;
76:                    int trash=SPI3BUF;
0003E8  801540     MOV SPI3BUF, W0
77:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
0003EA  A9C2A0     BCLR SPI3STAT, #6
78:                    IFS5bits.SPI3IF=0;   
0003EC  A9680B     BCLR 0x80B, #3
79:                }
0003EE  F90034     POP DSWPAG
0003F0  F90032     POP DSRPAG
0003F2  78004F     MOV [--W15], W0
0003F4  064000     RETFIE
80:                
81:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003F6  F80036     PUSH RCOUNT
0003F8  BE9F80     MOV.D W0, [W15++]
0003FA  BE9F82     MOV.D W2, [W15++]
0003FC  BE9F84     MOV.D W4, [W15++]
0003FE  BE9F86     MOV.D W6, [W15++]
82:                    _DMA2IF = 0; /* Received one frame of data*/    
000400  A90803     BCLR 0x803, #0
83:                    
84:                    if(rxBufferIndicator == 0)
000402  E21038     CP0 rxBufferIndicator
000404  3A0004     BRA NZ, 0x40E
85:                    {
86:                         processRxData((int *)rxBufferA, (int*)txBufferA);
000406  2CF801     MOV #0xCF80, W1
000408  2CE800     MOV #0xCE80, W0
00040A  073B1E     RCALL processRxData
00040C  370003     BRA 0x414
87:                    }
88:                    else
89:                    {
90:                         processRxData((int *)rxBufferB, (int*)txBufferB);
00040E  2CF001     MOV #0xCF00, W1
000410  2CE000     MOV #0xCE00, W0
000412  073B1A     RCALL processRxData
91:                    }
92:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
000414  AA1038     BTG rxBufferIndicator, #0
93:                }
000416  BE034F     MOV.D [--W15], W6
000418  BE024F     MOV.D [--W15], W4
00041A  BE014F     MOV.D [--W15], W2
00041C  BE004F     MOV.D [--W15], W0
00041E  F90036     POP RCOUNT
000420  064000     RETFIE
94:                
95:                /*
96:                //Description: This interrupt handles polling button input
97:                //Dependencies: initADC1(); 
98:                //Frequency: 44.1kHz
99:                void __attribute__ ((interrupt, auto_psv)) _T3Interrupt(void){
100:                   SEG_SEL=0;
101:                   SPI3BUF=0x0100;
102:                   //SEG_SEL=1;
103:                   IFS0bits.T3IF = 0;              //clear flag, restart
104:               }
105:               
106:               void __attribute__ ((interrupt, auto_psv)) _SPI2Interrupt(void){
107:                   //GLED=~GLED;                                             //check half freq w/ RLED                                        //returns SS2 to idle state
108:                   SPI2STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
109:                   IFS2bits.SPI2IF = 0;                                    //reset flag & restart
110:               }
111:               //Description: This interrupt handles UART reception
112:               //Dependencies: initUART1();
113:               void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
114:                   unsigned char trash;
115:                   GLED=~GLED;
116:                   trash=U1RXREG;
117:                   printf("RECIEVED: %d\r\n", trash);
118:                   IFS0bits.U1RXIF = 0;            //clear flag, restart
119:               }
120:               
121:               //Description: This interrupt handles UART transmission
122:               //Dependencies: initUART1();
123:               void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
124:                   YLED=~YLED;
125:                   IFS0bits.U1TXIF = 0;            //clear flag, restart
126:               } 
127:                */
---  C:/Users/ryan/Documents/seniorproject/ps-040/plcd.c  -----------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                extern unsigned char TEST_SIN;
15:                extern unsigned char pad[BUTTONS];
16:                
17:                unsigned int statusReg = 0x0C;  //internal copy of pwr reg
18:                                                // 0b_0 0 0 0 - 1 D C B (display, cursor, blink)
19:                char lcdBuf[80];
20:                
21:                void lcdWrite(unsigned char data){
22:                    if(!LCD_RS_P)LCD_RS=1;
0071E6  E20E42     CP0 PORTE
0071E8  350001     BRA LT, 0x71EC
0071EA  A8EE45     BSET 0xE45, #7
23:                    if(!PMMODEbits.BUSY) PMDIN1=data; //(!skips if busy!)
0071EC  E20602     CP0 PMMODE
0071EE  350002     BRA LT, 0x71F4
0071F0  FB8000     ZE W0, W0
0071F2  883040     MOV W0, PMDIN1
24:                }
0071F4  060000     RETURN
25:                
26:                void lcdCommand(unsigned char data){
27:                    if(LCD_RS_P)LCD_RS=0;
0071F6  E20E42     CP0 PORTE
0071F8  3D0001     BRA GE, 0x71FC
0071FA  A9EE45     BCLR 0xE45, #7
28:                    if(!PMMODEbits.BUSY) PMDIN1=data; //(!skips if busy!)
0071FC  E20602     CP0 PMMODE
0071FE  350002     BRA LT, 0x7204
007200  FB8000     ZE W0, W0
007202  883040     MOV W0, PMDIN1
29:                }
007204  060000     RETURN
30:                
31:                void lcdClear(void){
32:                    lcdCommand(LCD_CLEARDISPLAY);
007206  B3C010     MOV.B #0x1, W0
007208  07FFF6     RCALL lcdCommand
33:                }
00720A  060000     RETURN
34:                
35:                void lcdReturn(void){
36:                    lcdCommand(LCD_RETURNHOME);
00720C  B3C020     MOV.B #0x2, W0
00720E  07FFF3     RCALL lcdCommand
37:                }
007210  060000     RETURN
38:                
39:                void lcdSetCursor(unsigned char col, unsigned char row) {
40:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
41:                
42:                  if (row > 3) {
43:                    row = 3;
44:                  }
45:                  lcdCommand(LCD_SETDDRAMADDR | (col + offsets[row]));
007212  50CFE3     SUB.B W1, #0x3, [W15]
007214  360001     BRA LEU, 0x7218
007216  B3C031     MOV.B #0x3, W1
007218  FB8081     ZE W1, W1
00721A  2F1CB2     MOV #0xF1CB, W2
00721C  410081     ADD W2, W1, W1
00721E  404011     ADD.B W0, [W1], W0
007220  A07400     BSET.B W0, #7
007222  07FFE9     RCALL lcdCommand
46:                  Delay_us(50);
007224  200320     MOV #0x32, W0
007226  070417     RCALL Delay_us
47:                }
007228  060000     RETURN
48:                
49:                void lcdPwr(signed int pwr){
50:                    //lcd soft power on/off, does not reset device
51:                    if(pwr)
00722A  E00000     CP0 W0
00722C  320003     BRA Z, 0x7234
52:                        statusReg&=0x04;
00722E  200040     MOV #0x4, W0
007230  B63050     AND 0x1050
007232  370001     BRA 0x7236
53:                    else __builtin_btg(&statusReg, 2);
007234  AA5050     BTG 0x1050, #2
54:                    
55:                    lcdCommand(statusReg);
007236  BFD050     MOV.B 0x1050, WREG
007238  07FFDE     RCALL lcdCommand
56:                }
00723A  060000     RETURN
57:                
58:                void lcdCursorEn(signed int pwr){
59:                    //cursor on / off
60:                    if(pwr)
00723C  E00000     CP0 W0
00723E  320003     BRA Z, 0x7246
61:                        statusReg&=0x0A;
007240  2000A0     MOV #0xA, W0
007242  B63050     AND 0x1050
007244  370001     BRA 0x7248
62:                    else __builtin_btg(&statusReg, 1);
007246  AA3050     BTG 0x1050, #1
63:                    
64:                    lcdCommand(statusReg);
007248  BFD050     MOV.B 0x1050, WREG
00724A  07FFD5     RCALL lcdCommand
65:                }
00724C  060000     RETURN
66:                
67:                void lcdCursorBlink(signed int pwr){
68:                    if(pwr)
00724E  E00000     CP0 W0
007250  320003     BRA Z, 0x7258
69:                        statusReg&=0x09;
007252  200090     MOV #0x9, W0
007254  B63050     AND 0x1050
007256  370001     BRA 0x725A
70:                    else __builtin_btg(&statusReg, 0);
007258  AA1050     BTG 0x1050, #0
71:                    
72:                    lcdCommand(statusReg);
00725A  BFD050     MOV.B 0x1050, WREG
00725C  07FFCC     RCALL lcdCommand
73:                }
00725E  060000     RETURN
74:                
75:                //BLOCKING!
76:                void lcdWriteString(char *string) {
007260  BE9F88     MOV.D W8, [W15++]
007262  780400     MOV W0, W8
77:                    char *it = string;
78:                  for (; *it; it++) {
007264  784018     MOV.B [W8], W0
007266  E00400     CP0.B W0
007268  320007     BRA Z, 0x7278
007272  784058     MOV.B [++W8], W0
007274  E00400     CP0.B W0
007276  3AFFFA     BRA NZ, 0x726C
79:                    lcdWrite(*it);
00726C  07FFBC     RCALL lcdWrite
80:                    Delay_us(50);
00726A  200329     MOV #0x32, W9
00726E  780009     MOV W9, W0
007270  0703F2     RCALL Delay_us
81:                  }
82:                    Delay_us(40);
007278  200280     MOV #0x28, W0
00727A  0703ED     RCALL Delay_us
83:                }
00727C  BE044F     MOV.D [--W15], W8
00727E  060000     RETURN
84:                
85:                void lcdSetupPots(){
86:                    lcdSetCursor(0,0);
007280  EB4080     CLR.B W1
007282  784001     MOV.B W1, W0
007284  07FFC6     RCALL lcdSetCursor
87:                    lcdWriteString("P1:");
007286  2F19C0     MOV #0xF19C, W0
007288  07FFEB     RCALL lcdWriteString
88:                    lcdSetCursor(6,0);
00728A  EB4080     CLR.B W1
00728C  B3C060     MOV.B #0x6, W0
00728E  07FFC1     RCALL lcdSetCursor
89:                    lcdWriteString("P2:");
007290  2F1A00     MOV #0xF1A0, W0
007292  07FFE6     RCALL lcdWriteString
90:                    lcdSetCursor(12,0);
007294  EB4080     CLR.B W1
007296  B3C0C0     MOV.B #0xC, W0
007298  07FFBC     RCALL lcdSetCursor
91:                    lcdWriteString("P3:");
00729A  2F1A40     MOV #0xF1A4, W0
00729C  07FFE1     RCALL lcdWriteString
92:                    lcdSetCursor(0,1);
00729E  B3C011     MOV.B #0x1, W1
0072A0  EB4000     CLR.B W0
0072A2  07FFB7     RCALL lcdSetCursor
93:                    lcdWriteString("P4:");
0072A4  2F1A80     MOV #0xF1A8, W0
0072A6  07FFDC     RCALL lcdWriteString
94:                    lcdSetCursor(6,1);
0072A8  B3C011     MOV.B #0x1, W1
0072AA  B3C060     MOV.B #0x6, W0
0072AC  07FFB2     RCALL lcdSetCursor
95:                    lcdWriteString("P5:");
0072AE  2F1AC0     MOV #0xF1AC, W0
0072B0  07FFD7     RCALL lcdWriteString
96:                    lcdSetCursor(12,1);
0072B2  B3C011     MOV.B #0x1, W1
0072B4  B3C0C0     MOV.B #0xC, W0
0072B6  07FFAD     RCALL lcdSetCursor
97:                    lcdWriteString("P6:");
0072B8  2F1B00     MOV #0xF1B0, W0
0072BA  07FFD2     RCALL lcdWriteString
98:                    lcdSetCursor(0,2);
0072BC  B3C021     MOV.B #0x2, W1
0072BE  EB4000     CLR.B W0
0072C0  07FFA8     RCALL lcdSetCursor
99:                    lcdWriteString("I:");
0072C2  2F1B40     MOV #0xF1B4, W0
0072C4  07FFCD     RCALL lcdWriteString
100:                   lcdSetCursor(8,2);
0072C6  B3C021     MOV.B #0x2, W1
0072C8  B3C080     MOV.B #0x8, W0
0072CA  07FFA3     RCALL lcdSetCursor
101:                   lcdWriteString("O:");
0072CC  2F1B70     MOV #0xF1B7, W0
0072CE  07FFC8     RCALL lcdWriteString
102:                   lcdSetCursor(0,3);
0072D0  B3C031     MOV.B #0x3, W1
0072D2  EB4000     CLR.B W0
0072D4  07FF9E     RCALL lcdSetCursor
103:                   lcdWriteString("Cyc:");
0072D6  2F1BA0     MOV #0xF1BA, W0
0072D8  07FFC3     RCALL lcdWriteString
104:                   lcdSetCursor(11,3);
0072DA  B3C031     MOV.B #0x3, W1
0072DC  B3C0B0     MOV.B #0xB, W0
0072DE  07FF99     RCALL lcdSetCursor
105:                   if(TEST_SIN==TRUE)lcdWriteString("SINE");
0072E0  BFD01E     MOV.B TEST_SIN, WREG
0072E2  404FE1     ADD.B W0, #0x1, [W15]
0072E4  3A0003     BRA NZ, 0x72EC
0072E6  2F1BF0     MOV #0xF1BF, W0
0072E8  07FFBB     RCALL lcdWriteString
0072EA  370002     BRA 0x72F0
106:                   else lcdWriteString("THRU");
0072EC  2F1C40     MOV #0xF1C4, W0
0072EE  07FFB8     RCALL lcdWriteString
107:                   
108:               }
0072F0  060000     RETURN
109:               
110:               void lcdCustomSymbols(void){
111:                   int i=0;
112:                   lcdCommand(0x40);
0072F2  B3C400     MOV.B #0x40, W0
0072F4  07FF80     RCALL lcdCommand
113:                   Delay_us(200);
0072F6  200C80     MOV #0xC8, W0
0072F8  0703AE     RCALL Delay_us
114:                  // for(; i<8; i++)lcdWriteString(loadingOne[i]);
115:                   //lcdWriteString(loadingTwo);
116:                   //lcdWriteString(loadingThree);
117:                   //lcdWriteString(loadingFour);
118:               }
0072FA  060000     RETURN
119:               
120:               void lcdInit(void){
121:                   lcdCommand(0x38);              //function set, 8 bits, 2 line disp, 5x8
0072FC  B3C380     MOV.B #0x38, W0
0072FE  07FF7B     RCALL lcdCommand
122:                   Delay_us(4500);                //>4.1 mS required
007300  211940     MOV #0x1194, W0
007302  0703A9     RCALL Delay_us
123:                   lcdCommand(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
007304  B3C0C0     MOV.B #0xC, W0
007306  07FF77     RCALL lcdCommand
124:                   Delay_us(4500);
007308  211940     MOV #0x1194, W0
00730A  0703A5     RCALL Delay_us
125:                   lcdClear();                    //Display Clear  
00730C  07FF7C     RCALL lcdClear
126:                   Delay_us(1800);                //>1.64mS required
00730E  207080     MOV #0x708, W0
007310  0703A2     RCALL Delay_us
127:                   lcdCommand(0x06);               // entry Mode Set
007312  B3C060     MOV.B #0x6, W0
007314  07FF70     RCALL lcdCommand
128:                   Delay_us(200);
007316  200C80     MOV #0xC8, W0
007318  07039E     RCALL Delay_us
129:                   lcdReturn();
00731A  07FF78     RCALL lcdReturn
130:                   Delay_us(1500);
00731C  205DC0     MOV #0x5DC, W0
00731E  07039B     RCALL Delay_us
131:                   
132:                   //lcdCustomSymbols();
133:                   Delay_us(200);
007320  200C80     MOV #0xC8, W0
007322  070399     RCALL Delay_us
134:                   lcdClear();                         //Display Clear  
007324  07FF70     RCALL lcdClear
135:                   Delay_us(1500);
007326  205DC0     MOV #0x5DC, W0
007328  070396     RCALL Delay_us
136:                   lcdReturn();
00732A  07FF70     RCALL lcdReturn
137:                   Delay_us(200);
00732C  200C80     MOV #0xC8, W0
00732E  070393     RCALL Delay_us
138:               }
007330  060000     RETURN
139:               
140:               void lcdWriteWord(int word){
007332  4787E6     ADD W15, #0x6, W15
007334  781F88     MOV W8, [W15++]
007336  781F8E     MOV W14, [W15++]
007338  780400     MOV W0, W8
007360  200040     MOV #0x4, W0
141:                   int i;
142:                   char inchar[4];
143:                   
144:                   if(word<0) {
00733A  E00008     CP0 W8
00733C  3D0004     BRA GE, 0x7346
145:                       lcdWrite('-');
00733E  B3C2D0     MOV.B #0x2D, W0
007340  07FF52     RCALL lcdWrite
146:                       word=~word+1;
007342  EA0408     NEG W8, W8
007344  370002     BRA 0x734A
147:                   }else lcdWrite(' ');
007346  B3C200     MOV.B #0x20, W0
007348  07FF4E     RCALL lcdWrite
148:                  Delay_us(40);
00734A  200280     MOV #0x28, W0
00734C  070384     RCALL Delay_us
149:                  
150:                  inchar[0] = word&0x000F; 
00734E  64406F     AND.B W8, #0xF, W0
151:                  if (inchar[0] > 9) 
007350  504FE9     SUB.B W0, #0x9, [W15]
007352  340003     BRA LE, 0x735A
152:                      inchar[0]+=55;
007354  B04370     ADD.B #0x37, W0
007356  9FFF80     MOV.B W0, [W15-8]
007358  370002     BRA 0x735E
153:                  else inchar[0]+=48;
00735A  B04300     ADD.B #0x30, W0
00735C  9FFF80     MOV.B W0, [W15-8]
00735E  578768     SUB W15, #0x8, W14
154:                  
155:                  for(i=1; i<4; i++){ 
00737A  500FF0     SUB W0, #0x10, [W15]
00737C  3AFFF2     BRA NZ, 0x7362
156:                     inchar[i] = ((word>>(i*4))&0x0000F); 
007362  DEC080     ASR W8, W0, W1
007364  60C0EF     AND.B W1, #0xF, W1
007366  E8070E     INC W14, W14
007368  784F01     MOV.B W1, [W14]
157:                     if (inchar[i] > 9) 
00736A  50CFE9     SUB.B W1, #0x9, [W15]
00736C  340003     BRA LE, 0x7374
158:                         inchar[i]+=55;
00736E  B3C373     MOV.B #0x37, W3
007370  40CF03     ADD.B W1, W3, [W14]
007372  370002     BRA 0x7378
159:                     else inchar[i]+=48;
007374  B3C303     MOV.B #0x30, W3
007376  40CF03     ADD.B W1, W3, [W14]
007378  400064     ADD W0, #0x4, W0
160:                  } 
161:                  lcdWrite(inchar[3]);
00737E  97F83F     MOV.B [W15-5], W0
007380  07FF32     RCALL lcdWrite
162:                  Delay_us(50);
007382  200320     MOV #0x32, W0
007384  070368     RCALL Delay_us
163:                  lcdWrite(inchar[2]);
007386  97F82F     MOV.B [W15-6], W0
007388  07FF2E     RCALL lcdWrite
164:                   Delay_us(50);
00738A  200320     MOV #0x32, W0
00738C  070364     RCALL Delay_us
165:                  lcdWrite(inchar[1]);
00738E  97F81F     MOV.B [W15-7], W0
007390  07FF2A     RCALL lcdWrite
166:                  Delay_us(50);
007392  200320     MOV #0x32, W0
007394  070360     RCALL Delay_us
167:                  lcdWrite(inchar[0]);
007396  97F80F     MOV.B [W15-8], W0
007398  07FF26     RCALL lcdWrite
168:                  Delay_us(50);
00739A  200320     MOV #0x32, W0
00739C  07035C     RCALL Delay_us
169:               }
00739E  78074F     MOV [--W15], W14
0073A0  78044F     MOV [--W15], W8
0073A2  B1006F     SUB #0x6, W15
0073A4  060000     RETURN
170:               
171:               void lcdVUvertical(unsigned char col, unsigned char row, int data){
172:                   lcdSetCursor(col,row);
0073A6  07FF35     RCALL lcdSetCursor
173:               }
0073A8  060000     RETURN
174:               
175:               //4x4 pad debug
176:               void lcdDrawPads(unsigned char col){
0073AA  781F88     MOV W8, [W15++]
0073AC  784400     MOV.B W0, W8
177:                   lcdSetCursor(col, 0);
0073AE  EB4080     CLR.B W1
0073B0  784008     MOV.B W8, W0
0073B2  07FF2F     RCALL lcdSetCursor
178:                   if(pad[12])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
0073B4  269940     MOV #0x6994, W0
0073B6  E00410     CP0.B [W0]
0073B8  320003     BRA Z, 0x73C0
0073BA  2F1C90     MOV #0xF1C9, W0
0073BC  07FF51     RCALL lcdWriteString
0073BE  370004     BRA 0x73C8
0073C0  EBC000     SETM.B W0
0073C2  07FF11     RCALL lcdWrite
0073C4  200320     MOV #0x32, W0
0073C6  070347     RCALL Delay_us
179:                   if(pad[13])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
0073C8  269950     MOV #0x6995, W0
0073CA  E00410     CP0.B [W0]
0073CC  320003     BRA Z, 0x73D4
0073CE  2F1C90     MOV #0xF1C9, W0
0073D0  07FF47     RCALL lcdWriteString
0073D2  370004     BRA 0x73DC
0073D4  EBC000     SETM.B W0
0073D6  07FF07     RCALL lcdWrite
0073D8  200320     MOV #0x32, W0
0073DA  07033D     RCALL Delay_us
180:                   if(pad[14])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
0073DC  269960     MOV #0x6996, W0
0073DE  E00410     CP0.B [W0]
0073E0  320003     BRA Z, 0x73E8
0073E2  2F1C90     MOV #0xF1C9, W0
0073E4  07FF3D     RCALL lcdWriteString
0073E6  370004     BRA 0x73F0
0073E8  EBC000     SETM.B W0
0073EA  07FEFD     RCALL lcdWrite
0073EC  200320     MOV #0x32, W0
0073EE  070333     RCALL Delay_us
181:                   if(pad[15])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
0073F0  269970     MOV #0x6997, W0
0073F2  E00410     CP0.B [W0]
0073F4  320003     BRA Z, 0x73FC
0073F6  2F1C90     MOV #0xF1C9, W0
0073F8  07FF33     RCALL lcdWriteString
0073FA  370004     BRA 0x7404
0073FC  EBC000     SETM.B W0
0073FE  07FEF3     RCALL lcdWrite
007400  200320     MOV #0x32, W0
007402  070329     RCALL Delay_us
182:                   lcdSetCursor(col, 1);
007404  B3C011     MOV.B #0x1, W1
007406  784008     MOV.B W8, W0
007408  07FF04     RCALL lcdSetCursor
183:                   if(pad[8])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
00740A  269900     MOV #0x6990, W0
00740C  E00410     CP0.B [W0]
00740E  320003     BRA Z, 0x7416
007410  2F1C90     MOV #0xF1C9, W0
007412  07FF26     RCALL lcdWriteString
007414  370004     BRA 0x741E
007416  EBC000     SETM.B W0
007418  07FEE6     RCALL lcdWrite
00741A  200320     MOV #0x32, W0
00741C  07031C     RCALL Delay_us
184:                   if(pad[9])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
00741E  269910     MOV #0x6991, W0
007420  E00410     CP0.B [W0]
007422  320003     BRA Z, 0x742A
007424  2F1C90     MOV #0xF1C9, W0
007426  07FF1C     RCALL lcdWriteString
007428  370004     BRA 0x7432
00742A  EBC000     SETM.B W0
00742C  07FEDC     RCALL lcdWrite
00742E  200320     MOV #0x32, W0
007430  070312     RCALL Delay_us
185:                   if(pad[10])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
007432  269920     MOV #0x6992, W0
007434  E00410     CP0.B [W0]
007436  320003     BRA Z, 0x743E
007438  2F1C90     MOV #0xF1C9, W0
00743A  07FF12     RCALL lcdWriteString
00743C  370004     BRA 0x7446
00743E  EBC000     SETM.B W0
007440  07FED2     RCALL lcdWrite
007442  200320     MOV #0x32, W0
007444  070308     RCALL Delay_us
186:                   if(pad[11])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
007446  269930     MOV #0x6993, W0
007448  E00410     CP0.B [W0]
00744A  320003     BRA Z, 0x7452
00744C  2F1C90     MOV #0xF1C9, W0
00744E  07FF08     RCALL lcdWriteString
007450  370004     BRA 0x745A
007452  EBC000     SETM.B W0
007454  07FEC8     RCALL lcdWrite
007456  200320     MOV #0x32, W0
007458  0702FE     RCALL Delay_us
187:                   lcdSetCursor(col, 2);
00745A  B3C021     MOV.B #0x2, W1
00745C  784008     MOV.B W8, W0
00745E  07FED9     RCALL lcdSetCursor
188:                   if(pad[4])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
007460  2698C0     MOV #0x698C, W0
007462  E00410     CP0.B [W0]
007464  320003     BRA Z, 0x746C
007466  2F1C90     MOV #0xF1C9, W0
007468  07FEFB     RCALL lcdWriteString
00746A  370004     BRA 0x7474
00746C  EBC000     SETM.B W0
00746E  07FEBB     RCALL lcdWrite
007470  200320     MOV #0x32, W0
007472  0702F1     RCALL Delay_us
189:                   if(pad[5])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
007474  2698D0     MOV #0x698D, W0
007476  E00410     CP0.B [W0]
007478  320003     BRA Z, 0x7480
00747A  2F1C90     MOV #0xF1C9, W0
00747C  07FEF1     RCALL lcdWriteString
00747E  370004     BRA 0x7488
007480  EBC000     SETM.B W0
007482  07FEB1     RCALL lcdWrite
007484  200320     MOV #0x32, W0
007486  0702E7     RCALL Delay_us
190:                   if(pad[6])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
007488  2698E0     MOV #0x698E, W0
00748A  E00410     CP0.B [W0]
00748C  320003     BRA Z, 0x7494
00748E  2F1C90     MOV #0xF1C9, W0
007490  07FEE7     RCALL lcdWriteString
007492  370004     BRA 0x749C
007494  EBC000     SETM.B W0
007496  07FEA7     RCALL lcdWrite
007498  200320     MOV #0x32, W0
00749A  0702DD     RCALL Delay_us
191:                   if(pad[7])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
00749C  2698F0     MOV #0x698F, W0
00749E  E00410     CP0.B [W0]
0074A0  320003     BRA Z, 0x74A8
0074A2  2F1C90     MOV #0xF1C9, W0
0074A4  07FEDD     RCALL lcdWriteString
0074A6  370004     BRA 0x74B0
0074A8  EBC000     SETM.B W0
0074AA  07FE9D     RCALL lcdWrite
0074AC  200320     MOV #0x32, W0
0074AE  0702D3     RCALL Delay_us
192:                   lcdSetCursor(col, 3);
0074B0  B3C031     MOV.B #0x3, W1
0074B2  784008     MOV.B W8, W0
0074B4  07FEAE     RCALL lcdSetCursor
193:                   if(pad[0])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
0074B6  269880     MOV #0x6988, W0
0074B8  E00410     CP0.B [W0]
0074BA  320003     BRA Z, 0x74C2
0074BC  2F1C90     MOV #0xF1C9, W0
0074BE  07FED0     RCALL lcdWriteString
0074C0  370004     BRA 0x74CA
0074C2  EBC000     SETM.B W0
0074C4  07FE90     RCALL lcdWrite
0074C6  200320     MOV #0x32, W0
0074C8  0702C6     RCALL Delay_us
194:                   if(pad[1])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
0074CA  269890     MOV #0x6989, W0
0074CC  E00410     CP0.B [W0]
0074CE  320003     BRA Z, 0x74D6
0074D0  2F1C90     MOV #0xF1C9, W0
0074D2  07FEC6     RCALL lcdWriteString
0074D4  370004     BRA 0x74DE
0074D6  EBC000     SETM.B W0
0074D8  07FE86     RCALL lcdWrite
0074DA  200320     MOV #0x32, W0
0074DC  0702BC     RCALL Delay_us
195:                   if(pad[2])lcdWriteString(" "); else {lcdWrite(0xFF);Delay_us(50);}
0074DE  2698A0     MOV #0x698A, W0
0074E0  E00410     CP0.B [W0]
0074E2  320003     BRA Z, 0x74EA
0074E4  2F1C90     MOV #0xF1C9, W0
0074E6  07FEBC     RCALL lcdWriteString
0074E8  370004     BRA 0x74F2
0074EA  EBC000     SETM.B W0
0074EC  07FE7C     RCALL lcdWrite
0074EE  200320     MOV #0x32, W0
0074F0  0702B2     RCALL Delay_us
196:                   if(pad[3])lcdWriteString(" "); else lcdWrite(0xFF);
0074F2  2698B0     MOV #0x698B, W0
0074F4  E00410     CP0.B [W0]
0074F6  320003     BRA Z, 0x74FE
0074F8  2F1C90     MOV #0xF1C9, W0
0074FA  07FEB2     RCALL lcdWriteString
0074FC  370002     BRA 0x7502
0074FE  EBC000     SETM.B W0
007500  07FE72     RCALL lcdWrite
197:               }
007502  78044F     MOV [--W15], W8
007504  060000     RETURN
198:               
199:               /*
200:                char loadingOne[8] = {
201:               	0b10000,
202:               	0b10000,
203:               	0b10000,
204:               	0b10000,
205:               	0b10000,
206:               	0b10000,
207:               	0b10000,
208:               	0b10000
209:               };
210:               
211:               char loadingTwo[8] = {
212:               	0b11000,
213:               	0b11000,
214:               	0b11000,
215:               	0b11000,
216:               	0b11000,
217:               	0b11000,
218:               	0b11000,
219:               	0b11000
220:               };
221:               
222:               char loadingThree[8] = {
223:               	0b11100,
224:               	0b11100,
225:               	0b11100,
226:               	0b11100,
227:               	0b11100,
228:               	0b11100,
229:               	0b11100,
230:               	0b11100
231:               };
232:               
233:               char loadingFour[8] = {
234:               	0b11110,
235:               	0b11110,
236:               	0b11110,
237:               	0b11110,
238:               	0b11110,
239:               	0b11110,
240:               	0b11110,
241:               	0b11110
242:               };
243:                */
244:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/main.c  -----------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 //#include "fatfs/src/ff.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = ON   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                unsigned char pad[BUTTONS]={1};                                                                   //CONTROL VARIABLES//
22:                fractional pots[4]={0};
23:                fractional pots_scaled[4]={0};
24:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
25:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
26:                
27:                /* DMA BUFFERS */
28:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
29:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
31:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
32:                
33:                unsigned int bpm=0, rw=0, frameReady=0;
34:                unsigned int idle=0, cycle=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                               //STATUS VARIABLES//
37:                volatile unsigned char t1flag=FALSE;
38:                volatile unsigned char t2flag=FALSE;
39:                volatile unsigned char recording=TRUE;
40:                unsigned char UART_ON = FALSE;
41:                unsigned char TEST_SIN = FALSE;
42:                
43:                volatile unsigned char tremelo=FALSE;                                           //FX FLAGS//
44:                volatile unsigned char looper=FALSE;
45:                volatile unsigned char lpf=FALSE;
46:                
47:                void initBuffer(void){
007D46  267727     MOV #0x6772, W7
007D48  267F26     MOV #0x67F2, W6
007D4A  2CF7E5     MOV #0xCF7E, W5
007D4C  2CEFE4     MOV #0xCEFE, W4
007D4E  2CE7E3     MOV #0xCE7E, W3
007D50  2CDFE2     MOV #0xCDFE, W2
007D52  200401     MOV #0x40, W1
48:                    int i=0;
49:                    for(; i<STREAMBUF; i++){
007D64  3AFFF8     BRA NZ, 0x7D56
50:                        streamA[i]=0;
007D54  EB0000     CLR W0
007D56  782B80     MOV W0, [++W7]
51:                        streamB[i]=0;
007D58  782B00     MOV W0, [++W6]
52:                        txBufferA[i]=0;
007D5A  782A80     MOV W0, [++W5]
53:                        txBufferB[i]=0;
007D5C  782A00     MOV W0, [++W4]
54:                        rxBufferA[i]=0;
007D5E  782980     MOV W0, [++W3]
55:                        rxBufferB[i]=0;
007D60  782900     MOV W0, [++W2]
007D62  E90081     DEC W1, W1
56:                    }
57:                }
007D66  060000     RETURN
58:                
59:                int main(void) {
007D68  BE9F88     MOV.D W8, [W15++]
007D6A  BE9F8A     MOV.D W10, [W15++]
007D6C  BE9F8C     MOV.D W12, [W15++]
007D6E  781F8E     MOV W14, [W15++]
007D98  2FF80A     MOV #0xFF80, W10
007D9A  450508     ADD W10, W8, W10
60:                    initPorts();                    //configure io device & adc 
007D70  07FBCA     RCALL initPorts
61:                    //initUART1();                    //configure & enable UART
62:                    initBuffer();
007D72  07FFE9     RCALL initBuffer
63:                    initADC1();                     //configure & enable internal ADC
007D74  07FC78     RCALL initADC1
64:                    //initSPI2_ADC();                  //configure & enable SPI ADC !!!DEFUNCT!!!
65:                    initPMP();
007D76  07FC8A     RCALL initPMP
66:                    //||||||||----
67:                    //initDMA0();
68:                    initDCI_DAC();                  //configure & enable DAC
007D78  07FCCE     RCALL initDCI_DAC
69:                    initT1();                       //configure & start T1 
007D7A  07FC9D     RCALL initT1
70:                    initT2();                       //configure & start T2 
007D7C  07FCAB     RCALL initT2
71:                    //initSPI3_SEG();                  //start segment display
72:                
73:                    //initCAP_BPM();                  //configure bpm capture
74:                    //initT3();                       //configure & start T3
75:                    fractional temp;
76:                    int writePtr;
77:                    fractional *ping, *pong;
78:                    
79:                    while(1){   
80:                        
81:                        if(frameReady) {
007D86  E21014     CP0 frameReady
007D88  32001A     BRA Z, 0x7DBE
82:                            writePtr=STREAMBUF-1;
83:                            if(rw){
007D8A  E21012     CP0 rw
007D8C  320003     BRA Z, 0x7D94
84:                                ping = streamA+writePtr;
007D90  267F28     MOV #0x67F2, W8
007D92  370002     BRA 0x7D98
85:                                pong = outputB+writePtr;
007D8E  267729     MOV #0x6772, W9
86:                            }else{
87:                                ping = streamB+writePtr;
007D84  26872E     MOV #0x6872, W14
007D96  78040E     MOV W14, W8
88:                                pong = outputA+writePtr;
007D82  266F2D     MOV #0x66F2, W13
007D94  78048D     MOV W13, W9
89:                            }
90:                            for(; writePtr>=0; writePtr--){
007DAE  540F8A     SUB W8, W10, [W15]
007DB0  3AFFF5     BRA NZ, 0x7D9C
91:                                temp=*ping--; //!rw
007D9C  780028     MOV [W8--], W0
92:                                if(temp<=-32766||temp>=32766)hard_clipped=TRUE;
007D7E  27FFDB     MOV #0x7FFD, W11
007D80  EBC600     SETM.B W12
007D9E  40008B     ADD W0, W11, W1
007DA0  408FE6     ADD W1, #0x6, [W15]
007DA2  360002     BRA LEU, 0x7DA8
007DA4  2101A1     MOV #0x101A, W1
007DA6  78488C     MOV.B W12, [W1]
93:                                temp=fx(temp);    //run fx on latest sample
007DA8  07FEB7     RCALL fx
94:                                *pong--=mixer(temp); //rw
007DAA  07FE5E     RCALL mixer
007DAC  781480     MOV W0, [W9--]
95:                                
96:                            }
97:                            temp = 8*idle/STREAMBUF;
007DB2  8080B0     MOV idle, W0
007DB4  DD0043     SL W0, #3, W0
007DB6  DE0046     LSR W0, #6, W0
98:                            cycle=temp;
007DB8  8880C0     MOV W0, cycle
99:                            idle=0;
007DBA  EF3016     CLR idle
100:                           frameReady=0;
007DBC  EF3014     CLR frameReady
101:                       }
102:                       if(t2flag==TRUE){
007DBE  BFD01C     MOV.B t2flag, WREG
007DC0  404FE1     ADD.B W0, #0x1, [W15]
007DC2  3A0003     BRA NZ, 0x7DCA
103:                           scanMatrix();                   //read button matrix
007DC4  07FD1B     RCALL scanMatrix
104:                           readPots();                     //read control pots
007DC6  07FD91     RCALL readPots
105:                           t2flag=FALSE;
007DC8  EF701C     CLR.B t2flag
106:                       }
107:                       if(t1flag==TRUE){
007DCA  BFD01B     MOV.B t1flag, WREG
007DCC  404FE1     ADD.B W0, #0x1, [W15]
007DCE  3A0002     BRA NZ, 0x7DD4
108:                           display();
007DD0  07FE0B     RCALL display
109:                           t1flag=FALSE; 
007DD2  EF701B     CLR.B t1flag
110:                       }
111:                       idle++; //999
007DD4  EC3016     INC idle
112:                   }
007DD6  37FFD7     BRA 0x7D86
113:                   return 0;
114:               }
115:               // example test 
---  C:/Users/ryan/Documents/seniorproject/ps-040/devInits.c  -------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 
5:                 #include <xc.h>
6:                 #include <p33EP512GM310.h>
7:                 #include <libpic30.h>
8:                 #include "common.h"
9:                 #include "devInits.h"
10:                #include "utilities.h"
11:                #include "plcd.h"
12:                
13:                extern unsigned char UART_ON;
14:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
15:                 
16:                //Description: Responsible i/o, clock, & RP pin config setup
17:                //Prereq: NONE
18:                //Dependencies: NONE
19:                //*Note: This is ALWAYS the first function called in main*
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
007506  2FF3F0     MOV #0xFF3F, W0
007508  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
00750A  2FFE00     MOV #0xFFE0, W0
00750C  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
00750E  2FE000     MOV #0xFE00, W0
007510  B60746     AND PLLFBD, WREG
007512  B30490     IOR #0x49, W0
007514  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
007516  200201     MOV #0x20, W1
007518  803A12     MOV OSCCON, W2
00751A  608002     AND W1, W2, W0
00751C  32FFFD     BRA Z, 0x7518
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
00751E  803A10     MOV OSCCON, W0
007520  A16000     BCLR W0, #6
007522  200461     MOV #0x46, W1
007524  200572     MOV #0x57, W2
007526  207423     MOV #0x742, W3
007528  784981     MOV.B W1, [W3]
00752A  784982     MOV.B W2, [W3]
00752C  784980     MOV.B W0, [W3]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
00752E  2FFC00     MOV #0xFFC0, W0
007530  803424     MOV RPOR2, W4
007532  600184     AND W0, W4, W3
007534  A00003     BSET W3, #0
007536  883423     MOV W3, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
007538  2FF803     MOV #0xFF80, W3
00753A  803685     MOV RPINR24, W5
00753C  618205     AND W3, W5, W4
00753E  B303D4     IOR #0x3D, W4
007540  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
007542  B60686     AND RPOR3, WREG
007544  B300C0     IOR #0xC, W0
007546  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
007548  2C0FF0     MOV #0xC0FF, W0
00754A  803424     MOV RPOR2, W4
00754C  600284     AND W0, W4, W5
00754E  20D004     MOV #0xD00, W4
007550  720205     IOR W4, W5, W4
007552  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
007554  803434     MOV RPOR3, W4
007556  600284     AND W0, W4, W5
007558  20B004     MOV #0xB00, W4
00755A  720205     IOR W4, W5, W4
00755C  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
00755E  803575     MOV RPINR7, W5
007560  618185     AND W3, W5, W3
007562  B305F3     IOR #0x5F, W3
007564  883573     MOV W3, RPINR7
36:                    RPINR29bits.SCK3R=0x39;      //SCK3 input on pin 84
007566  280FF4     MOV #0x80FF, W4
007568  8036D3     MOV RPINR29, W3
00756A  620203     AND W4, W3, W4
00756C  239003     MOV #0x3900, W3
00756E  718184     IOR W3, W4, W3
007570  8836D3     MOV W3, RPINR29
37:                    RPOR7bits.RP57R=0x20;        //SCK3 output on pin 84
007572  803474     MOV RPOR7, W4
007574  600184     AND W0, W4, W3
007576  A0D003     BSET W3, #13
007578  883473     MOV W3, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
00757A  B60690     AND RPOR8, WREG
00757C  21F003     MOV #0x1F00, W3
00757E  718180     IOR W3, W0, W3
007580  883483     MOV W3, RPOR8
39:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
007582  803A10     MOV OSCCON, W0
007584  A06000     BSET W0, #6
007586  207423     MOV #0x742, W3
007588  784981     MOV.B W1, [W3]
00758A  784982     MOV.B W2, [W3]
00758C  784980     MOV.B W0, [W3]
40:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
41:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
00758E  EB8000     SETM W0
007590  883B60     MOV W0, PMD7
007592  F8076C     PUSH PMD7
007594  F9076A     POP PMD6
007596  F8076A     PUSH PMD6
007598  F90766     POP PMD4
00759A  F80766     PUSH PMD4
00759C  F90764     POP PMD3
00759E  F80764     PUSH PMD3
0075A0  F90762     POP PMD2
0075A2  F80762     PUSH PMD2
0075A4  F90760     POP PMD1
42:                    PMD1bits.AD1MD=0;
0075A6  A90760     BCLR PMD1, #0
43:                    PMD1bits.SPI1MD=0;
0075A8  A96760     BCLR PMD1, #3
44:                    PMD1bits.SPI2MD=0;
0075AA  A98760     BCLR PMD1, #4
45:                    PMD1bits.U1MD=0;
0075AC  A9A760     BCLR PMD1, #5
46:                    PMD1bits.U2MD=0;
0075AE  A9C760     BCLR PMD1, #6
47:                    PMD1bits.DCIMD=0;
0075B0  A90761     BCLR 0x761, #0
48:                    PMD1bits.T1MD=0;
0075B2  A96761     BCLR 0x761, #3
49:                    PMD1bits.T2MD=0;
0075B4  A98761     BCLR 0x761, #4
50:                    PMD1bits.T3MD=0;
0075B6  A9A761     BCLR 0x761, #5
51:                    PMD1bits.T4MD=0;
0075B8  A9C761     BCLR 0x761, #6
52:                    PMD3bits.PMPMD=0;
0075BA  A90765     BCLR 0x765, #0
53:                    PMD3bits.CMPMD=0;
0075BC  A94765     BCLR 0x765, #2
54:                    PMD6bits.SPI3MD=0;
0075BE  A9076A     BCLR PMD6, #0
55:                    PMD7bits.DMA0MD=0;
0075C0  A9876C     BCLR PMD7, #4
56:                    
57:                    /* ANALOG PINS (1 = analog) */
58:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
0075C2  EF2E6E     CLR ANSELG
0075C4  F80E6E     PUSH ANSELG
0075C6  F90E5E     POP ANSELF
0075C8  F80E5E     PUSH ANSELF
0075CA  F90E4E     POP ANSELE
0075CC  F80E4E     PUSH ANSELE
0075CE  F90E3E     POP ANSELD
0075D0  F80E3E     PUSH ANSELD
0075D2  F90E2E     POP ANSELC
0075D4  F80E2E     PUSH ANSELC
0075D6  F90E1E     POP ANSELB
0075D8  F80E1E     PUSH ANSELB
0075DA  F90E0E     POP ANSELA
59:                    ANSELBbits.ANSB0 = 1; // Ensure AN0/RB0 is analog
0075DC  A80E1E     BSET ANSELB, #0
60:                    ANSELBbits.ANSB1 = 1; // Ensure AN1/RB1 is analog
0075DE  A82E1E     BSET ANSELB, #1
61:                    ANSELBbits.ANSB2 = 1; // Ensure AN2/RB2 is analog
0075E0  A84E1E     BSET ANSELB, #2
62:                    ANSELBbits.ANSB3 = 1; // Ensure AN5/RB5 is analog
0075E2  A86E1E     BSET ANSELB, #3
63:                    
64:                    /* IO DIRECTION (1 = input) */
65:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
0075E4  EF2E60     CLR TRISG
0075E6  F80E60     PUSH TRISG
0075E8  F90E50     POP TRISF
0075EA  F80E50     PUSH TRISF
0075EC  F90E40     POP TRISE
0075EE  F80E40     PUSH TRISE
0075F0  F90E30     POP TRISD
0075F2  F80E30     PUSH TRISD
0075F4  F90E20     POP TRISC
0075F6  F80E20     PUSH TRISC
0075F8  F90E10     POP TRISB
0075FA  F80E10     PUSH TRISB
0075FC  F90E00     POP TRISA
66:                    TRISA=0x0603;
0075FE  206031     MOV #0x603, W1
007600  887001     MOV W1, TRISA
67:                    TRISB=0x0003;
007602  200031     MOV #0x3, W1
007604  887081     MOV W1, TRISB
68:                    TRISC=0x2080;
007606  220801     MOV #0x2080, W1
007608  887101     MOV W1, TRISC
69:                    TRISD=CNPUD=0x001E;
00760A  2001E1     MOV #0x1E, W1
00760C  8871D1     MOV W1, CNPUD
00760E  F80E3A     PUSH CNPUD
007610  F90E30     POP TRISD
70:                    TRISE=0x7000;
007612  270001     MOV #0x7000, W1
007614  887201     MOV W1, TRISE
71:                    TRISF=CNPUF=0x00F0;
007616  200F01     MOV #0xF0, W1
007618  8872D1     MOV W1, CNPUF
00761A  F80E5A     PUSH CNPUF
00761C  F90E50     POP TRISF
72:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
00761E  887350     MOV W0, CNPUG
007620  F80E6A     PUSH CNPUG
007622  F90E60     POP TRISG
73:                    
74:                    /* DIGITAL OUTPUT LATCH */
75:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
007624  EF2E64     CLR LATG
007626  F80E64     PUSH LATG
007628  F90E54     POP LATF
00762A  F80E54     PUSH LATF
00762C  F90E44     POP LATE
00762E  F80E44     PUSH LATE
007630  F90E34     POP LATD
007632  F80E34     PUSH LATD
007634  F90E24     POP LATC
007636  F80E24     PUSH LATC
007638  F90E14     POP LATB
00763A  F80E14     PUSH LATB
00763C  F90E04     POP LATA
76:                    LATA=0x0040;
00763E  200400     MOV #0x40, W0
007640  887020     MOV W0, LATA
77:                    
78:                    
79:                    
80:                }
007642  060000     RETURN
81:                
82:                //Description: Initializes UART1 device & interrupts
83:                //Prereq: NONE
84:                //Dependencies: NONE
85:                void initUART1(void){
86:                    IFS0bits.U1TXIF = 0;        //clear flag
007644  A98801     BCLR 0x801, #4
87:                    IFS0bits.U1RXIF = 0;        //clear flag
007646  A96801     BCLR 0x801, #3
88:                    U1STA=0x1510;               //enable tx & rx
007648  215100     MOV #0x1510, W0
00764A  881110     MOV W0, U1STA
89:                    U1BRG=BRGVAL;               //baud rate
00764C  2004A0     MOV #0x4A, W0
00764E  881140     MOV W0, U1BRG
90:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
007650  2FFF90     MOV #0xFFF9, W0
007652  B60220     AND U1MODE, WREG
007654  A01000     BSET W0, #1
007656  881100     MOV W0, U1MODE
91:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
007658  270000     MOV #0x7000, W0
00765A  B72844     IOR IPC2
92:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
00765C  200070     MOV #0x7, W0
00765E  B72846     IOR IPC3
93:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
94:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
95:                    U1MODEbits.UARTEN = 1;      //start uart
007660  A8E221     BSET 0x221, #7
96:                    UART_ON = TRUE;
007662  EFF01D     SETM.B UART_ON
97:                    
98:                }
007664  060000     RETURN
99:                
100:               //Description: Initializes onboard ADC 
101:               //Prereq: NONE
102:               //Dependencies: NONE
103:               void initADC1(void){
104:                   AD1CON1bits.ASAM = 1;       //enable simultaneous sample
007666  A84320     BSET AD1CON1, #2
105:                   AD1CON1bits.SIMSAM = 0;     //enable simultaneous sample
007668  A96320     BCLR AD1CON1, #3
106:                   AD1CON1bits.FORM=2;         //signed fractional format
00766A  2FCFF0     MOV #0xFCFF, W0
00766C  801902     MOV AD1CON1, W2
00766E  600082     AND W0, W2, W1
007670  A09001     BSET W1, #9
007672  881901     MOV W1, AD1CON1
107:                   AD1CON2bits.CHPS = 0b01;    //sample channels 0-3
007674  B60322     AND AD1CON2, WREG
007676  A08000     BSET W0, #8
007678  881910     MOV W0, AD1CON2
108:                   AD1CON3bits.ADCS = 0x3F;    //tad ~ 1us
00767A  B3C3F0     MOV.B #0x3F, W0
00767C  B7E324     MOV.B WREG, AD1CON3
109:                   //AD1CHS0bits.CH0SA = 0x03;   //ch0->an3 (no use an0)
110:                   AD1CHS0bits.CH0NA = 0; // Select Vref- for CH0 -ve input
00767E  A9E328     BCLR AD1CHS0, #7
111:                   AD1CHS123bits.CH123NA = 0; // Select Vref- for CH1/CH2/CH3 -ve input
007680  2FFF90     MOV #0xFFF9, W0
007682  B62326     AND AD1CHS123
112:                   AD1CON1bits.ADON = 1;       //start ADC module
007684  A8E321     BSET 0x321, #7
113:                   Delay_us(20);
007686  200140     MOV #0x14, W0
007688  0701E6     RCALL Delay_us
114:               }
00768A  060000     RETURN
115:               
116:               void initPMP(void){
117:                   /*
118:                    Data is clocked on falling edge of E
119:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
120:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
121:                    */
122:                   PMMODEbits.MODE=3;  //master mode 1 
00768C  203000     MOV #0x300, W0
00768E  B72602     IOR PMMODE
123:                   PMCONbits.PTWREN = 1;
007690  A82601     BSET 0x601, #1
124:                   PMCONbits.PTRDEN = 1;
007692  A80601     BSET 0x601, #0
125:                   PMCONbits.WRSP=1;   //write strobe active high
007694  A82600     BSET PMCON, #1
126:                   PMCONbits.RDSP=1;   //read strobe active high
007696  A80600     BSET PMCON, #0
127:               
128:                   PMMODEbits.WAITB = 0;
007698  2FF3F0     MOV #0xFF3F, W0
00769A  B62602     AND PMMODE
129:                   PMMODEbits.WAITM = 0xC;
00769C  2FFC30     MOV #0xFFC3, W0
00769E  B60602     AND PMMODE, WREG
0076A0  B30300     IOR #0x30, W0
0076A2  883010     MOV W0, PMMODE
130:                   PMMODEbits.WAITE = 0;
0076A4  2FFFC0     MOV #0xFFFC, W0
0076A6  B62602     AND PMMODE
131:                   LCD_RS=0;
0076A8  A9EE45     BCLR 0xE45, #7
132:                   PMCONbits.PMPEN = 1;
0076AA  A8E601     BSET 0x601, #7
133:                   
134:                   
135:                   /* INIT DEVICE */
136:                   Delay_us(40000);
0076AC  29C400     MOV #0x9C40, W0
0076AE  0701D3     RCALL Delay_us
137:                   lcdInit();
0076B0  07FE25     RCALL lcdInit
138:                   
139:                   /* SETUP SCREEN */
140:                   lcdSetupPots();
0076B2  07FDE6     RCALL lcdSetupPots
141:               }
0076B4  060000     RETURN
142:               
143:               
144:               //Description: Initializes timer for LED's UART and display
145:               //Prereq: initUART1()
146:               //Dependencies: _T1Interrupt(void)
147:               //Frequency: 15Hz
148:               void initT1(void){          //16 bit timer
149:                   TMR1 = 0x0000;          //clear timer 4
0076B6  EF2100     CLR TMR1
150:                   T1CONbits.TCKPS = 3;    //prescale 1:256
0076B8  200300     MOV #0x30, W0
0076BA  B72104     IOR T1CON
151:                   T1CONbits.TCS = 0;      //use internal clock
0076BC  A92104     BCLR T1CON, #1
152:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
0076BE  A9C104     BCLR T1CON, #6
153:                   PR1 = Fcy/(256*Fdisp);    //period register
0076C0  223280     MOV #0x2328, W0
0076C2  880810     MOV W0, PR1
154:                   //PR1=0x7FFF;
155:                   IFS0bits.T1IF = 0;      //clear timer 1 interrupt flag
0076C4  A96800     BCLR IFS0, #3
156:                   IEC0bits.T1IE = 1;      //enable timer 1 interrupt
0076C6  A86820     BSET IEC0, #3
157:                   IPC0bits.T1IP = 2;      //interrupt priority 2 (low)
0076C8  28FFF0     MOV #0x8FFF, W0
0076CA  B60840     AND IPC0, WREG
0076CC  A0D000     BSET W0, #13
0076CE  884200     MOV W0, IPC0
158:                   T1CONbits.TON = 1;      //start timer
0076D0  A8E105     BSET 0x105, #7
159:               }
0076D2  060000     RETURN
160:               
161:               //Description:  Initializes timer handles polling button input
162:               //Prereq: initADC1() 
163:               //Dependencies: _T2Interrupt(void)
164:               //Frequency: 512Hz
165:               void initT2(void){          //16/32 bit timer
166:                   TMR2 = 0x0000;          //clear timer 4
0076D4  EF2106     CLR TMR2
167:                   T2CONbits.T32 = 0;      //16 bit mode
0076D6  A96110     BCLR T2CON, #3
168:                   T2CONbits.TCKPS = 1;    //prescale 1:8
0076D8  2FFCF0     MOV #0xFFCF, W0
0076DA  B60110     AND T2CON, WREG
0076DC  A04000     BSET W0, #4
0076DE  880880     MOV W0, T2CON
169:                   T2CONbits.TCS = 0;      //use internal clock
0076E0  A92110     BCLR T2CON, #1
170:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
0076E2  A9C110     BCLR T2CON, #6
171:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
0076E4  241EB0     MOV #0x41EB, W0
0076E6  880860     MOV W0, PR2
172:                   IFS0bits.T2IF = 0;      //clear timer 2 interrupt flag
0076E8  A9E800     BCLR IFS0, #7
173:                   IEC0bits.T2IE = 1;      //enable timer 2 interrupt
0076EA  A8E820     BSET IEC0, #7
174:                   IPC1bits.T2IP = 2;      //interrupt priority 2 (low)
0076EC  28FFF0     MOV #0x8FFF, W0
0076EE  B60842     AND IPC1, WREG
0076F0  A0D000     BSET W0, #13
0076F2  884210     MOV W0, IPC1
175:                   T2CONbits.TON = 1;      //start timer
0076F4  A8E111     BSET 0x111, #7
176:               }
0076F6  060000     RETURN
177:               
178:               //Description: Initialize timer handling ADC sampling
179:               //Prereq: initSPI_ADC()
180:               //Dependencies: _T3Interrupt(void)
181:               //Frequency: 44.1kHz
182:               //*Note: Currently unused as readDac is chained to DCI interrupt*
183:               void initT3(void){          //16/32 bit timer
184:                   TMR3 = 0x0000;          //clear timer 3
0076F8  EF210A     CLR TMR3
185:                   T3CONbits.TCKPS = 3;    //prescale 256:1
0076FA  200300     MOV #0x30, W0
0076FC  B72112     IOR T3CON
186:                   T3CONbits.TCS = 0;      //use internal clock
0076FE  A92112     BCLR T3CON, #1
187:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
007700  A9C112     BCLR T3CON, #6
188:                   PR3 = Fcy/(256*T3freq);           //period register
007702  200060     MOV #0x6, W0
007704  880870     MOV W0, PR3
189:                   //PR3 = 0xFFFF;
190:                   IFS0bits.T3IF = 0;      //clear timer 3 interrupt flag
007706  A90801     BCLR 0x801, #0
191:                   IEC0bits.T3IE = 1;      //enable timer 3 interrupt
007708  A80821     BSET 0x821, #0
192:                   IPC2bits.T3IP = 2;      //interrupt priority 3 (low)
00770A  2FFF80     MOV #0xFFF8, W0
00770C  B60844     AND IPC2, WREG
00770E  A01000     BSET W0, #1
007710  884220     MOV W0, IPC2
193:                   T3CONbits.TON = 1;      //start timer
007712  A8E113     BSET 0x113, #7
194:               }
007714  060000     RETURN
195:               
196:               //Description: Initializes & starts 16 bit DCI I2S DAC
197:               //Prereq: initSPI_ADC(void)
198:               //Dependencies: readDAC(void)
199:               void initDCI_DAC(void){
200:                   DCICON1bits.CSCKD=0;
007716  A94281     BCLR 0x281, #2
201:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
007718  2F0000     MOV #0xF000, W0
00771A  B60284     AND DCICON3, WREG
00771C  B30170     IOR #0x17, W0
00771E  881420     MOV W0, DCICON3
202:                   DCICON1bits.COFSM=1;    //i2s mode
007720  2FFFC0     MOV #0xFFFC, W0
007722  B60280     AND DCICON1, WREG
007724  A00000     BSET W0, #0
007726  881400     MOV W0, DCICON1
203:                   DCICON1bits.CSCKE=1;    //sample on rising edge
007728  A82281     BSET 0x281, #1
204:                   DCICON2bits.WS=0xF;     //16 bit data word
00772A  2000F0     MOV #0xF, W0
00772C  B72282     IOR DCICON2
205:                   DCICON2bits.COFSG=0;    //data frame has 1 words
00772E  2FE1F0     MOV #0xFE1F, W0
007730  B62282     AND DCICON2
206:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
007732  A80288     BSET TSCON, #0
207:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
007734  A82288     BSET TSCON, #1
208:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
007736  A8028C     BSET RSCON, #0
209:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
007738  A8228C     BSET RSCON, #1
210:                   DCICON1bits.DJST=0;     //align data
00773A  A9A280     BCLR DCICON1, #5
211:                   DCICON2bits.BLEN=1;     //2 words buffer btwn interrupts
00773C  2F3FF0     MOV #0xF3FF, W0
00773E  B60282     AND DCICON2, WREG
007740  A0A000     BSET W0, #10
007742  881410     MOV W0, DCICON2
212:                   IPC15bits.DCIIP = 6;    // Interrput priority
007744  2FFF80     MOV #0xFFF8, W0
007746  B6085E     AND IPC15, WREG
007748  B30060     IOR #0x6, W0
00774A  8842F0     MOV W0, IPC15
213:                   IFS3bits.DCIIF=0;
00774C  A98807     BCLR 0x807, #4
214:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
00774E  A88827     BSET 0x827, #4
215:                   TXBUF0=0;
007750  EF2298     CLR TXBUF0
216:                   TXBUF1=0;   
007752  EF229A     CLR TXBUF1
217:                   DCICON1bits.DCIEN=1;    //ENABLE
007754  A8E281     BSET 0x281, #7
218:               }
007756  060000     RETURN
219:               
220:               void initDMA0(void){
221:                   unsigned long address;
222:                   
223:                   /*
224:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
225:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
226:                   DMA0PAD =  0X0608; // Point DMA to PMP
227:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
228:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
229:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
230:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
231:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
232:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
233:                   DMA0CONbits.CHEN=1; // Enable DMA
234:                   */
235:                   
236:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
007758  A9CB01     BCLR 0xB01, #6
237:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
00775A  A8AB01     BSET 0xB01, #5
238:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
00775C  2FFCF4     MOV #0xFFCF, W4
00775E  20B000     MOV #0xB00, W0
007760  620810     AND W4, [W0], [W0]
239:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
007762  2FFFC3     MOV #0xFFFC, W3
007764  805801     MOV DMA0CON, W1
007766  618001     AND W3, W1, W0
007768  A01000     BSET W0, #1
00776A  885800     MOV W0, DMA0CON
240:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
00776C  A98B01     BCLR 0xB01, #4
241:                   DMA0CONbits.NULLW = 0;
00776E  A96B01     BCLR 0xB01, #3
242:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
007770  A9EB03     BCLR 0xB03, #7
243:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
007772  B3C3C2     MOV.B #0x3C, W2
007774  20B025     MOV #0xB02, W5
007776  784A82     MOV.B W2, [W5]
244:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
007778  27FFF0     MOV #0x7FFF, W0
00777A  2CF801     MOV #0xCF80, W1
00777C  608080     AND W1, W0, W1
245:                   address +=__builtin_edspage(txBufferA) << 15;
00777E  200016     MOV #0x1, W6
007780  DD334F     SL W6, #15, W6
007782  EB0380     CLR W7
007784  408306     ADD W1, W6, W6
007786  4B83E0     ADDC W7, #0x0, W7
246:                   DMA0STAL = address & 0xFFFF;
007788  885826     MOV W6, DMA0STAL
247:                   DMA0STAH = address >>16;
00778A  885837     MOV W7, DMA0STAH
248:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
00778C  2CF001     MOV #0xCF00, W1
00778E  608080     AND W1, W0, W1
249:                   address +=__builtin_edspage(txBufferB) << 15;
007790  200016     MOV #0x1, W6
007792  DD334F     SL W6, #15, W6
007794  EB0380     CLR W7
007796  408306     ADD W1, W6, W6
007798  4B83E0     ADDC W7, #0x0, W7
250:                   DMA0STBL = address & 0xFFFF;
00779A  885846     MOV W6, DMA0STBL
251:                   DMA0STBH = address >>16;
00779C  885857     MOV W7, DMA0STBH
252:                   DMA0PAD = (int)&TXBUF0;
00779E  202981     MOV #0x298, W1
0077A0  885861     MOV W1, DMA0PAD
253:                   DMA0CNT = STREAMBUF-1;
0077A2  2003F1     MOV #0x3F, W1
0077A4  885871     MOV W1, DMA0CNT
254:                   /* DMA 2 - DCI to DPSRAM*/
255:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
0077A6  A9CB21     BCLR 0xB21, #6
256:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
0077A8  A9AB21     BCLR 0xB21, #5
257:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
0077AA  A98B21     BCLR 0xB21, #4
258:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
0077AC  A96B21     BCLR 0xB21, #3
259:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
0077AE  20B205     MOV #0xB20, W5
0077B0  620A95     AND W4, [W5], [W5]
260:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
0077B2  805904     MOV DMA2CON, W4
0077B4  618184     AND W3, W4, W3
0077B6  A01003     BSET W3, #1
0077B8  885903     MOV W3, DMA2CON
261:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
0077BA  A9EB23     BCLR 0xB23, #7
262:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
0077BC  784182     MOV.B W2, W3
0077BE  20B225     MOV #0xB22, W5
0077C0  784A83     MOV.B W3, [W5]
263:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
0077C2  2CE804     MOV #0xCE80, W4
0077C4  620200     AND W4, W0, W4
264:                   address +=__builtin_edspage(rxBufferA) << 15;
0077C6  200012     MOV #0x1, W2
0077C8  DD114F     SL W2, #15, W2
0077CA  EB0180     CLR W3
0077CC  420102     ADD W4, W2, W2
0077CE  4981E0     ADDC W3, #0x0, W3
265:                   DMA2STAL = address & 0xFFFF;
0077D0  885922     MOV W2, DMA2STAL
266:                   DMA2STAH = address >>16;
0077D2  885933     MOV W3, DMA2STAH
267:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
0077D4  2CE002     MOV #0xCE00, W2
0077D6  610000     AND W2, W0, W0
268:                   address +=__builtin_edspage(rxBufferB) << 15;
0077D8  200012     MOV #0x1, W2
0077DA  DD114F     SL W2, #15, W2
0077DC  EB0180     CLR W3
0077DE  400102     ADD W0, W2, W2
0077E0  4981E0     ADDC W3, #0x0, W3
269:                   DMA2STBL = address & 0xFFFF;
0077E2  885942     MOV W2, DMA2STBL
270:                   DMA2STBH = address >>16;
0077E4  885953     MOV W3, DMA2STBH
271:                   DMA2PAD = (int)&RXBUF0;
0077E6  202900     MOV #0x290, W0
0077E8  885960     MOV W0, DMA2PAD
272:                   DMA2CNT = STREAMBUF-1;
0077EA  885971     MOV W1, DMA2CNT
273:                   _DMA2IP = 5;
0077EC  2FFF80     MOV #0xFFF8, W0
0077EE  B6084C     AND IPC6, WREG
0077F0  B30050     IOR #0x5, W0
0077F2  884260     MOV W0, IPC6
274:                   _DMA2IE = 1;
0077F4  A80823     BSET 0x823, #0
275:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
0077F6  A8EB01     BSET 0xB01, #7
276:                   DMA2CONbits.CHEN = 1;
0077F8  A8EB21     BSET 0xB21, #7
277:               }
0077FA  060000     RETURN
278:               
279:               /*
280:               void initCAP_BPM(void){
281:                   IFS0bits.IC1IF=0;
282:                   IPC0bits.IC1IP=3;
283:                   IC1CON1bits.ICTSEL=0;   //Fp is clock source (7))
284:                   IC1CON1bits.ICM=2;      //capture every falling edge
285:                   IC1CON2bits.ICTRIG=1;
286:                   IC1CON2bits.SYNCSEL=0xD;
287:                   IEC0bits.IC1IE=1;
288:               }
289:               
290:               //Description: Initializes 16 bit SPI ADC 
291:               //Prereq: NONE
292:               //Dependencies: NONE
293:               void initSPI2_ADC(void){
294:                   //ADC_CONV=1;                 //prevent shift as per errata
295:                   PORTBbits.RB10=1;           //prevent shift as per errata
296:                   IFS2bits.SPI2IF = 0;        // Clear the Interrupt flag
297:                   IEC2bits.SPI2IE = 0;        // Disable the interrupt
298:                   SPI2CON1bits.MSTEN=1;       //master mode
299:                   SPI2CON1bits.DISSCK = 0;    //Internal serial clock is enabled
300:                   SPI2CON1bits.MODE16=1;      //16 bit
301:                   SPI2CON1bits.DISSDO=1;      //no SDO 
302:                   SPI2CON1bits.SSEN=0;        //no use SS
303:                   SPI2CON2bits.FRMEN=0;       //no enable framed mode
304:                   SPI2CON2bits.SPIBEN=1;      //enhanced buffer mode
305:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
306:                   SPI2CON1bits.SMP=1;         //data sampled at end of output time
307:                   SPI2CON1bits.CKP=1;         //idle clock is high
308:                   SPI2CON1bits.CKE=1;         //data changes from H to L
309:                   SPI2CON1bits.PPRE=2;        //4:1 primary prescale
310:                   SPI2CON1bits.SPRE=0;        //8:1 secondary
311:                   SPI2STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
312:                   IPC8bits.SPI2IP = 5;        // Interrupt priority
313:                   IFS2bits.SPI2IF = 0;        // Clear the Interrupt flag
314:                   IEC2bits.SPI2IE = 1;        // Enable the interrupt
315:                   SPI2STATbits.SPIEN = 1;     //start SPI module
316:               }
317:               
318:               void initSPI3_SEG(void){
319:                   SEG_SEL = 1;
320:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
321:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
322:                   SPI3CON1bits.MSTEN=1;       //master mode
323:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
324:                   SPI3CON1bits.MODE16=1;      //16 bit
325:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
326:                   SPI3CON1bits.SSEN=0;        //use SS
327:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
328:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
329:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
330:                   SPI3CON1bits.SMP=0;         //data sampled at end of output time
331:                   SPI3CON1bits.CKP=0;         //idle clock is low
332:                   SPI3CON1bits.CKE=1;         //data changes from H to L
333:                   SPI3CON1bits.PPRE=1;        //4:1 primary prescale
334:                   SPI3CON1bits.SPRE=7;        //1:1 secondary
335:                   SPI3STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
336:                   IPC22bits.SPI3IP = 3;        // Interrupt priority
337:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
338:                   IEC5bits.SPI3IE = 0;        // Enable the interrupt
339:                   SPI3STATbits.SPIEN = 1;     //start SPI module
340:                   __delay32(40);
341:                   MAX7219_Init();
342:               }
343:               */
344:               
---  C:/Users/ryan/Documents/seniorproject/ps-040/audio.c  ----------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[8];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[4];
7:                 extern fractional pots_scaled[4];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                fractional mixer(fractional sample){
007A68  F80022     PUSH ACCA
007A6A  F80024     PUSH ACCAH
007A6C  F80026     PUSH ACCAU
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    
38:                
39:                    if(kick_playing==TRUE&&kick_ptr<kick_max){
007A6E  2103E1     MOV #0x103E, W1
007A70  784091     MOV.B [W1], W1
007A72  40CFE1     ADD.B W1, #0x1, [W15]
007A74  3A0011     BRA NZ, 0x7A98
007A76  874CC2     MOV 0xE998, W2
007A78  808203     MOV kick_ptr, W3
007A7A  518F82     SUB W3, W2, [W15]
007A7C  31000D     BRA C, 0x7A98
40:                        result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
007A7E  780200     MOV W0, W4
007A80  273325     MOV #0x7332, W5
007A82  C00113     MPY W4*W5, A
41:                        result1 = __builtin_add(result1,kick[kick_ptr++],0);
007A84  780003     MOV W3, W0
007A86  400080     ADD W0, W0, W1
007A88  292D82     MOV #0x92D8, W2
007A8A  410081     ADD W2, W1, W1
007A8C  780091     MOV [W1], W1
007A8E  E80000     INC W0, W0
007A90  888200     MOV W0, kick_ptr
007A92  C90001     ADD W1, A
42:                        sample=__builtin_sac(result1, 0);
007A94  CC0000     SAC A, W0
007A96  37000C     BRA 0x7AB0
43:                    }
44:                    else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
007A98  269882     MOV #0x6988, W2
007A9A  B3C013     MOV.B #0x1, W3
007A9C  11CF92     SUBR.B W3, [W2], [W15]
007A9E  3A0008     BRA NZ, 0x7AB0
007AA0  40CFE1     ADD.B W1, #0x1, [W15]
007AA2  3A0006     BRA NZ, 0x7AB0
007AA4  874CC1     MOV 0xE998, W1
007AA6  808204     MOV kick_ptr, W4
007AA8  520F81     SUB W4, W1, [W15]
007AAA  3A0002     BRA NZ, 0x7AB0
45:                        kick_playing=FALSE;
007AAC  EF703E     CLR.B kick_playing
46:                        kick_ptr=0;
007AAE  EF3040     CLR kick_ptr
47:                    }
48:                    /*
49:                    if(hat_playing==TRUE&&hat_ptr<hat_max){
50:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
51:                        result1 = __builtin_add(result1,hat[hat_ptr++],0);
52:                        sample=__builtin_sac(result1, 0);
53:                    }
54:                    else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
55:                        hat_playing=FALSE;
56:                        hat_ptr=0;
57:                    }
58:                     */
59:                
60:                    if(snare_playing==TRUE&&snare_ptr<snare_max){
007AB0  210421     MOV #0x1042, W1
007AB2  784091     MOV.B [W1], W1
007AB4  40CFE1     ADD.B W1, #0x1, [W15]
007AB6  3A0011     BRA NZ, 0x7ADA
007AB8  874CD2     MOV 0xE99A, W2
007ABA  808225     MOV snare_ptr, W5
007ABC  528F82     SUB W5, W2, [W15]
007ABE  31000D     BRA C, 0x7ADA
61:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
007AC0  780200     MOV W0, W4
007AC2  26CCC5     MOV #0x6CCC, W5
007AC4  C00113     MPY W4*W5, A
62:                        result1 = __builtin_add(result1,snare[snare_ptr++],0);
007AC6  808220     MOV snare_ptr, W0
007AC8  400080     ADD W0, W0, W1
007ACA  2BE382     MOV #0xBE38, W2
007ACC  410081     ADD W2, W1, W1
007ACE  780091     MOV [W1], W1
007AD0  E80000     INC W0, W0
007AD2  888220     MOV W0, snare_ptr
007AD4  C90001     ADD W1, A
63:                        sample=__builtin_sac(result1, 0);
007AD6  CC0000     SAC A, W0
007AD8  37000C     BRA 0x7AF2
64:                    }
65:                    else if (pad[2]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
007ADA  2698A2     MOV #0x698A, W2
007ADC  B3C013     MOV.B #0x1, W3
007ADE  11CF92     SUBR.B W3, [W2], [W15]
007AE0  3A0008     BRA NZ, 0x7AF2
007AE2  40CFE1     ADD.B W1, #0x1, [W15]
007AE4  3A0006     BRA NZ, 0x7AF2
007AE6  874CD1     MOV 0xE99A, W1
007AE8  808224     MOV snare_ptr, W4
007AEA  520F81     SUB W4, W1, [W15]
007AEC  3A0002     BRA NZ, 0x7AF2
66:                        snare_playing=FALSE;
007AEE  EF7042     CLR.B snare_playing
67:                        snare_ptr=0;
007AF0  EF3044     CLR snare_ptr
68:                    }
69:                    
70:                    
71:                    //VOLUME CONTROL
72:                    /*
73:                    if(pots[0]==0x001F)
74:                        sample=0;
75:                    else if(pots[0]>0xFFF0);
76:                    else{
77:                        result1 =__builtin_mpy(sample,pots[0], NULL, NULL, 0, NULL, NULL, 0);
78:                        sample=__builtin_sac(result1, 0);
79:                    }
80:                    */
81:                    if (TEST_SIN==TRUE){
007AF2  2101E1     MOV #0x101E, W1
007AF4  784091     MOV.B [W1], W1
007AF6  40CFE1     ADD.B W1, #0x1, [W15]
007AF8  3A000B     BRA NZ, 0x7B10
82:                        i++;
007AFA  EC1032     INC i, WREG
007AFC  888190     MOV W0, i
83:                        if(i==1024)
007AFE  204001     MOV #0x400, W1
007B00  500F81     SUB W0, W1, [W15]
007B02  3A0001     BRA NZ, 0x7B06
84:                            i=0;
007B04  EF3032     CLR i
85:                        return sintab[i];
007B06  808190     MOV i, W0
007B08  400000     ADD W0, W0, W0
007B0A  2E99C1     MOV #0xE99C, W1
007B0C  408000     ADD W1, W0, W0
007B0E  780010     MOV [W0], W0
86:                    }
87:                    else 
88:                        return sample;
89:                    
90:                }
007B10  F90026     POP ACCAU
007B12  F90024     POP ACCAH
007B14  F90022     POP ACCA
007B16  060000     RETURN
91:                
92:                fractional fx(fractional sample){
007B18  F80022     PUSH ACCA
007B1A  F80024     PUSH ACCAH
007B1C  F80026     PUSH ACCAU
007B1E  F80028     PUSH ACCB
007B20  F8002A     PUSH ACCBH
007B22  F8002C     PUSH ACCBU
93:                    volatile register int result1 asm("A");
94:                    volatile register int result2 asm("B");
95:                    static fractional delayed_sample;
96:                    static fractional trem_mod;
97:                    if(tremelo==TRUE){                                                          //TREMELO//
007B24  2101F1     MOV #0x101F, W1
007B26  784091     MOV.B [W1], W1
007B28  40CFE1     ADD.B W1, #0x1, [W15]
007B2A  3A0027     BRA NZ, 0x7B7A
98:                        if (trem_var<=pots_scaled[1]){
007B2C  808151     MOV trem_var, W1
007B2E  808052     MOV 0x100A, W2
007B30  510F81     SUB W2, W1, [W15]
007B32  39000F     BRA NC, 0x7B52
99:                            trem_var++;
007B34  E80081     INC W1, W1
007B36  888151     MOV W1, trem_var
100:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
007B38  808131     MOV tremelo_ptr, W1
007B3A  408081     ADD W1, W1, W1
007B3C  2E99C2     MOV #0xE99C, W2
007B3E  410081     ADD W2, W1, W1
007B40  780291     MOV [W1], W5
007B42  808254     MOV 0x104A, W4
007B44  C00113     MPY W4*W5, A
101:                           trem_mod=__builtin_sac(result1, 0);
007B46  CC0004     SAC A, W4
007B48  888174     MOV W4, trem_mod
102:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
007B4A  780280     MOV W0, W5
007B4C  C08113     MPY W4*W5, B
103:                           sample=__builtin_sac(result2, 0);
007B4E  CC8000     SAC B, W0
007B50  370014     BRA 0x7B7A
104:                       }
105:                       else{
106:                           trem_var=0;
007B52  EF302A     CLR trem_var
107:                           if(tremelo_ptr==1024)
007B54  204001     MOV #0x400, W1
007B56  808132     MOV tremelo_ptr, W2
007B58  510F81     SUB W2, W1, [W15]
007B5A  3A0001     BRA NZ, 0x7B5E
108:                               tremelo_ptr=0;
007B5C  EF3026     CLR tremelo_ptr
109:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
007B5E  808131     MOV tremelo_ptr, W1
007B60  408101     ADD W1, W1, W2
007B62  2E99C3     MOV #0xE99C, W3
007B64  418102     ADD W3, W2, W2
007B66  780292     MOV [W2], W5
007B68  E80081     INC W1, W1
007B6A  888131     MOV W1, tremelo_ptr
007B6C  808254     MOV 0x104A, W4
007B6E  C00113     MPY W4*W5, A
110:                           trem_mod=__builtin_sac(result1, 0);
007B70  CC0004     SAC A, W4
007B72  888174     MOV W4, trem_mod
111:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
007B74  780280     MOV W0, W5
007B76  C08113     MPY W4*W5, B
112:                           sample=__builtin_sac(result2, 0);
007B78  CC8000     SAC B, W0
113:                       }
114:                   }
115:                   if(looper==TRUE){                                                           //LOOPER// 
007B7A  210201     MOV #0x1020, W1
007B7C  784091     MOV.B [W1], W1
007B7E  40CFE1     ADD.B W1, #0x1, [W15]
007B80  3A0019     BRA NZ, 0x7BB4
116:                       if(loop_lim>=LOOP_BUF_SIZE)
007B82  22B100     MOV #0x2B10, W0
007B84  E31024     CP loop_lim
007B86  360002     BRA LEU, 0x7B8C
117:                           loop_lim=LOOP_BUF_SIZE;
007B88  E80000     INC W0, W0
007B8A  888120     MOV W0, loop_lim
118:                       if(loop_ptr<loop_lim){
007B8C  808120     MOV loop_lim, W0
007B8E  E31022     CP loop_ptr
007B90  310008     BRA C, 0x7BA2
119:                           sample = (loop[loop_ptr++]);
007B92  808111     MOV loop_ptr, W1
007B94  408001     ADD W1, W1, W0
007B96  210522     MOV #0x1052, W2
007B98  410000     ADD W2, W0, W0
007B9A  780010     MOV [W0], W0
007B9C  E80081     INC W1, W1
007B9E  888111     MOV W1, loop_ptr
007BA0  37001D     BRA 0x7BDC
120:                       }
121:                       else {
122:                           loop_ptr=0;
007BA2  EF3022     CLR loop_ptr
123:                           sample = (loop[loop_ptr++]);
007BA4  808111     MOV loop_ptr, W1
007BA6  408001     ADD W1, W1, W0
007BA8  210522     MOV #0x1052, W2
007BAA  410000     ADD W2, W0, W0
007BAC  780010     MOV [W0], W0
007BAE  E80081     INC W1, W1
007BB0  888111     MOV W1, loop_ptr
007BB2  370014     BRA 0x7BDC
124:                       }
125:                   }                                                                           
126:                   else {                                                                      //buffer
127:                       if(loop_ptr<LOOP_BUF_SIZE)
007BB4  22B101     MOV #0x2B10, W1
007BB6  808112     MOV loop_ptr, W2
007BB8  510F81     SUB W2, W1, [W15]
007BBA  3E0008     BRA GTU, 0x7BCC
128:                           loop[loop_ptr++]=sample;
007BBC  808111     MOV loop_ptr, W1
007BBE  408101     ADD W1, W1, W2
007BC0  210523     MOV #0x1052, W3
007BC2  418102     ADD W3, W2, W2
007BC4  780900     MOV W0, [W2]
007BC6  E80081     INC W1, W1
007BC8  888111     MOV W1, loop_ptr
007BCA  370008     BRA 0x7BDC
129:                       else {
130:                           loop_ptr=0;
007BCC  EF3022     CLR loop_ptr
131:                           loop[loop_ptr++]=sample;
007BCE  808111     MOV loop_ptr, W1
007BD0  408101     ADD W1, W1, W2
007BD2  210523     MOV #0x1052, W3
007BD4  418102     ADD W3, W2, W2
007BD6  780900     MOV W0, [W2]
007BD8  E80081     INC W1, W1
007BDA  888111     MOV W1, loop_ptr
132:                       }
133:                   }
134:                   
135:                                                                                               //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
136:                   if(lpf==TRUE){
007BDC  210211     MOV #0x1021, W1
007BDE  784091     MOV.B [W1], W1
007BE0  40CFE1     ADD.B W1, #0x1, [W15]
007BE2  3A0008     BRA NZ, 0x7BF4
137:                       result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
007BE4  808234     MOV 0x1046, W4
007BE6  780280     MOV W0, W5
007BE8  C08113     MPY W4*W5, B
138:                       result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
007BEA  808244     MOV 0x1048, W4
007BEC  808185     MOV delayed_sample, W5
007BEE  C08112     MAC W4*W5, B
139:                       delayed_sample=__builtin_sac(result2, 0);
007BF0  CC8000     SAC B, W0
007BF2  888180     MOV W0, delayed_sample
140:                       sample=delayed_sample;
141:                   }
142:                   return sample;
143:               }
007BF4  F9002C     POP ACCBU
007BF6  F9002A     POP ACCBH
007BF8  F90028     POP ACCB
007BFA  F90026     POP ACCAU
007BFC  F90024     POP ACCAH
007BFE  F90022     POP ACCA
007C00  060000     RETURN
144:               
145:               //test
