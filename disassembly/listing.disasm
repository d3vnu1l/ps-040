Disassembly Listing for sampler_0.49.2
Generated From:
/home/fbuga/Documents/ps-040/dist/default/production/ps-040.production.elf
Feb 1, 2018 6:19:35 PM

---  /home/fbuga/Documents/ps-040/utilitites.c  ---------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <libpic30.h>
4:                 #include <dsp.h>
5:                 #include <stdio.h>
6:                 #include <stdlib.h>
7:                 #include <math.h>
8:                 #include "common.h"
9:                 #include "sounds.h"
10:                #include "audio.h"
11:                #include "flash.h"
12:                #include "screens.h"
13:                #include "utilities.h"
14:                #include "devInits.h"
15:                
16:                fractional FXSCALE = Q15(NUMFX*0.000030518509476);
17:                
18:                //CONTROL VARIABLES//
19:                extern unsigned char pad[BUTTONS];
20:                extern fractional pots[POTS];
21:                extern fractional pots_scaled[POTS];
22:                extern fractional pots_custom[POTS];
23:                extern unsigned char UART_ON; 
24:                extern enum screenStruc state;
25:                
26:                //STATUS VARIABLES//
27:                extern unsigned char hard_clipped;
28:                extern unsigned char UART_EN;
29:                extern unsigned char TEST_SIN;
30:                
31:                extern enum fxStruct fxUnits[NUMFXUNITS];
32:                
33:                
34:                //FX FLAGS & VARS
35:                extern unsigned char kick_playing, snare_playing;   
36:                
37:                void scanButtons(void){
38:                    
39:                    static unsigned char pad_last[BUTTONS]={1};
40:                    int portrdG, portrdD, portrdF;
41:                
42:                    portrdG = PORTG;
008C04  807313     MOV PORTG, W3
43:                    portrdD = PORTD;
008C06  807191     MOV PORTD, W1
44:                    portrdF = PORTF;
008C08  807292     MOV PORTF, W2
45:                    
46:                    pad[34]=(portrdF>>7)&1;     // Special function button
008C0A  DE9247     ASR W2, #7, W4
008C0C  624261     AND.B W4, #0x1, W4
008C0E  268D45     MOV #0x68D4, W5
008C10  784A84     MOV.B W4, [W5]
47:                    
48:                    if(pad[34]){
008C12  320033     BRA Z, 0x8C7A
49:                        pad[6]=(portrdF>>6)&1;
008C14  DE92C6     ASR W2, #6, W5
008C16  268B84     MOV #0x68B8, W4
008C18  62CA61     AND.B W5, #0x1, [W4]
50:                        pad[5]=(portrdF>>5)&1;
008C1A  DE92C5     ASR W2, #5, W5
008C1C  E90204     DEC W4, W4
008C1E  62CA61     AND.B W5, #0x1, [W4]
51:                        pad[4]=(portrdF>>4)&1;
008C20  DE9144     ASR W2, #4, W2
008C22  E90204     DEC W4, W4
008C24  614A61     AND.B W2, #0x1, [W4]
52:                        pad[0]=(portrdG)&1;
008C26  520164     SUB W4, #0x4, W2
008C28  61C961     AND.B W3, #0x1, [W2]
53:                        pad[1]=(portrdG>>1)&1;
008C2A  D18203     ASR W3, W4
008C2C  E80102     INC W2, W2
008C2E  624961     AND.B W4, #0x1, [W2]
54:                        pad[2]=(portrdG>>2)&1;
008C30  DE9A42     ASR W3, #2, W4
008C32  E80102     INC W2, W2
008C34  624961     AND.B W4, #0x1, [W2]
55:                        pad[3]=(portrdG>>3)&1;
008C36  DE9A43     ASR W3, #3, W4
008C38  E80102     INC W2, W2
008C3A  624961     AND.B W4, #0x1, [W2]
56:                        pad[16]=(portrdG>>10)&1;    // Encoder button
008C3C  DE9A4A     ASR W3, #10, W4
008C3E  41016D     ADD W2, #0xD, W2
008C40  624961     AND.B W4, #0x1, [W2]
57:                        pad[11]=(portrdG>>11)&1;
008C42  DE9A4B     ASR W3, #11, W4
008C44  510165     SUB W2, #0x5, W2
008C46  624961     AND.B W4, #0x1, [W2]
58:                        pad[12]=(portrdG>>12)&1;
008C48  DE9A4C     ASR W3, #12, W4
008C4A  E80102     INC W2, W2
008C4C  624961     AND.B W4, #0x1, [W2]
59:                        pad[13]=(portrdG>>13)&1;
008C4E  DE9A4D     ASR W3, #13, W4
008C50  E80102     INC W2, W2
008C52  624961     AND.B W4, #0x1, [W2]
60:                        pad[14]=(portrdG>>14)&1;
008C54  DE984E     ASR W3, #14, W0
008C56  E80102     INC W2, W2
008C58  604961     AND.B W0, #0x1, [W2]
61:                        pad[15]=(portrdG>>15)&1;
008C5A  DE19CF     LSR W3, #15, W3
008C5C  E80002     INC W2, W0
008C5E  784803     MOV.B W3, [W0]
62:                        pad[7]=(portrdD>>1)&1;
008C60  D18101     ASR W1, W2
008C62  500068     SUB W0, #0x8, W0
008C64  614861     AND.B W2, #0x1, [W0]
63:                        pad[8]=(portrdD>>2)&1;
008C66  DE8942     ASR W1, #2, W2
008C68  E80000     INC W0, W0
008C6A  614861     AND.B W2, #0x1, [W0]
64:                        pad[9]=(portrdD>>3)&1;
008C6C  DE8943     ASR W1, #3, W2
008C6E  E80000     INC W0, W0
008C70  614861     AND.B W2, #0x1, [W0]
65:                        pad[10]=(portrdD>>4)&1;
008C72  DE88C4     ASR W1, #4, W1
008C74  E80000     INC W0, W0
008C76  60C861     AND.B W1, #0x1, [W0]
008C78  370032     BRA 0x8CDE
66:                    } else {
67:                        pad[23]=(portrdF>>6)&1;
008C7A  DE92C6     ASR W2, #6, W5
008C7C  268C94     MOV #0x68C9, W4
008C7E  62CA61     AND.B W5, #0x1, [W4]
68:                        pad[22]=(portrdF>>5)&1;
008C80  DE92C5     ASR W2, #5, W5
008C82  E90204     DEC W4, W4
008C84  62CA61     AND.B W5, #0x1, [W4]
69:                        pad[21]=(portrdF>>4)&1;
008C86  DE9144     ASR W2, #4, W2
008C88  E90204     DEC W4, W4
008C8A  614A61     AND.B W2, #0x1, [W4]
70:                        pad[17]=(portrdG)&1;
008C8C  520164     SUB W4, #0x4, W2
008C8E  61C961     AND.B W3, #0x1, [W2]
71:                        pad[18]=(portrdG>>1)&1;
008C90  D18203     ASR W3, W4
008C92  E80102     INC W2, W2
008C94  624961     AND.B W4, #0x1, [W2]
72:                        pad[19]=(portrdG>>2)&1;
008C96  DE9A42     ASR W3, #2, W4
008C98  E80102     INC W2, W2
008C9A  624961     AND.B W4, #0x1, [W2]
73:                        pad[20]=(portrdG>>3)&1;
008C9C  DE9A43     ASR W3, #3, W4
008C9E  E80102     INC W2, W2
008CA0  624961     AND.B W4, #0x1, [W2]
74:                        pad[33]=(portrdG>>10)&1;    // Encoder button
008CA2  DE9A4A     ASR W3, #10, W4
008CA4  41016D     ADD W2, #0xD, W2
008CA6  624961     AND.B W4, #0x1, [W2]
75:                        pad[28]=(portrdG>>11)&1;
008CA8  DE9A4B     ASR W3, #11, W4
008CAA  510165     SUB W2, #0x5, W2
008CAC  624961     AND.B W4, #0x1, [W2]
76:                        pad[29]=(portrdG>>12)&1;
008CAE  DE9A4C     ASR W3, #12, W4
008CB0  E80102     INC W2, W2
008CB2  624961     AND.B W4, #0x1, [W2]
77:                        pad[30]=(portrdG>>13)&1;
008CB4  DE9A4D     ASR W3, #13, W4
008CB6  E80102     INC W2, W2
008CB8  624961     AND.B W4, #0x1, [W2]
78:                        pad[31]=(portrdG>>14)&1;
008CBA  DE984E     ASR W3, #14, W0
008CBC  E80102     INC W2, W2
008CBE  604961     AND.B W0, #0x1, [W2]
79:                        pad[32]=(portrdG>>15)&1;
008CC0  DE19CF     LSR W3, #15, W3
008CC2  E80002     INC W2, W0
008CC4  784803     MOV.B W3, [W0]
80:                        pad[24]=(portrdD>>1)&1;
008CC6  D18101     ASR W1, W2
008CC8  500068     SUB W0, #0x8, W0
008CCA  614861     AND.B W2, #0x1, [W0]
81:                        pad[25]=(portrdD>>2)&1;
008CCC  DE8942     ASR W1, #2, W2
008CCE  E80000     INC W0, W0
008CD0  614861     AND.B W2, #0x1, [W0]
82:                        pad[26]=(portrdD>>3)&1;
008CD2  DE8943     ASR W1, #3, W2
008CD4  E80000     INC W0, W0
008CD6  614861     AND.B W2, #0x1, [W0]
83:                        pad[27]=(portrdD>>4)&1;
008CD8  DE88C4     ASR W1, #4, W1
008CDA  E80000     INC W0, W0
008CDC  60C861     AND.B W1, #0x1, [W0]
84:                    }
85:                    
86:                    // SAMPLE TRIGGERS 
87:                    if(pad[0]==0&&kick_playing==FALSE){                                         //kick
008CDE  268B20     MOV #0x68B2, W0
008CE0  E00410     CP0.B [W0]
008CE2  3A0003     BRA NZ, 0x8CEA
008CE4  E2501E     CP0.B kick_playing
008CE6  3A0001     BRA NZ, 0x8CEA
88:                        kick_playing=TRUE;
008CE8  EFF01E     SETM.B kick_playing
89:                    }
90:                    /*
91:                    if(pad[2]==0&&hat_playing==FALSE){                                          //hat
92:                        hat_playing=TRUE;
93:                    }
94:                    */
95:                    if(pad[1]==0&&snare_playing==FALSE){                                        //snare
008CEA  268B30     MOV #0x68B3, W0
008CEC  E00410     CP0.B [W0]
008CEE  3A0003     BRA NZ, 0x8CF6
008CF0  E25022     CP0.B snare_playing
008CF2  3A0001     BRA NZ, 0x8CF6
96:                        snare_playing=TRUE;
008CF4  EFF022     SETM.B snare_playing
97:                    }
98:                }
008CF6  060000     RETURN
99:                
100:               void readPots(void){
008CF8  4787F2     ADD W15, #0x12, W15
008CFA  BE9F88     MOV.D W8, [W15++]
008CFC  BE9F8A     MOV.D W10, [W15++]
008CFE  BE9F8C     MOV.D W12, [W15++]
008D00  781F8E     MOV W14, [W15++]
008D02  F80022     PUSH ACCA
008D04  F80024     PUSH ACCAH
008D06  F80026     PUSH ACCAU
101:                   volatile register int result asm("A");
102:                   fractional pots_buf[POTS/2]; 
103:                   fractional pots_last[POTS/2];
104:                   static fractional pots_smoothed[POTS/2];
105:                   const fractional pot_alpha = 0x0F80;    //larger = rougher, lower = more latency
106:                   const fractional pot_alpha_inv = 32767-pot_alpha;
107:                   const unsigned int shift = 0xFE00;
108:                   int i;
109:                   _AD1IF = 0; // Clear conversion done status bit
008D08  A9A801     BCLR 0x801, #5
110:                   if(pad[34])i=0;
008D0C  268D40     MOV #0x68D4, W0
008D0E  E00410     CP0.B [W0]
008D10  320001     BRA Z, 0x8D14
008D12  EB0080     CLR W1
111:                   else i=POTS/2;
008D0A  200061     MOV #0x6, W1
112:                   pots_buf[0]=(ADC1BUF5>>1)|0x7;
008D14  D5030A     LSR ADC1BUF5, WREG
008D16  780680     MOV W0, W13
008D18  B3007D     IOR #0x7, W13
113:                   pots_buf[1]=(ADC1BUF2>>1)|0x7;
008D1A  D50304     LSR ADC1BUF2, WREG
008D1C  780600     MOV W0, W12
008D1E  B3007C     IOR #0x7, W12
114:                   pots_buf[2]=(ADC1BUF4>>1)|0x7;
008D20  D50308     LSR ADC1BUF4, WREG
008D22  780580     MOV W0, W11
008D24  B3007B     IOR #0x7, W11
115:                   pots_buf[3]=(ADC1BUF1>>1)|0x7;
008D26  D50302     LSR ADC1BUF1, WREG
008D28  780200     MOV W0, W4
008D2A  B30074     IOR #0x7, W4
008D2C  9FB7D4     MOV W4, [W15-22]
116:                   pots_buf[4]=(ADC1BUF3>>1)|0x7;
008D2E  D50306     LSR ADC1BUF3, WREG
008D30  780280     MOV W0, W5
008D32  B30075     IOR #0x7, W5
008D34  9FB7C5     MOV W5, [W15-24]
117:                   pots_buf[5]=(ADC1BUF0>>1)|0x7;
008D36  D50300     LSR ADC1BUF0, WREG
008D38  780500     MOV W0, W10
008D3A  B3007A     IOR #0x7, W10
118:                   
119:                   pots_last[0]=(pots_smoothed[0]&shift);
008D3C  26D9C2     MOV #0x6D9C, W2
008D3E  2FE000     MOV #0xFE00, W0
008D40  600312     AND W0, [W2], W6
008D42  9FB7B6     MOV W6, [W15-26]
120:                   pots_last[1]=(pots_smoothed[1]&shift);
008D44  E88482     INC2 W2, W9
008D46  600199     AND W0, [W9], W3
008D48  9FB7A3     MOV W3, [W15-28]
121:                   pots_last[2]=(pots_smoothed[2]&shift);
008D4A  410464     ADD W2, #0x4, W8
008D4C  600218     AND W0, [W8], W4
008D4E  9FB794     MOV W4, [W15-30]
122:                   pots_last[3]=(pots_smoothed[3]&shift);
008D50  4103E6     ADD W2, #0x6, W7
008D52  600297     AND W0, [W7], W5
008D54  9FB785     MOV W5, [W15-32]
123:                   pots_last[4]=(pots_smoothed[4]&shift);
008D56  410368     ADD W2, #0x8, W6
008D58  600316     AND W0, [W6], W6
008D5A  9FAFF6     MOV W6, [W15-34]
124:                   pots_last[5]=(pots_smoothed[5]&shift);
008D5C  4101EA     ADD W2, #0xA, W3
008D5E  600213     AND W0, [W3], W4
008D60  9FAFE4     MOV W4, [W15-36]
125:                   
126:                   result =__builtin_mpy(pots_buf[0],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
008D62  20F805     MOV #0xF80, W5
008D64  78030D     MOV W13, W6
008D66  C40113     MPY W5*W6, A
127:                   result =__builtin_mac(result, pots_smoothed[0], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008D68  780712     MOV [W2], W14
008D6A  2707F4     MOV #0x707F, W4
008D6C  78030E     MOV W14, W6
008D6E  C10112     MAC W4*W6, A
128:                   pots_smoothed[0]=__builtin_sac(result, 0);
008D70  CC0012     SAC A, [W2]
129:                   result =__builtin_mpy(pots_buf[1],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
008D72  78030C     MOV W12, W6
008D74  C40113     MPY W5*W6, A
130:                   result =__builtin_mac(result, pots_smoothed[1], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008D76  780319     MOV [W9], W6
008D78  C10112     MAC W4*W6, A
131:                   pots_smoothed[1]=__builtin_sac(result, 0);
008D7A  CC0019     SAC A, [W9]
132:                   result =__builtin_mpy(pots_buf[2],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
008D7C  78030B     MOV W11, W6
008D7E  C40113     MPY W5*W6, A
133:                   result =__builtin_mac(result, pots_smoothed[2], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008D80  780318     MOV [W8], W6
008D82  C10112     MAC W4*W6, A
134:                   pots_smoothed[2]=__builtin_sac(result, 0);
008D84  CC0018     SAC A, [W8]
135:                   result =__builtin_mpy(pots_buf[3],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
008D86  97B35F     MOV [W15-22], W6
008D88  C40113     MPY W5*W6, A
136:                   result =__builtin_mac(result, pots_smoothed[3], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008D8A  780317     MOV [W7], W6
008D8C  C10112     MAC W4*W6, A
137:                   pots_smoothed[3]=__builtin_sac(result, 0);
008D8E  CC0017     SAC A, [W7]
138:                   result =__builtin_mpy(pots_buf[4],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
008D90  97B34F     MOV [W15-24], W6
008D92  C40113     MPY W5*W6, A
139:                   result =__builtin_mac(result, pots_smoothed[4], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008D94  410368     ADD W2, #0x8, W6
008D96  780396     MOV [W6], W7
008D98  C20112     MAC W4*W7, A
140:                   pots_smoothed[4]=__builtin_sac(result, 0);
008D9A  CC0016     SAC A, [W6]
141:                   result =__builtin_mpy(pots_buf[5],pot_alpha, NULL, NULL, 0, NULL, NULL, 0);
008D9C  78030A     MOV W10, W6
008D9E  C40113     MPY W5*W6, A
142:                   result =__builtin_mac(result, pots_smoothed[5], pot_alpha_inv, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008DA0  780293     MOV [W3], W5
008DA2  C00112     MAC W4*W5, A
143:                   pots_smoothed[5]=__builtin_sac(result, 0);
008DA4  CC0004     SAC A, W4
008DA6  780984     MOV W4, [W3]
144:                   
145:                   if((pots_smoothed[0]&shift)!=pots_last[0]) 
008DA8  600012     AND W0, [W2], W0
008DAA  97B13F     MOV [W15-26], W2
008DAC  500F82     SUB W0, W2, [W15]
008DAE  320004     BRA Z, 0x8DB8
146:                       pots[i]=pots_buf[0];
008DB0  408001     ADD W1, W1, W0
008DB2  2606A2     MOV #0x606A, W2
008DB4  410000     ADD W2, W0, W0
008DB6  78080D     MOV W13, [W0]
147:                   if((pots_smoothed[1]&shift)!=pots_last[1]) 
008DB8  2FE000     MOV #0xFE00, W0
008DBA  26D9E2     MOV #0x6D9E, W2
008DBC  600012     AND W0, [W2], W0
008DBE  97B1AF     MOV [W15-28], W3
008DC0  500F83     SUB W0, W3, [W15]
008DC2  320005     BRA Z, 0x8DCE
148:                       pots[i+1]=pots_buf[1];
008DC4  E80001     INC W1, W0
008DC6  400000     ADD W0, W0, W0
008DC8  2606A2     MOV #0x606A, W2
008DCA  410000     ADD W2, W0, W0
008DCC  78080C     MOV W12, [W0]
149:                   if((pots_smoothed[2]&shift)!=pots_last[2]) 
008DCE  2FE000     MOV #0xFE00, W0
008DD0  26DA02     MOV #0x6DA0, W2
008DD2  600012     AND W0, [W2], W0
008DD4  97B29F     MOV [W15-30], W5
008DD6  500F85     SUB W0, W5, [W15]
008DD8  320005     BRA Z, 0x8DE4
150:                       pots[i+2]=pots_buf[2];
008DDA  E88001     INC2 W1, W0
008DDC  400000     ADD W0, W0, W0
008DDE  2606A2     MOV #0x606A, W2
008DE0  410000     ADD W2, W0, W0
008DE2  78080B     MOV W11, [W0]
151:                   if((pots_smoothed[3]&shift)!=pots_last[3]) 
008DE4  2FE000     MOV #0xFE00, W0
008DE6  26DA22     MOV #0x6DA2, W2
008DE8  600012     AND W0, [W2], W0
008DEA  97B30F     MOV [W15-32], W6
008DEC  500F86     SUB W0, W6, [W15]
008DEE  320006     BRA Z, 0x8DFC
152:                       pots[i+3]=pots_buf[3];
008DF0  408063     ADD W1, #0x3, W0
008DF2  400000     ADD W0, W0, W0
008DF4  2606A2     MOV #0x606A, W2
008DF6  410000     ADD W2, W0, W0
008DF8  97B2DF     MOV [W15-22], W5
008DFA  780805     MOV W5, [W0]
153:                   if((pots_smoothed[4]&shift)!=pots_last[4]) 
008DFC  2FE000     MOV #0xFE00, W0
008DFE  26DA42     MOV #0x6DA4, W2
008E00  600012     AND W0, [W2], W0
008E02  97AB7F     MOV [W15-34], W6
008E04  500F86     SUB W0, W6, [W15]
008E06  320006     BRA Z, 0x8E14
154:                       pots[i+4]=pots_buf[4];
008E08  408064     ADD W1, #0x4, W0
008E0A  400000     ADD W0, W0, W0
008E0C  2606A2     MOV #0x606A, W2
008E0E  410000     ADD W2, W0, W0
008E10  97B2CF     MOV [W15-24], W5
008E12  780805     MOV W5, [W0]
155:                   if((pots_smoothed[5]&shift)!=pots_last[5]) 
008E14  2FE000     MOV #0xFE00, W0
008E16  620200     AND W4, W0, W4
008E18  97AB6F     MOV [W15-36], W6
008E1A  520F86     SUB W4, W6, [W15]
008E1C  320005     BRA Z, 0x8E28
156:                       pots[i+5]=pots_buf[5];     
008E1E  4080E5     ADD W1, #0x5, W1
008E20  408081     ADD W1, W1, W1
008E22  2606A0     MOV #0x606A, W0
008E24  400081     ADD W0, W1, W1
008E26  78088A     MOV W10, [W1]
157:               }
008E28  F90026     POP ACCAU
008E2A  F90024     POP ACCAH
008E2C  F90022     POP ACCA
008E2E  78074F     MOV [--W15], W14
008E30  BE064F     MOV.D [--W15], W12
008E32  BE054F     MOV.D [--W15], W10
008E34  BE044F     MOV.D [--W15], W8
008E36  B1012F     SUB #0x12, W15
008E38  060000     RETURN
158:               
159:               void scalePots(void){
008E3A  F80022     PUSH ACCA
008E3C  F80024     PUSH ACCAH
008E3E  F80026     PUSH ACCAU
160:                   /* Potentiometer scaling for fx or lcd display */
161:                   volatile register int scaled asm("A");
162:                   
163:                   scaled=__builtin_mpy(pots[0],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008E40  232644     MOV #0x3264, W4
008E42  830355     MOV pots, W5
008E44  C00113     MPY W4*W5, A
164:                   pots_scaled[0]=__builtin_sac(scaled, 7);
008E46  260820     MOV #0x6082, W0
008E48  CC0390     SAC A, #7, [W0]
165:                   scaled=__builtin_mpy(pots[1],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008E4A  830365     MOV 0x606C, W5
008E4C  C00113     MPY W4*W5, A
166:                   pots_scaled[1]=__builtin_sac(scaled, 7);
008E4E  E88000     INC2 W0, W0
008E50  CC0390     SAC A, #7, [W0]
167:                   scaled=__builtin_mpy(pots[2],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008E52  830375     MOV 0x606E, W5
008E54  C00113     MPY W4*W5, A
168:                   pots_scaled[2]=__builtin_sac(scaled, 7);
008E56  E88000     INC2 W0, W0
008E58  CC0390     SAC A, #7, [W0]
169:                   scaled=__builtin_mpy(pots[3],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008E5A  830385     MOV 0x6070, W5
008E5C  C00113     MPY W4*W5, A
170:                   pots_scaled[3]=__builtin_sac(scaled, 7);
008E5E  E88000     INC2 W0, W0
008E60  CC0390     SAC A, #7, [W0]
171:                   scaled=__builtin_mpy(pots[4],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008E62  830395     MOV 0x6072, W5
008E64  C00113     MPY W4*W5, A
172:                   pots_scaled[4]=__builtin_sac(scaled, 7);
008E66  E88000     INC2 W0, W0
008E68  CC0390     SAC A, #7, [W0]
173:                   scaled=__builtin_mpy(pots[5],POT_PERCENT, NULL, NULL, 0, NULL, NULL, 0);
008E6A  8303A5     MOV 0x6074, W5
008E6C  C00113     MPY W4*W5, A
174:                   pots_scaled[5]=__builtin_sac(scaled, 7);
008E6E  E88000     INC2 W0, W0
008E70  CC0390     SAC A, #7, [W0]
175:                   
176:                   scaled=__builtin_mpy(pots[POT_FX_SELECT1],FXSCALE, NULL, NULL, 0, NULL, NULL, 0);
008E72  808234     MOV 0x1046, W4
008E74  8303F5     MOV 0x607E, W5
008E76  C00113     MPY W4*W5, A
177:                   pots_scaled[POT_FX_SELECT1]=__builtin_sac(scaled, 0);
008E78  40006A     ADD W0, #0xA, W0
008E7A  CC0010     SAC A, [W0]
178:                   scaled=__builtin_mpy(pots[POT_FX_SELECT2],FXSCALE, NULL, NULL, 0, NULL, NULL, 0);
008E7C  830405     MOV 0x6080, W5
008E7E  C00113     MPY W4*W5, A
179:                   pots_scaled[POT_FX_SELECT2]=__builtin_sac(scaled, 0);
008E80  E88000     INC2 W0, W0
008E82  CC0010     SAC A, [W0]
180:               }
008E84  F90026     POP ACCAU
008E86  F90024     POP ACCAH
008E88  F90022     POP ACCA
008E8A  060000     RETURN
181:               
182:               fractional scalePotsCustom(unsigned int steps, fractional scaleme){
008E8C  781F88     MOV W8, [W15++]
008E8E  F80022     PUSH ACCA
008E90  F80024     PUSH ACCAH
008E92  F80026     PUSH ACCAU
008E94  780100     MOV W0, W2
008E96  780401     MOV W1, W8
183:                   volatile register int scaled asm("A");
184:                   fractional scale = Q15(steps*0.000030518509476);
008E98  B81061     MUL.UU W2, #1, W0
008E9A  07BBA6     RCALL ___floatunsisf
008E9C  201002     MOV #0x100, W2
008E9E  238003     MOV #0x3800, W3
008EA0  07BBF8     RCALL ___mulsf3
008EA2  2FE002     MOV #0xFE00, W2
008EA4  246FF3     MOV #0x46FF, W3
008EA6  07BBF5     RCALL ___mulsf3
008EA8  200002     MOV #0x0, W2
008EAA  23F003     MOV #0x3F00, W3
008EAC  07BB1F     RCALL ___addsf3
008EAE  07BB7B     RCALL ___fixsfsi
185:                   
186:                   scaled=__builtin_mpy(scaleme,scale, NULL, NULL, 0, NULL, NULL, 0);
008EB0  780208     MOV W8, W4
008EB2  780280     MOV W0, W5
008EB4  C00113     MPY W4*W5, A
187:                   return(__builtin_sac(scaled, 0));
008EB6  CC0000     SAC A, W0
188:               }
008EB8  F90026     POP ACCAU
008EBA  F90024     POP ACCAH
008EBC  F90022     POP ACCA
008EBE  78044F     MOV [--W15], W8
008EC0  060000     RETURN
189:               
190:               void changeFX(void){
191:                   fxUnits[0]=pots_scaled[POT_FX_SELECT1];
008EC2  8304B0     MOV 0x6096, W0
008EC4  888060     MOV W0, fxUnits
192:                   fxUnits[1]=pots_scaled[POT_FX_SELECT2];
008EC6  8304C0     MOV 0x6098, W0
008EC8  888070     MOV W0, 0x100E
193:               }
008ECA  060000     RETURN
194:               
195:               void display(void){
196:                   scalePots();
008ECC  07FFB6     RCALL scalePots
197:                   changeFX();
008ECE  07FFF9     RCALL changeFX
198:                   // Update ui state logic here
199:                   state = (ENCODERCNTL/4)+1;
008ED0  800E30     MOV POS1CNTL, W0
008ED2  DE0042     LSR W0, #2, W0
008ED4  E80000     INC W0, W0
008ED6  8881C0     MOV W0, 0x1038
200:                   
201:                   // Update screen here
202:                   screenUpdate();
008ED8  07FB23     RCALL screenUpdate
203:                  
204:                  if(UART_ON==TRUE){
008EDA  BFD007     MOV.B UART_ON, WREG
008EDC  404FE1     ADD.B W0, #0x1, [W15]
008EDE  3A0007     BRA NZ, 0x8EEE
205:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
206:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
207:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
208:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
008EE0  F8606E     PUSH 0x606E
008EE2  F8606C     PUSH 0x606C
008EE4  F8606A     PUSH pots
008EE6  2FA280     MOV #0xFA28, W0
008EE8  781F80     MOV W0, [W15++]
008EEA  07BC44     RCALL __printf_cdnopuxX
008EEC  5787E8     SUB W15, #0x8, W15
209:                       //printf("%d\r\n", sample);  //check input ADC
210:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
211:                   }
212:                  
213:                  SLED=~SLED;
008EEE  8072A0     MOV LATF, W0
008EF0  EA8000     COM W0, W0
008EF2  600061     AND W0, #0x1, W0
008EF4  8072A1     MOV LATF, W1
008EF6  A10001     BCLR W1, #0
008EF8  700081     IOR W0, W1, W1
008EFA  8872A1     MOV W1, LATF
214:               }
008EFC  060000     RETURN
215:               
216:               void processRxData(fractional *sourceBuffer, fractional *targetBuffer){
217:                   /* This procedure loops back the received data to the*/
218:                   /* the codec output. The user application could process*/
219:                   /* this data as per application requirements.*/
220:                   int index;
221:                   for(index = 0;index < STREAMBUF;index ++)
008EFE  EB0100     CLR W2
008F00  201003     MOV #0x100, W3
008F04  E80102     INC W2, W2
008F06  510F83     SUB W2, W3, [W15]
008F08  3AFFFC     BRA NZ, 0x8F02
222:                   {
223:                       targetBuffer[index] = sourceBuffer[index];
008F02  7818B0     MOV [W0++], [W1++]
224:                   }
225:               }
008F0A  060000     RETURN
226:               
227:               //A blocking delay function. Not very accurate but good enough.
228:               void Delay_us(unsigned int delay)
229:               {
230:                   int i;
231:                   for (i = 0; i < delay; i++)
008F0C  E00000     CP0 W0
008F0E  320006     BRA Z, 0x8F1C
008F10  EB0080     CLR W1
008F16  E80081     INC W1, W1
008F18  500F81     SUB W0, W1, [W15]
008F1A  3EFFFB     BRA GTU, 0x8F12
232:                   {
233:                       __asm__ volatile ("repeat #50");
008F12  090032     REPEAT #0x32
234:                       __asm__ volatile ("nop");
008F14  000000     NOP
235:                   }
236:               }
008F1C  060000     RETURN
---  /home/fbuga/Documents/ps-040/screens.c  ------------------------------------------------------------
1:                 /*
2:                  * File:   screens.c
3:                  * Author: ryan
4:                  *
5:                  * Created on January 28, 2018, 11:17 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "screens.h"
11:                #include "common.h"
12:                #include "plcd.h"
13:                #include "dsp.h"
14:                #include "flash.h"
15:                
16:                extern unsigned char TEST_SIN;
17:                extern fractional pots[POTS];
18:                extern fractional pots_scaled[POTS];
19:                extern unsigned char pad[BUTTONS];
20:                extern enum screenStruc state, laststate;
21:                extern char flash_readback[512];
22:                extern unsigned int process_time;
23:                
24:                extern enum fxStruct fxUnits[NUMFXUNITS];
25:                
26:                int fxLast=0;
27:                int fxNow=0;
28:                
29:                void (*fxModPointers[NUMFX])(unsigned int, fractional, fractional, fractional) = {screenNoFXmod, screenLPFmod, screenTRMmod, screenLOPmod, screenBITmod};
30:                
31:                void screenDebugAudio(){
32:                
33:                }
0082E0  060000     RETURN
34:                
35:                void screenDebugBuffers(){
36:                    if(state!=laststate){
0082E2  808050     MOV laststate, W0
0082E4  E31038     CP 0x1038
0082E6  32001B     BRA Z, 0x831E
37:                        //setup here
38:                        lcdClearQ();
0082E8  07FBC1     RCALL lcdClearQ
39:                        lcdSetCursorQ(0,0);
0082EA  EB4080     CLR.B W1
0082EC  784001     MOV.B W1, W0
0082EE  07FBC9     RCALL lcdSetCursorQ
40:                        lcdWriteStringQ("Buffer Debug");
0082F0  2F9BF0     MOV #0xF9BF, W0
0082F2  07FBDB     RCALL lcdWriteStringQ
41:                        lcdSetCursorQ(0,1);
0082F4  B3C011     MOV.B #0x1, W1
0082F6  EB4000     CLR.B W0
0082F8  07FBC4     RCALL lcdSetCursorQ
42:                        lcdWriteStringQ("FX time:");
0082FA  2F9CC0     MOV #0xF9CC, W0
0082FC  07FBD6     RCALL lcdWriteStringQ
43:                        lcdSetCursorQ(11,1);
0082FE  B3C011     MOV.B #0x1, W1
008300  B3C0B0     MOV.B #0xB, W0
008302  07FBBF     RCALL lcdSetCursorQ
44:                        lcdWriteStringQ("/256");
008304  2F9D50     MOV #0xF9D5, W0
008306  07FBD1     RCALL lcdWriteStringQ
45:                        lcdSetCursorQ(0,2);
008308  B3C021     MOV.B #0x2, W1
00830A  EB4000     CLR.B W0
00830C  07FBBA     RCALL lcdSetCursorQ
46:                        lcdWriteStringQ("LCD:");
00830E  2F9DA0     MOV #0xF9DA, W0
008310  07FBCC     RCALL lcdWriteStringQ
47:                        lcdSetCursorQ(0,3);
008312  B3C031     MOV.B #0x3, W1
008314  EB4000     CLR.B W0
008316  07FBB5     RCALL lcdSetCursorQ
48:                        lcdWriteStringQ("Flash:");
008318  2F9DF0     MOV #0xF9DF, W0
00831A  07FBC7     RCALL lcdWriteStringQ
00831C  370006     BRA 0x832A
49:                    } else {
50:                        //update here
51:                        lcdSetCursorQ(8,1);
00831E  B3C011     MOV.B #0x1, W1
008320  B3C080     MOV.B #0x8, W0
008322  07FBAF     RCALL lcdSetCursorQ
52:                        lcdWriteDecimalQ(process_time,3);
008324  200031     MOV #0x3, W1
008326  BFD004     MOV.B process_time, WREG
008328  07FCA6     RCALL lcdWriteDecimalQ
53:                        //lcdSetCursorQ(4,2);
54:                        //lcdWriteDecimalQ();
55:                        //lcdSetCursorQ(6,3);
56:                        //lcdWriteDecimalQ();
57:                        
58:                    }
59:                }
00832A  060000     RETURN
60:                
61:                void screenDebugPots(void){
00832C  BE9F88     MOV.D W8, [W15++]
00832E  BE9F8A     MOV.D W10, [W15++]
62:                    int bank=0;
00836A  EB0480     CLR W9
63:                    
64:                    if(state!=laststate){
008330  808050     MOV laststate, W0
008332  E31038     CP 0x1038
008334  320016     BRA Z, 0x8362
65:                        // Setup here
66:                        lcdClearQ();
008336  07FB9A     RCALL lcdClearQ
67:                        lcdSetCursorQ(0,0);
008338  EB4080     CLR.B W1
00833A  784001     MOV.B W1, W0
00833C  07FBA2     RCALL lcdSetCursorQ
68:                        lcdWriteStringQ("Potentiometer Debug");
00833E  2F9E60     MOV #0xF9E6, W0
008340  07FBB4     RCALL lcdWriteStringQ
69:                        lcdSetCursorQ(9,1);
008342  B3C011     MOV.B #0x1, W1
008344  B3C090     MOV.B #0x9, W0
008346  07FB9D     RCALL lcdSetCursorQ
70:                        lcdWriteStringQ("|");
008348  2F9FA0     MOV #0xF9FA, W0
00834A  07FBAF     RCALL lcdWriteStringQ
71:                         lcdSetCursorQ(9,2);
00834C  B3C021     MOV.B #0x2, W1
00834E  B3C090     MOV.B #0x9, W0
008350  07FB98     RCALL lcdSetCursorQ
72:                        lcdWriteStringQ("|");
008352  2F9FA0     MOV #0xF9FA, W0
008354  07FBAA     RCALL lcdWriteStringQ
73:                         lcdSetCursorQ(9,3);
008356  B3C031     MOV.B #0x3, W1
008358  B3C090     MOV.B #0x9, W0
00835A  07FB93     RCALL lcdSetCursorQ
74:                        lcdWriteStringQ("|");
00835C  2F9FA0     MOV #0xF9FA, W0
00835E  07FBA5     RCALL lcdWriteStringQ
008360  37005A     BRA 0x8416
75:                    } else {
76:                        // Update here
77:                        if(!pad[34])bank=POTS/2;
008362  200069     MOV #0x6, W9
008364  268D40     MOV #0x68D4, W0
008366  E00410     CP0.B [W0]
008368  320001     BRA Z, 0x836C
78:                        lcdSetCursorQ(0,1);
00836C  B3C011     MOV.B #0x1, W1
00836E  EB4000     CLR.B W0
008370  07FB88     RCALL lcdSetCursorQ
79:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
008372  448589     ADD W9, W9, W11
008374  260828     MOV #0x6082, W8
008376  44000B     ADD W8, W11, W0
008378  780010     MOV [W0], W0
00837A  200031     MOV #0x3, W1
00837C  07FC7C     RCALL lcdWriteDecimalQ
80:                        lcdWriteQ(',');
00837E  B3C2C0     MOV.B #0x2C, W0
008380  07FB60     RCALL lcdWriteQ
81:                        lcdWriteWordUnsignedQ(pots[bank++]);
008382  E80509     INC W9, W10
008384  2606A9     MOV #0x606A, W9
008386  44858B     ADD W9, W11, W11
008388  78001B     MOV [W11], W0
00838A  07FC1D     RCALL lcdWriteWordUnsignedQ
82:                        lcdSetCursorQ(11,1);
00838C  B3C011     MOV.B #0x1, W1
00838E  B3C0B0     MOV.B #0xB, W0
008390  07FB78     RCALL lcdSetCursorQ
83:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
008392  45058A     ADD W10, W10, W11
008394  44000B     ADD W8, W11, W0
008396  780010     MOV [W0], W0
008398  200031     MOV #0x3, W1
00839A  07FC6D     RCALL lcdWriteDecimalQ
84:                        lcdWriteQ(',');
00839C  B3C2C0     MOV.B #0x2C, W0
00839E  07FB51     RCALL lcdWriteQ
85:                        lcdWriteWordUnsignedQ(pots[bank++]);
0083A0  E8050A     INC W10, W10
0083A2  44858B     ADD W9, W11, W11
0083A4  78001B     MOV [W11], W0
0083A6  07FC0F     RCALL lcdWriteWordUnsignedQ
86:                        lcdSetCursorQ(0,2);
0083A8  B3C021     MOV.B #0x2, W1
0083AA  EB4000     CLR.B W0
0083AC  07FB6A     RCALL lcdSetCursorQ
87:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
0083AE  45058A     ADD W10, W10, W11
0083B0  44000B     ADD W8, W11, W0
0083B2  780010     MOV [W0], W0
0083B4  200031     MOV #0x3, W1
0083B6  07FC5F     RCALL lcdWriteDecimalQ
88:                        lcdWriteQ(',');
0083B8  B3C2C0     MOV.B #0x2C, W0
0083BA  07FB43     RCALL lcdWriteQ
89:                        lcdWriteWordUnsignedQ(pots[bank++]);
0083BC  E8050A     INC W10, W10
0083BE  44858B     ADD W9, W11, W11
0083C0  78001B     MOV [W11], W0
0083C2  07FC01     RCALL lcdWriteWordUnsignedQ
90:                        lcdSetCursorQ(11,2);
0083C4  B3C021     MOV.B #0x2, W1
0083C6  B3C0B0     MOV.B #0xB, W0
0083C8  07FB5C     RCALL lcdSetCursorQ
91:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
0083CA  45058A     ADD W10, W10, W11
0083CC  44000B     ADD W8, W11, W0
0083CE  780010     MOV [W0], W0
0083D0  200031     MOV #0x3, W1
0083D2  07FC51     RCALL lcdWriteDecimalQ
92:                        lcdWriteQ(',');
0083D4  B3C2C0     MOV.B #0x2C, W0
0083D6  07FB35     RCALL lcdWriteQ
93:                        lcdWriteWordUnsignedQ(pots[bank++]);
0083D8  E8050A     INC W10, W10
0083DA  44858B     ADD W9, W11, W11
0083DC  78001B     MOV [W11], W0
0083DE  07FBF3     RCALL lcdWriteWordUnsignedQ
94:                        lcdSetCursorQ(0,3);
0083E0  B3C031     MOV.B #0x3, W1
0083E2  EB4000     CLR.B W0
0083E4  07FB4E     RCALL lcdSetCursorQ
95:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
0083E6  45058A     ADD W10, W10, W11
0083E8  44000B     ADD W8, W11, W0
0083EA  780010     MOV [W0], W0
0083EC  200031     MOV #0x3, W1
0083EE  07FC43     RCALL lcdWriteDecimalQ
96:                        lcdWriteQ(',');
0083F0  B3C2C0     MOV.B #0x2C, W0
0083F2  07FB27     RCALL lcdWriteQ
97:                        lcdWriteWordUnsignedQ(pots[bank++]);
0083F4  E8050A     INC W10, W10
0083F6  44858B     ADD W9, W11, W11
0083F8  78001B     MOV [W11], W0
0083FA  07FBE5     RCALL lcdWriteWordUnsignedQ
98:                        lcdSetCursorQ(11,3);
0083FC  B3C031     MOV.B #0x3, W1
0083FE  B3C0B0     MOV.B #0xB, W0
008400  07FB40     RCALL lcdSetCursorQ
99:                        lcdWriteDecimalQ(pots_scaled[bank], 3);
008402  45050A     ADD W10, W10, W10
008404  44040A     ADD W8, W10, W8
008406  780018     MOV [W8], W0
008408  200031     MOV #0x3, W1
00840A  07FC35     RCALL lcdWriteDecimalQ
100:                       lcdWriteQ(',');
00840C  B3C2C0     MOV.B #0x2C, W0
00840E  07FB19     RCALL lcdWriteQ
101:                       lcdWriteWordUnsignedQ(pots[bank++]);
008410  44850A     ADD W9, W10, W10
008412  78001A     MOV [W10], W0
008414  07FBD8     RCALL lcdWriteWordUnsignedQ
102:                   }
103:               }
008416  BE054F     MOV.D [--W15], W10
008418  BE044F     MOV.D [--W15], W8
00841A  060000     RETURN
104:               
105:               
106:               void screenDebugFlash(void){
00841C  781F88     MOV W8, [W15++]
107:                       if(state!=laststate){
00841E  808050     MOV laststate, W0
008420  E31038     CP 0x1038
008422  32003D     BRA Z, 0x849E
108:                       //setup here
109:                       lcdClearQ();
008424  07FB23     RCALL lcdClearQ
110:                       lcdSetCursorQ(0,0);
008426  EB4080     CLR.B W1
008428  784001     MOV.B W1, W0
00842A  07FB2B     RCALL lcdSetCursorQ
111:                       lcdWriteWordQ(flash_readback[2]);
00842C  25E6C0     MOV #0x5E6C, W0
00842E  FB0010     SE [W0], W0
008430  07FB5A     RCALL lcdWriteWordQ
112:                        lcdSetCursorQ(6,0);
008432  EB4080     CLR.B W1
008434  B3C060     MOV.B #0x6, W0
008436  07FB25     RCALL lcdSetCursorQ
113:                       lcdWriteWordQ(flash_readback[3]);
008438  25E6D0     MOV #0x5E6D, W0
00843A  FB0010     SE [W0], W0
00843C  07FB54     RCALL lcdWriteWordQ
114:                        lcdSetCursorQ(12,0);
00843E  EB4080     CLR.B W1
008440  B3C0C0     MOV.B #0xC, W0
008442  07FB1F     RCALL lcdSetCursorQ
115:                       lcdWriteWordQ(flash_readback[4]);
008444  25E6E0     MOV #0x5E6E, W0
008446  FB0010     SE [W0], W0
008448  07FB4E     RCALL lcdWriteWordQ
116:                        lcdSetCursorQ(0,1);
00844A  B3C011     MOV.B #0x1, W1
00844C  EB4000     CLR.B W0
00844E  07FB19     RCALL lcdSetCursorQ
117:                       lcdWriteWordQ(flash_readback[5]);
008450  25E6F0     MOV #0x5E6F, W0
008452  FB0010     SE [W0], W0
008454  07FB48     RCALL lcdWriteWordQ
118:                       lcdSetCursorQ(6,1);
008456  B3C011     MOV.B #0x1, W1
008458  B3C060     MOV.B #0x6, W0
00845A  07FB13     RCALL lcdSetCursorQ
119:                       lcdWriteWordQ(flash_readback[6]);
00845C  25E700     MOV #0x5E70, W0
00845E  FB0010     SE [W0], W0
008460  07FB42     RCALL lcdWriteWordQ
120:                        lcdSetCursorQ(12,1);
008462  B3C011     MOV.B #0x1, W1
008464  B3C0C0     MOV.B #0xC, W0
008466  07FB0D     RCALL lcdSetCursorQ
121:                       lcdWriteWordQ(flash_readback[7]);
008468  25E710     MOV #0x5E71, W0
00846A  FB0010     SE [W0], W0
00846C  07FB3C     RCALL lcdWriteWordQ
122:                       lcdSetCursorQ(0,2);
00846E  B3C021     MOV.B #0x2, W1
008470  EB4000     CLR.B W0
008472  07FB07     RCALL lcdSetCursorQ
123:                       lcdWriteWordQ(flash_readback[8]);
008474  25E728     MOV #0x5E72, W8
008476  FB0018     SE [W8], W0
008478  07FB36     RCALL lcdWriteWordQ
124:                       lcdSetCursorQ(6,2);
00847A  B3C021     MOV.B #0x2, W1
00847C  B3C060     MOV.B #0x6, W0
00847E  07FB01     RCALL lcdSetCursorQ
125:                       lcdWriteWordQ(flash_readback[9]);
008480  E80008     INC W8, W0
008482  FB0010     SE [W0], W0
008484  07FB30     RCALL lcdWriteWordQ
126:                        lcdSetCursorQ(12,2);
008486  B3C021     MOV.B #0x2, W1
008488  B3C0C0     MOV.B #0xC, W0
00848A  07FAFB     RCALL lcdSetCursorQ
127:                       lcdWriteWordQ(flash_readback[10]);
00848C  E88008     INC2 W8, W0
00848E  FB0010     SE [W0], W0
008490  07FB2A     RCALL lcdWriteWordQ
128:                       lcdSetCursorQ(0,3);
008492  B3C031     MOV.B #0x3, W1
008494  EB4000     CLR.B W0
008496  07FAF5     RCALL lcdSetCursorQ
129:                       lcdWriteWordQ(flash_readback[8]);
008498  FB0018     SE [W8], W0
00849A  07FB25     RCALL lcdWriteWordQ
00849C  370008     BRA 0x84AE
130:                   } else {
131:                       //update here
132:                       lcdSetCursorQ(9,3);
00849E  B3C031     MOV.B #0x3, W1
0084A0  B3C090     MOV.B #0x9, W0
0084A2  07FAEF     RCALL lcdSetCursorQ
133:                       lcdWriteStringQ("Stat:");
0084A4  2F9FC0     MOV #0xF9FC, W0
0084A6  07FB01     RCALL lcdWriteStringQ
134:                       lcdWriteWordQ(flashStatusCheck());
0084A8  0705F5     RCALL flashStatusCheck
0084AA  FB0000     SE W0, W0
0084AC  07FB1C     RCALL lcdWriteWordQ
135:                   }
136:               }
0084AE  78044F     MOV [--W15], W8
0084B0  060000     RETURN
137:               
138:               void screenDebugInput(void){
139:                   if(state!=laststate){
0084B2  808050     MOV laststate, W0
0084B4  E31038     CP 0x1038
0084B6  32000C     BRA Z, 0x84D0
140:                       //setup here
141:                       lcdClearQ();
0084B8  07FAD9     RCALL lcdClearQ
142:                       lcdSetCursorQ(0,0);
0084BA  EB4080     CLR.B W1
0084BC  784001     MOV.B W1, W0
0084BE  07FAE1     RCALL lcdSetCursorQ
143:                       lcdWriteStringQ("Input Debug");
0084C0  2FA020     MOV #0xFA02, W0
0084C2  07FAF3     RCALL lcdWriteStringQ
144:                       lcdSetCursorQ(0,1);
0084C4  B3C011     MOV.B #0x1, W1
0084C6  EB4000     CLR.B W0
0084C8  07FADC     RCALL lcdSetCursorQ
145:                       lcdWriteStringQ("ADC variance: ");
0084CA  2FA0E0     MOV #0xFA0E, W0
0084CC  07FAEE     RCALL lcdWriteStringQ
0084CE  370002     BRA 0x84D4
146:                   } else {
147:                       //update here
148:                       lcdDrawPads(16);
0084D0  B3C100     MOV.B #0x10, W0
0084D2  07FC03     RCALL lcdDrawPads
149:                   }
150:               }
0084D4  060000     RETURN
151:               
152:               void screenNoFXmod(unsigned int col, fractional param1, fractional param2, fractional param3){
0080D6  781F88     MOV W8, [W15++]
0080D8  780400     MOV W0, W8
153:                       if(fxNow!=fxLast){
0080DA  808210     MOV fxLast, W0
0080DC  E31044     CP fxNow
0080DE  320015     BRA Z, 0x810A
154:                       // Setup here
155:                           
156:                       lcdSetCursorQ(col+5,0);
0080E0  444065     ADD.B W8, #0x5, W0
0080E2  EB4080     CLR.B W1
0080E4  07FCCE     RCALL lcdSetCursorQ
157:                       lcdWriteStringQ("OFF");
0080E6  2F9860     MOV #0xF986, W0
0080E8  07FCE0     RCALL lcdWriteStringQ
158:                       lcdSetCursorQ(col,1);
0080EA  B3C011     MOV.B #0x1, W1
0080EC  784008     MOV.B W8, W0
0080EE  07FCC9     RCALL lcdSetCursorQ
159:                       lcdWriteStringQ("        ");
0080F0  2F98A0     MOV #0xF98A, W0
0080F2  07FCDB     RCALL lcdWriteStringQ
160:                       lcdSetCursorQ(col,2);
0080F4  B3C021     MOV.B #0x2, W1
0080F6  784008     MOV.B W8, W0
0080F8  07FCC4     RCALL lcdSetCursorQ
161:                       lcdWriteStringQ("        ");
0080FA  2F98A0     MOV #0xF98A, W0
0080FC  07FCD6     RCALL lcdWriteStringQ
162:                       lcdSetCursorQ(col,3);
0080FE  B3C031     MOV.B #0x3, W1
008100  784008     MOV.B W8, W0
008102  07FCBF     RCALL lcdSetCursorQ
163:                       lcdWriteStringQ("        ");
008104  2F98A0     MOV #0xF98A, W0
008106  07FCD1     RCALL lcdWriteStringQ
008108  370005     BRA 0x8114
164:               
165:                   } else {
166:                       // Update here
167:                       lcdSetCursorQ(col+5,0);
00810A  444065     ADD.B W8, #0x5, W0
00810C  EB4080     CLR.B W1
00810E  07FCB9     RCALL lcdSetCursorQ
168:                       lcdWriteStringQ("OFF");
008110  2F9860     MOV #0xF986, W0
008112  07FCCB     RCALL lcdWriteStringQ
169:                   }
170:               }
008114  78044F     MOV [--W15], W8
008116  060000     RETURN
171:               
172:               void screenLPFmod(unsigned int col, fractional param1, fractional param2, fractional param3){
00826E  BE9F88     MOV.D W8, [W15++]
008270  BE9F8A     MOV.D W10, [W15++]
008272  780400     MOV W0, W8
008274  780501     MOV W1, W10
008276  780582     MOV W2, W11
008278  780483     MOV W3, W9
173:                   if(fxNow!=fxLast){
00827A  808210     MOV fxLast, W0
00827C  E31044     CP fxNow
00827E  320015     BRA Z, 0x82AA
174:                       // Setup here
175:                       lcdSetCursorQ(col+5,0);
008280  444065     ADD.B W8, #0x5, W0
008282  EB4080     CLR.B W1
008284  07FBFE     RCALL lcdSetCursorQ
176:                       lcdWriteStringQ("LPF");
008286  2F9B70     MOV #0xF9B7, W0
008288  07FC10     RCALL lcdWriteStringQ
177:                       lcdSetCursorQ(col,1);
00828A  B3C011     MOV.B #0x1, W1
00828C  784008     MOV.B W8, W0
00828E  07FBF9     RCALL lcdSetCursorQ
178:                       lcdWriteStringQ("frq");
008290  2F9BB0     MOV #0xF9BB, W0
008292  07FC0B     RCALL lcdWriteStringQ
179:                       lcdSetCursorQ(col,2);
008294  B3C021     MOV.B #0x2, W1
008296  784008     MOV.B W8, W0
008298  07FBF4     RCALL lcdSetCursorQ
180:                       lcdWriteStringQ("d/w");
00829A  2F99B0     MOV #0xF99B, W0
00829C  07FC06     RCALL lcdWriteStringQ
181:                       lcdSetCursorQ(col,3);
00829E  B3C031     MOV.B #0x3, W1
0082A0  784008     MOV.B W8, W0
0082A2  07FBEF     RCALL lcdSetCursorQ
182:                       lcdWriteStringQ("pwr");
0082A4  2F99F0     MOV #0xF99F, W0
0082A6  07FC01     RCALL lcdWriteStringQ
0082A8  370018     BRA 0x82DA
183:                   } else {
184:                       // Update here
185:                       lcdSetCursorQ(col+5,1);
0082AA  444465     ADD.B W8, #0x5, W8
0082AC  B3C011     MOV.B #0x1, W1
0082AE  784008     MOV.B W8, W0
0082B0  07FBE8     RCALL lcdSetCursorQ
186:                       lcdWriteDecimalQ(param1, 3);
0082B2  200031     MOV #0x3, W1
0082B4  78400A     MOV.B W10, W0
0082B6  07FCDF     RCALL lcdWriteDecimalQ
187:                       lcdSetCursorQ(col+5,2);
0082B8  B3C021     MOV.B #0x2, W1
0082BA  784008     MOV.B W8, W0
0082BC  07FBE2     RCALL lcdSetCursorQ
188:                       lcdWriteDecimalQ(param2, 3);
0082BE  200031     MOV #0x3, W1
0082C0  78400B     MOV.B W11, W0
0082C2  07FCD9     RCALL lcdWriteDecimalQ
189:                       lcdSetCursorQ(col+5,3);
0082C4  B3C031     MOV.B #0x3, W1
0082C6  784008     MOV.B W8, W0
0082C8  07FBDC     RCALL lcdSetCursorQ
190:                       if(param3>=50)
0082CA  200310     MOV #0x31, W0
0082CC  548F80     SUB W9, W0, [W15]
0082CE  340003     BRA LE, 0x82D6
191:                           lcdWriteStringQ(" ON");
0082D0  2F9A30     MOV #0xF9A3, W0
0082D2  07FBEB     RCALL lcdWriteStringQ
0082D4  370002     BRA 0x82DA
192:                       else lcdWriteStringQ("OFF");
0082D6  2F9860     MOV #0xF986, W0
0082D8  07FBE8     RCALL lcdWriteStringQ
193:                   }
194:               }
0082DA  BE054F     MOV.D [--W15], W10
0082DC  BE044F     MOV.D [--W15], W8
0082DE  060000     RETURN
195:               
196:               void screenTRMmod(unsigned int col, fractional param1, fractional param2, fractional param3){
0081FC  BE9F88     MOV.D W8, [W15++]
0081FE  BE9F8A     MOV.D W10, [W15++]
008200  780400     MOV W0, W8
008202  780501     MOV W1, W10
008204  780582     MOV W2, W11
008206  780483     MOV W3, W9
197:                   if(fxNow!=fxLast){
008208  808210     MOV fxLast, W0
00820A  E31044     CP fxNow
00820C  320015     BRA Z, 0x8238
198:                       // Setup here
199:                       lcdSetCursorQ(col+5,0);
00820E  444065     ADD.B W8, #0x5, W0
008210  EB4080     CLR.B W1
008212  07FC37     RCALL lcdSetCursorQ
200:                       lcdWriteStringQ("TRM");
008214  2F9AB0     MOV #0xF9AB, W0
008216  07FC49     RCALL lcdWriteStringQ
201:                       lcdSetCursorQ(col,1);
008218  B3C011     MOV.B #0x1, W1
00821A  784008     MOV.B W8, W0
00821C  07FC32     RCALL lcdSetCursorQ
202:                       lcdWriteStringQ("rat");
00821E  2F9AF0     MOV #0xF9AF, W0
008220  07FC44     RCALL lcdWriteStringQ
203:                       lcdSetCursorQ(col,2);
008222  B3C021     MOV.B #0x2, W1
008224  784008     MOV.B W8, W0
008226  07FC2D     RCALL lcdSetCursorQ
204:                       lcdWriteStringQ("dep");
008228  2F9B30     MOV #0xF9B3, W0
00822A  07FC3F     RCALL lcdWriteStringQ
205:                       lcdSetCursorQ(col,3);
00822C  B3C031     MOV.B #0x3, W1
00822E  784008     MOV.B W8, W0
008230  07FC28     RCALL lcdSetCursorQ
206:                       lcdWriteStringQ("pwr");
008232  2F99F0     MOV #0xF99F, W0
008234  07FC3A     RCALL lcdWriteStringQ
008236  370018     BRA 0x8268
207:                   } else {
208:                       // Update here
209:                       lcdSetCursorQ(col+5,1);
008238  444465     ADD.B W8, #0x5, W8
00823A  B3C011     MOV.B #0x1, W1
00823C  784008     MOV.B W8, W0
00823E  07FC21     RCALL lcdSetCursorQ
210:                       lcdWriteDecimalQ(param1, 3);
008240  200031     MOV #0x3, W1
008242  78400A     MOV.B W10, W0
008244  07FD18     RCALL lcdWriteDecimalQ
211:                       lcdSetCursorQ(col+5,2);
008246  B3C021     MOV.B #0x2, W1
008248  784008     MOV.B W8, W0
00824A  07FC1B     RCALL lcdSetCursorQ
212:                       lcdWriteDecimalQ(param2, 3);
00824C  200031     MOV #0x3, W1
00824E  78400B     MOV.B W11, W0
008250  07FD12     RCALL lcdWriteDecimalQ
213:                       lcdSetCursorQ(col+5,3);
008252  B3C031     MOV.B #0x3, W1
008254  784008     MOV.B W8, W0
008256  07FC15     RCALL lcdSetCursorQ
214:                       if(param3>=50)
008258  200310     MOV #0x31, W0
00825A  548F80     SUB W9, W0, [W15]
00825C  340003     BRA LE, 0x8264
215:                           lcdWriteStringQ(" ON");
00825E  2F9A30     MOV #0xF9A3, W0
008260  07FC24     RCALL lcdWriteStringQ
008262  370002     BRA 0x8268
216:                       else lcdWriteStringQ("OFF");
008264  2F9860     MOV #0xF986, W0
008266  07FC21     RCALL lcdWriteStringQ
217:                   }
218:               }
008268  BE054F     MOV.D [--W15], W10
00826A  BE044F     MOV.D [--W15], W8
00826C  060000     RETURN
219:               
220:               void screenLOPmod(unsigned int col, fractional param1, fractional param2, fractional param3){
00818A  BE9F88     MOV.D W8, [W15++]
00818C  BE9F8A     MOV.D W10, [W15++]
00818E  780400     MOV W0, W8
008190  780501     MOV W1, W10
008192  780582     MOV W2, W11
008194  780483     MOV W3, W9
221:                   if(fxNow!=fxLast){
008196  808210     MOV fxLast, W0
008198  E31044     CP fxNow
00819A  320015     BRA Z, 0x81C6
222:                       // Setup here
223:                       lcdSetCursorQ(col+5,0);
00819C  444065     ADD.B W8, #0x5, W0
00819E  EB4080     CLR.B W1
0081A0  07FC70     RCALL lcdSetCursorQ
224:                       lcdWriteStringQ("LOP");
0081A2  2F9A70     MOV #0xF9A7, W0
0081A4  07FC82     RCALL lcdWriteStringQ
225:                       lcdSetCursorQ(col,1);
0081A6  B3C011     MOV.B #0x1, W1
0081A8  784008     MOV.B W8, W0
0081AA  07FC6B     RCALL lcdSetCursorQ
226:                       lcdWriteStringQ("siz");
0081AC  2F9970     MOV #0xF997, W0
0081AE  07FC7D     RCALL lcdWriteStringQ
227:                       lcdSetCursorQ(col,2);
0081B0  B3C021     MOV.B #0x2, W1
0081B2  784008     MOV.B W8, W0
0081B4  07FC66     RCALL lcdSetCursorQ
228:                       lcdWriteStringQ("d/w");
0081B6  2F99B0     MOV #0xF99B, W0
0081B8  07FC78     RCALL lcdWriteStringQ
229:                       lcdSetCursorQ(col,3);
0081BA  B3C031     MOV.B #0x3, W1
0081BC  784008     MOV.B W8, W0
0081BE  07FC61     RCALL lcdSetCursorQ
230:                       lcdWriteStringQ("pwr");
0081C0  2F99F0     MOV #0xF99F, W0
0081C2  07FC73     RCALL lcdWriteStringQ
0081C4  370018     BRA 0x81F6
231:                   } else {
232:                       // Update here
233:                       lcdSetCursorQ(col+5,1);
0081C6  444465     ADD.B W8, #0x5, W8
0081C8  B3C011     MOV.B #0x1, W1
0081CA  784008     MOV.B W8, W0
0081CC  07FC5A     RCALL lcdSetCursorQ
234:                       lcdWriteDecimalQ(param1, 3);
0081CE  200031     MOV #0x3, W1
0081D0  78400A     MOV.B W10, W0
0081D2  07FD51     RCALL lcdWriteDecimalQ
235:                       lcdSetCursorQ(col+5,2);
0081D4  B3C021     MOV.B #0x2, W1
0081D6  784008     MOV.B W8, W0
0081D8  07FC54     RCALL lcdSetCursorQ
236:                       lcdWriteDecimalQ(param2, 3);
0081DA  200031     MOV #0x3, W1
0081DC  78400B     MOV.B W11, W0
0081DE  07FD4B     RCALL lcdWriteDecimalQ
237:                       lcdSetCursorQ(col+5,3);
0081E0  B3C031     MOV.B #0x3, W1
0081E2  784008     MOV.B W8, W0
0081E4  07FC4E     RCALL lcdSetCursorQ
238:                       if(param3>=50)
0081E6  200310     MOV #0x31, W0
0081E8  548F80     SUB W9, W0, [W15]
0081EA  340003     BRA LE, 0x81F2
239:                           lcdWriteStringQ(" ON");
0081EC  2F9A30     MOV #0xF9A3, W0
0081EE  07FC5D     RCALL lcdWriteStringQ
0081F0  370002     BRA 0x81F6
240:                       else lcdWriteStringQ("OFF");
0081F2  2F9860     MOV #0xF986, W0
0081F4  07FC5A     RCALL lcdWriteStringQ
241:                   }
242:               }
0081F6  BE054F     MOV.D [--W15], W10
0081F8  BE044F     MOV.D [--W15], W8
0081FA  060000     RETURN
243:               
244:               void screenBITmod(unsigned int col, fractional param1, fractional param2, fractional param3){
008118  BE9F88     MOV.D W8, [W15++]
00811A  BE9F8A     MOV.D W10, [W15++]
00811C  780400     MOV W0, W8
00811E  780501     MOV W1, W10
008120  780582     MOV W2, W11
008122  780483     MOV W3, W9
245:                   if(fxNow!=fxLast){
008124  808210     MOV fxLast, W0
008126  E31044     CP fxNow
008128  320015     BRA Z, 0x8154
246:                       // Setup here
247:                       lcdSetCursorQ(col+5,0);
00812A  444065     ADD.B W8, #0x5, W0
00812C  EB4080     CLR.B W1
00812E  07FCA9     RCALL lcdSetCursorQ
248:                       lcdWriteStringQ("BIT");
008130  2F9930     MOV #0xF993, W0
008132  07FCBB     RCALL lcdWriteStringQ
249:                       lcdSetCursorQ(col,1);
008134  B3C011     MOV.B #0x1, W1
008136  784008     MOV.B W8, W0
008138  07FCA4     RCALL lcdSetCursorQ
250:                       lcdWriteStringQ("siz");
00813A  2F9970     MOV #0xF997, W0
00813C  07FCB6     RCALL lcdWriteStringQ
251:                       lcdSetCursorQ(col,2);
00813E  B3C021     MOV.B #0x2, W1
008140  784008     MOV.B W8, W0
008142  07FC9F     RCALL lcdSetCursorQ
252:                       lcdWriteStringQ("d/w");
008144  2F99B0     MOV #0xF99B, W0
008146  07FCB1     RCALL lcdWriteStringQ
253:                       lcdSetCursorQ(col,3);
008148  B3C031     MOV.B #0x3, W1
00814A  784008     MOV.B W8, W0
00814C  07FC9A     RCALL lcdSetCursorQ
254:                       lcdWriteStringQ("pwr");
00814E  2F99F0     MOV #0xF99F, W0
008150  07FCAC     RCALL lcdWriteStringQ
008152  370018     BRA 0x8184
255:                   } else {
256:                       // Update here
257:                       lcdSetCursorQ(col+5,1);
008154  444465     ADD.B W8, #0x5, W8
008156  B3C011     MOV.B #0x1, W1
008158  784008     MOV.B W8, W0
00815A  07FC93     RCALL lcdSetCursorQ
258:                       lcdWriteDecimalQ(param1, 3);
00815C  200031     MOV #0x3, W1
00815E  78400A     MOV.B W10, W0
008160  07FD8A     RCALL lcdWriteDecimalQ
259:                       lcdSetCursorQ(col+5,2);
008162  B3C021     MOV.B #0x2, W1
008164  784008     MOV.B W8, W0
008166  07FC8D     RCALL lcdSetCursorQ
260:                       lcdWriteDecimalQ(param2, 3);
008168  200031     MOV #0x3, W1
00816A  78400B     MOV.B W11, W0
00816C  07FD84     RCALL lcdWriteDecimalQ
261:                       lcdSetCursorQ(col+5,3);
00816E  B3C031     MOV.B #0x3, W1
008170  784008     MOV.B W8, W0
008172  07FC87     RCALL lcdSetCursorQ
262:                       if(param3>=50)
008174  200310     MOV #0x31, W0
008176  548F80     SUB W9, W0, [W15]
008178  340003     BRA LE, 0x8180
263:                           lcdWriteStringQ(" ON");
00817A  2F9A30     MOV #0xF9A3, W0
00817C  07FC96     RCALL lcdWriteStringQ
00817E  370002     BRA 0x8184
264:                       else lcdWriteStringQ("OFF");
008180  2F9860     MOV #0xF986, W0
008182  07FC93     RCALL lcdWriteStringQ
265:                   }
266:               }
008184  BE054F     MOV.D [--W15], W10
008186  BE044F     MOV.D [--W15], W8
008188  060000     RETURN
267:               
268:               void screenFX(void){
0084D6  781F88     MOV W8, [W15++]
269:                   if(state!=laststate){
0084D8  808050     MOV laststate, W0
0084DA  E31038     CP 0x1038
0084DC  32000C     BRA Z, 0x84F6
270:                       //setup here
271:                       lcdClearQ();
0084DE  07FAC6     RCALL lcdClearQ
272:                       lcdSetCursorQ(0,0);
0084E0  EB4080     CLR.B W1
0084E2  784001     MOV.B W1, W0
0084E4  07FACE     RCALL lcdSetCursorQ
273:                       lcdWriteStringQ("Fx1:");
0084E6  2FA1D0     MOV #0xFA1D, W0
0084E8  07FAE0     RCALL lcdWriteStringQ
274:                       lcdSetCursorQ(10,0);
0084EA  EB4080     CLR.B W1
0084EC  B3C0A0     MOV.B #0xA, W0
0084EE  07FAC9     RCALL lcdSetCursorQ
275:                       lcdWriteStringQ("Fx2:");
0084F0  2FA220     MOV #0xFA22, W0
0084F2  07FADB     RCALL lcdWriteStringQ
0084F4  370013     BRA 0x851C
276:                       
277:                   } else {
278:                       //update here 
279:                       fxModPointers[fxUnits[0]](0,  pots_scaled[FX_1], pots_scaled[FX_2], pots_scaled[FX_3]);
0084F6  808060     MOV fxUnits, W0
0084F8  400000     ADD W0, W0, W0
0084FA  26DB28     MOV #0x6DB2, W8
0084FC  440000     ADD W8, W0, W0
0084FE  780210     MOV [W0], W4
008500  830453     MOV 0x608A, W3
008502  830432     MOV 0x6086, W2
008504  830411     MOV pots_scaled, W1
008506  EB0000     CLR W0
008508  010004     CALL W4
280:                       fxModPointers[fxUnits[1]](10, pots_scaled[FX_4], pots_scaled[FX_5], pots_scaled[FX_6]);
00850A  808070     MOV 0x100E, W0
00850C  400000     ADD W0, W0, W0
00850E  440400     ADD W8, W0, W8
008510  780218     MOV [W8], W4
008512  830463     MOV 0x608C, W3
008514  830442     MOV 0x6088, W2
008516  830421     MOV 0x6084, W1
008518  2000A0     MOV #0xA, W0
00851A  010004     CALL W4
281:                   }
282:                        
283:               }
00851C  78044F     MOV [--W15], W8
00851E  060000     RETURN
284:               
285:               void screenUpdate(void){
286:                   fxNow=fxUnits[0]+fxUnits[1];
008520  808060     MOV fxUnits, W0
008522  B4100E     ADD 0x100E, WREG
008524  888220     MOV W0, fxNow
287:                   
288:                   switch(state){
008526  8081C0     MOV 0x1038, W0
008528  500FE3     SUB W0, #0x3, [W15]
00852A  32000F     BRA Z, 0x854A
00852C  3E0005     BRA GTU, 0x8538
00852E  500FE1     SUB W0, #0x1, [W15]
008530  320008     BRA Z, 0x8542
008532  500FE2     SUB W0, #0x2, [W15]
008534  3A000F     BRA NZ, 0x8554
008536  370007     BRA 0x8546
008538  500FE4     SUB W0, #0x4, [W15]
00853A  320009     BRA Z, 0x854E
00853C  500FE5     SUB W0, #0x5, [W15]
00853E  3A000A     BRA NZ, 0x8554
008540  370008     BRA 0x8552
289:                       case start: break;
290:                       case scrnFX:            screenFX(); 
008542  07FFC9     RCALL screenFX
291:                       break;
008544  370007     BRA 0x8554
292:                       case debugscrnPOTS:     screenDebugPots();
008546  07FEF2     RCALL screenDebugPots
293:                       break;
008548  370005     BRA 0x8554
294:                       case debugscrnFLASH:    screenDebugFlash();
00854A  07FF68     RCALL screenDebugFlash
295:                       break;
00854C  370003     BRA 0x8554
296:                       case debugscrnBUFFERS:  screenDebugBuffers();
00854E  07FEC9     RCALL screenDebugBuffers
297:                       break;
008550  370001     BRA 0x8554
298:                       case debugscrnINPUT:    screenDebugInput();
008552  07FFAF     RCALL screenDebugInput
299:                       break;
300:                                       
301:                       default: break;
302:                   }
303:                   
304:                   laststate=state;
008554  F81038     PUSH 0x1038
008556  F9100A     POP laststate
305:                   fxLast=fxUnits[0]+fxUnits[1];
008558  808060     MOV fxUnits, W0
00855A  B4100E     ADD 0x100E, WREG
00855C  888210     MOV W0, fxLast
306:               }
00855E  060000     RETURN
307:                   /*
308:                   lcdSetCursorQ(0,3);
309:                   if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
310:                       lcdWriteStringQ("CLIP");
311:                       hard_clipped=FALSE;  
312:                   }
313:                   else if(TEST_SIN==TRUE)lcdWriteStringQ("SINE");
314:                   else lcdWriteStringQ("THRU");
315:                    * 
316:                    *    lcdSetCursorQ(10,3);
317:                  lcdWriteWordQ(ENCODERCNTL);
318:                   */
319:               
320:               
---  /home/fbuga/Documents/ps-040/routines.c  -----------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern fractional outputA[STREAMBUF], outputB[STREAMBUF];
10:                extern fractional streamA[STREAMBUF], streamB[STREAMBUF];
11:                extern unsigned int write_ptr, rw, frameReady;
12:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
13:                
14:                //misc.
15:                volatile fractional sampinA=0, sampinB=0;
16:                
17:                volatile int rxBufferIndicator = 0;
18:                fractional *ping, *pong;
19:                
20:                //Description: This interrupt triggers at the completion of DCI output
21:                //Dependancies: initSPI2(); 
22:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
00032A  BE9F80     MOV.D W0, [W15++]
00032C  BE9F82     MOV.D W2, [W15++]
00032E  781F84     MOV W4, [W15++]
000330  F80032     PUSH DSRPAG
000332  F80034     PUSH DSWPAG
000334  200010     MOV #0x1, W0
000336  8801A0     MOV W0, DSWPAG
000338  202000     MOV #0x200, W0
00033A  880190     MOV W0, DSRPAG
00033C  000000     NOP
23:                    static fractional sampoutA=0, sampoutB=0;
24:                    
25:                    int trashA=RXBUF0;
00033E  801480     MOV RXBUF0, W0
26:                    sampinA=RXBUF1;
000340  F80292     PUSH RXBUF1
000342  F91010     POP sampinA
27:                    int trashB=RXBUF2;
000344  8014A0     MOV RXBUF2, W0
28:                    sampinB=RXBUF3;
000346  F80296     PUSH RXBUF3
000348  F91012     POP sampinB
29:                    TXBUF0=TXBUF1=sampoutA;                                    //output buffered sample to DAC
00034A  F8101C     PUSH sampoutA
00034C  F9029A     POP TXBUF1
00034E  F8029A     PUSH TXBUF1
000350  F90298     POP TXBUF0
30:                    TXBUF2=TXBUF3=sampoutB;
000352  F8101A     PUSH sampoutB
000354  F9029E     POP TXBUF3
000356  F8029E     PUSH TXBUF3
000358  F9029C     POP TXBUF2
31:                
32:                
33:                    
34:                    __builtin_btg(&sampinA, 15);                             //convert to Q1.15 compatible format
00035A  210100     MOV #0x1010, W0
00035C  A2F010     BTG [W0], #15
35:                    __builtin_btg(&sampinB, 15);                             //convert to Q1.15 compatible format
00035E  210120     MOV #0x1012, W0
000360  A2F010     BTG [W0], #15
36:                    
37:                
38:                      
39:                    
40:                    if(write_ptr--==0){                       //reset pointer when out of bounds
000362  8081A0     MOV 0x1034, W0
000364  E90080     DEC W0, W1
000366  8881A1     MOV W1, 0x1034
000368  E00000     CP0 W0
00036A  3A0005     BRA NZ, 0x376
41:                        write_ptr=STREAMBUF-1;
00036C  200FF0     MOV #0xFF, W0
00036E  8881A0     MOV W0, 0x1034
42:                        __builtin_btg(&rw,0);
000370  AA1000     BTG rw, #0
43:                        frameReady=1;
000372  200010     MOV #0x1, W0
000374  888010     MOV W0, frameReady
44:                    }
45:                   
46:                    if(rw){
000376  E21000     CP0 rw
000378  320014     BRA Z, 0x3A2
47:                        streamB[write_ptr]=sampinA;
00037A  8081A0     MOV 0x1034, W0
00037C  266B22     MOV #0x66B2, W2
00037E  400180     ADD W0, W0, W3
000380  410083     ADD W2, W3, W1
000382  808084     MOV sampinA, W4
000384  780884     MOV W4, [W1]
48:                        sampoutA=outputA[write_ptr--]; 
000386  260B21     MOV #0x60B2, W1
000388  408183     ADD W1, W3, W3
00038A  780193     MOV [W3], W3
00038C  8880E3     MOV W3, sampoutA
00038E  E90000     DEC W0, W0
000390  8881A0     MOV W0, 0x1034
49:                        streamB[write_ptr]=sampinB;
000392  400000     ADD W0, W0, W0
000394  410100     ADD W2, W0, W2
000396  808093     MOV sampinB, W3
000398  780903     MOV W3, [W2]
50:                        sampoutB=outputA[write_ptr];
00039A  408000     ADD W1, W0, W0
00039C  780010     MOV [W0], W0
00039E  8880D0     MOV W0, sampoutB
0003A0  370013     BRA 0x3C8
51:                        
52:                    }
53:                    else {
54:                        streamA[write_ptr]=sampinA; 
0003A2  8081A0     MOV 0x1034, W0
0003A4  264B22     MOV #0x64B2, W2
0003A6  400180     ADD W0, W0, W3
0003A8  410083     ADD W2, W3, W1
0003AA  808084     MOV sampinA, W4
0003AC  780884     MOV W4, [W1]
55:                        sampoutA=outputB[write_ptr--];  
0003AE  262B21     MOV #0x62B2, W1
0003B0  408183     ADD W1, W3, W3
0003B2  780193     MOV [W3], W3
0003B4  8880E3     MOV W3, sampoutA
0003B6  E90000     DEC W0, W0
0003B8  8881A0     MOV W0, 0x1034
56:                        streamA[write_ptr]=sampinB; 
0003BA  400000     ADD W0, W0, W0
0003BC  410100     ADD W2, W0, W2
0003BE  808093     MOV sampinB, W3
0003C0  780903     MOV W3, [W2]
57:                        sampoutB=outputB[write_ptr];  
0003C2  408000     ADD W1, W0, W0
0003C4  780010     MOV [W0], W0
0003C6  8880D0     MOV W0, sampoutB
58:                    } 
59:                    
60:                    _DCIIF=0;
0003C8  A98807     BCLR 0x807, #4
61:                }
0003CA  F90034     POP DSWPAG
0003CC  F90032     POP DSRPAG
0003CE  78024F     MOV [--W15], W4
0003D0  BE014F     MOV.D [--W15], W2
0003D2  BE004F     MOV.D [--W15], W0
0003D4  064000     RETFIE
62:                
63:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003D6  F80036     PUSH RCOUNT
0003D8  BE9F80     MOV.D W0, [W15++]
0003DA  BE9F82     MOV.D W2, [W15++]
0003DC  BE9F84     MOV.D W4, [W15++]
0003DE  BE9F86     MOV.D W6, [W15++]
64:                    _DMA2IF = 0; /* Received one frame of data*/    
0003E0  A90803     BCLR 0x803, #0
65:                    
66:                    if(rxBufferIndicator == 0)
0003E2  E21014     CP0 rxBufferIndicator
0003E4  3A0004     BRA NZ, 0x3EE
67:                    {
68:                         processRxData((int *)rxBufferA, (int*)txBufferA);
0003E6  2CE001     MOV #0xCE00, W1
0003E8  2CA000     MOV #0xCA00, W0
0003EA  074589     RCALL processRxData
0003EC  370003     BRA 0x3F4
69:                    }
70:                    else
71:                    {
72:                         processRxData((int *)rxBufferB, (int*)txBufferB);
0003EE  2CC001     MOV #0xCC00, W1
0003F0  2C8000     MOV #0xC800, W0
0003F2  074585     RCALL processRxData
73:                    }
74:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
0003F4  AA1014     BTG rxBufferIndicator, #0
75:                }
0003F6  BE034F     MOV.D [--W15], W6
0003F8  BE024F     MOV.D [--W15], W4
0003FA  BE014F     MOV.D [--W15], W2
0003FC  BE004F     MOV.D [--W15], W0
0003FE  F90036     POP RCOUNT
000400  064000     RETFIE
76:                
77:                /*
78:                //Description: This interrupt handles UART reception
79:                //Dependencies: initUART1();
80:                void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
81:                    unsigned char trash;
82:                    trash=U1RXREG;
83:                    printf("RECIEVED: %d\r\n", trash);
84:                    IFS0bits.U1RXIF = 0;            //clear flag, restart
85:                }
86:                
87:                //Description: This interrupt handles UART transmission
88:                //Dependencies: initUART1();
89:                void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
90:                    YLED=~YLED;
91:                    IFS0bits.U1TXIF = 0;            //clear flag, restart
92:                } 
93:                  
94:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
95:                    //SEG_SEL=1;
96:                    int trash=SPI3BUF;
97:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
98:                    IFS5bits.SPI3IF=0;
99:                    
100:               }
101:                */
---  /home/fbuga/Documents/ps-040/plcd.c  ---------------------------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                #include "screens.h"
14:                
15:                extern unsigned char pad[BUTTONS];
16:                int lcdBuf[LCDBUF+1]={0};
17:                int *lcdWritePtr=lcdBuf;
18:                int *lcdReadPtr=lcdBuf;
19:                
20:                // There are write and command macros in the header, make sure these match.
21:                void lcdWriteQ(unsigned char data){
22:                    *lcdWritePtr++=data|0x0000;
007A42  FB8000     ZE W0, W0
007A44  8081F1     MOV 0x103E, W1
007A46  781880     MOV W0, [W1++]
007A48  8881F1     MOV W1, 0x103E
23:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007A4A  26AD60     MOV #0x6AD6, W0
007A4C  508F80     SUB W1, W0, [W15]
007A4E  3A0002     BRA NZ, 0x7A54
24:                        lcdWritePtr=lcdBuf;
007A50  B12000     SUB #0x200, W0
007A52  8881F0     MOV W0, 0x103E
25:                }
007A54  060000     RETURN
26:                
27:                // There are write and command macros in the header, make sure these match.
28:                void lcdCommandQ(unsigned char data){
29:                    *lcdWritePtr++=data|0x0100;     //flag for rs=1
007A56  FB8000     ZE W0, W0
007A58  8081F1     MOV 0x103E, W1
007A5A  A08000     BSET W0, #8
007A5C  781880     MOV W0, [W1++]
007A5E  8881F1     MOV W1, 0x103E
30:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007A60  26AD60     MOV #0x6AD6, W0
007A62  508F80     SUB W1, W0, [W15]
007A64  3A0002     BRA NZ, 0x7A6A
31:                        lcdWritePtr=lcdBuf;
007A66  B12000     SUB #0x200, W0
007A68  8881F0     MOV W0, 0x103E
32:                }
007A6A  060000     RETURN
33:                
34:                void lcdClearQ(void){
35:                    *lcdWritePtr++=LCD_CLEARDISPLAY|0x0300;     //flag for rs=1 & long delay
007A6C  8081F0     MOV 0x103E, W0
007A6E  203011     MOV #0x301, W1
007A70  781801     MOV W1, [W0++]
007A72  8881F0     MOV W0, 0x103E
36:                    if(lcdWritePtr==&lcdBuf[LCDBUF])
007A74  26AD61     MOV #0x6AD6, W1
007A76  500F81     SUB W0, W1, [W15]
007A78  3A0003     BRA NZ, 0x7A80
37:                        lcdWritePtr=lcdBuf;
007A7A  2FE000     MOV #0xFE00, W0
007A7C  400001     ADD W0, W1, W0
007A7E  8881F0     MOV W0, 0x103E
38:                }
007A80  060000     RETURN
39:                
40:                void lcdSetCursorQ(unsigned char col, unsigned char row) {
007A82  784101     MOV.B W1, W2
41:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
42:                  if (row > 3) {
43:                    row = 3;
44:                  }
45:                  *lcdWritePtr++=(LCD_SETDDRAMADDR | (col + offsets[row]))|0x0100;  //flag for rs=0 
007A84  8081F1     MOV 0x103E, W1
007A86  514FE3     SUB.B W2, #0x3, [W15]
007A88  360001     BRA LEU, 0x7A8C
007A8A  B3C032     MOV.B #0x3, W2
007A8C  FB8102     ZE W2, W2
007A8E  2FA3E3     MOV #0xFA3E, W3
007A90  418102     ADD W3, W2, W2
007A92  FB8112     ZE [W2], W2
007A94  FB8000     ZE W0, W0
007A96  410000     ADD W2, W0, W0
007A98  201802     MOV #0x180, W2
007A9A  701882     IOR W0, W2, [W1++]
007A9C  8881F1     MOV W1, 0x103E
46:                    if(lcdWritePtr==&lcdBuf[LCDBUF]) 
007A9E  26AD60     MOV #0x6AD6, W0
007AA0  508F80     SUB W1, W0, [W15]
007AA2  3A0002     BRA NZ, 0x7AA8
47:                        lcdWritePtr=lcdBuf; 
007AA4  B12000     SUB #0x200, W0
007AA6  8881F0     MOV W0, 0x103E
48:                }
007AA8  060000     RETURN
49:                
50:                void lcdWriteStringQ(char *string) {
51:                    char *it = string;
52:                    for (; *it; it++) {
007AAA  784090     MOV.B [W0], W1
007AAC  E00401     CP0.B W1
007AAE  32000D     BRA Z, 0x7ACA
007AC4  7840D0     MOV.B [++W0], W1
007AC6  E00401     CP0.B W1
007AC8  3AFFF6     BRA NZ, 0x7AB6
53:                        lcdWriteQMac(*it);
007AB0  26AD63     MOV #0x6AD6, W3
007AB2  2FE004     MOV #0xFE00, W4
007AB4  420203     ADD W4, W3, W4
007AB6  FB0101     SE W1, W2
007AB8  8081F1     MOV 0x103E, W1
007ABA  781882     MOV W2, [W1++]
007ABC  8881F1     MOV W1, 0x103E
007ABE  508F83     SUB W1, W3, [W15]
007AC0  3A0001     BRA NZ, 0x7AC4
007AC2  8881F4     MOV W4, 0x103E
54:                  }
55:                }
007ACA  060000     RETURN
56:                
57:                void lcdCustomSymbols(void){
58:                    int i=0;
59:                    lcdCommandQMac(0x40);
007ACC  8081F0     MOV 0x103E, W0
007ACE  201401     MOV #0x140, W1
007AD0  781801     MOV W1, [W0++]
007AD2  8881F0     MOV W0, 0x103E
007AD4  26AD61     MOV #0x6AD6, W1
007AD6  500F81     SUB W0, W1, [W15]
007AD8  3A0003     BRA NZ, 0x7AE0
007ADA  2FE000     MOV #0xFE00, W0
007ADC  400001     ADD W0, W1, W0
007ADE  8881F0     MOV W0, 0x103E
60:                    Delay_us(200);
007AE0  200C80     MOV #0xC8, W0
007AE2  070A14     RCALL Delay_us
61:                   // for(; i<8; i++)lcdWriteString(loadingOne[i]);
62:                    //lcdWriteString(loadingTwo);
63:                    //lcdWriteString(loadingThree);
64:                    //lcdWriteString(loadingFour);
65:                }
007AE4  060000     RETURN
66:                
67:                void lcdWriteWordQ(int word){
007AE6  4787E6     ADD W15, #0x6, W15
007AE8  781F8E     MOV W14, [W15++]
007B2C  200041     MOV #0x4, W1
68:                    int i;
69:                    char inchar[4];
70:                    
71:                    if(word<0) {
007AEA  E00000     CP0 W0
007AEC  3D000C     BRA GE, 0x7B06
72:                        lcdWriteQMac('-');
007AEE  8081F1     MOV 0x103E, W1
007AF0  2002D2     MOV #0x2D, W2
007AF2  781882     MOV W2, [W1++]
007AF4  8881F1     MOV W1, 0x103E
007AF6  26AD62     MOV #0x6AD6, W2
007AF8  508F82     SUB W1, W2, [W15]
007AFA  3A0003     BRA NZ, 0x7B02
007AFC  2FE001     MOV #0xFE00, W1
007AFE  408082     ADD W1, W2, W1
007B00  8881F1     MOV W1, 0x103E
73:                        word=~word+1;
007B02  EA0000     NEG W0, W0
007B04  37000A     BRA 0x7B1A
74:                    }else lcdWriteQMac(' ');
007B06  8081F1     MOV 0x103E, W1
007B08  200202     MOV #0x20, W2
007B0A  781882     MOV W2, [W1++]
007B0C  8881F1     MOV W1, 0x103E
007B0E  26AD62     MOV #0x6AD6, W2
007B10  508F82     SUB W1, W2, [W15]
007B12  3A0003     BRA NZ, 0x7B1A
007B14  2FE001     MOV #0xFE00, W1
007B16  408082     ADD W1, W2, W1
007B18  8881F1     MOV W1, 0x103E
75:                   
76:                   inchar[0] = word&0x000F; 
007B1A  6040EF     AND.B W0, #0xF, W1
77:                   if (inchar[0] > 9) 
007B1C  50CFE9     SUB.B W1, #0x9, [W15]
007B1E  340003     BRA LE, 0x7B26
78:                       inchar[0]+=55;
007B20  B04371     ADD.B #0x37, W1
007B22  9FFFA1     MOV.B W1, [W15-6]
007B24  370002     BRA 0x7B2A
79:                   else inchar[0]+=48;
007B26  B04301     ADD.B #0x30, W1
007B28  9FFFA1     MOV.B W1, [W15-6]
007B2A  578766     SUB W15, #0x6, W14
80:                   
81:                   for(i=1; i<4; i++){ 
007B46  508FF0     SUB W1, #0x10, [W15]
007B48  3AFFF2     BRA NZ, 0x7B2E
82:                      inchar[i] = ((word>>(i*4))&0x0000F); 
007B2E  DE8101     ASR W0, W1, W2
007B30  61416F     AND.B W2, #0xF, W2
007B32  E8070E     INC W14, W14
007B34  784F02     MOV.B W2, [W14]
83:                      if (inchar[i] > 9) 
007B36  514FE9     SUB.B W2, #0x9, [W15]
007B38  340003     BRA LE, 0x7B40
84:                          inchar[i]+=55;
007B3A  B3C374     MOV.B #0x37, W4
007B3C  414F04     ADD.B W2, W4, [W14]
007B3E  370002     BRA 0x7B44
85:                      else inchar[i]+=48;
007B40  B3C304     MOV.B #0x30, W4
007B42  414F04     ADD.B W2, W4, [W14]
007B44  4080E4     ADD W1, #0x4, W1
86:                   } 
87:                   lcdWriteQMac(inchar[3]);
007B4A  97F8DF     MOV.B [W15-3], W1
007B4C  FB0081     SE W1, W1
007B4E  8081F0     MOV 0x103E, W0
007B50  781801     MOV W1, [W0++]
007B52  26AD61     MOV #0x6AD6, W1
007B54  500F81     SUB W0, W1, [W15]
007B56  3A000A     BRA NZ, 0x7B6C
88:                   lcdWriteQMac(inchar[2]);
007B58  97F84F     MOV.B [W15-4], W0
007B5A  FB0000     SE W0, W0
007B5C  8B46B0     MOV W0, lcdBuf
007B6C  97F8CF     MOV.B [W15-4], W1
007B6E  FB0081     SE W1, W1
007B70  781801     MOV W1, [W0++]
007B72  8881F0     MOV W0, 0x103E
007B74  26AD61     MOV #0x6AD6, W1
007B76  500F81     SUB W0, W1, [W15]
007B78  3A0009     BRA NZ, 0x7B8C
89:                   lcdWriteQMac(inchar[1]);
007B5E  97F83F     MOV.B [W15-5], W0
007B60  FB0000     SE W0, W0
007B62  8B46C0     MOV W0, 0x68D8
007B64  2FE040     MOV #0xFE04, W0
007B66  400001     ADD W0, W1, W0
007B68  8881F0     MOV W0, 0x103E
007B6A  37001F     BRA 0x7BAA
007B7A  97F83F     MOV.B [W15-5], W0
007B7C  FB0000     SE W0, W0
007B7E  8B46B0     MOV W0, lcdBuf
007B8C  97F8BF     MOV.B [W15-5], W1
007B8E  FB0081     SE W1, W1
007B90  8081F0     MOV 0x103E, W0
007B92  781801     MOV W1, [W0++]
007B94  8881F0     MOV W0, 0x103E
007B96  26AD61     MOV #0x6AD6, W1
007B98  500F81     SUB W0, W1, [W15]
007B9A  3A0007     BRA NZ, 0x7BAA
90:                   lcdWriteQMac(inchar[0]);
007B80  97F8AF     MOV.B [W15-6], W1
007B82  FB0001     SE W1, W0
007B84  8B46C0     MOV W0, 0x68D8
007B86  268DA0     MOV #0x68DA, W0
007B88  8881F0     MOV W0, 0x103E
007B8A  37001A     BRA 0x7BC0
007B9C  97FA2F     MOV.B [W15-6], W4
007B9E  FB0004     SE W4, W0
007BA0  8B46B0     MOV W0, lcdBuf
007BA2  2FE020     MOV #0xFE02, W0
007BA4  400001     ADD W0, W1, W0
007BA6  8881F0     MOV W0, 0x103E
007BA8  37000B     BRA 0x7BC0
007BAA  97F82F     MOV.B [W15-6], W0
007BAC  FB0080     SE W0, W1
007BAE  8081F0     MOV 0x103E, W0
007BB0  781801     MOV W1, [W0++]
007BB2  8881F0     MOV W0, 0x103E
007BB4  26AD61     MOV #0x6AD6, W1
007BB6  500F81     SUB W0, W1, [W15]
007BB8  3A0003     BRA NZ, 0x7BC0
007BBA  2FE000     MOV #0xFE00, W0
007BBC  400001     ADD W0, W1, W0
007BBE  8881F0     MOV W0, 0x103E
91:                }
007BC0  78074F     MOV [--W15], W14
007BC2  B1006F     SUB #0x6, W15
007BC4  060000     RETURN
92:                
93:                void lcdWriteWordUnsignedQ(unsigned int word){
007BC6  4787E6     ADD W15, #0x6, W15
007BC8  781F8E     MOV W14, [W15++]
007BDC  200041     MOV #0x4, W1
94:                    int i;
95:                    char inchar[4];
96:                    
97:                   inchar[0] = word&0x000F; 
007BCA  6040EF     AND.B W0, #0xF, W1
98:                   if (inchar[0] > 9) 
007BCC  50CFE9     SUB.B W1, #0x9, [W15]
007BCE  340003     BRA LE, 0x7BD6
99:                       inchar[0]+=55;
007BD0  B04371     ADD.B #0x37, W1
007BD2  9FFFA1     MOV.B W1, [W15-6]
007BD4  370002     BRA 0x7BDA
100:                  else inchar[0]+=48;
007BD6  B04301     ADD.B #0x30, W1
007BD8  9FFFA1     MOV.B W1, [W15-6]
007BDA  578766     SUB W15, #0x6, W14
101:                  
102:                  for(i=1; i<4; i++){ 
007BF6  508FF0     SUB W1, #0x10, [W15]
007BF8  3AFFF2     BRA NZ, 0x7BDE
103:                     inchar[i] = ((word>>(i*4))&0x0000F); 
007BDE  DE0101     LSR W0, W1, W2
007BE0  61416F     AND.B W2, #0xF, W2
007BE2  E8070E     INC W14, W14
007BE4  784F02     MOV.B W2, [W14]
104:                     if (inchar[i] > 9) 
007BE6  514FE9     SUB.B W2, #0x9, [W15]
007BE8  340003     BRA LE, 0x7BF0
105:                         inchar[i]+=55;
007BEA  B3C374     MOV.B #0x37, W4
007BEC  414F04     ADD.B W2, W4, [W14]
007BEE  370002     BRA 0x7BF4
106:                     else inchar[i]+=48;
007BF0  B3C304     MOV.B #0x30, W4
007BF2  414F04     ADD.B W2, W4, [W14]
007BF4  4080E4     ADD W1, #0x4, W1
107:                  } 
108:                  lcdWriteQMac(inchar[3]);
007BFA  97F8DF     MOV.B [W15-3], W1
007BFC  FB0081     SE W1, W1
007BFE  8081F0     MOV 0x103E, W0
007C00  781801     MOV W1, [W0++]
007C02  26AD61     MOV #0x6AD6, W1
007C04  500F81     SUB W0, W1, [W15]
007C06  3A000A     BRA NZ, 0x7C1C
109:                  lcdWriteQMac(inchar[2]);
007C08  97F84F     MOV.B [W15-4], W0
007C0A  FB0000     SE W0, W0
007C0C  8B46B0     MOV W0, lcdBuf
007C1C  97F8CF     MOV.B [W15-4], W1
007C1E  FB0081     SE W1, W1
007C20  781801     MOV W1, [W0++]
007C22  8881F0     MOV W0, 0x103E
007C24  26AD61     MOV #0x6AD6, W1
007C26  500F81     SUB W0, W1, [W15]
007C28  3A0009     BRA NZ, 0x7C3C
110:                  lcdWriteQMac(inchar[1]);
007C0E  97F83F     MOV.B [W15-5], W0
007C10  FB0000     SE W0, W0
007C12  8B46C0     MOV W0, 0x68D8
007C14  2FE040     MOV #0xFE04, W0
007C16  400001     ADD W0, W1, W0
007C18  8881F0     MOV W0, 0x103E
007C1A  37001F     BRA 0x7C5A
007C2A  97F83F     MOV.B [W15-5], W0
007C2C  FB0000     SE W0, W0
007C2E  8B46B0     MOV W0, lcdBuf
007C3C  97F8BF     MOV.B [W15-5], W1
007C3E  FB0081     SE W1, W1
007C40  8081F0     MOV 0x103E, W0
007C42  781801     MOV W1, [W0++]
007C44  8881F0     MOV W0, 0x103E
007C46  26AD61     MOV #0x6AD6, W1
007C48  500F81     SUB W0, W1, [W15]
007C4A  3A0007     BRA NZ, 0x7C5A
111:                  lcdWriteQMac(inchar[0]);
007C30  97F8AF     MOV.B [W15-6], W1
007C32  FB0001     SE W1, W0
007C34  8B46C0     MOV W0, 0x68D8
007C36  268DA0     MOV #0x68DA, W0
007C38  8881F0     MOV W0, 0x103E
007C3A  37001A     BRA 0x7C70
007C4C  97FA2F     MOV.B [W15-6], W4
007C4E  FB0004     SE W4, W0
007C50  8B46B0     MOV W0, lcdBuf
007C52  2FE020     MOV #0xFE02, W0
007C54  400001     ADD W0, W1, W0
007C56  8881F0     MOV W0, 0x103E
007C58  37000B     BRA 0x7C70
007C5A  97F82F     MOV.B [W15-6], W0
007C5C  FB0080     SE W0, W1
007C5E  8081F0     MOV 0x103E, W0
007C60  781801     MOV W1, [W0++]
007C62  8881F0     MOV W0, 0x103E
007C64  26AD61     MOV #0x6AD6, W1
007C66  500F81     SUB W0, W1, [W15]
007C68  3A0003     BRA NZ, 0x7C70
007C6A  2FE000     MOV #0xFE00, W0
007C6C  400001     ADD W0, W1, W0
007C6E  8881F0     MOV W0, 0x103E
112:               }
007C70  78074F     MOV [--W15], W14
007C72  B1006F     SUB #0x6, W15
007C74  060000     RETURN
113:               
114:               void lcdWriteDecimalQ(char word, int digits){
007C76  FA0000     LNK #0x0
007C78  781F88     MOV W8, [W15++]
007C7A  780381     MOV W1, W7
115:                   const char maxdigits = 4;
116:                   char result[maxdigits];
007C7E  4787E6     ADD W15, #0x6, W15
007C80  780186     MOV W6, W3
117:                   char i = 3;
007C82  B3C032     MOV.B #0x3, W2
118:                   do {
119:                       result[i] = '0' + word % 10;
007C84  2000A4     MOV #0xA, W4
007C86  FB0282     SE W2, W5
007C88  418285     ADD W3, W5, W5
007C8A  FB0000     SE W0, W0
007C8C  090011     REPEAT #0x11
007C8E  D80004     DIV.SW W0, W4
007C90  B3C308     MOV.B #0x30, W8
007C92  40CA88     ADD.B W1, W8, [W5]
120:                       word /= 10;
121:                       i--;
007C94  E94102     DEC.B W2, W2
122:                   }
123:                   while (word > 0);
007C96  E00400     CP0.B W0
007C98  3CFFF6     BRA GT, 0x7C86
124:                   while (i>=0) result[i--] = ' '; 
007C9A  E00402     CP0.B W2
007C9C  350007     BRA LT, 0x7CAC
007C9E  B3C204     MOV.B #0x20, W4
007CA0  FB0002     SE W2, W0
007CA2  418000     ADD W3, W0, W0
007CA4  784804     MOV.B W4, [W0]
007CA6  E94102     DEC.B W2, W2
007CA8  414FE1     ADD.B W2, #0x1, [W15]
007CAA  3AFFFA     BRA NZ, 0x7CA0
125:                 
126:                   for (i=maxdigits-digits; i<maxdigits; i++) {
007CAC  B3C041     MOV.B #0x4, W1
007CAE  50C087     SUB.B W1, W7, W1
007CB0  50CFE3     SUB.B W1, #0x3, [W15]
007CB2  3C000F     BRA GT, 0x7CD2
007CCC  E84081     INC.B W1, W1
007CCE  50CFE4     SUB.B W1, #0x4, [W15]
007CD0  3AFFF4     BRA NZ, 0x7CBA
127:                       lcdWriteQMac(result[i]);
007CB4  26AD64     MOV #0x6AD6, W4
007CB6  2FE005     MOV #0xFE00, W5
007CB8  428284     ADD W5, W4, W5
007CBA  FB0001     SE W1, W0
007CBC  418000     ADD W3, W0, W0
007CBE  FB0110     SE [W0], W2
007CC0  8081F0     MOV 0x103E, W0
007CC2  781802     MOV W2, [W0++]
007CC4  8881F0     MOV W0, 0x103E
007CC6  500F84     SUB W0, W4, [W15]
007CC8  3A0001     BRA NZ, 0x7CCC
007CCA  8881F5     MOV W5, 0x103E
128:                   }
129:               }
007C7C  78030F     MOV W15, W6
007CD2  780786     MOV W6, W15
007CD4  78044F     MOV [--W15], W8
007CD6  FA8000     ULNK
007CD8  060000     RETURN
130:               
131:               //4x4 pad debug
132:               void lcdDrawPads(unsigned char col){
007CDA  BE9F88     MOV.D W8, [W15++]
007CDC  784480     MOV.B W0, W9
133:                   unsigned char block=0xFF;
007CEC  EBC400     SETM.B W8
134:                   if(!pad[34]||!pad[16]) block='*';
007CDE  B3C2A8     MOV.B #0x2A, W8
007CE0  268D40     MOV #0x68D4, W0
007CE2  E00410     CP0.B [W0]
007CE4  320004     BRA Z, 0x7CEE
007CE6  500072     SUB W0, #0x12, W0
007CE8  E00410     CP0.B [W0]
007CEA  320001     BRA Z, 0x7CEE
135:                   
136:                   lcdSetCursorQ(col, 0);
007CEE  EB4080     CLR.B W1
007CF0  784009     MOV.B W9, W0
007CF2  07FEC7     RCALL lcdSetCursorQ
137:                   if(!pad[12]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007CF4  268BE0     MOV #0x68BE, W0
007CF6  E00410     CP0.B [W0]
007CF8  3A000B     BRA NZ, 0x7D10
007CFA  8081F0     MOV 0x103E, W0
007CFC  200201     MOV #0x20, W1
007CFE  781801     MOV W1, [W0++]
007D00  8881F0     MOV W0, 0x103E
007D02  26AD61     MOV #0x6AD6, W1
007D04  500F81     SUB W0, W1, [W15]
007D06  3A000E     BRA NZ, 0x7D24
007D08  2FE000     MOV #0xFE00, W0
007D0A  400001     ADD W0, W1, W0
007D0C  8881F0     MOV W0, 0x103E
007D0E  37000A     BRA 0x7D24
007D10  FB8088     ZE W8, W1
007D12  8081F0     MOV 0x103E, W0
007D14  781801     MOV W1, [W0++]
007D16  8881F0     MOV W0, 0x103E
007D18  26AD61     MOV #0x6AD6, W1
007D1A  500F81     SUB W0, W1, [W15]
007D1C  3A0003     BRA NZ, 0x7D24
007D1E  2FE000     MOV #0xFE00, W0
007D20  400001     ADD W0, W1, W0
007D22  8881F0     MOV W0, 0x103E
138:                   if(!pad[13]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D24  268BF0     MOV #0x68BF, W0
007D26  E00410     CP0.B [W0]
007D28  3A000B     BRA NZ, 0x7D40
007D2A  8081F0     MOV 0x103E, W0
007D2C  200201     MOV #0x20, W1
007D2E  781801     MOV W1, [W0++]
007D30  8881F0     MOV W0, 0x103E
007D32  26AD61     MOV #0x6AD6, W1
007D34  500F81     SUB W0, W1, [W15]
007D36  3A000E     BRA NZ, 0x7D54
007D38  2FE000     MOV #0xFE00, W0
007D3A  400001     ADD W0, W1, W0
007D3C  8881F0     MOV W0, 0x103E
007D3E  37000A     BRA 0x7D54
007D40  FB8088     ZE W8, W1
007D42  8081F0     MOV 0x103E, W0
007D44  781801     MOV W1, [W0++]
007D46  8881F0     MOV W0, 0x103E
007D48  26AD61     MOV #0x6AD6, W1
007D4A  500F81     SUB W0, W1, [W15]
007D4C  3A0003     BRA NZ, 0x7D54
007D4E  2FE000     MOV #0xFE00, W0
007D50  400001     ADD W0, W1, W0
007D52  8881F0     MOV W0, 0x103E
139:                   if(!pad[14]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D54  268C00     MOV #0x68C0, W0
007D56  E00410     CP0.B [W0]
007D58  3A000B     BRA NZ, 0x7D70
007D5A  8081F0     MOV 0x103E, W0
007D5C  200201     MOV #0x20, W1
007D5E  781801     MOV W1, [W0++]
007D60  8881F0     MOV W0, 0x103E
007D62  26AD61     MOV #0x6AD6, W1
007D64  500F81     SUB W0, W1, [W15]
007D66  3A000E     BRA NZ, 0x7D84
007D68  2FE000     MOV #0xFE00, W0
007D6A  400001     ADD W0, W1, W0
007D6C  8881F0     MOV W0, 0x103E
007D6E  37000A     BRA 0x7D84
007D70  FB8088     ZE W8, W1
007D72  8081F0     MOV 0x103E, W0
007D74  781801     MOV W1, [W0++]
007D76  8881F0     MOV W0, 0x103E
007D78  26AD61     MOV #0x6AD6, W1
007D7A  500F81     SUB W0, W1, [W15]
007D7C  3A0003     BRA NZ, 0x7D84
007D7E  2FE000     MOV #0xFE00, W0
007D80  400001     ADD W0, W1, W0
007D82  8881F0     MOV W0, 0x103E
140:                   if(!pad[15]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007D84  268C10     MOV #0x68C1, W0
007D86  E00410     CP0.B [W0]
007D88  3A000B     BRA NZ, 0x7DA0
007D8A  8081F0     MOV 0x103E, W0
007D8C  200201     MOV #0x20, W1
007D8E  781801     MOV W1, [W0++]
007D90  8881F0     MOV W0, 0x103E
007D92  26AD61     MOV #0x6AD6, W1
007D94  500F81     SUB W0, W1, [W15]
007D96  3A000E     BRA NZ, 0x7DB4
007D98  2FE000     MOV #0xFE00, W0
007D9A  400001     ADD W0, W1, W0
007D9C  8881F0     MOV W0, 0x103E
007D9E  37000A     BRA 0x7DB4
007DA0  FB8088     ZE W8, W1
007DA2  8081F0     MOV 0x103E, W0
007DA4  781801     MOV W1, [W0++]
007DA6  8881F0     MOV W0, 0x103E
007DA8  26AD61     MOV #0x6AD6, W1
007DAA  500F81     SUB W0, W1, [W15]
007DAC  3A0003     BRA NZ, 0x7DB4
007DAE  2FE000     MOV #0xFE00, W0
007DB0  400001     ADD W0, W1, W0
007DB2  8881F0     MOV W0, 0x103E
141:                   lcdSetCursorQ(col, 1);
007DB4  B3C011     MOV.B #0x1, W1
007DB6  784009     MOV.B W9, W0
007DB8  07FE64     RCALL lcdSetCursorQ
142:                   if(!pad[8]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007DBA  268BA0     MOV #0x68BA, W0
007DBC  E00410     CP0.B [W0]
007DBE  3A000B     BRA NZ, 0x7DD6
007DC0  8081F0     MOV 0x103E, W0
007DC2  200201     MOV #0x20, W1
007DC4  781801     MOV W1, [W0++]
007DC6  8881F0     MOV W0, 0x103E
007DC8  26AD61     MOV #0x6AD6, W1
007DCA  500F81     SUB W0, W1, [W15]
007DCC  3A000E     BRA NZ, 0x7DEA
007DCE  2FE000     MOV #0xFE00, W0
007DD0  400001     ADD W0, W1, W0
007DD2  8881F0     MOV W0, 0x103E
007DD4  37000A     BRA 0x7DEA
007DD6  FB8088     ZE W8, W1
007DD8  8081F0     MOV 0x103E, W0
007DDA  781801     MOV W1, [W0++]
007DDC  8881F0     MOV W0, 0x103E
007DDE  26AD61     MOV #0x6AD6, W1
007DE0  500F81     SUB W0, W1, [W15]
007DE2  3A0003     BRA NZ, 0x7DEA
007DE4  2FE000     MOV #0xFE00, W0
007DE6  400001     ADD W0, W1, W0
007DE8  8881F0     MOV W0, 0x103E
143:                   if(!pad[9]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007DEA  268BB0     MOV #0x68BB, W0
007DEC  E00410     CP0.B [W0]
007DEE  3A000B     BRA NZ, 0x7E06
007DF0  8081F0     MOV 0x103E, W0
007DF2  200201     MOV #0x20, W1
007DF4  781801     MOV W1, [W0++]
007DF6  8881F0     MOV W0, 0x103E
007DF8  26AD61     MOV #0x6AD6, W1
007DFA  500F81     SUB W0, W1, [W15]
007DFC  3A000E     BRA NZ, 0x7E1A
007DFE  2FE000     MOV #0xFE00, W0
007E00  400001     ADD W0, W1, W0
007E02  8881F0     MOV W0, 0x103E
007E04  37000A     BRA 0x7E1A
007E06  FB8088     ZE W8, W1
007E08  8081F0     MOV 0x103E, W0
007E0A  781801     MOV W1, [W0++]
007E0C  8881F0     MOV W0, 0x103E
007E0E  26AD61     MOV #0x6AD6, W1
007E10  500F81     SUB W0, W1, [W15]
007E12  3A0003     BRA NZ, 0x7E1A
007E14  2FE000     MOV #0xFE00, W0
007E16  400001     ADD W0, W1, W0
007E18  8881F0     MOV W0, 0x103E
144:                   if(!pad[10]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E1A  268BC0     MOV #0x68BC, W0
007E1C  E00410     CP0.B [W0]
007E1E  3A000B     BRA NZ, 0x7E36
007E20  8081F0     MOV 0x103E, W0
007E22  200201     MOV #0x20, W1
007E24  781801     MOV W1, [W0++]
007E26  8881F0     MOV W0, 0x103E
007E28  26AD61     MOV #0x6AD6, W1
007E2A  500F81     SUB W0, W1, [W15]
007E2C  3A000E     BRA NZ, 0x7E4A
007E2E  2FE000     MOV #0xFE00, W0
007E30  400001     ADD W0, W1, W0
007E32  8881F0     MOV W0, 0x103E
007E34  37000A     BRA 0x7E4A
007E36  FB8088     ZE W8, W1
007E38  8081F0     MOV 0x103E, W0
007E3A  781801     MOV W1, [W0++]
007E3C  8881F0     MOV W0, 0x103E
007E3E  26AD61     MOV #0x6AD6, W1
007E40  500F81     SUB W0, W1, [W15]
007E42  3A0003     BRA NZ, 0x7E4A
007E44  2FE000     MOV #0xFE00, W0
007E46  400001     ADD W0, W1, W0
007E48  8881F0     MOV W0, 0x103E
145:                   if(!pad[11]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E4A  268BD0     MOV #0x68BD, W0
007E4C  E00410     CP0.B [W0]
007E4E  3A000B     BRA NZ, 0x7E66
007E50  8081F0     MOV 0x103E, W0
007E52  200201     MOV #0x20, W1
007E54  781801     MOV W1, [W0++]
007E56  8881F0     MOV W0, 0x103E
007E58  26AD61     MOV #0x6AD6, W1
007E5A  500F81     SUB W0, W1, [W15]
007E5C  3A000E     BRA NZ, 0x7E7A
007E5E  2FE000     MOV #0xFE00, W0
007E60  400001     ADD W0, W1, W0
007E62  8881F0     MOV W0, 0x103E
007E64  37000A     BRA 0x7E7A
007E66  FB8088     ZE W8, W1
007E68  8081F0     MOV 0x103E, W0
007E6A  781801     MOV W1, [W0++]
007E6C  8881F0     MOV W0, 0x103E
007E6E  26AD61     MOV #0x6AD6, W1
007E70  500F81     SUB W0, W1, [W15]
007E72  3A0003     BRA NZ, 0x7E7A
007E74  2FE000     MOV #0xFE00, W0
007E76  400001     ADD W0, W1, W0
007E78  8881F0     MOV W0, 0x103E
146:                   lcdSetCursorQ(col, 2);
007E7A  B3C021     MOV.B #0x2, W1
007E7C  784009     MOV.B W9, W0
007E7E  07FE01     RCALL lcdSetCursorQ
147:                   if(!pad[4]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007E80  268B60     MOV #0x68B6, W0
007E82  E00410     CP0.B [W0]
007E84  3A000B     BRA NZ, 0x7E9C
007E86  8081F0     MOV 0x103E, W0
007E88  200201     MOV #0x20, W1
007E8A  781801     MOV W1, [W0++]
007E8C  8881F0     MOV W0, 0x103E
007E8E  26AD61     MOV #0x6AD6, W1
007E90  500F81     SUB W0, W1, [W15]
007E92  3A000E     BRA NZ, 0x7EB0
007E94  2FE000     MOV #0xFE00, W0
007E96  400001     ADD W0, W1, W0
007E98  8881F0     MOV W0, 0x103E
007E9A  37000A     BRA 0x7EB0
007E9C  FB8088     ZE W8, W1
007E9E  8081F0     MOV 0x103E, W0
007EA0  781801     MOV W1, [W0++]
007EA2  8881F0     MOV W0, 0x103E
007EA4  26AD61     MOV #0x6AD6, W1
007EA6  500F81     SUB W0, W1, [W15]
007EA8  3A0003     BRA NZ, 0x7EB0
007EAA  2FE000     MOV #0xFE00, W0
007EAC  400001     ADD W0, W1, W0
007EAE  8881F0     MOV W0, 0x103E
148:                   if(!pad[5]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007EB0  268B70     MOV #0x68B7, W0
007EB2  E00410     CP0.B [W0]
007EB4  3A000B     BRA NZ, 0x7ECC
007EB6  8081F0     MOV 0x103E, W0
007EB8  200201     MOV #0x20, W1
007EBA  781801     MOV W1, [W0++]
007EBC  8881F0     MOV W0, 0x103E
007EBE  26AD61     MOV #0x6AD6, W1
007EC0  500F81     SUB W0, W1, [W15]
007EC2  3A000E     BRA NZ, 0x7EE0
007EC4  2FE000     MOV #0xFE00, W0
007EC6  400001     ADD W0, W1, W0
007EC8  8881F0     MOV W0, 0x103E
007ECA  37000A     BRA 0x7EE0
007ECC  FB8088     ZE W8, W1
007ECE  8081F0     MOV 0x103E, W0
007ED0  781801     MOV W1, [W0++]
007ED2  8881F0     MOV W0, 0x103E
007ED4  26AD61     MOV #0x6AD6, W1
007ED6  500F81     SUB W0, W1, [W15]
007ED8  3A0003     BRA NZ, 0x7EE0
007EDA  2FE000     MOV #0xFE00, W0
007EDC  400001     ADD W0, W1, W0
007EDE  8881F0     MOV W0, 0x103E
149:                   if(!pad[6]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007EE0  268B80     MOV #0x68B8, W0
007EE2  E00410     CP0.B [W0]
007EE4  3A000B     BRA NZ, 0x7EFC
007EE6  8081F0     MOV 0x103E, W0
007EE8  200201     MOV #0x20, W1
007EEA  781801     MOV W1, [W0++]
007EEC  8881F0     MOV W0, 0x103E
007EEE  26AD61     MOV #0x6AD6, W1
007EF0  500F81     SUB W0, W1, [W15]
007EF2  3A000E     BRA NZ, 0x7F10
007EF4  2FE000     MOV #0xFE00, W0
007EF6  400001     ADD W0, W1, W0
007EF8  8881F0     MOV W0, 0x103E
007EFA  37000A     BRA 0x7F10
007EFC  FB8088     ZE W8, W1
007EFE  8081F0     MOV 0x103E, W0
007F00  781801     MOV W1, [W0++]
007F02  8881F0     MOV W0, 0x103E
007F04  26AD61     MOV #0x6AD6, W1
007F06  500F81     SUB W0, W1, [W15]
007F08  3A0003     BRA NZ, 0x7F10
007F0A  2FE000     MOV #0xFE00, W0
007F0C  400001     ADD W0, W1, W0
007F0E  8881F0     MOV W0, 0x103E
150:                   if(!pad[7]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F10  268B90     MOV #0x68B9, W0
007F12  E00410     CP0.B [W0]
007F14  3A000B     BRA NZ, 0x7F2C
007F16  8081F0     MOV 0x103E, W0
007F18  200201     MOV #0x20, W1
007F1A  781801     MOV W1, [W0++]
007F1C  8881F0     MOV W0, 0x103E
007F1E  26AD61     MOV #0x6AD6, W1
007F20  500F81     SUB W0, W1, [W15]
007F22  3A000E     BRA NZ, 0x7F40
007F24  2FE000     MOV #0xFE00, W0
007F26  400001     ADD W0, W1, W0
007F28  8881F0     MOV W0, 0x103E
007F2A  37000A     BRA 0x7F40
007F2C  FB8088     ZE W8, W1
007F2E  8081F0     MOV 0x103E, W0
007F30  781801     MOV W1, [W0++]
007F32  8881F0     MOV W0, 0x103E
007F34  26AD61     MOV #0x6AD6, W1
007F36  500F81     SUB W0, W1, [W15]
007F38  3A0003     BRA NZ, 0x7F40
007F3A  2FE000     MOV #0xFE00, W0
007F3C  400001     ADD W0, W1, W0
007F3E  8881F0     MOV W0, 0x103E
151:                   lcdSetCursorQ(col, 3);
007F40  B3C031     MOV.B #0x3, W1
007F42  784009     MOV.B W9, W0
007F44  07FD9E     RCALL lcdSetCursorQ
152:                   if(!pad[0]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F46  268B20     MOV #0x68B2, W0
007F48  E00410     CP0.B [W0]
007F4A  3A000B     BRA NZ, 0x7F62
007F4C  8081F0     MOV 0x103E, W0
007F4E  200201     MOV #0x20, W1
007F50  781801     MOV W1, [W0++]
007F52  8881F0     MOV W0, 0x103E
007F54  26AD61     MOV #0x6AD6, W1
007F56  500F81     SUB W0, W1, [W15]
007F58  3A000E     BRA NZ, 0x7F76
007F5A  2FE000     MOV #0xFE00, W0
007F5C  400001     ADD W0, W1, W0
007F5E  8881F0     MOV W0, 0x103E
007F60  37000A     BRA 0x7F76
007F62  FB8088     ZE W8, W1
007F64  8081F0     MOV 0x103E, W0
007F66  781801     MOV W1, [W0++]
007F68  8881F0     MOV W0, 0x103E
007F6A  26AD61     MOV #0x6AD6, W1
007F6C  500F81     SUB W0, W1, [W15]
007F6E  3A0003     BRA NZ, 0x7F76
007F70  2FE000     MOV #0xFE00, W0
007F72  400001     ADD W0, W1, W0
007F74  8881F0     MOV W0, 0x103E
153:                   if(!pad[1]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007F76  268B30     MOV #0x68B3, W0
007F78  E00410     CP0.B [W0]
007F7A  3A000B     BRA NZ, 0x7F92
007F7C  8081F0     MOV 0x103E, W0
007F7E  200201     MOV #0x20, W1
007F80  781801     MOV W1, [W0++]
007F82  8881F0     MOV W0, 0x103E
007F84  26AD61     MOV #0x6AD6, W1
007F86  500F81     SUB W0, W1, [W15]
007F88  3A000E     BRA NZ, 0x7FA6
007F8A  2FE000     MOV #0xFE00, W0
007F8C  400001     ADD W0, W1, W0
007F8E  8881F0     MOV W0, 0x103E
007F90  37000A     BRA 0x7FA6
007F92  FB8088     ZE W8, W1
007F94  8081F0     MOV 0x103E, W0
007F96  781801     MOV W1, [W0++]
007F98  8881F0     MOV W0, 0x103E
007F9A  26AD61     MOV #0x6AD6, W1
007F9C  500F81     SUB W0, W1, [W15]
007F9E  3A0003     BRA NZ, 0x7FA6
007FA0  2FE000     MOV #0xFE00, W0
007FA2  400001     ADD W0, W1, W0
007FA4  8881F0     MOV W0, 0x103E
154:                   if(!pad[2]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007FA6  268B40     MOV #0x68B4, W0
007FA8  E00410     CP0.B [W0]
007FAA  3A000B     BRA NZ, 0x7FC2
007FAC  8081F0     MOV 0x103E, W0
007FAE  200201     MOV #0x20, W1
007FB0  781801     MOV W1, [W0++]
007FB2  8881F0     MOV W0, 0x103E
007FB4  26AD61     MOV #0x6AD6, W1
007FB6  500F81     SUB W0, W1, [W15]
007FB8  3A000E     BRA NZ, 0x7FD6
007FBA  2FE000     MOV #0xFE00, W0
007FBC  400001     ADD W0, W1, W0
007FBE  8881F0     MOV W0, 0x103E
007FC0  37000A     BRA 0x7FD6
007FC2  FB8088     ZE W8, W1
007FC4  8081F0     MOV 0x103E, W0
007FC6  781801     MOV W1, [W0++]
007FC8  8881F0     MOV W0, 0x103E
007FCA  26AD61     MOV #0x6AD6, W1
007FCC  500F81     SUB W0, W1, [W15]
007FCE  3A0003     BRA NZ, 0x7FD6
007FD0  2FE000     MOV #0xFE00, W0
007FD2  400001     ADD W0, W1, W0
007FD4  8881F0     MOV W0, 0x103E
155:                   if(!pad[3]){lcdWriteQMac(' ');} else lcdWriteQMac(block);
007FD6  268B50     MOV #0x68B5, W0
007FD8  E00410     CP0.B [W0]
007FDA  3A000B     BRA NZ, 0x7FF2
007FDC  8081F0     MOV 0x103E, W0
007FDE  200201     MOV #0x20, W1
007FE0  781801     MOV W1, [W0++]
007FE2  8881F0     MOV W0, 0x103E
007FE4  26AD61     MOV #0x6AD6, W1
007FE6  500F81     SUB W0, W1, [W15]
007FE8  3A000E     BRA NZ, 0x8006
007FEA  2FE000     MOV #0xFE00, W0
007FEC  400001     ADD W0, W1, W0
007FEE  8881F0     MOV W0, 0x103E
007FF0  37000A     BRA 0x8006
007FF2  FB8408     ZE W8, W8
007FF4  8081F0     MOV 0x103E, W0
007FF6  781808     MOV W8, [W0++]
007FF8  8881F0     MOV W0, 0x103E
007FFA  26AD61     MOV #0x6AD6, W1
007FFC  500F81     SUB W0, W1, [W15]
007FFE  3A0003     BRA NZ, 0x8006
008000  2FE000     MOV #0xFE00, W0
008002  400001     ADD W0, W1, W0
008004  8881F0     MOV W0, 0x103E
156:               }
008006  BE044F     MOV.D [--W15], W8
008008  060000     RETURN
157:               
158:               void lcdPoll(void){  
159:                   if(lcdWritePtr!=lcdReadPtr){   
00800A  808200     MOV 0x1040, W0
00800C  E3103E     CP 0x103E
00800E  320018     BRA Z, 0x8040
160:                       if((*lcdReadPtr>>8)&1) LCD_RS=0;
008010  201001     MOV #0x100, W1
008012  608090     AND W1, [W0], W1
008014  320002     BRA Z, 0x801A
008016  A9EE45     BCLR 0xE45, #7
008018  370001     BRA 0x801C
161:                       else LCD_RS=1;
00801A  A8EE45     BSET 0xE45, #7
162:                       if((*lcdReadPtr>>9)&1) PR3=0x2DF0; //2DF0 for ~1.3mS
00801C  202001     MOV #0x200, W1
00801E  608090     AND W1, [W0], W1
008020  320003     BRA Z, 0x8028
008022  22DF01     MOV #0x2DF0, W1
008024  880871     MOV W1, PR3
008026  370002     BRA 0x802C
163:                       else PR3=0x0120; //120 for ~40uS
008028  201201     MOV #0x120, W1
00802A  880871     MOV W1, PR3
164:                       PMDIN1=(*lcdReadPtr++)&0x00FF;
00802C  200FF1     MOV #0xFF, W1
00802E  6080B0     AND W1, [W0++], W1
008030  883041     MOV W1, PMDIN1
008032  888200     MOV W0, 0x1040
165:                       if(lcdReadPtr==&lcdBuf[LCDBUF]) lcdReadPtr=lcdBuf;
008034  26AD61     MOV #0x6AD6, W1
008036  500F81     SUB W0, W1, [W15]
008038  3A0003     BRA NZ, 0x8040
00803A  2FE000     MOV #0xFE00, W0
00803C  400001     ADD W0, W1, W0
00803E  888200     MOV W0, 0x1040
166:                   } 
167:                   TMR3=0x0000; 
008040  EF210A     CLR TMR3
168:               }
008042  060000     RETURN
169:               
170:               //ALWAYS SENDS, blocks program
171:               void lcdBlockingSend(unsigned char data){
008044  BE9F88     MOV.D W8, [W15++]
008046  781F8A     MOV W10, [W15++]
008048  784500     MOV.B W0, W10
172:                   while(PMMODEbits.BUSY)Delay_us(2);
00804A  E20602     CP0 PMMODE
00804C  3D0007     BRA GE, 0x805C
00804E  200028     MOV #0x2, W8
008050  280009     MOV #0x8000, W9
008052  780008     MOV W8, W0
008054  07075B     RCALL Delay_us
008056  803011     MOV PMMODE, W1
008058  648001     AND W9, W1, W0
00805A  3AFFFB     BRA NZ, 0x8052
173:                   PMDIN1=data; 
00805C  FB850A     ZE W10, W10
00805E  88304A     MOV W10, PMDIN1
174:               }
008060  78054F     MOV [--W15], W10
008062  BE044F     MOV.D [--W15], W8
008064  060000     RETURN
175:               //ALWAYS SENDS, blocks program
176:               void lcdBlockingClear(void){
008066  BE9F88     MOV.D W8, [W15++]
177:                   while(PMMODEbits.BUSY)Delay_us(2);
008068  E20602     CP0 PMMODE
00806A  3D0007     BRA GE, 0x807A
00806C  200028     MOV #0x2, W8
00806E  280009     MOV #0x8000, W9
008070  780008     MOV W8, W0
008072  07074C     RCALL Delay_us
008074  803011     MOV PMMODE, W1
008076  648001     AND W9, W1, W0
008078  3AFFFB     BRA NZ, 0x8070
178:                   PMDIN1=LCD_CLEARDISPLAY; 
00807A  200010     MOV #0x1, W0
00807C  883040     MOV W0, PMDIN1
179:               }
00807E  BE044F     MOV.D [--W15], W8
008080  060000     RETURN
180:               
181:               //ALWAYS SENDS, blocks program
182:               void lcdBlockingReturn(void){
008082  BE9F88     MOV.D W8, [W15++]
183:                   while(PMMODEbits.BUSY)Delay_us(2);
008084  E20602     CP0 PMMODE
008086  3D0007     BRA GE, 0x8096
008088  200028     MOV #0x2, W8
00808A  280009     MOV #0x8000, W9
00808C  780008     MOV W8, W0
00808E  07073E     RCALL Delay_us
008090  803011     MOV PMMODE, W1
008092  648001     AND W9, W1, W0
008094  3AFFFB     BRA NZ, 0x808C
184:                   PMDIN1=LCD_RETURNHOME;
008096  200020     MOV #0x2, W0
008098  883040     MOV W0, PMDIN1
185:               }
00809A  BE044F     MOV.D [--W15], W8
00809C  060000     RETURN
186:               
187:               void lcdInit(void){
188:                   LCD_RS=0;
00809E  A9EE45     BCLR 0xE45, #7
189:                   lcdBlockingSend(0x38);              //function set, 8 bits, 2 line disp, 5x8
0080A0  B3C380     MOV.B #0x38, W0
0080A2  07FFD0     RCALL lcdBlockingSend
190:                   Delay_us(4500);                //>4.1 mS required
0080A4  211940     MOV #0x1194, W0
0080A6  070732     RCALL Delay_us
191:                   lcdBlockingSend(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
0080A8  B3C0C0     MOV.B #0xC, W0
0080AA  07FFCC     RCALL lcdBlockingSend
192:                   Delay_us(4500);
0080AC  211940     MOV #0x1194, W0
0080AE  07072E     RCALL Delay_us
193:                   lcdBlockingClear();                    //Display Clear  
0080B0  07FFDA     RCALL lcdBlockingClear
194:                   Delay_us(1800);                //>1.64mS required
0080B2  207080     MOV #0x708, W0
0080B4  07072B     RCALL Delay_us
195:                   lcdBlockingSend(0x06);               // entry Mode Set
0080B6  B3C060     MOV.B #0x6, W0
0080B8  07FFC5     RCALL lcdBlockingSend
196:                   Delay_us(200);
0080BA  200C80     MOV #0xC8, W0
0080BC  070727     RCALL Delay_us
197:                   lcdBlockingReturn();
0080BE  07FFE1     RCALL lcdBlockingReturn
198:                   Delay_us(1500);
0080C0  205DC0     MOV #0x5DC, W0
0080C2  070724     RCALL Delay_us
199:                   
200:                   //lcdCustomSymbols();
201:                   Delay_us(200);
0080C4  200C80     MOV #0xC8, W0
0080C6  070722     RCALL Delay_us
202:                   lcdBlockingClear();                         //Display Clear  
0080C8  07FFCE     RCALL lcdBlockingClear
203:                   Delay_us(1500);
0080CA  205DC0     MOV #0x5DC, W0
0080CC  07071F     RCALL Delay_us
204:                   lcdBlockingReturn();
0080CE  07FFD9     RCALL lcdBlockingReturn
205:                   Delay_us(200);
0080D0  200C80     MOV #0xC8, W0
0080D2  07071C     RCALL Delay_us
206:               }
0080D4  060000     RETURN
---  /home/fbuga/Documents/ps-040/main.c  ---------------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 #include "audio.h"
9:                 #include "plcd.h"
10:                
11:                #pragma config ICS = PGD1       //pgeDC 1 is used
12:                #pragma config JTAGEN = OFF     //disable jtag
13:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
14:                #pragma config FWDTEN = OFF     //disable watchdog timer 
15:                #pragma config GCP = OFF        //disable general segment code protect
16:                #pragma config PLLKEN = ON      //wait for PLL lock
17:                #pragma config POSCMD = NONE    //no external oscillator
18:                #pragma config OSCIOFNC = OFF   //OSC2 is clock output
19:                #pragma config FNOSC = FRCPLL   //clock source
20:                
21:                /* Data Buffers & index variables */
22:                fractional outputA[STREAMBUF], outputB[STREAMBUF];
23:                fractional streamA[STREAMBUF], streamB[STREAMBUF];
24:                unsigned int write_ptr=STREAMBUF, rw=0, frameReady=0;
25:                
26:                /* DMA BUFFERS */
27:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
28:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
29:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
31:                
32:                
33:                /* Debug Variables */
34:                unsigned int process_time=0;
35:                
36:                unsigned char hard_clipped=FALSE;                                              
37:                volatile unsigned char recording=TRUE;
38:                unsigned char UART_ON = FALSE;
39:                unsigned char TEST_SIN = FALSE;
40:                
41:                char flash_readback[512]={0};
42:                
43:                /* Screen state variables */
44:                enum screenStruc state = scrnFX;
45:                enum screenStruc laststate = invalid;
46:                enum fxStruct fxUnits[NUMFXUNITS]={0,0};
47:                
48:                /* Buttons & Potentiometers */
49:                unsigned char pad[BUTTONS];                                                            
50:                fractional pots[POTS]={0};
51:                fractional pots_scaled[POTS]={0};
52:                fractional pots_custom[POTS]={0};
53:                
54:                void initBuffer(void){
0091A2  264B07     MOV #0x64B0, W7
0091A4  266B06     MOV #0x66B0, W6
0091A6  2CDFE5     MOV #0xCDFE, W5
0091A8  2CBFE4     MOV #0xCBFE, W4
0091AA  2C9FE3     MOV #0xC9FE, W3
0091AC  2C7FE2     MOV #0xC7FE, W2
0091AE  201001     MOV #0x100, W1
0091C4  200232     MOV #0x23, W2
0091C6  410100     ADD W2, W0, W2
55:                    int i;
56:                    for(i=0; i<STREAMBUF; i++){
0091C0  3AFFF8     BRA NZ, 0x91B2
0091C2  268B10     MOV #0x68B1, W0
57:                        streamA[i]=0;
0091B0  EB0000     CLR W0
0091B2  782B80     MOV W0, [++W7]
58:                        streamB[i]=0;
0091B4  782B00     MOV W0, [++W6]
59:                        txBufferA[i]=0;
0091B6  782A80     MOV W0, [++W5]
60:                        txBufferB[i]=0;
0091B8  782A00     MOV W0, [++W4]
61:                        rxBufferA[i]=0;
0091BA  782980     MOV W0, [++W3]
62:                        rxBufferB[i]=0;
0091BC  782900     MOV W0, [++W2]
0091BE  E90081     DEC W1, W1
63:                    }
64:                    
65:                    for(i=0; i<BUTTONS; i++)
0091CC  500F82     SUB W0, W2, [W15]
0091CE  3AFFFD     BRA NZ, 0x91CA
66:                        pad[i]=1;
0091C8  B3C011     MOV.B #0x1, W1
0091CA  786801     MOV.B W1, [++W0]
67:                }
0091D0  060000     RETURN
68:                
69:                int main(void) {
0091D2  BE9F88     MOV.D W8, [W15++]
0091D4  BE9F8A     MOV.D W10, [W15++]
0091D6  781F8C     MOV W12, [W15++]
70:                    initPorts();                    //configure io device & adc 
0091D8  07F9C3     RCALL initPorts
71:                    //initUART1();                    //configure & enable UART
72:                    initBuffer();
0091DA  07FFE3     RCALL initBuffer
73:                    initADC1();                     //configure & enable internal ADC
0091DC  07FA88     RCALL initADC1
74:                    initPMP();
0091DE  07FAA3     RCALL initPMP
75:                    //||||||||----
76:                    //initDMA0();
77:                    initDCI_DAC();                  //configure & enable DAC
0091E0  07FAE1     RCALL initDCI_DAC
78:                    initT1();                       //configure & start T1 
0091E2  07FAB5     RCALL initT1
79:                    initT2();                       //configure & start T2 
0091E4  07FABD     RCALL initT2
80:                    initSPI3_MEM();                  //start segment display
0091E6  07FB56     RCALL initSPI3_MEM
81:                    //initCAP_BPM();                  //configure bpm capture
82:                    initT3();                       //configure & start T3 for lcd
0091E8  07FAC7     RCALL initT3
83:                    initQEI_ENC();
0091EA  07FB76     RCALL initQEI_ENC
84:                    //initT5();
85:                    fractional temp;
86:                    fractional *ping, *pong;
87:                    
88:                    while(1){    
89:                        if(frameReady) {
0091F6  E21002     CP0 frameReady
0091F8  32000F     BRA Z, 0x9218
90:                            process_time=(STREAMBUF-1);             //DEBUG
0091FA  200FF0     MOV #0xFF, W0
0091FC  888020     MOV W0, process_time
91:                            if(rw){
0091FE  E21000     CP0 rw
009200  320003     BRA Z, 0x9208
92:                                ping = streamA+(STREAMBUF-1);
0091F2  266B0C     MOV #0x66B0, W12
009204  78000C     MOV W12, W0
009206  370002     BRA 0x920C
93:                                pong = outputB+(STREAMBUF-1);
0091F0  264B0B     MOV #0x64B0, W11
009202  78008B     MOV W11, W1
94:                            }else{
95:                                ping = streamB+(STREAMBUF-1);
0091EE  268B0A     MOV #0x68B0, W10
00920A  78000A     MOV W10, W0
96:                                pong = outputA+(STREAMBUF-1);
0091EC  262B09     MOV #0x62B0, W9
009208  780089     MOV W9, W1
97:                            }
98:                            
99:                            processAudio(ping, pong); 
00920C  07FC5D     RCALL processAudio
100:                           process_time=(STREAMBUF-1)-write_ptr;    //DEBUG
00920E  8081A0     MOV 0x1034, W0
009210  200FF1     MOV #0xFF, W1
009212  508000     SUB W1, W0, W0
009214  888020     MOV W0, process_time
101:                           frameReady=0;
009216  EF3002     CLR frameReady
102:                           
103:                           
104:                       }
105:                       if(_T2IF){
009218  ABE800     BTST IFS0, #7
00921A  320006     BRA Z, 0x9228
106:                           scanButtons();                   //read button matrix
00921C  07FCF3     RCALL scanButtons
107:                           if(_AD1IF) readPots();
0091F4  220008     MOV #0x2000, W8
00921E  804001     MOV IFS0, W1
009220  640001     AND W8, W1, W0
009222  320001     BRA Z, 0x9226
009224  07FD69     RCALL readPots
108:                           _T2IF=0;
009226  A9E800     BCLR IFS0, #7
109:                       }
110:                       if(_T1IF){
009228  AB6800     BTST IFS0, #3
00922A  320002     BRA Z, 0x9230
111:                           display();
00922C  07FE4F     RCALL display
112:                           _T1IF=0;
00922E  A96800     BCLR IFS0, #3
113:                       }
114:                       if(_T3IF) {
009230  AB0801     BTST 0x801, #0
009232  32FFE1     BRA Z, 0x91F6
115:                           lcdPoll();
009234  07F6EA     RCALL lcdPoll
116:                           _T3IF=0;
009236  A90801     BCLR 0x801, #0
009238  37FFDE     BRA 0x91F6
117:                       }
118:                   }
119:                   return 0;
120:               }
121:               // example test 
---  /home/fbuga/Documents/ps-040/flash.c  --------------------------------------------------------------
1:                 /*
2:                  * File:   flash.c
3:                  * Author: root
4:                  *
5:                  * Created on January 28, 2018, 5:00 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "flash.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                char flashBuf[STREAMBUF*2];
15:                char receive;
16:                
17:                void flashWriteReg(char command) {
18:                    SS3=0;
00907C  A92E54     BCLR LATF, #1
19:                    SPI3BUF=command;               //WEL=1 for write enable
00907E  FB0000     SE W0, W0
009080  881540     MOV W0, SPI3BUF
20:                    while(!_SPI3IF); _SPI3IF=0;
009082  208001     MOV #0x800, W1
009084  804052     MOV IFS5, W2
009086  608002     AND W1, W2, W0
009088  32FFFD     BRA Z, 0x9084
00908A  A9680B     BCLR 0x80B, #3
21:                    receive=SPI3BUF;
00908C  801540     MOV SPI3BUF, W0
00908E  B7F048     MOV.B WREG, receive
22:                    SS3=1;
009090  A82E54     BSET LATF, #1
23:                }
009092  060000     RETURN
24:                
25:                char flashStatusCheck(void){
26:                    SS3=0;
009094  A92E54     BCLR LATF, #1
27:                    SPI3BUF=FLASH_RDSR1;               //WEL=1 for write enable
009096  200050     MOV #0x5, W0
009098  881540     MOV W0, SPI3BUF
28:                    while(!_SPI3IF); _SPI3IF=0;
00909A  208001     MOV #0x800, W1
00909C  804052     MOV IFS5, W2
00909E  608002     AND W1, W2, W0
0090A0  32FFFD     BRA Z, 0x909C
0090A2  A9680B     BCLR 0x80B, #3
29:                    receive=SPI3BUF;
0090A4  801540     MOV SPI3BUF, W0
30:                    SPI3BUF=0x00;               //WEL=1 for write enable
0090A6  EF22A8     CLR SPI3BUF
31:                    while(!_SPI3IF); _SPI3IF=0;
0090A8  208001     MOV #0x800, W1
0090AA  804052     MOV IFS5, W2
0090AC  608002     AND W1, W2, W0
0090AE  32FFFD     BRA Z, 0x90AA
0090B0  A9680B     BCLR 0x80B, #3
32:                    receive=SPI3BUF;
0090B2  801540     MOV SPI3BUF, W0
0090B4  B7F048     MOV.B WREG, receive
33:                    SS3=1;
0090B6  A82E54     BSET LATF, #1
34:                    
35:                    return receive;
36:                }
0090B8  060000     RETURN
37:                
38:                void flashWritePage(int addressH, int addressL){
39:                    int i;
40:                    SS3=0;
0090BA  A92E54     BCLR LATF, #1
41:                    SPI3BUF=FLASH_PP;
0090BC  200022     MOV #0x2, W2
0090BE  881542     MOV W2, SPI3BUF
42:                    while(!_SPI3IF); _SPI3IF=0;
0090C0  208003     MOV #0x800, W3
0090C2  804054     MOV IFS5, W4
0090C4  618104     AND W3, W4, W2
0090C6  32FFFD     BRA Z, 0x90C2
0090C8  A9680B     BCLR 0x80B, #3
43:                    receive=SPI3BUF;
0090CA  801542     MOV SPI3BUF, W2
44:                    SPI3BUF=addressH&&0xFF;
0090CC  A7F000     BTSC W0, #15
0090CE  EA0000     NEG W0, W0
0090D0  EA0000     NEG W0, W0
0090D2  DE004F     LSR W0, #15, W0
0090D4  881540     MOV W0, SPI3BUF
45:                    while(!_SPI3IF); _SPI3IF=0;
0090D6  208002     MOV #0x800, W2
0090D8  804053     MOV IFS5, W3
0090DA  610003     AND W2, W3, W0
0090DC  32FFFD     BRA Z, 0x90D8
0090DE  A9680B     BCLR 0x80B, #3
46:                    receive=SPI3BUF;
0090E0  801540     MOV SPI3BUF, W0
47:                    SPI3BUF=(addressL&&0xFF00)>>8;
0090E2  EF22A8     CLR SPI3BUF
48:                    while(!_SPI3IF); _SPI3IF=0;
0090E4  208002     MOV #0x800, W2
0090E6  804054     MOV IFS5, W4
0090E8  610004     AND W2, W4, W0
0090EA  32FFFD     BRA Z, 0x90E6
0090EC  A9680B     BCLR 0x80B, #3
49:                    receive=SPI3BUF;
0090EE  801540     MOV SPI3BUF, W0
50:                    SPI3BUF=addressL&&0xFF;
0090F0  780001     MOV W1, W0
0090F2  A7F000     BTSC W0, #15
0090F4  EA0000     NEG W0, W0
0090F6  EA0000     NEG W0, W0
0090F8  DE004F     LSR W0, #15, W0
0090FA  881540     MOV W0, SPI3BUF
51:                    while(!_SPI3IF); _SPI3IF=0;
0090FC  208001     MOV #0x800, W1
0090FE  804052     MOV IFS5, W2
009100  608002     AND W1, W2, W0
009102  32FFFD     BRA Z, 0x90FE
009104  A9680B     BCLR 0x80B, #3
52:                    receive=SPI3BUF;
009106  801540     MOV SPI3BUF, W0
009108  202002     MOV #0x200, W2
53:                    
54:                    for(i=0; i<512;i++){    //write 512 bytes
00911C  3AFFF8     BRA NZ, 0x910E
00911E  B7F048     MOV.B WREG, receive
55:                        //send byte
56:                        SPI3BUF=0xAA;
00910A  200AA3     MOV #0xAA, W3
00910E  881543     MOV W3, SPI3BUF
57:                        while(!_SPI3IF); _SPI3IF=0;
00910C  208001     MOV #0x800, W1
009110  804054     MOV IFS5, W4
009112  608004     AND W1, W4, W0
009114  32FFFD     BRA Z, 0x9110
009116  A9680B     BCLR 0x80B, #3
58:                        receive=SPI3BUF;
009118  801540     MOV SPI3BUF, W0
00911A  E90102     DEC W2, W2
59:                    }
60:                    SS3=1;
009120  A82E54     BSET LATF, #1
61:                }
009122  060000     RETURN
62:                
63:                void flashRead(char *array, int bytes){
009124  BE9F88     MOV.D W8, [W15++]
009126  BE9F8A     MOV.D W10, [W15++]
009128  781F8C     MOV W12, [W15++]
00912A  780581     MOV W1, W11
64:                    int i;
65:                    
66:                    SS3=0;
00912C  A92E54     BCLR LATF, #1
67:                    SPI3BUF=FLASH_READ;
00912E  200031     MOV #0x3, W1
009130  881541     MOV W1, SPI3BUF
68:                    while(!_SPI3IF); _SPI3IF=0;
009132  208002     MOV #0x800, W2
009134  804053     MOV IFS5, W3
009136  610083     AND W2, W3, W1
009138  32FFFD     BRA Z, 0x9134
00913A  A9680B     BCLR 0x80B, #3
69:                    receive=SPI3BUF;
00913C  801541     MOV SPI3BUF, W1
70:                    SPI3BUF=0x00;
00913E  EF22A8     CLR SPI3BUF
71:                    while(!_SPI3IF); _SPI3IF=0;
009140  208002     MOV #0x800, W2
009142  804053     MOV IFS5, W3
009144  610083     AND W2, W3, W1
009146  32FFFD     BRA Z, 0x9142
009148  A9680B     BCLR 0x80B, #3
72:                    receive=SPI3BUF;
00914A  801541     MOV SPI3BUF, W1
73:                    SPI3BUF=0x00;
00914C  EF22A8     CLR SPI3BUF
74:                    while(!_SPI3IF); _SPI3IF=0;
00914E  208002     MOV #0x800, W2
009150  804053     MOV IFS5, W3
009152  610083     AND W2, W3, W1
009154  32FFFD     BRA Z, 0x9150
009156  A9680B     BCLR 0x80B, #3
75:                    receive=SPI3BUF;
009158  801541     MOV SPI3BUF, W1
76:                    SPI3BUF=0x00;
00915A  EF22A8     CLR SPI3BUF
77:                    while(!_SPI3IF); _SPI3IF=0;
00915C  208002     MOV #0x800, W2
00915E  804053     MOV IFS5, W3
009160  610083     AND W2, W3, W1
009162  32FFFD     BRA Z, 0x915E
009164  A9680B     BCLR 0x80B, #3
78:                    receive=SPI3BUF;
009166  801541     MOV SPI3BUF, W1
009168  784181     MOV.B W1, W3
00916A  210482     MOV #0x1048, W2
00916C  784903     MOV.B W3, [W2]
79:                    
80:                    for(i=0; i<bytes;i++){    //read 512 bytes
00916E  E0000B     CP0 W11
009170  340010     BRA LE, 0x9192
009172  780500     MOV W0, W10
009174  EB0480     CLR W9
00918C  E80489     INC W9, W9
00918E  558F89     SUB W11, W9, [W15]
009190  3CFFF4     BRA GT, 0x917A
81:                        //receive byte
82:                        SPI3BUF=0x00;
009176  EB0600     CLR W12
00917A  88154C     MOV W12, SPI3BUF
83:                        while(!_SPI3IF); _SPI3IF=0;
009178  208008     MOV #0x800, W8
00917C  804051     MOV IFS5, W1
00917E  640001     AND W8, W1, W0
009180  32FFFD     BRA Z, 0x917C
009182  A9680B     BCLR 0x80B, #3
84:                        Delay_us(1);
009184  200010     MOV #0x1, W0
009186  07FEC2     RCALL Delay_us
85:                        array[i]=SPI3BUF;
009188  801540     MOV SPI3BUF, W0
00918A  785D00     MOV.B W0, [W10++]
86:                    }
87:                    SS3=1;
009192  A82E54     BSET LATF, #1
88:                }
009194  78064F     MOV [--W15], W12
009196  BE054F     MOV.D [--W15], W10
009198  BE044F     MOV.D [--W15], W8
00919A  060000     RETURN
89:                
90:                void flashBulkErase(void) {
91:                    flashWriteReg(FLASH_FRMT);
00919C  B3C600     MOV.B #0x60, W0
00919E  07FF6E     RCALL flashWriteReg
92:                }
0091A0  060000     RETURN
---  /home/fbuga/Documents/ps-040/devInits.c  -----------------------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 #include <xc.h>
5:                 #include <p33EP512GM310.h>
6:                 #include <libpic30.h>
7:                 #include "common.h"
8:                 #include "devInits.h"
9:                 #include "utilities.h"
10:                #include "plcd.h"
11:                #include "screens.h"
12:                #include "flash.h"
13:                #include "dsp.h"
14:                
15:                extern unsigned char UART_ON;
16:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
17:                
18:                extern char flash_readback[512];
19:                
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
008560  2FF3F0     MOV #0xFF3F, W0
008562  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
008564  2FFE00     MOV #0xFFE0, W0
008566  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
008568  2FE000     MOV #0xFE00, W0
00856A  B60746     AND PLLFBD, WREG
00856C  B30490     IOR #0x49, W0
00856E  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
008570  200201     MOV #0x20, W1
008572  803A12     MOV OSCCON, W2
008574  608002     AND W1, W2, W0
008576  32FFFD     BRA Z, 0x8572
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
008578  803A10     MOV OSCCON, W0
00857A  A16000     BCLR W0, #6
00857C  200462     MOV #0x46, W2
00857E  200573     MOV #0x57, W3
008580  207421     MOV #0x742, W1
008582  784882     MOV.B W2, [W1]
008584  784883     MOV.B W3, [W1]
008586  784880     MOV.B W0, [W1]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
008588  2FFC00     MOV #0xFFC0, W0
00858A  803424     MOV RPOR2, W4
00858C  600084     AND W0, W4, W1
00858E  A00001     BSET W1, #0
008590  883421     MOV W1, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
008592  2FF801     MOV #0xFF80, W1
008594  803685     MOV RPINR24, W5
008596  608205     AND W1, W5, W4
008598  B303D4     IOR #0x3D, W4
00859A  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
00859C  B60686     AND RPOR3, WREG
00859E  B300C0     IOR #0xC, W0
0085A0  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
0085A2  2C0FF0     MOV #0xC0FF, W0
0085A4  803426     MOV RPOR2, W6
0085A6  600286     AND W0, W6, W5
0085A8  20D004     MOV #0xD00, W4
0085AA  720205     IOR W4, W5, W4
0085AC  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
0085AE  803434     MOV RPOR3, W4
0085B0  600284     AND W0, W4, W5
0085B2  20B004     MOV #0xB00, W4
0085B4  720205     IOR W4, W5, W4
0085B6  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
0085B8  803575     MOV RPINR7, W5
0085BA  608205     AND W1, W5, W4
0085BC  B305F4     IOR #0x5F, W4
0085BE  883574     MOV W4, RPINR7
36:                    RPINR29bits.SCK3R=0x39;     //SCK3 input on pin 84
0085C0  280FF4     MOV #0x80FF, W4
0085C2  8036D5     MOV RPINR29, W5
0085C4  620305     AND W4, W5, W6
0085C6  239005     MOV #0x3900, W5
0085C8  728286     IOR W5, W6, W5
0085CA  8836D5     MOV W5, RPINR29
37:                    RPOR7bits.RP57R=0x20;       //SCK3 output on pin 84
0085CC  803476     MOV RPOR7, W6
0085CE  600286     AND W0, W6, W5
0085D0  A0D005     BSET W5, #13
0085D2  883475     MOV W5, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
0085D4  803485     MOV RPOR8, W5
0085D6  600305     AND W0, W5, W6
0085D8  21F005     MOV #0x1F00, W5
0085DA  728286     IOR W5, W6, W5
0085DC  883485     MOV W5, RPOR8
39:                    RPOR9bits.RP97R=0x21;       //SS3 on pin 88
0085DE  B60692     AND RPOR9, WREG
0085E0  221005     MOV #0x2100, W5
0085E2  728280     IOR W5, W0, W5
0085E4  883495     MOV W5, RPOR9
40:                    RPINR29bits.SDI3R=0x4C;     //SDI on pin 79, RPI76
0085E6  8036D6     MOV RPINR29, W6
0085E8  608006     AND W1, W6, W0
0085EA  B304C0     IOR #0x4C, W0
0085EC  8836D0     MOV W0, RPINR29
41:                    RPINR14bits.QEA1R=0x10;     //QEA on pin 22, RPI16
0085EE  8035E0     MOV RPINR14, W0
0085F0  608080     AND W1, W0, W1
0085F2  A04001     BSET W1, #4
0085F4  8835E1     MOV W1, RPINR14
42:                    RPINR14bits.QEB1R=0x1B;     //QEB on pin 21, RPI27
0085F6  8035E5     MOV RPINR14, W5
0085F8  620205     AND W4, W5, W4
0085FA  21B000     MOV #0x1B00, W0
0085FC  700004     IOR W0, W4, W0
0085FE  8835E0     MOV W0, RPINR14
43:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
008600  803A10     MOV OSCCON, W0
008602  A06000     BSET W0, #6
008604  207421     MOV #0x742, W1
008606  784882     MOV.B W2, [W1]
008608  784883     MOV.B W3, [W1]
00860A  784880     MOV.B W0, [W1]
44:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
45:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
00860C  EB8000     SETM W0
00860E  883B60     MOV W0, PMD7
008610  F8076C     PUSH PMD7
008612  F9076A     POP PMD6
008614  F8076A     PUSH PMD6
008616  F90766     POP PMD4
008618  F80766     PUSH PMD4
00861A  F90764     POP PMD3
00861C  F80764     PUSH PMD3
00861E  F90762     POP PMD2
008620  F80762     PUSH PMD2
008622  F90760     POP PMD1
46:                    PMD1bits.AD1MD=0;
008624  A90760     BCLR PMD1, #0
47:                    PMD1bits.SPI1MD=0;
008626  A96760     BCLR PMD1, #3
48:                    PMD1bits.SPI2MD=0;
008628  A98760     BCLR PMD1, #4
49:                    PMD1bits.U1MD=0;
00862A  A9A760     BCLR PMD1, #5
50:                    PMD1bits.U2MD=0;
00862C  A9C760     BCLR PMD1, #6
51:                    PMD1bits.DCIMD=0;
00862E  A90761     BCLR 0x761, #0
52:                    PMD1bits.T1MD=0;
008630  A96761     BCLR 0x761, #3
53:                    PMD1bits.T2MD=0;
008632  A98761     BCLR 0x761, #4
54:                    PMD1bits.T3MD=0;
008634  A9A761     BCLR 0x761, #5
55:                    PMD1bits.T4MD=0;
008636  A9C761     BCLR 0x761, #6
56:                    PMD1bits.T5MD=0;
008638  A9E761     BCLR 0x761, #7
57:                    PMD3bits.PMPMD=0;
00863A  A90765     BCLR 0x765, #0
58:                    PMD3bits.CMPMD=0;
00863C  A94765     BCLR 0x765, #2
59:                    PMD6bits.SPI3MD=0;
00863E  A9076A     BCLR PMD6, #0
60:                    PMD7bits.DMA0MD=0;
008640  A9876C     BCLR PMD7, #4
61:                    
62:                    /* Digital IO DIRECTION (1 = input) */
63:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
008642  EF2E60     CLR TRISG
008644  F80E60     PUSH TRISG
008646  F90E50     POP TRISF
008648  F80E50     PUSH TRISF
00864A  F90E40     POP TRISE
00864C  F80E40     PUSH TRISE
00864E  F90E30     POP TRISD
008650  F80E30     PUSH TRISD
008652  F90E20     POP TRISC
008654  F80E20     PUSH TRISC
008656  F90E10     POP TRISB
008658  F80E10     PUSH TRISB
00865A  F90E00     POP TRISA
64:                    TRISA=0x1E01; CNPUA=0x0801;
00865C  21E011     MOV #0x1E01, W1
00865E  887001     MOV W1, TRISA
008660  208011     MOV #0x801, W1
008662  887051     MOV W1, CNPUA
65:                    TRISB=0x0000; CNPUB=0x0000;
008664  EF2E10     CLR TRISB
008666  EF2E1A     CLR CNPUB
66:                    TRISC=0x2087;
008668  220871     MOV #0x2087, W1
00866A  887101     MOV W1, TRISC
67:                    TRISD=0x011E; CNPUD=0x001E;
00866C  2011E1     MOV #0x11E, W1
00866E  887181     MOV W1, TRISD
008670  2001E1     MOV #0x1E, W1
008672  8871D1     MOV W1, CNPUD
68:                    TRISE=0x7300;
008674  273001     MOV #0x7300, W1
008676  887201     MOV W1, TRISE
69:                    TRISF=0x00F0; CNPUF=0x00F1;
008678  200F01     MOV #0xF0, W1
00867A  887281     MOV W1, TRISF
00867C  E80081     INC W1, W1
00867E  8872D1     MOV W1, CNPUF
70:                    TRISG=CNPUG=0xFFFF;   //PORTG all inputs,//weak pull ups on all of G
008680  887350     MOV W0, CNPUG
008682  F80E6A     PUSH CNPUG
008684  F90E60     POP TRISG
71:                    
72:                    /* DIGITAL OUTPUT LATCH */
73:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
008686  EF2E64     CLR LATG
008688  F80E64     PUSH LATG
00868A  F90E54     POP LATF
00868C  F80E54     PUSH LATF
00868E  F90E44     POP LATE
008690  F80E44     PUSH LATE
008692  F90E34     POP LATD
008694  F80E34     PUSH LATD
008696  F90E24     POP LATC
008698  F80E24     PUSH LATC
00869A  F90E14     POP LATB
00869C  F80E14     PUSH LATB
00869E  F90E04     POP LATA
74:                    LATA=0x0040;
0086A0  200400     MOV #0x40, W0
0086A2  887020     MOV W0, LATA
75:                    
76:                    /* ANALOG PINS (1 = analog) */
77:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
0086A4  EF2E6E     CLR ANSELG
0086A6  F80E6E     PUSH ANSELG
0086A8  F90E5E     POP ANSELF
0086AA  F80E5E     PUSH ANSELF
0086AC  F90E4E     POP ANSELE
0086AE  F80E4E     PUSH ANSELE
0086B0  F90E3E     POP ANSELD
0086B2  F80E3E     PUSH ANSELD
0086B4  F90E2E     POP ANSELC
0086B6  F80E2E     PUSH ANSELC
0086B8  F90E1E     POP ANSELB
0086BA  F80E1E     PUSH ANSELB
0086BC  F90E0E     POP ANSELA
78:                    ANSELCbits.ANSC0=1;     //AN6
0086BE  A80E2E     BSET ANSELC, #0
79:                    ANSELCbits.ANSC1=1;     //AN7
0086C0  A82E2E     BSET ANSELC, #1
80:                    ANSELCbits.ANSC2=1;     //AN8
0086C2  A84E2E     BSET ANSELC, #2
81:                    ANSELAbits.ANSA12=1;    //AN10 
0086C4  A88E0F     BSET 0xE0F, #4
82:                    ANSELEbits.ANSE8=1;     //AN21
0086C6  A80E4F     BSET 0xE4F, #0
83:                    ANSELEbits.ANSE9=1;     //AN20
0086C8  A82E4F     BSET 0xE4F, #1
84:                    
85:                    
86:                    
87:                }
0086CA  060000     RETURN
88:                
89:                void initUART1(void){
90:                    IFS0bits.U1TXIF = 0;        //clear flag
0086CC  A98801     BCLR 0x801, #4
91:                    IFS0bits.U1RXIF = 0;        //clear flag
0086CE  A96801     BCLR 0x801, #3
92:                    U1STA=0x1510;               //enable tx & rx
0086D0  215100     MOV #0x1510, W0
0086D2  881110     MOV W0, U1STA
93:                    U1BRG=BRGVAL;               //baud rate
0086D4  2004A0     MOV #0x4A, W0
0086D6  881140     MOV W0, U1BRG
94:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
0086D8  2FFF90     MOV #0xFFF9, W0
0086DA  B60220     AND U1MODE, WREG
0086DC  A01000     BSET W0, #1
0086DE  881100     MOV W0, U1MODE
95:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
0086E0  270000     MOV #0x7000, W0
0086E2  B72844     IOR IPC2
96:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
0086E4  200070     MOV #0x7, W0
0086E6  B72846     IOR IPC3
97:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
98:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
99:                    U1MODEbits.UARTEN = 1;      //start uart
0086E8  A8E221     BSET 0x221, #7
100:                   UART_ON = TRUE;
0086EA  EFF007     SETM.B UART_ON
101:                   
102:               }
0086EC  060000     RETURN
103:               
104:               void initADC1(void){ 
105:               
106:                   /* Assign MUXA inputs */
107:                   AD1CON1 = 0x04E4; // Enable 12-bit mode, auto-sample and auto-conversion
0086EE  204E40     MOV #0x4E4, W0
0086F0  881900     MOV W0, AD1CON1
108:                   AD1CON2 = 0x0408; // Sample alternately using channel scanning
0086F2  B10DC0     SUB #0xDC, W0
0086F4  881910     MOV W0, AD1CON2
109:                   AD1CON2bits.SMPI=(POTS/2)-1; // Sample 6 channels
0086F6  2FF830     MOV #0xFF83, W0
0086F8  B60322     AND AD1CON2, WREG
0086FA  B30140     IOR #0x14, W0
0086FC  881910     MOV W0, AD1CON2
110:                   AD1CON3 = 0x0F0F; // Sample for 15*TAD before converting
0086FE  20F0F0     MOV #0xF0F, W0
008700  881920     MOV W0, AD1CON3
111:                   AD1CON1bits.FORM=2;         //signed fractional format 
008702  2FCFF0     MOV #0xFCFF, W0
008704  B60320     AND AD1CON1, WREG
008706  A09000     BSET W0, #9
008708  881900     MOV W0, AD1CON1
112:                   AD1CON3bits.ADCS=0x07;
00870A  B3C070     MOV.B #0x7, W0
00870C  B7E324     MOV.B WREG, AD1CON3
113:                   AD1CON3bits.SAMC=0x1F;
00870E  21F000     MOV #0x1F00, W0
008710  B72324     IOR AD1CON3
114:                   //select  AN6,7,8
115:                   AD1CSSLbits.CSS6=1; //AN6
008712  A8C330     BSET AD1CSSL, #6
116:                   AD1CSSLbits.CSS7=1; //AN7
008714  A8E330     BSET AD1CSSL, #7
117:                   AD1CSSLbits.CSS8=1; //AN8
008716  A80331     BSET 0x331, #0
118:                   AD1CSSLbits.CSS10=1;//AN10
008718  A84331     BSET 0x331, #2
119:                   AD1CSSHbits.CSS20=1;//AN20
00871A  A8832E     BSET AD1CSSH, #4
120:                   AD1CSSHbits.CSS21=1;//AN21
00871C  A8A32E     BSET AD1CSSH, #5
121:                   //AD1CSSLbits.CSS9=1; //AN9
122:                   /* Enable ADC module and provide ADC stabilization delay */
123:                   AD1CON1bits.ADON = 1;
00871E  A8E321     BSET 0x321, #7
124:                   Delay_us(30);
008720  2001E0     MOV #0x1E, W0
008722  0703F4     RCALL Delay_us
125:               }
008724  060000     RETURN
126:               
127:               void initPMP(void){
128:                   /*
129:                    Data is clocked on falling edge of E
130:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
131:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
132:                    */
133:                   PMMODEbits.MODE=3;  //master mode 1 
008726  203000     MOV #0x300, W0
008728  B72602     IOR PMMODE
134:                   PMCONbits.PTWREN = 1;
00872A  A82601     BSET 0x601, #1
135:                   PMCONbits.PTRDEN = 1;
00872C  A80601     BSET 0x601, #0
136:                   PMCONbits.WRSP=1;   //write strobe active high
00872E  A82600     BSET PMCON, #1
137:                   PMCONbits.RDSP=1;   //read strobe active high
008730  A80600     BSET PMCON, #0
138:               
139:                   PMMODEbits.WAITB = 0;
008732  2FF3F0     MOV #0xFF3F, W0
008734  B62602     AND PMMODE
140:                   PMMODEbits.WAITM = 0xC;
008736  2FFC30     MOV #0xFFC3, W0
008738  B60602     AND PMMODE, WREG
00873A  B30300     IOR #0x30, W0
00873C  883010     MOV W0, PMMODE
141:                   PMMODEbits.WAITE = 0;
00873E  2FFFC0     MOV #0xFFFC, W0
008740  B62602     AND PMMODE
142:                   LCD_RS=0;
008742  A9EE45     BCLR 0xE45, #7
143:                   PMCONbits.PMPEN = 1;
008744  A8E601     BSET 0x601, #7
144:                   
145:                   /* INIT DEVICE */
146:                   Delay_us(40000);
008746  29C400     MOV #0x9C40, W0
008748  0703E1     RCALL Delay_us
147:                   lcdInit();
00874A  07FCA9     RCALL lcdInit
148:                   
149:                   /* SETUP SCREEN */
150:                   //lcdSetupPots();
151:               }
00874C  060000     RETURN
152:               
153:               
154:               //Description: Initializes timer for LED's UART and display
155:               //Prereq: initUART1()
156:               //Dependencies: _T1Interrupt(void)
157:               //Frequency: 15Hz
158:               void initT1(void){          //16 bit timer
159:                   TMR1 = 0x0000;          //clear timer 4
00874E  EF2100     CLR TMR1
160:                   T1CONbits.TCKPS = 3;    //prescale 1:256
008750  200300     MOV #0x30, W0
008752  B72104     IOR T1CON
161:                   T1CONbits.TCS = 0;      //use internal clock
008754  A92104     BCLR T1CON, #1
162:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
008756  A9C104     BCLR T1CON, #6
163:                   PR1 = Fcy/(256*Fdisp);    //period register
008758  246500     MOV #0x4650, W0
00875A  880810     MOV W0, PR1
164:                   //PR1=0x7FFF;
165:               
166:                   T1CONbits.TON = 1;      //start timer
00875C  A8E105     BSET 0x105, #7
167:               }
00875E  060000     RETURN
168:               
169:               //Description:  Initializes timer handles polling button input
170:               //Prereq: initADC1() 
171:               //Dependencies: _T2Interrupt(void)
172:               //Frequency: 512Hz
173:               void initT2(void){          //16/32 bit timer
174:                   TMR2 = 0x0000;          //clear timer 4
008760  EF2106     CLR TMR2
175:                   T2CONbits.T32 = 0;      //16 bit mode
008762  A96110     BCLR T2CON, #3
176:                   T2CONbits.TCKPS = 1;    //prescale 1:8
008764  2FFCF0     MOV #0xFFCF, W0
008766  B60110     AND T2CON, WREG
008768  A04000     BSET W0, #4
00876A  880880     MOV W0, T2CON
177:                   T2CONbits.TCS = 0;      //use internal clock
00876C  A92110     BCLR T2CON, #1
178:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
00876E  A9C110     BCLR T2CON, #6
179:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
008770  270800     MOV #0x7080, W0
008772  880860     MOV W0, PR2
180:               
181:                   T2CONbits.TON = 1;      //start timer
008774  A8E111     BSET 0x111, #7
182:               }
008776  060000     RETURN
183:               
184:               //Description: Initialize timer handling LCD sending
185:               //Dependencies: _T3Interrupt(void)
186:               //Frequency: 44.1kHz
187:               void initT3(void){          //16/32 bit timer
188:                   TMR3 = 0x0000;          //clear timer 3
008778  EF210A     CLR TMR3
189:                   T3CONbits.TCKPS = 1;    //prescale 8:1
00877A  2FFCF0     MOV #0xFFCF, W0
00877C  B60112     AND T3CON, WREG
00877E  A04000     BSET W0, #4
008780  880890     MOV W0, T3CON
190:                   T3CONbits.TCS = 0;      //use internal clock
008782  A92112     BCLR T3CON, #1
191:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
008784  A9C112     BCLR T3CON, #6
192:                   //PR3 = Fcy/(256*T3freq);           //period register
193:                   PR3 = 0x01D0;           //45uS initial delay
008786  201D00     MOV #0x1D0, W0
008788  880870     MOV W0, PR3
194:                   
195:                   T3CONbits.TON = 1;
00878A  A8E113     BSET 0x113, #7
196:                   
197:               }
00878C  060000     RETURN
198:               
199:               /*=============================================================================  
200:               Timer 5 is setup to time-out every 125 microseconds (8Khz Rate). As a result, the module 
201:               will stop sampling and trigger a conversion on every Timer3 time-out, i.e., Ts=125us. 
202:               =============================================================================*/
203:               void initT5() 
204:               {
205:                       TMR5 = 0x0000;
00878E  EF2118     CLR TMR5
206:                       PR5 = 4999;
008790  213870     MOV #0x1387, W0
008792  8808E0     MOV W0, PR5
207:                       T5CONbits.TCKPS = 2;    //prescale 8:1
008794  2FFCF0     MOV #0xFFCF, W0
008796  B60120     AND T5CON, WREG
008798  A05000     BSET W0, #5
00879A  880900     MOV W0, T5CON
208:                       IFS1bits.T5IF = 0;
00879C  A98803     BCLR 0x803, #4
209:                       IEC1bits.T5IE = 0;
00879E  A98823     BCLR 0x823, #4
210:               
211:                       //Start Timer 3
212:                       T5CONbits.TON = 1;
0087A0  A8E121     BSET 0x121, #7
213:               
214:               }
0087A2  060000     RETURN
215:               
216:               //Description: Initializes & starts 16 bit DCI I2S DAC
217:               //Prereq: initSPI_ADC(void)
218:               //Dependencies: readDAC(void)
219:               void initDCI_DAC(void){
220:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
0087A4  2F0000     MOV #0xF000, W0
0087A6  B60284     AND DCICON3, WREG
0087A8  B30170     IOR #0x17, W0
0087AA  881420     MOV W0, DCICON3
221:                   DCICON1bits.COFSM=1;                //i2s mode
0087AC  2FFFC0     MOV #0xFFFC, W0
0087AE  B60280     AND DCICON1, WREG
0087B0  A00000     BSET W0, #0
0087B2  881400     MOV W0, DCICON1
222:                   DCICON1bits.CSCKE=1;                //sample on rising edge
0087B4  A82281     BSET 0x281, #1
223:                   DCICON2bits.WS=0xF;                 //16 bit data word
0087B6  2000F0     MOV #0xF, W0
0087B8  B72282     IOR DCICON2
224:                   DCICON2bits.COFSG=0;    //data frame has 1 word (per frame)
0087BA  2FE1F0     MOV #0xFE1F, W0
0087BC  B62282     AND DCICON2
225:                   DCICON1bits.DJST=0;     //align data
0087BE  A9A280     BCLR DCICON1, #5
226:                   DCICON2bits.BLEN=3;     //4 words buffer btwn interrupts
0087C0  20C000     MOV #0xC00, W0
0087C2  B72282     IOR DCICON2
227:                   
228:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
0087C4  A80288     BSET TSCON, #0
229:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
0087C6  A82288     BSET TSCON, #1
230:                   TSCONbits.TSE2 = 1;     // Transmit on Time Slot 2     
0087C8  A84288     BSET TSCON, #2
231:                   TSCONbits.TSE3 = 1;     // Transmit on Time Slot 3   
0087CA  A86288     BSET TSCON, #3
232:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
0087CC  A8028C     BSET RSCON, #0
233:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
0087CE  A8228C     BSET RSCON, #1
234:                   RSCONbits.RSE2 = 1;     // rcv on Time Slot 2     
0087D0  A8428C     BSET RSCON, #2
235:                   RSCONbits.RSE3 = 1;     // rcv on Time Slot 3 
0087D2  A8628C     BSET RSCON, #3
236:                   
237:               
238:                   
239:                   IPC15bits.DCIIP = 6;    // Interrput priority
0087D4  2FFF80     MOV #0xFFF8, W0
0087D6  B6085E     AND IPC15, WREG
0087D8  B30060     IOR #0x6, W0
0087DA  8842F0     MOV W0, IPC15
240:                   IFS3bits.DCIIF=0;
0087DC  A98807     BCLR 0x807, #4
241:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
0087DE  A88827     BSET 0x827, #4
242:                   
243:                   // Pre-load send registers.
244:                   TXBUF0=0;
0087E0  EF2298     CLR TXBUF0
245:                   TXBUF1=0;   
0087E2  EF229A     CLR TXBUF1
246:                   TXBUF2=0;
0087E4  EF229C     CLR TXBUF2
247:                   TXBUF3=0;
0087E6  EF229E     CLR TXBUF3
248:                   DCICON1bits.DCIEN=1;    //ENABLE
0087E8  A8E281     BSET 0x281, #7
249:                   // Stabilization delay
250:                   Delay_us(20);
0087EA  200140     MOV #0x14, W0
0087EC  07038F     RCALL Delay_us
251:               }
0087EE  060000     RETURN
252:               
253:               void initDMA0(void){
254:                   unsigned long address;
255:                   
256:                   /*
257:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
258:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
259:                   DMA0PAD =  0X0608; // Point DMA to PMP
260:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
261:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
262:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
263:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
264:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
265:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
266:                   DMA0CONbits.CHEN=1; // Enable DMA
267:                   */
268:                   
269:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
0087F0  A9CB01     BCLR 0xB01, #6
270:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
0087F2  A8AB01     BSET 0xB01, #5
271:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
0087F4  2FFCF4     MOV #0xFFCF, W4
0087F6  20B000     MOV #0xB00, W0
0087F8  620810     AND W4, [W0], [W0]
272:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
0087FA  2FFFC3     MOV #0xFFFC, W3
0087FC  805801     MOV DMA0CON, W1
0087FE  618001     AND W3, W1, W0
008800  A01000     BSET W0, #1
008802  885800     MOV W0, DMA0CON
273:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
008804  A98B01     BCLR 0xB01, #4
274:                   DMA0CONbits.NULLW = 0;
008806  A96B01     BCLR 0xB01, #3
275:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
008808  A9EB03     BCLR 0xB03, #7
276:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
00880A  B3C3C2     MOV.B #0x3C, W2
00880C  20B025     MOV #0xB02, W5
00880E  784A82     MOV.B W2, [W5]
277:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
008810  27FFF0     MOV #0x7FFF, W0
008812  2CE001     MOV #0xCE00, W1
008814  608080     AND W1, W0, W1
278:                   address +=__builtin_edspage(txBufferA) << 15;
008816  200016     MOV #0x1, W6
008818  DD334F     SL W6, #15, W6
00881A  EB0380     CLR W7
00881C  408306     ADD W1, W6, W6
00881E  4B83E0     ADDC W7, #0x0, W7
279:                   DMA0STAL = address & 0xFFFF;
008820  885826     MOV W6, DMA0STAL
280:                   DMA0STAH = address >>16;
008822  885837     MOV W7, DMA0STAH
281:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
008824  2CC001     MOV #0xCC00, W1
008826  608080     AND W1, W0, W1
282:                   address +=__builtin_edspage(txBufferB) << 15;
008828  200016     MOV #0x1, W6
00882A  DD334F     SL W6, #15, W6
00882C  EB0380     CLR W7
00882E  408306     ADD W1, W6, W6
008830  4B83E0     ADDC W7, #0x0, W7
283:                   DMA0STBL = address & 0xFFFF;
008832  885846     MOV W6, DMA0STBL
284:                   DMA0STBH = address >>16;
008834  885857     MOV W7, DMA0STBH
285:                   DMA0PAD = (int)&TXBUF0;
008836  202981     MOV #0x298, W1
008838  885861     MOV W1, DMA0PAD
286:                   DMA0CNT = STREAMBUF-1;
00883A  200FF1     MOV #0xFF, W1
00883C  885871     MOV W1, DMA0CNT
287:                   /* DMA 2 - DCI to DPSRAM*/
288:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
00883E  A9CB21     BCLR 0xB21, #6
289:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
008840  A9AB21     BCLR 0xB21, #5
290:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
008842  A98B21     BCLR 0xB21, #4
291:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
008844  A96B21     BCLR 0xB21, #3
292:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
008846  20B205     MOV #0xB20, W5
008848  620A95     AND W4, [W5], [W5]
293:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
00884A  805904     MOV DMA2CON, W4
00884C  618184     AND W3, W4, W3
00884E  A01003     BSET W3, #1
008850  885903     MOV W3, DMA2CON
294:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
008852  A9EB23     BCLR 0xB23, #7
295:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
008854  784182     MOV.B W2, W3
008856  20B225     MOV #0xB22, W5
008858  784A83     MOV.B W3, [W5]
296:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
00885A  2CA004     MOV #0xCA00, W4
00885C  620200     AND W4, W0, W4
297:                   address +=__builtin_edspage(rxBufferA) << 15;
00885E  200012     MOV #0x1, W2
008860  DD114F     SL W2, #15, W2
008862  EB0180     CLR W3
008864  420102     ADD W4, W2, W2
008866  4981E0     ADDC W3, #0x0, W3
298:                   DMA2STAL = address & 0xFFFF;
008868  885922     MOV W2, DMA2STAL
299:                   DMA2STAH = address >>16;
00886A  885933     MOV W3, DMA2STAH
300:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
00886C  2C8002     MOV #0xC800, W2
00886E  610000     AND W2, W0, W0
301:                   address +=__builtin_edspage(rxBufferB) << 15;
008870  200012     MOV #0x1, W2
008872  DD114F     SL W2, #15, W2
008874  EB0180     CLR W3
008876  400102     ADD W0, W2, W2
008878  4981E0     ADDC W3, #0x0, W3
302:                   DMA2STBL = address & 0xFFFF;
00887A  885942     MOV W2, DMA2STBL
303:                   DMA2STBH = address >>16;
00887C  885953     MOV W3, DMA2STBH
304:                   DMA2PAD = (int)&RXBUF0;
00887E  202900     MOV #0x290, W0
008880  885960     MOV W0, DMA2PAD
305:                   DMA2CNT = STREAMBUF-1;
008882  885971     MOV W1, DMA2CNT
306:                   _DMA2IP = 5;
008884  2FFF80     MOV #0xFFF8, W0
008886  B6084C     AND IPC6, WREG
008888  B30050     IOR #0x5, W0
00888A  884260     MOV W0, IPC6
307:                   _DMA2IE = 1;
00888C  A80823     BSET 0x823, #0
308:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
00888E  A8EB01     BSET 0xB01, #7
309:                   DMA2CONbits.CHEN = 1;
008890  A8EB21     BSET 0xB21, #7
310:               }
008892  060000     RETURN
311:               
312:               void initSPI3_MEM(void){
313:                   SS3=1;                     // Assert chip select (active low)
008894  A82E54     BSET LATF, #1
314:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
008896  A9680B     BCLR 0x80B, #3
315:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
008898  A9682B     BCLR 0x82B, #3
316:                   SPI3CON1bits.MSTEN=1;       //master mode
00889A  A8A2A2     BSET SPI3CON1, #5
317:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
00889C  A982A3     BCLR 0x2A3, #4
318:                   SPI3CON1bits.MODE16=0;      //8 bit
00889E  A942A3     BCLR 0x2A3, #2
319:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
0088A0  A962A3     BCLR 0x2A3, #3
320:                   SPI3CON1bits.SSEN=1;        //use SS
0088A2  A8E2A2     BSET SPI3CON1, #7
321:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
0088A4  A9E2A5     BCLR 0x2A5, #7
322:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
0088A6  A902A4     BCLR SPI3CON2, #0
323:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
0088A8  2FFE33     MOV #0xFFE3, W3
0088AA  801300     MOV SPI2STAT, W0
0088AC  618080     AND W3, W0, W1
0088AE  B30141     IOR #0x14, W1
0088B0  881301     MOV W1, SPI2STAT
324:                   
325:                   SPI3CON1bits.SMP=1;         //data sampled at end of output time
0088B2  A822A3     BSET 0x2A3, #1
326:                   SPI3CON1bits.CKP=0;         //idle clock is low
0088B4  A9C2A2     BCLR SPI3CON1, #6
327:                   SPI3CON1bits.CKE=1;         //data changes from H to L
0088B6  A802A3     BSET 0x2A3, #0
328:                   
329:                   SPI3CON1bits.PPRE=3;        //1:1 primary prescale
0088B8  200030     MOV #0x3, W0
0088BA  B722A2     IOR SPI3CON1
330:                   SPI3CON1bits.SPRE=6;        //2:1 secondary
0088BC  801511     MOV SPI3CON1, W1
0088BE  618001     AND W3, W1, W0
0088C0  B30180     IOR #0x18, W0
0088C2  881510     MOV W0, SPI3CON1
331:                   
332:                   SPI3STATbits.SPIROV = 0;        // Clear SPI1 receive overflow flag if set
0088C4  A9C2A0     BCLR SPI3STAT, #6
333:                   //IPC22bits.SPI3IP = 3;         // Interrupt priority
334:                   //IFS5bits.SPI3IF = 0;          // Clear the Interrupt flag
335:                   //IEC5bits.SPI3IE = 0;          // Enable the interrupt
336:                   SPI3STATbits.SPIEN = 1;         //start SPI module
0088C6  A8E2A1     BSET 0x2A1, #7
337:                  
338:                   Delay_us(20);                       // Stabilization Delay
0088C8  200140     MOV #0x14, W0
0088CA  070320     RCALL Delay_us
339:                   
340:                   flashWriteReg(FLASH_WREN);
0088CC  B3C060     MOV.B #0x6, W0
0088CE  0703D6     RCALL flashWriteReg
341:                   /*
342:                   flashBulkErase();
343:                   while(flashStatusCheck()&1);
344:               
345:                   flashWritePage
346:                   while(flashStatusCheck()&1);
347:                   */
348:                   
349:                   flashRead(flash_readback, 256);     // READBACK
0088D0  201001     MOV #0x100, W1
0088D2  25E6A0     MOV #0x5E6A, W0
0088D4  070427     RCALL flashRead
350:                   
351:               }
0088D6  060000     RETURN
352:               
353:               void initQEI_ENC(void){
354:                   QEI1CONbits.INTDIV=6;       // 1:64 prescaler
0088D8  2FF8F0     MOV #0xFF8F, W0
0088DA  B601C0     AND QEI1CON, WREG
0088DC  B30600     IOR #0x60, W0
0088DE  880E00     MOV W0, QEI1CON
355:                   QEI1IOCbits.FLTREN=1;       // Enable input filter
0088E0  A8C1C3     BSET 0x1C3, #6
356:                   QEI1CONbits.QEIEN=1;        // Enable Quad encoder inteface
0088E2  A8E1C1     BSET 0x1C1, #7
357:               }
0088E4  060000     RETURN
358:               
---  /home/fbuga/Documents/ps-040/audio.c  --------------------------------------------------------------
1:                 #include "xc.h"
2:                 #include "audio.h"
3:                 #include "common.h"
4:                 #include <dsp.h>
5:                 
6:                 
7:                 
8:                 extern char pad[BUTTONS];                                                             //CONTROL VARIABLES//
9:                 extern fractional pots[POTS];
10:                extern fractional pots_scaled[POTS];
11:                
12:                volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
13:                extern unsigned char hard_clipped;
14:                volatile fractional loop[LOOP_BUF_SIZE]={0};
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                
17:                extern fractional sintab[1024];     //misc//
18:                extern unsigned char TEST_SIN;
19:                
20:                extern unsigned char kick_playing;                                              //SAMPLES//
21:                extern unsigned int kick_max, kick_ptr;
22:                extern fractional kick[5552];
23:                //extern unsigned char kick_mode;
24:                /*
25:                extern unsigned char hat_playing;
26:                extern unsigned int hat_max, hat_ptr;
27:                extern fractional hat[5552];
28:                 */
29:                extern unsigned char snare_playing;
30:                extern unsigned int snare_max, snare_ptr;
31:                extern fractional snare[5552];
32:                extern enum fxStruct fxUnits[NUMFXUNITS];
33:                
34:                void (*fxFuncPointers[NUMFX])(fractional *, fractional *, fractional, fractional, fractional) = {NULL, runLPF, runTRM, runLOP, runBIT};
35:                
36:                void runBufferLooper(fractional *source){
008A1E  FA0002     LNK #0x2
008A20  2FE004     MOV #0xFE00, W4
008A22  420200     ADD W4, W0, W4
37:                    static fractional delayed_sample;
38:                    volatile fractional sample;
39:                    
40:                    int *readPTR=source;
41:                    
42:                    int counter=(STREAMBUF-1);
43:                    for(; counter>=0; counter--){
008A54  500F84     SUB W0, W4, [W15]
008A56  3AFFE9     BRA NZ, 0x8A2A
44:                        sample=*readPTR--; //!rw
008A2A  7800A0     MOV [W0--], W1
008A2C  9FBFF1     MOV W1, [W15-2]
45:                        if(loop_ptr<LOOP_BUF_SIZE)
008A24  2270F3     MOV #0x270F, W3
008A2E  808157     MOV loop_ptr, W7
008A30  538F83     SUB W7, W3, [W15]
008A32  3E0008     BRA GTU, 0x8A44
46:                            loop[loop_ptr++]=sample;
008A34  808151     MOV loop_ptr, W1
008A36  408281     ADD W1, W1, W5
008A38  410285     ADD W2, W5, W5
008A3A  97BBFF     MOV [W15-2], W7
008A3C  780A87     MOV W7, [W5]
008A3E  E80081     INC W1, W1
008A40  888151     MOV W1, loop_ptr
008A42  370008     BRA 0x8A54
47:                        else {
48:                            loop_ptr=0;
008A26  EB0300     CLR W6
008A44  888156     MOV W6, loop_ptr
49:                            loop[loop_ptr++]=sample;
008A28  2104A2     MOV #0x104A, W2
008A46  808151     MOV loop_ptr, W1
008A48  408281     ADD W1, W1, W5
008A4A  410285     ADD W2, W5, W5
008A4C  97BBFF     MOV [W15-2], W7
008A4E  780A87     MOV W7, [W5]
008A50  E80081     INC W1, W1
008A52  888151     MOV W1, loop_ptr
50:                        }
51:                    }
52:                }
008A58  FA8000     ULNK
008A5A  060000     RETURN
53:                
54:                void runLPF(fractional *source, fractional *destination, fractional param1, fractional param2, fractional param3){
0089D6  FA0002     LNK #0x2
0089D8  F80022     PUSH ACCA
0089DA  F80024     PUSH ACCAH
0089DC  F80026     PUSH ACCAU
0089F2  2FE003     MOV #0xFE00, W3
0089F4  418180     ADD W3, W0, W3
55:                    volatile register int result asm("A");
56:                    static fractional delayed_sample;
57:                    volatile fractional sample;
58:                    if(param3>=0x3FFF){     //LPF CONTROL
0089DE  23FFE3     MOV #0x3FFE, W3
0089E0  520F83     SUB W4, W3, [W15]
0089E2  340018     BRA LE, 0x8A14
59:                        if(param1>=310){                      
0089E4  201353     MOV #0x135, W3
0089E6  510F83     SUB W2, W3, [W15]
0089E8  340004     BRA LE, 0x89F2
60:                            lpf_alpha=param1;
0089EA  8881D2     MOV W2, 0x103A
61:                            lpf_inv_alpha=(32767-lpf_alpha); 
0089EC  27FFF3     MOV #0x7FFF, W3
0089EE  518102     SUB W3, W2, W2
0089F0  8881E2     MOV W2, 0x103C
62:                        }
63:                
64:                
65:                        int *readPTR=source;
66:                        int *rewritePTR=destination;
67:                
68:                
69:                        int counter=(STREAMBUF-1);
70:                        for(; counter>=0; counter--){
008A10  500F83     SUB W0, W3, [W15]
008A12  3AFFF1     BRA NZ, 0x89F6
71:                            sample=*readPTR--; //!rw
0089F6  780120     MOV [W0--], W2
0089F8  9FBFC2     MOV W2, [W15-8]
72:                
73:                            //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
74:                            result =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
0089FA  97BA4F     MOV [W15-8], W4
0089FC  8081D5     MOV 0x103A, W5
0089FE  C00113     MPY W4*W5, A
75:                            result =__builtin_mac(result, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result);
008A00  8081E4     MOV 0x103C, W4
008A02  808195     MOV delayed_sample, W5
008A04  C00112     MAC W4*W5, A
76:                            delayed_sample=__builtin_sac(result, 0);
008A06  CC0002     SAC A, W2
008A08  888192     MOV W2, delayed_sample
77:                            sample=delayed_sample;
008A0A  9FBFC2     MOV W2, [W15-8]
78:                
79:                            *rewritePTR--=sample; //rw
008A0C  97B94F     MOV [W15-8], W2
008A0E  781082     MOV W2, [W1--]
80:                        }
81:                    }
82:                    
83:                }
008A14  F90026     POP ACCAU
008A16  F90024     POP ACCAH
008A18  F90022     POP ACCA
008A1A  FA8000     ULNK
008A1C  060000     RETURN
84:                
85:                void runTRM(fractional *source, fractional *destination, fractional param1, fractional param2, fractional param3){
0088E6  FA0004     LNK #0x4
0088E8  BE9F88     MOV.D W8, [W15++]
0088EA  BE9F8A     MOV.D W10, [W15++]
0088EC  F80022     PUSH ACCA
0088EE  F80024     PUSH ACCAH
0088F0  F80026     PUSH ACCAU
0088F2  F80028     PUSH ACCB
0088F4  F8002A     PUSH ACCBH
0088F6  F8002C     PUSH ACCBU
0088F8  780283     MOV W3, W5
00890E  2FE027     MOV #0xFE02, W7
008910  438381     ADD W7, W1, W7
86:                    volatile register int result1 asm("A");
87:                    volatile register int result2 asm("B");
88:                    volatile fractional sample, trem_mod;
89:                    int *readPTR=source;
90:                    int *rewritePTR=destination;
91:                    int counter=(STREAMBUF-1);
92:                    static unsigned int trem_delay=0, tremelo_ptr=0;
93:                    const int pot_offset = 5;
94:                    
95:                    if(param3>=0x3FFF){     // TREM CONTROL
0088FA  23FFE3     MOV #0x3FFE, W3
0088FC  520F83     SUB W4, W3, [W15]
0088FE  340042     BRA LE, 0x8984
96:                        result1 =__builtin_mpy(param1,Q15(0.0006), NULL, NULL, 0, NULL, NULL, 0);
008900  780202     MOV W2, W4
008902  200146     MOV #0x14, W6
008904  C10113     MPY W4*W6, A
97:                        param1=__builtin_sac(result1, 0);
008906  CC0003     SAC A, W3
98:                        if(param2<-0x7) param2=0;
008908  428FE7     ADD W5, #0x7, [W15]
00890A  3D0001     BRA GE, 0x890E
00890C  EB0280     CLR W5
99:                        
100:                       for(; counter>=0; counter--){
00897C  508F87     SUB W1, W7, [W15]
00897E  320002     BRA Z, 0x8984
101:                           sample=*readPTR--; //!rw
00891C  780120     MOV [W0--], W2
00891E  9FB7C2     MOV W2, [W15-24]
102:                                                                          //TREMELO//
103:                           if (trem_delay<=param1+pot_offset){
008912  4181E5     ADD W3, #0x5, W3
008920  808182     MOV trem_delay, W2
008922  518F82     SUB W3, W2, [W15]
008924  390012     BRA NC, 0x894A
104:                               trem_delay++;
008926  E80102     INC W2, W2
008928  888182     MOV W2, trem_delay
105:                               result1 =__builtin_mpy(param2,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
00892A  808172     MOV tremelo_ptr, W2
00892C  410102     ADD W2, W2, W2
00892E  448102     ADD W9, W2, W2
008930  780212     MOV [W2], W4
008932  C00113     MPY W4*W5, A
106:                               trem_mod=__builtin_sac(result1, 0);
008934  CC0002     SAC A, W2
008936  9FB7D2     MOV W2, [W15-22]
107:                               trem_mod=0x7FF0-trem_mod;
008938  97B15F     MOV [W15-22], W2
00893A  540102     SUB W8, W2, W2
00893C  9FB7D2     MOV W2, [W15-22]
108:                               result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
00893E  97B34F     MOV [W15-24], W6
008940  97B25F     MOV [W15-22], W4
008942  C18113     MPY W4*W6, B
109:                               sample=__builtin_sac(result2, 0);
008944  CC8004     SAC B, W4
008946  9FB7C4     MOV W4, [W15-24]
008948  370017     BRA 0x8978
110:                           }
111:                           else{
112:                               trem_delay=0;
008914  EB0500     CLR W10
00894A  88818A     MOV W10, trem_delay
113:                               if(tremelo_ptr==1024)
008916  20400B     MOV #0x400, W11
00894C  808172     MOV tremelo_ptr, W2
00894E  510F8B     SUB W2, W11, [W15]
008950  3A0002     BRA NZ, 0x8956
114:                                   tremelo_ptr=0;
008952  88817A     MOV W10, tremelo_ptr
008954  370002     BRA 0x895A
115:                               else tremelo_ptr++;
008956  E80102     INC W2, W2
008958  888172     MOV W2, tremelo_ptr
116:                               
117:                               result1 =__builtin_mpy(param2,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
008918  2F1869     MOV #0xF186, W9
00895A  808172     MOV tremelo_ptr, W2
00895C  410102     ADD W2, W2, W2
00895E  448102     ADD W9, W2, W2
008960  780212     MOV [W2], W4
008962  C00113     MPY W4*W5, A
118:                               trem_mod=__builtin_sac(result1, 0);
008964  CC0002     SAC A, W2
008966  9FB7D2     MOV W2, [W15-22]
119:                               trem_mod=0x7FF0-trem_mod;
00891A  27FF08     MOV #0x7FF0, W8
008968  97B15F     MOV [W15-22], W2
00896A  540102     SUB W8, W2, W2
00896C  9FB7D2     MOV W2, [W15-22]
120:                               result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
00896E  97B34F     MOV [W15-24], W6
008970  97B25F     MOV [W15-22], W4
008972  C18113     MPY W4*W6, B
121:                               sample=__builtin_sac(result2, 0);
008974  CC8006     SAC B, W6
008976  9FB7C6     MOV W6, [W15-24]
122:                           }
123:               
124:                           *rewritePTR--=sample; //rw
008978  97B14F     MOV [W15-24], W2
00897A  780882     MOV W2, [W1]
008980  E98081     DEC2 W1, W1
008982  37FFCC     BRA 0x891C
125:                       }
126:                   }
127:               }
008984  F9002C     POP ACCBU
008986  F9002A     POP ACCBH
008988  F90028     POP ACCB
00898A  F90026     POP ACCAU
00898C  F90024     POP ACCAH
00898E  F90022     POP ACCA
008990  BE054F     MOV.D [--W15], W10
008992  BE044F     MOV.D [--W15], W8
008994  FA8000     ULNK
008996  060000     RETURN
128:               
129:               void runBIT(fractional *source, fractional *destination, fractional param1, fractional param2, fractional param3){
008998  FA0002     LNK #0x2
00899A  BE9F88     MOV.D W8, [W15++]
00899C  781F8A     MOV W10, [W15++]
00899E  780480     MOV W0, W9
0089A0  780501     MOV W1, W10
0089A2  780082     MOV W2, W1
0089A4  780404     MOV W4, W8
0089B0  2FE001     MOV #0xFE00, W1
0089B2  408089     ADD W1, W9, W1
130:                   volatile fractional sample;
131:                   
132:                   int *readPTR=source;
133:                   int *rewritePTR=destination;
134:                   int counter=(STREAMBUF-1);
135:                   int shift = scalePotsCustom(14, param1);
0089A6  2000E0     MOV #0xE, W0
0089A8  070271     RCALL scalePotsCustom
136:                   fractional shiftedsample, sign;
137:                   
138:                   for(; counter>=0; counter--){
0089CA  548F81     SUB W9, W1, [W15]
0089CC  3AFFF4     BRA NZ, 0x89B6
139:                       sample=*readPTR--; //!rw
0089B6  7801A9     MOV [W9--], W3
0089B8  9FBFC3     MOV W3, [W15-8]
140:                       
141:                       if(param3>=0x3FFF){     // BIT CONTROL
0089B4  23FFE0     MOV #0x3FFE, W0
0089BA  540F80     SUB W8, W0, [W15]
0089BC  340004     BRA LE, 0x89C6
142:                           sign = sample&0x8000;
0089BE  97B9CF     MOV [W15-8], W3
143:                           sample=sample&(-1<<(16-shift));
0089AA  100070     SUBR W0, #0x10, W0
0089AC  EB8100     SETM W2
0089AE  DD1100     SL W2, W0, W2
0089C0  97B9CF     MOV [W15-8], W3
0089C2  610183     AND W2, W3, W3
0089C4  9FBFC3     MOV W3, [W15-8]
144:                       }
145:               
146:                       *rewritePTR--=sample; //rw
0089C6  97B9CF     MOV [W15-8], W3
0089C8  781503     MOV W3, [W10--]
147:                   }
148:               }
0089CE  78054F     MOV [--W15], W10
0089D0  BE044F     MOV.D [--W15], W8
0089D2  FA8000     ULNK
0089D4  060000     RETURN
149:               
150:               void runLOP(fractional *source, fractional *destination, fractional param1, fractional param2, fractional param3){
008A5C  FA0002     LNK #0x2
008A5E  BE9F88     MOV.D W8, [W15++]
008A60  F80022     PUSH ACCA
008A62  F80024     PUSH ACCAH
008A64  F80026     PUSH ACCAU
008A78  2FE004     MOV #0xFE00, W4
008A7A  420200     ADD W4, W0, W4
151:                   volatile register int result asm("A");
152:                   volatile fractional sample;
153:                   
154:                   result =__builtin_mpy(param1,Q15(0.3052), NULL, NULL, 0, NULL, NULL, 0);
008A66  780282     MOV W2, W5
008A68  227106     MOV #0x2710, W6
008A6A  C40113     MPY W5*W6, A
155:                   int loop_lim = __builtin_sac(result, 0);
008A6C  CC0002     SAC A, W2
156:                   
157:                   int *readPTR=source;
158:                   int *rewritePTR=destination;
159:                   int counter=(STREAMBUF-1);
160:                   
161:                   //Run looper Buffer
162:                   if(param3<0x3FFF){
008A6E  23FFE3     MOV #0x3FFE, W3
008A70  520F83     SUB W4, W3, [W15]
008A72  3C0002     BRA GT, 0x8A78
163:                       runBufferLooper(source); 
008A74  07FFD4     RCALL runBufferLooper
008A76  370022     BRA 0x8ABC
164:                   }
165:                   else {
166:                       for(; counter>=0; counter--){
008AB8  500F84     SUB W0, W4, [W15]
008ABA  3AFFE4     BRA NZ, 0x8A84
167:                           sample=*readPTR--; //!rw    
008A84  7802A0     MOV [W0--], W5
008A86  9FBFA5     MOV W5, [W15-12]
168:               
169:                           if(param3>=0x3FFF){
170:                               if(loop_lim>=LOOP_BUF_SIZE)
008A7C  2270F3     MOV #0x270F, W3
008A88  510F83     SUB W2, W3, [W15]
008A8A  340001     BRA LE, 0x8A8E
171:                                   loop_lim=LOOP_BUF_SIZE;
008A7E  227106     MOV #0x2710, W6
008A8C  780106     MOV W6, W2
172:                               if(loop_ptr<loop_lim){
008A8E  808155     MOV loop_ptr, W5
008A90  528F82     SUB W5, W2, [W15]
008A92  310008     BRA C, 0x8AA4
173:                                   sample = (loop[loop_ptr++]);
008A94  808155     MOV loop_ptr, W5
008A96  428405     ADD W5, W5, W8
008A98  438408     ADD W7, W8, W8
008A9A  780418     MOV [W8], W8
008A9C  9FBFA8     MOV W8, [W15-12]
008A9E  E80285     INC W5, W5
008AA0  888155     MOV W5, loop_ptr
008AA2  370008     BRA 0x8AB4
174:                               }
175:                               else {
176:                                   loop_ptr=0;
008A80  EB0480     CLR W9
008AA4  888159     MOV W9, loop_ptr
177:                                   sample = (loop[loop_ptr++]);
008A82  2104A7     MOV #0x104A, W7
008AA6  808155     MOV loop_ptr, W5
008AA8  428405     ADD W5, W5, W8
008AAA  438408     ADD W7, W8, W8
008AAC  780418     MOV [W8], W8
008AAE  9FBFA8     MOV W8, [W15-12]
008AB0  E80285     INC W5, W5
008AB2  888155     MOV W5, loop_ptr
178:                               }
179:                           }
180:                           *rewritePTR--=sample; //rw
008AB4  97BAAF     MOV [W15-12], W5
008AB6  781085     MOV W5, [W1--]
181:                       }               
182:                   }
183:               }
008ABC  F90026     POP ACCAU
008ABE  F90024     POP ACCAH
008AC0  F90022     POP ACCA
008AC2  BE044F     MOV.D [--W15], W8
008AC4  FA8000     ULNK
008AC6  060000     RETURN
184:               
185:               void processAudio(fractional *source, fractional *destination){
008AC8  4787E6     ADD W15, #0x6, W15
008ACA  BE9F88     MOV.D W8, [W15++]
008ACC  BE9F8A     MOV.D W10, [W15++]
008ACE  BE9F8C     MOV.D W12, [W15++]
008AD0  781F8E     MOV W14, [W15++]
008AD2  F80022     PUSH ACCA
008AD4  F80024     PUSH ACCAH
008AD6  F80026     PUSH ACCAU
008AD8  780400     MOV W0, W8
008ADA  9FB7D1     MOV W1, [W15-22]
008B10  97B05F     MOV [W15-22], W0
008B12  2FE001     MOV #0xFE00, W1
008B14  400101     ADD W0, W1, W2
186:                   volatile register int result1 asm("A");
187:                   static int i=0;
188:                   volatile fractional sample;
189:                   int counter=(STREAMBUF-1);
190:                   
191:                   //Run each FX unit
192:                   if(fxUnits[0]==0); else fxFuncPointers[fxUnits[0]](source, source, pots[FX_1], pots[FX_2], pots[FX_3]);
008ADC  808060     MOV fxUnits, W0
008ADE  E00000     CP0 W0
008AE0  32000A     BRA Z, 0x8AF6
008AE2  400000     ADD W0, W0, W0
008AE4  26DA81     MOV #0x6DA8, W1
008AE6  408000     ADD W1, W0, W0
008AE8  780290     MOV [W0], W5
008AEA  830394     MOV 0x6072, W4
008AEC  830373     MOV 0x606E, W3
008AEE  830352     MOV pots, W2
008AF0  780088     MOV W8, W1
008AF2  780008     MOV W8, W0
008AF4  010005     CALL W5
193:                   if(fxUnits[1]==0); else fxFuncPointers[fxUnits[1]](source, source, pots[FX_4], pots[FX_5], pots[FX_6]);
008AF6  808070     MOV 0x100E, W0
008AF8  E00000     CP0 W0
008AFA  32000A     BRA Z, 0x8B10
008AFC  400000     ADD W0, W0, W0
008AFE  26DA81     MOV #0x6DA8, W1
008B00  408000     ADD W1, W0, W0
008B02  780290     MOV [W0], W5
008B04  8303A4     MOV 0x6074, W4
008B06  830383     MOV 0x6070, W3
008B08  830362     MOV 0x606C, W2
008B0A  780088     MOV W8, W1
008B0C  780008     MOV W8, W0
008B0E  010005     CALL W5
194:                  
195:                   for(; counter>=0; counter--){
008BDA  500F82     SUB W0, W2, [W15]
008BDC  3AFFA3     BRA NZ, 0x8B24
008BDE  97B6DF     MOV [W15-22], W13
008BE0  2FE020     MOV #0xFE02, W0
008BE2  468080     ADD W13, W0, W1
196:                       sample=*source--; //!rw
008B24  7802A8     MOV [W8--], W5
008B26  9FB7C5     MOV W5, [W15-24]
197:               
198:                       if(kick_playing==TRUE&&kick_ptr<kick_max){
008B28  2101E1     MOV #0x101E, W1
008B2A  784091     MOV.B [W1], W1
008B2C  40CFE1     ADD.B W1, #0x1, [W15]
008B2E  3A0011     BRA NZ, 0x8B52
008B30  878C0E     MOV 0xF180, W14
008B32  808107     MOV kick_ptr, W7
008B34  538F8E     SUB W7, W14, [W15]
008B36  31000D     BRA C, 0x8B52
199:                           result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
008B18  27332C     MOV #0x7332, W12
008B38  97B2CF     MOV [W15-24], W5
008B3A  78038C     MOV W12, W7
008B3C  C50113     MPY W5*W7, A
200:                           result1 = __builtin_add(result1,kick[kick_ptr++],0);
008B1A  2C620B     MOV #0xC620, W11
008B3E  808101     MOV kick_ptr, W1
008B40  408701     ADD W1, W1, W14
008B42  45870E     ADD W11, W14, W14
008B44  78071E     MOV [W14], W14
008B46  E80081     INC W1, W1
008B48  888101     MOV W1, kick_ptr
008B4A  C9000E     ADD W14, A
201:                           sample=__builtin_sac(result1, 0);
008B4C  CC000D     SAC A, W13
008B4E  9FB7CD     MOV W13, [W15-24]
008B50  37000E     BRA 0x8B6E
202:                       }
203:                       else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
008B16  268B24     MOV #0x68B2, W4
008B52  B3C015     MOV.B #0x1, W5
008B54  12CF94     SUBR.B W5, [W4], [W15]
008B56  3A000B     BRA NZ, 0x8B6E
008B58  40CFE1     ADD.B W1, #0x1, [W15]
008B5A  3A0009     BRA NZ, 0x8B6E
008B5C  878C01     MOV 0xF180, W1
008B5E  808107     MOV kick_ptr, W7
008B60  538F81     SUB W7, W1, [W15]
008B62  3A0005     BRA NZ, 0x8B6E
204:                           kick_playing=FALSE;
008B64  B3C001     MOV.B #0x0, W1
008B66  2101ED     MOV #0x101E, W13
008B68  784E81     MOV.B W1, [W13]
205:                           kick_ptr=0;
008B6A  EB0080     CLR W1
008B6C  888101     MOV W1, kick_ptr
206:                       }
207:                       /*
208:                       if(hat_playing==TRUE&&hat_ptr<hat_max){
209:                           result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
210:                           result1 = __builtin_add(result1,hat[hat_ptr++],0);
211:                           sample=__builtin_sac(result1, 0);
212:                       }
213:                       else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
214:                           hat_playing=FALSE;
215:                           hat_ptr=0;
216:                       }
217:                        */
218:               
219:                       if(snare_playing==TRUE&&snare_ptr<snare_max){
008B6E  210221     MOV #0x1022, W1
008B70  784091     MOV.B [W1], W1
008B72  40CFE1     ADD.B W1, #0x1, [W15]
008B74  3A0011     BRA NZ, 0x8B98
008B76  878C1E     MOV 0xF182, W14
008B78  808125     MOV snare_ptr, W5
008B7A  528F8E     SUB W5, W14, [W15]
008B7C  31000D     BRA C, 0x8B98
220:                           result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
008B1E  26CCCA     MOV #0x6CCC, W10
008B7E  97B3CF     MOV [W15-24], W7
008B80  78028A     MOV W10, W5
008B82  C50113     MPY W5*W7, A
221:                           result1 = __builtin_add(result1,snare[snare_ptr++],0);
008B20  295489     MOV #0x9548, W9
008B84  808121     MOV snare_ptr, W1
008B86  408701     ADD W1, W1, W14
008B88  44870E     ADD W9, W14, W14
008B8A  78071E     MOV [W14], W14
008B8C  E80081     INC W1, W1
008B8E  888121     MOV W1, snare_ptr
008B90  C9000E     ADD W14, A
222:                           sample=__builtin_sac(result1, 0);
008B92  CC0007     SAC A, W7
008B94  9FB7C7     MOV W7, [W15-24]
008B96  37000E     BRA 0x8BB4
223:                       }
224:                       else if (pad[1]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
008B1C  E80184     INC W4, W3
008B98  B3C01D     MOV.B #0x1, W13
008B9A  16CF93     SUBR.B W13, [W3], [W15]
008B9C  3A000B     BRA NZ, 0x8BB4
008B9E  40CFE1     ADD.B W1, #0x1, [W15]
008BA0  3A0009     BRA NZ, 0x8BB4
008BA2  878C11     MOV 0xF182, W1
008BA4  808125     MOV snare_ptr, W5
008BA6  528F81     SUB W5, W1, [W15]
008BA8  3A0005     BRA NZ, 0x8BB4
225:                           snare_playing=FALSE;
008BAA  B3C00D     MOV.B #0x0, W13
008BAC  210227     MOV #0x1022, W7
008BAE  784B8D     MOV.B W13, [W7]
226:                           snare_ptr=0;
008BB0  EB0680     CLR W13
008BB2  88812D     MOV W13, snare_ptr
227:                       }
228:               
229:               
230:                       if (TEST_SIN==TRUE){
008BB4  210081     MOV #0x1008, W1
008BB6  784091     MOV.B [W1], W1
008BB8  40CFE1     ADD.B W1, #0x1, [W15]
008BBA  3A000D     BRA NZ, 0x8BD6
231:                           i++;
008BBC  808161     MOV i, W1
008BBE  E80081     INC W1, W1
008BC0  888161     MOV W1, i
232:                           if(i==1024)
008B22  204006     MOV #0x400, W6
008BC2  508F86     SUB W1, W6, [W15]
008BC4  3A0002     BRA NZ, 0x8BCA
233:                               i=0;
008BC6  EB0080     CLR W1
008BC8  888161     MOV W1, i
234:                           sample=sintab[i];
008BCA  808161     MOV i, W1
008BCC  408081     ADD W1, W1, W1
008BCE  2F1865     MOV #0xF186, W5
008BD0  428081     ADD W5, W1, W1
008BD2  780091     MOV [W1], W1
008BD4  9FB7C1     MOV W1, [W15-24]
235:                       }
236:               
237:               
238:                       
239:                       //return sample;
240:                       *destination--=sample; //rw
008BD6  97B3CF     MOV [W15-24], W7
008BD8  781007     MOV W7, [W0--]
241:                   }
242:                   
243:                   //VOLUME CONTROL
244:                   //if(pots[POT_VOLUME]<=0x000F); 
245:                   if(pots[POT_VOLUME]>=0x7FF7);
008BE4  8303C3     MOV 0x6078, W3
008BE6  27FF60     MOV #0x7FF6, W0
008BE8  518F80     SUB W3, W0, [W15]
008BEA  3C0003     BRA GT, 0x8BF2
246:                   else{
247:                       VectorScale(STREAMBUF, destination+1, destination+1, pots[POT_VOLUME]);
008BEC  780101     MOV W1, W2
008BEE  201000     MOV #0x100, W0
008BF0  07BC6A     RCALL _VectorScale
248:                   }
249:               }
008BF2  F90026     POP ACCAU
008BF4  F90024     POP ACCAH
008BF6  F90022     POP ACCA
008BF8  78074F     MOV [--W15], W14
008BFA  BE064F     MOV.D [--W15], W12
008BFC  BE054F     MOV.D [--W15], W10
008BFE  BE044F     MOV.D [--W15], W8
008C00  B1006F     SUB #0x6, W15
008C02  060000     RETURN
