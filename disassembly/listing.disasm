Disassembly Listing for sampler_0.49.2
Generated From:
/home/fbuga/Documents/ps-040/dist/default/production/ps-040.production.elf
Jan 16, 2018 3:24:45 AM

---  /home/fbuga/Documents/ps-040/utilitites.c  ---------------------------------------------------------
1:                 #include "utilities.h"
2:                 #include <xc.h>
3:                 #include <p33EP512GM310.h>
4:                 #include <libpic30.h>
5:                 #include <dsp.h>
6:                 #include <stdio.h>
7:                 #include <stdlib.h>
8:                 #include <math.h>
9:                 #include "common.h"
10:                #include "sounds.h"
11:                #include "audio.h"
12:                #include "plcd.h"
13:                
14:                #include "devInits.h"
15:                
16:                
17:                //CONTROL VARIABLES//
18:                extern unsigned char pad[8];
19:                extern fractional pots[4];
20:                extern fractional pots_scaled[4];
21:                extern unsigned char UART_ON; 
22:                
23:                //STATUS VARIABLES//
24:                extern unsigned char hard_clipped;
25:                extern unsigned char UART_EN;
26:                extern unsigned int rw, frameReady, cycle;
27:                
28:                extern fractional sampin;
29:                extern fractional sampout;
30:                
31:                
32:                //FX FLAGS & VARS
33:                extern unsigned char tremelo, looper, lpf;
34:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
35:                extern unsigned int loop_lim;
36:                extern fractional lpf_alpha, lpf_inv_alpha;
37:                extern fractional tremelo_depth;
38:                
39:                void scanMatrix(void){
40:                    static unsigned char pad_last[8] = {1,1,1,1,1,1,1,1};
41:                    unsigned int portrd = PADS;
0074E8  807310     MOV PORTG, W0
42:                    //
43:                    
44:                    pad[0]=PORTGbits.RG15;
0074EA  807311     MOV PORTG, W1
0074EC  DE08CF     LSR W1, #15, W1
0074EE  266700     MOV #0x6670, W0
0074F0  784801     MOV.B W1, [W0]
45:                    pad[4]=1;
0074F2  B3C010     MOV.B #0x1, W0
0074F4  266742     MOV #0x6674, W2
0074F6  784900     MOV.B W0, [W2]
46:                    pad[7]=1;
0074F8  410163     ADD W2, #0x3, W2
0074FA  784900     MOV.B W0, [W2]
47:                    
48:                    if(pad[7]==0&&pad_last[7]==1){                                              //TREMELO CONTROL
49:                        pad_last[7]=0;
50:                        if(tremelo==FALSE)
51:                            tremelo=TRUE;
52:                        else tremelo=FALSE;
53:                        TREMELO_LED=tremelo;
54:                    }
55:                    else{
56:                        pad_last[7]=pad[7];
0074FC  269932     MOV #0x6993, W2
0074FE  784900     MOV.B W0, [W2]
57:                    }
58:                    
59:                    if(pad[4]==0){                                                              //LOOPER CONTROL
60:                        looper=TRUE;
61:                        YLED=looper;
62:                    }
63:                    else {
64:                        looper=FALSE;
007500  EF7022     CLR.B looper
65:                        YLED=looper;
007502  A92E44     BCLR LATE, #1
66:                    }
67:                   
68:                    if(pad[0]==0&&pad_last[0]==1){                                              //LPF CONTROL
007504  E00401     CP0.B W1
007506  3A000B     BRA NZ, 0x751E
007508  510067     SUB W2, #0x7, W0
00750A  B3C012     MOV.B #0x1, W2
00750C  114F90     SUBR.B W2, [W0], [W15]
00750E  3A0007     BRA NZ, 0x751E
69:                        pad_last[0]=0;
007510  EB4800     CLR.B [W0]
70:                        if(lpf==FALSE)
007512  E25023     CP0.B lpf
007514  3A0002     BRA NZ, 0x751A
71:                            lpf=TRUE;
007516  EFF023     SETM.B lpf
007518  370004     BRA 0x7522
72:                        else lpf=FALSE;
00751A  EF7023     CLR.B lpf
00751C  370002     BRA 0x7522
73:                    }
74:                    else{
75:                        pad_last[0]=pad[0];
00751E  2698C0     MOV #0x698C, W0
007520  784801     MOV.B W1, [W0]
76:                    }
77:                    
78:                    //lpf=TRUE;
79:                    
80:                    
81:                }
007522  060000     RETURN
82:                
83:                void readPots(void){
84:                    volatile register int scaled asm("A");
85:                    
86:                    AD1CON1bits.SAMP = 0;      // start sampling
007524  A92320     BCLR AD1CON1, #1
87:                    while (!_AD1IF);           //wait for conversions to complete
007526  220001     MOV #0x2000, W1
007528  804002     MOV IFS0, W2
00752A  608002     AND W1, W2, W0
00752C  32FFFD     BRA Z, 0x7528
88:                    _AD1IF = 0;                //clear status bit
00752E  A9A801     BCLR 0x801, #5
89:                    pots[0]=(ADC1BUF0>>1)+0x1F;
007530  210000     MOV #0x1000, W0
007532  801801     MOV ADC1BUF0, W1
007534  D10081     LSR W1, W1
007536  40887F     ADD W1, #0x1F, [W0]
90:                    pots[1]=(ADC1BUF1>>1)+0x1F;
007538  801811     MOV ADC1BUF1, W1
00753A  D10081     LSR W1, W1
00753C  4080FF     ADD W1, #0x1F, W1
00753E  980011     MOV W1, [W0+2]
91:                    pots[2]=(ADC1BUF2>>1)+0x1F;
007540  801822     MOV ADC1BUF2, W2
007542  D10102     LSR W2, W2
007544  41017F     ADD W2, #0x1F, W2
007546  980022     MOV W2, [W0+4]
92:                    pots[3]=(ADC1BUF3>>1)+0x1F;
007548  801832     MOV ADC1BUF3, W2
00754A  D10102     LSR W2, W2
00754C  41017F     ADD W2, #0x1F, W2
00754E  980032     MOV W2, [W0+6]
93:                    //pot scaling 
94:                    
95:                    if(pots[1]<=2048)
007550  208000     MOV #0x800, W0
007552  508F80     SUB W1, W0, [W15]
007554  3C0003     BRA GT, 0x755C
96:                        pots_scaled[1]=8;
007556  200080     MOV #0x8, W0
007558  888050     MOV W0, 0x100A
00755A  370056     BRA 0x7608
97:                    else if(pots[1]<=4096)
00755C  210000     MOV #0x1000, W0
00755E  508F80     SUB W1, W0, [W15]
007560  3C0003     BRA GT, 0x7568
98:                        pots_scaled[1]=12;
007562  2000C0     MOV #0xC, W0
007564  888050     MOV W0, 0x100A
007566  370050     BRA 0x7608
99:                    else if(pots[1]<=6144)
007568  218000     MOV #0x1800, W0
00756A  508F80     SUB W1, W0, [W15]
00756C  3C0003     BRA GT, 0x7574
100:                       pots_scaled[1]=14;
00756E  2000E0     MOV #0xE, W0
007570  888050     MOV W0, 0x100A
007572  37004A     BRA 0x7608
101:                   else if(pots[1]<=8192)
007574  220000     MOV #0x2000, W0
007576  508F80     SUB W1, W0, [W15]
007578  3C0003     BRA GT, 0x7580
102:                       pots_scaled[1]=16;
00757A  200100     MOV #0x10, W0
00757C  888050     MOV W0, 0x100A
00757E  370044     BRA 0x7608
103:                   else if(pots[1]<=10240)
007580  228000     MOV #0x2800, W0
007582  508F80     SUB W1, W0, [W15]
007584  3C0003     BRA GT, 0x758C
104:                       pots_scaled[1]=19;
007586  200130     MOV #0x13, W0
007588  888050     MOV W0, 0x100A
00758A  37003E     BRA 0x7608
105:                   else if(pots[1]<=12288)
00758C  230000     MOV #0x3000, W0
00758E  508F80     SUB W1, W0, [W15]
007590  3C0003     BRA GT, 0x7598
106:                       pots_scaled[1]=23;
007592  200170     MOV #0x17, W0
007594  888050     MOV W0, 0x100A
007596  370038     BRA 0x7608
107:                   else if(pots[1]<=14336)
007598  238000     MOV #0x3800, W0
00759A  508F80     SUB W1, W0, [W15]
00759C  3C0003     BRA GT, 0x75A4
108:                       pots_scaled[1]=28;
00759E  2001C0     MOV #0x1C, W0
0075A0  888050     MOV W0, 0x100A
0075A2  370032     BRA 0x7608
109:                   else if(pots[1]<=16384)
0075A4  240000     MOV #0x4000, W0
0075A6  508F80     SUB W1, W0, [W15]
0075A8  3C0003     BRA GT, 0x75B0
110:                       pots_scaled[1]=32;
0075AA  200200     MOV #0x20, W0
0075AC  888050     MOV W0, 0x100A
0075AE  37002C     BRA 0x7608
111:                   else if(pots[1]<=18432)
0075B0  248000     MOV #0x4800, W0
0075B2  508F80     SUB W1, W0, [W15]
0075B4  3C0003     BRA GT, 0x75BC
112:                       pots_scaled[1]=36;
0075B6  200240     MOV #0x24, W0
0075B8  888050     MOV W0, 0x100A
0075BA  370026     BRA 0x7608
113:                   else if(pots[1]<=20480)
0075BC  250000     MOV #0x5000, W0
0075BE  508F80     SUB W1, W0, [W15]
0075C0  3C0003     BRA GT, 0x75C8
114:                       pots_scaled[2]=40;
0075C2  200280     MOV #0x28, W0
0075C4  888060     MOV W0, 0x100C
0075C6  370020     BRA 0x7608
115:                   else if(pots[1]<=22528)
0075C8  258000     MOV #0x5800, W0
0075CA  508F80     SUB W1, W0, [W15]
0075CC  3C0003     BRA GT, 0x75D4
116:                       pots_scaled[2]=44;
0075CE  2002C0     MOV #0x2C, W0
0075D0  888060     MOV W0, 0x100C
0075D2  37001A     BRA 0x7608
117:                   else if(pots[1]<=24576)
0075D4  260000     MOV #0x6000, W0
0075D6  508F80     SUB W1, W0, [W15]
0075D8  3C0003     BRA GT, 0x75E0
118:                       pots_scaled[1]=48;
0075DA  200300     MOV #0x30, W0
0075DC  888050     MOV W0, 0x100A
0075DE  370014     BRA 0x7608
119:                   else if(pots[1]<=26624)
0075E0  268000     MOV #0x6800, W0
0075E2  508F80     SUB W1, W0, [W15]
0075E4  3C0003     BRA GT, 0x75EC
120:                       pots_scaled[1]=52;
0075E6  200340     MOV #0x34, W0
0075E8  888050     MOV W0, 0x100A
0075EA  37000E     BRA 0x7608
121:                   else if(pots[1]<=28672)
0075EC  270000     MOV #0x7000, W0
0075EE  508F80     SUB W1, W0, [W15]
0075F0  3C0003     BRA GT, 0x75F8
122:                       pots_scaled[1]=56;
0075F2  200380     MOV #0x38, W0
0075F4  888050     MOV W0, 0x100A
0075F6  370008     BRA 0x7608
123:                   else if(pots[1]<=30720)
0075F8  278000     MOV #0x7800, W0
0075FA  508F80     SUB W1, W0, [W15]
0075FC  3C0003     BRA GT, 0x7604
124:                       pots_scaled[1]=60;
0075FE  2003C0     MOV #0x3C, W0
007600  888050     MOV W0, 0x100A
007602  370002     BRA 0x7608
125:                   else if(pots[1]<=32768)
126:                       pots_scaled[1]=64;
007604  200400     MOV #0x40, W0
007606  888050     MOV W0, 0x100A
127:                   else if(pots[1]<=34816)
128:                       pots_scaled[1]=68;
129:                   else 
130:                       pots_scaled[1]=72;
131:                    
132:                                                                                                
133:                   loop_lim=154*pots_scaled[1];                                                //LOOPER CONTROL
007608  2009A0     MOV #0x9A, W0
00760A  808051     MOV 0x100A, W1
00760C  B98880     MULW.SS W1, W0, W0
00760E  888130     MOV W0, loop_lim
134:                   if(pots[1]>=310){                                                           //LPF CONTROL
007610  808010     MOV 0x1002, W0
007612  201351     MOV #0x135, W1
007614  500F81     SUB W0, W1, [W15]
007616  340004     BRA LE, 0x7620
135:                       lpf_alpha=pots[1];
007618  888220     MOV W0, 0x1044
136:                       lpf_inv_alpha=(32767-lpf_alpha); 
00761A  27FFF1     MOV #0x7FFF, W1
00761C  508000     SUB W1, W0, W0
00761E  888230     MOV W0, 0x1046
137:                   }
138:                   //tremelo_depth=pots[4];
139:                           
140:               }
007620  060000     RETURN
141:               
142:               void display(void){
143:                   lcdSetCursor(2,3);
007622  B3C031     MOV.B #0x3, W1
007624  B3C020     MOV.B #0x2, W0
007626  07007D     RCALL lcdSetCursor
144:                   if(pad[0])lcdWriteString("OFF");
007628  266700     MOV #0x6670, W0
00762A  E00410     CP0.B [W0]
00762C  320003     BRA Z, 0x7634
00762E  2F1D20     MOV #0xF1D2, W0
007630  07009F     RCALL lcdWriteString
007632  370002     BRA 0x7638
145:                   else lcdWriteString("ON ");
007634  2F1D60     MOV #0xF1D6, W0
007636  07009C     RCALL lcdWriteString
146:                   
147:                  lcdSetCursor(2,2);
007638  B3C021     MOV.B #0x2, W1
00763A  784001     MOV.B W1, W0
00763C  070072     RCALL lcdSetCursor
148:                  lcdWriteWord(sampin);
00763E  8081F0     MOV sampin, W0
007640  070105     RCALL lcdWriteWord
149:                  lcdSetCursor(10,2);
007642  B3C021     MOV.B #0x2, W1
007644  B3C0A0     MOV.B #0xA, W0
007646  07006D     RCALL lcdSetCursor
150:                  lcdWriteWord(sampout);
007648  808200     MOV sampout, W0
00764A  070100     RCALL lcdWriteWord
151:                   lcdSetCursor(9,3);
00764C  B3C031     MOV.B #0x3, W1
00764E  B3C090     MOV.B #0x9, W0
007650  070068     RCALL lcdSetCursor
152:                   lcdWriteWord(cycle);
007652  8080D0     MOV cycle, W0
007654  0700FB     RCALL lcdWriteWord
153:                
154:                  
155:                  if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
007656  BFD01C     MOV.B hard_clipped, WREG
007658  404FE1     ADD.B W0, #0x1, [W15]
00765A  3A0003     BRA NZ, 0x7662
156:                       HARD_CLIP_LED=1;
00765C  A82E24     BSET LATC, #1
157:                       hard_clipped=FALSE;
00765E  EF701C     CLR.B hard_clipped
007660  370001     BRA 0x7664
158:                   }  else HARD_CLIP_LED=0;
007662  A92E24     BCLR LATC, #1
159:                   
160:                  if(UART_ON==TRUE){
007664  BFD01F     MOV.B UART_ON, WREG
007666  404FE1     ADD.B W0, #0x1, [W15]
007668  3A000A     BRA NZ, 0x767E
161:                       //IC1CON2bits.TRIGSTAT = ~pad[4]; 
162:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
163:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
164:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
165:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
00766A  210000     MOV #0x1000, W0
00766C  9000A0     MOV [W0+4], W1
00766E  781F81     MOV W1, [W15++]
007670  900090     MOV [W0+2], W1
007672  781F81     MOV W1, [W15++]
007674  781F90     MOV [W0], [W15++]
007676  2F1DA0     MOV #0xF1DA, W0
007678  781F80     MOV W0, [W15++]
00767A  07C745     RCALL __printf_cdnopuxX
00767C  5787E8     SUB W15, #0x8, W15
166:                       //printf("%d\r\n", sample);  //check input ADC
167:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
168:                   }
169:                  
170:                  SLED=~SLED;
00767E  8072A0     MOV LATF, W0
007680  EA8000     COM W0, W0
007682  600061     AND W0, #0x1, W0
007684  8072A1     MOV LATF, W1
007686  A10001     BCLR W1, #0
007688  700081     IOR W0, W1, W1
00768A  8872A1     MOV W1, LATF
171:               }
00768C  060000     RETURN
172:               
173:               void processRxData(fractional * sourceBuffer, fractional * targetBuffer){
174:                   /* This procedure loops back the received data to the*/
175:                   /* the codec output. The user application could process*/
176:                   /* this data as per application requirements.*/
177:                   int index;
178:                   for(index = 0;index < STREAMBUF;index ++)
00768E  EB0100     CLR W2
007690  200403     MOV #0x40, W3
007694  E80102     INC W2, W2
007696  510F83     SUB W2, W3, [W15]
007698  3AFFFC     BRA NZ, 0x7692
179:                   {
180:                       targetBuffer[index] = sourceBuffer[index];
007692  7818B0     MOV [W0++], [W1++]
181:                   }
182:               }
00769A  060000     RETURN
183:               
184:               void processData(int in[][STREAMBUF], int out[][STREAMBUF]){
00769C  BE9F88     MOV.D W8, [W15++]
00769E  BE9F8A     MOV.D W10, [W15++]
0076A0  BE9F8C     MOV.D W12, [W15++]
0076A2  BE0500     MOV.D W0, W10
185:                   fractional temp;
186:                   int writePtr=0;
0076A4  EB0400     CLR W8
187:                   for(writePtr; writePtr<STREAMBUF; writePtr++){
0076D2  E80408     INC W8, W8
0076D4  200400     MOV #0x40, W0
0076D6  540F80     SUB W8, W0, [W15]
0076D8  3AFFE8     BRA NZ, 0x76AA
188:                       temp=in[!rw][writePtr];
0076A6  20080D     MOV #0x80, W13
0076AA  EB0000     CLR W0
0076AC  E21014     CP0 rw
0076AE  3A0001     BRA NZ, 0x76B2
0076B0  78000D     MOV W13, W0
0076B2  450000     ADD W10, W0, W0
0076B4  440088     ADD W8, W8, W1
0076B6  400001     ADD W0, W1, W0
0076B8  780010     MOV [W0], W0
189:                           
190:                       if(temp<=-32766||temp>=32766)
0076A8  27FFDC     MOV #0x7FFD, W12
0076BA  40008C     ADD W0, W12, W1
0076BC  408FE6     ADD W1, #0x6, [W15]
0076BE  360001     BRA LEU, 0x76C2
191:                           hard_clipped=TRUE;
0076C0  EFF01C     SETM.B hard_clipped
192:                       temp=fx(temp);    //run fx on latest sample
0076C2  070166     RCALL fx
193:                       out[rw][writePtr]=mixer(temp);
0076C4  8080A9     MOV rw, W9
0076C6  DD4CC7     SL W9, #7, W9
0076C8  458489     ADD W11, W9, W9
0076CA  0700FC     RCALL mixer
0076CC  440088     ADD W8, W8, W1
0076CE  448481     ADD W9, W1, W9
0076D0  780C80     MOV W0, [W9]
194:                   }
195:                   
196:                   frameReady=0;
0076DA  EF3016     CLR frameReady
197:               }
0076DC  BE064F     MOV.D [--W15], W12
0076DE  BE054F     MOV.D [--W15], W10
0076E0  BE044F     MOV.D [--W15], W8
0076E2  060000     RETURN
198:               
199:               //A blocking delay function. Not very accurate but good enough.
200:               void Delay_us(unsigned int delay)
201:               {
202:                   int i;
203:                   for (i = 0; i < delay; i++)
0076E4  E00000     CP0 W0
0076E6  320006     BRA Z, 0x76F4
0076E8  EB0080     CLR W1
0076EE  E80081     INC W1, W1
0076F0  500F81     SUB W0, W1, [W15]
0076F2  3EFFFB     BRA GTU, 0x76EA
204:                   {
205:                       __asm__ volatile ("repeat #50");
0076EA  090032     REPEAT #0x32
206:                       __asm__ volatile ("nop");
0076EC  000000     NOP
207:                   }
208:               }
0076F4  060000     RETURN
---  /home/fbuga/Documents/ps-040/routines.c  -----------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 #include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern char pad[8];
10:                extern fractional pots[4]; 
11:                extern fractional stream[2][STREAMBUF];
12:                extern fractional output[2][STREAMBUF];
13:                extern unsigned int write_ptr, rw, frameReady;
14:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
15:                
16:                //STATUS VARIABLES
17:                extern unsigned char recording;
18:                extern const int sintab[1024];
19:                extern unsigned char t1flag, t2flag;
20:                
21:                //FX FLAGS
22:                extern unsigned char tremelo, looper;
23:                
24:                //misc.
25:                volatile fractional sampin=0;
26:                volatile fractional sampout=0;;
27:                volatile int rxBufferIndicator = 0;
28:                
29:                //Description: This interrupt toggles status led, runs UART1 and handles display
30:                //Dependencies: initUART1();
31:                //Frequency: 60
32:                void __attribute__ ((interrupt, auto_psv)) _T1Interrupt(void){
000306  F80032     PUSH DSRPAG
000308  F80034     PUSH DSWPAG
00030A  781F88     MOV W8, [W15++]
00030C  200018     MOV #0x1, W8
00030E  8801A8     MOV W8, DSWPAG
000310  202008     MOV #0x200, W8
000312  880198     MOV W8, DSRPAG
000314  000000     NOP
000316  78044F     MOV [--W15], W8
33:                    t1flag=TRUE;
000318  EFF01D     SETM.B t1flag
34:                    IFS0bits.T1IF = 0;              //clear interrupt flag & restart
00031A  A96800     BCLR IFS0, #3
35:                }
00031C  F90034     POP DSWPAG
00031E  F90032     POP DSRPAG
000320  064000     RETFIE
36:                
37:                //Description: This interrupt handles polling button input
38:                //Dependencies: initADC1(); 
39:                //Frequency: 512Hz
40:                void __attribute__ ((interrupt, auto_psv)) _T2Interrupt(void){
000322  F80032     PUSH DSRPAG
000324  F80034     PUSH DSWPAG
000326  781F88     MOV W8, [W15++]
000328  200018     MOV #0x1, W8
00032A  8801A8     MOV W8, DSWPAG
00032C  202008     MOV #0x200, W8
00032E  880198     MOV W8, DSRPAG
000330  000000     NOP
000332  78044F     MOV [--W15], W8
41:                    t2flag=TRUE;
000334  EFF01E     SETM.B t2flag
42:                    IFS0bits.T2IF = 0;              //clear interrupt flag & restart
000336  A9E800     BCLR IFS0, #7
43:                }
000338  F90034     POP DSWPAG
00033A  F90032     POP DSRPAG
00033C  064000     RETFIE
44:                
45:                //Description: This interrupt triggers at the completion of DCI output
46:                //Dependancies: initSPI2(); 
47:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
00033E  BE9F80     MOV.D W0, [W15++]
000340  F80032     PUSH DSRPAG
000342  F80034     PUSH DSWPAG
000344  200010     MOV #0x1, W0
000346  8801A0     MOV W0, DSWPAG
000348  202000     MOV #0x200, W0
00034A  880190     MOV W0, DSRPAG
00034C  000000     NOP
48:                    TXBUF0=TXBUF1=sampout;                                    //output buffered sample to DAC
00034E  F81040     PUSH sampout
000350  F9029A     POP TXBUF1
000352  F8029A     PUSH TXBUF1
000354  F90298     POP TXBUF0
49:                    sampin=RXBUF1;
000356  F80292     PUSH RXBUF1
000358  F9103E     POP sampin
50:                    int trash=RXBUF0;
00035A  801480     MOV RXBUF0, W0
51:                    __builtin_btg(&sampin, 15);                             //convert to Q1.15 compatible format    
00035C  2103E0     MOV #0x103E, W0
00035E  A2F010     BTG [W0], #15
52:                    if(write_ptr==(STREAMBUF-1)){                       //reset pointer when out of bounds
000360  808090     MOV write_ptr, W0
000362  2003F1     MOV #0x3F, W1
000364  500F81     SUB W0, W1, [W15]
000366  3A0005     BRA NZ, 0x372
53:                        write_ptr=0;
000368  EF3012     CLR write_ptr
54:                        __builtin_btg(&rw,0);
00036A  AA1014     BTG rw, #0
55:                        frameReady=1;
00036C  200010     MOV #0x1, W0
00036E  8880B0     MOV W0, frameReady
000370  370002     BRA 0x376
56:                    }else write_ptr++;
000372  E80000     INC W0, W0
000374  888090     MOV W0, write_ptr
57:                    
58:                    if(recording==TRUE){
000376  BFD04A     MOV.B 0x104A, WREG
000378  404FE1     ADD.B W0, #0x1, [W15]
00037A  3A0009     BRA NZ, 0x38E
59:                        stream[rw][write_ptr]=sampin;                 //get output
00037C  8080A0     MOV rw, W0
00037E  DD0046     SL W0, #6, W0
000380  808091     MOV write_ptr, W1
000382  400001     ADD W0, W1, W0
000384  400000     ADD W0, W0, W0
000386  267781     MOV #0x6778, W1
000388  408000     ADD W1, W0, W0
00038A  8081F1     MOV sampin, W1
00038C  780801     MOV W1, [W0]
60:                    }
61:                
62:                    sampout=output[!rw][write_ptr];             //mix  new output
00038E  8080A0     MOV rw, W0
000390  A7F000     BTSC W0, #15
000392  EA0000     NEG W0, W0
000394  E90000     DEC W0, W0
000396  DE004F     LSR W0, #15, W0
000398  DD0046     SL W0, #6, W0
00039A  808091     MOV write_ptr, W1
00039C  400001     ADD W0, W1, W0
00039E  400000     ADD W0, W0, W0
0003A0  266781     MOV #0x6678, W1
0003A2  408000     ADD W1, W0, W0
0003A4  780010     MOV [W0], W0
0003A6  888200     MOV W0, sampout
63:                    
64:                    IFS3bits.DCIIF=0;
0003A8  A98807     BCLR 0x807, #4
65:                }
0003AA  F90034     POP DSWPAG
0003AC  F90032     POP DSRPAG
0003AE  BE004F     MOV.D [--W15], W0
0003B0  064000     RETFIE
66:                void __attribute__ ((interrupt, auto_psv)) _IC1Interrupt(void){
0003B2  BE9F80     MOV.D W0, [W15++]
0003B4  F80032     PUSH DSRPAG
0003B6  F80034     PUSH DSWPAG
0003B8  200010     MOV #0x1, W0
0003BA  8801A0     MOV W0, DSWPAG
0003BC  202000     MOV #0x200, W0
0003BE  880190     MOV W0, DSRPAG
0003C0  000000     NOP
67:                    IFS0bits.IC1IF=0;   
0003C2  A92800     BCLR IFS0, #1
68:                    //bpm=IC1BUF;
69:                    RLED=~RLED;
0003C4  807120     MOV LATC, W0
0003C6  EA8000     COM W0, W0
0003C8  600061     AND W0, #0x1, W0
0003CA  807121     MOV LATC, W1
0003CC  A10001     BCLR W1, #0
0003CE  700081     IOR W0, W1, W1
0003D0  887121     MOV W1, LATC
70:                }
0003D2  F90034     POP DSWPAG
0003D4  F90032     POP DSRPAG
0003D6  BE004F     MOV.D [--W15], W0
0003D8  064000     RETFIE
71:                
72:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
0003DA  781F80     MOV W0, [W15++]
0003DC  F80032     PUSH DSRPAG
0003DE  F80034     PUSH DSWPAG
0003E0  200010     MOV #0x1, W0
0003E2  8801A0     MOV W0, DSWPAG
0003E4  202000     MOV #0x200, W0
0003E6  880190     MOV W0, DSRPAG
0003E8  000000     NOP
73:                    //SEG_SEL=1;
74:                    int trash=SPI3BUF;
0003EA  801540     MOV SPI3BUF, W0
75:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
0003EC  A9C2A0     BCLR SPI3STAT, #6
76:                    IFS5bits.SPI3IF=0;   
0003EE  A9680B     BCLR 0x80B, #3
77:                }
0003F0  F90034     POP DSWPAG
0003F2  F90032     POP DSRPAG
0003F4  78004F     MOV [--W15], W0
0003F6  064000     RETFIE
78:                
79:                void __attribute__((__interrupt__,no_auto_psv)) _DMA2Interrupt(void){
0003F8  F80036     PUSH RCOUNT
0003FA  BE9F80     MOV.D W0, [W15++]
0003FC  BE9F82     MOV.D W2, [W15++]
0003FE  BE9F84     MOV.D W4, [W15++]
000400  BE9F86     MOV.D W6, [W15++]
80:                    _DMA2IF = 0; /* Received one frame of data*/    
000402  A90803     BCLR 0x803, #0
81:                    
82:                    if(rxBufferIndicator == 0)
000404  E21042     CP0 rxBufferIndicator
000406  3A0004     BRA NZ, 0x410
83:                    {
84:                         processRxData((int *)rxBufferA, (int*)txBufferA);
000408  2CF801     MOV #0xCF80, W1
00040A  2CE800     MOV #0xCE80, W0
00040C  073940     RCALL processRxData
00040E  370003     BRA 0x416
85:                    }
86:                    else
87:                    {
88:                         processRxData((int *)rxBufferB, (int*)txBufferB);
000410  2CF001     MOV #0xCF00, W1
000412  2CE000     MOV #0xCE00, W0
000414  07393C     RCALL processRxData
89:                    }
90:                    rxBufferIndicator ^= 1; /* Toggle the indicator*/    
000416  AA1042     BTG rxBufferIndicator, #0
91:                }
000418  BE034F     MOV.D [--W15], W6
00041A  BE024F     MOV.D [--W15], W4
00041C  BE014F     MOV.D [--W15], W2
00041E  BE004F     MOV.D [--W15], W0
000420  F90036     POP RCOUNT
000422  064000     RETFIE
92:                
93:                /*
94:                //Description: This interrupt handles polling button input
95:                //Dependencies: initADC1(); 
96:                //Frequency: 44.1kHz
97:                void __attribute__ ((interrupt, auto_psv)) _T3Interrupt(void){
98:                    SEG_SEL=0;
99:                    SPI3BUF=0x0100;
100:                   //SEG_SEL=1;
101:                   IFS0bits.T3IF = 0;              //clear flag, restart
102:               }
103:               
104:               void __attribute__ ((interrupt, auto_psv)) _SPI2Interrupt(void){
105:                   //GLED=~GLED;                                             //check half freq w/ RLED                                        //returns SS2 to idle state
106:                   SPI2STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
107:                   IFS2bits.SPI2IF = 0;                                    //reset flag & restart
108:               }
109:               //Description: This interrupt handles UART reception
110:               //Dependencies: initUART1();
111:               void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
112:                   unsigned char trash;
113:                   GLED=~GLED;
114:                   trash=U1RXREG;
115:                   printf("RECIEVED: %d\r\n", trash);
116:                   IFS0bits.U1RXIF = 0;            //clear flag, restart
117:               }
118:               
119:               //Description: This interrupt handles UART transmission
120:               //Dependencies: initUART1();
121:               void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
122:                   YLED=~YLED;
123:                   IFS0bits.U1TXIF = 0;            //clear flag, restart
124:               } 
125:                */
---  /home/fbuga/Documents/ps-040/plcd.c  ---------------------------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "plcd.h"
11:                #include "common.h"
12:                #include "utilities.h"
13:                
14:                extern unsigned char TEST_SIN;
15:                
16:                unsigned int statusReg = 0x0C;  //internal copy of pwr reg
17:                                                // 0b_0 0 0 0 - 1 D C B (display, cursor, blink)
18:                char lcdBuf[80];
19:                
20:                void lcdWrite(unsigned char data){
21:                    if(!LCD_RS_P)LCD_RS=1;
0076F6  E20E42     CP0 PORTE
0076F8  350001     BRA LT, 0x76FC
0076FA  A8EE45     BSET 0xE45, #7
22:                    if(!PMMODEbits.BUSY) PMDIN1=data; //(!skips if busy!)
0076FC  E20602     CP0 PMMODE
0076FE  350002     BRA LT, 0x7704
007700  FB8000     ZE W0, W0
007702  883040     MOV W0, PMDIN1
23:                }
007704  060000     RETURN
24:                
25:                void lcdCommand(unsigned char data){
26:                    if(LCD_RS_P)LCD_RS=0;
007706  E20E42     CP0 PORTE
007708  3D0001     BRA GE, 0x770C
00770A  A9EE45     BCLR 0xE45, #7
27:                    if(!PMMODEbits.BUSY) PMDIN1=data; //(!skips if busy!)
00770C  E20602     CP0 PMMODE
00770E  350002     BRA LT, 0x7714
007710  FB8000     ZE W0, W0
007712  883040     MOV W0, PMDIN1
28:                }
007714  060000     RETURN
29:                
30:                void lcdClear(void){
31:                    lcdCommand(LCD_CLEARDISPLAY);
007716  B3C010     MOV.B #0x1, W0
007718  07FFF6     RCALL lcdCommand
32:                }
00771A  060000     RETURN
33:                
34:                void lcdReturn(void){
35:                    lcdCommand(LCD_RETURNHOME);
00771C  B3C020     MOV.B #0x2, W0
00771E  07FFF3     RCALL lcdCommand
36:                }
007720  060000     RETURN
37:                
38:                void lcdSetCursor(unsigned char col, unsigned char row) {
39:                  static unsigned char offsets[] = { 0x00, 0x40, 0x14, 0x54 };
40:                
41:                  if (row > 3) {
42:                    row = 3;
43:                  }
44:                  lcdCommand(LCD_SETDDRAMADDR | (col + offsets[row]));
007722  50CFE3     SUB.B W1, #0x3, [W15]
007724  360001     BRA LEU, 0x7728
007726  B3C031     MOV.B #0x3, W1
007728  FB8081     ZE W1, W1
00772A  2F1CE2     MOV #0xF1CE, W2
00772C  410081     ADD W2, W1, W1
00772E  404011     ADD.B W0, [W1], W0
007730  A07400     BSET.B W0, #7
007732  07FFE9     RCALL lcdCommand
45:                  Delay_us(50);
007734  200320     MOV #0x32, W0
007736  07FFD6     RCALL Delay_us
46:                }
007738  060000     RETURN
47:                
48:                void lcdPwr(signed int pwr){
49:                    //lcd soft power on/off, does not reset device
50:                    if(pwr)
00773A  E00000     CP0 W0
00773C  320003     BRA Z, 0x7744
51:                        statusReg&=0x04;
00773E  200040     MOV #0x4, W0
007740  B6304C     AND 0x104C
007742  370001     BRA 0x7746
52:                    else __builtin_btg(&statusReg, 2);
007744  AA504C     BTG 0x104C, #2
53:                    
54:                    lcdCommand(statusReg);
007746  BFD04C     MOV.B 0x104C, WREG
007748  07FFDE     RCALL lcdCommand
55:                }
00774A  060000     RETURN
56:                
57:                void lcdCursorEn(signed int pwr){
58:                    //cursor on / off
59:                    if(pwr)
00774C  E00000     CP0 W0
00774E  320003     BRA Z, 0x7756
60:                        statusReg&=0x0A;
007750  2000A0     MOV #0xA, W0
007752  B6304C     AND 0x104C
007754  370001     BRA 0x7758
61:                    else __builtin_btg(&statusReg, 1);
007756  AA304C     BTG 0x104C, #1
62:                    
63:                    lcdCommand(statusReg);
007758  BFD04C     MOV.B 0x104C, WREG
00775A  07FFD5     RCALL lcdCommand
64:                }
00775C  060000     RETURN
65:                
66:                void lcdCursorBlink(signed int pwr){
67:                    if(pwr)
00775E  E00000     CP0 W0
007760  320003     BRA Z, 0x7768
68:                        statusReg&=0x09;
007762  200090     MOV #0x9, W0
007764  B6304C     AND 0x104C
007766  370001     BRA 0x776A
69:                    else __builtin_btg(&statusReg, 0);
007768  AA104C     BTG 0x104C, #0
70:                    
71:                    lcdCommand(statusReg);
00776A  BFD04C     MOV.B 0x104C, WREG
00776C  07FFCC     RCALL lcdCommand
72:                }
00776E  060000     RETURN
73:                
74:                //BLOCKING!
75:                void lcdWriteString(char *string) {
007770  BE9F88     MOV.D W8, [W15++]
007772  780400     MOV W0, W8
76:                    char *it = string;
77:                  for (; *it; it++) {
007774  784018     MOV.B [W8], W0
007776  E00400     CP0.B W0
007778  320007     BRA Z, 0x7788
007782  784058     MOV.B [++W8], W0
007784  E00400     CP0.B W0
007786  3AFFFA     BRA NZ, 0x777C
78:                    lcdWrite(*it);
00777C  07FFBC     RCALL lcdWrite
79:                    Delay_us(50);
00777A  200329     MOV #0x32, W9
00777E  780009     MOV W9, W0
007780  07FFB1     RCALL Delay_us
80:                  }
81:                    Delay_us(40);
007788  200280     MOV #0x28, W0
00778A  07FFAC     RCALL Delay_us
82:                }
00778C  BE044F     MOV.D [--W15], W8
00778E  060000     RETURN
83:                
84:                void lcdSetupPots(){
85:                    lcdSetCursor(0,0);
007790  EB4080     CLR.B W1
007792  784001     MOV.B W1, W0
007794  07FFC6     RCALL lcdSetCursor
86:                    lcdWriteString("P1:");
007796  2F19E0     MOV #0xF19E, W0
007798  07FFEB     RCALL lcdWriteString
87:                    lcdSetCursor(6,0);
00779A  EB4080     CLR.B W1
00779C  B3C060     MOV.B #0x6, W0
00779E  07FFC1     RCALL lcdSetCursor
88:                    lcdWriteString("P2:");
0077A0  2F1A20     MOV #0xF1A2, W0
0077A2  07FFE6     RCALL lcdWriteString
89:                    lcdSetCursor(12,0);
0077A4  EB4080     CLR.B W1
0077A6  B3C0C0     MOV.B #0xC, W0
0077A8  07FFBC     RCALL lcdSetCursor
90:                    lcdWriteString("P3:");
0077AA  2F1A60     MOV #0xF1A6, W0
0077AC  07FFE1     RCALL lcdWriteString
91:                    lcdSetCursor(0,1);
0077AE  B3C011     MOV.B #0x1, W1
0077B0  EB4000     CLR.B W0
0077B2  07FFB7     RCALL lcdSetCursor
92:                    lcdWriteString("P4:");
0077B4  2F1AA0     MOV #0xF1AA, W0
0077B6  07FFDC     RCALL lcdWriteString
93:                    lcdSetCursor(6,1);
0077B8  B3C011     MOV.B #0x1, W1
0077BA  B3C060     MOV.B #0x6, W0
0077BC  07FFB2     RCALL lcdSetCursor
94:                    lcdWriteString("P5:");
0077BE  2F1AE0     MOV #0xF1AE, W0
0077C0  07FFD7     RCALL lcdWriteString
95:                    lcdSetCursor(12,1);
0077C2  B3C011     MOV.B #0x1, W1
0077C4  B3C0C0     MOV.B #0xC, W0
0077C6  07FFAD     RCALL lcdSetCursor
96:                    lcdWriteString("P6:");
0077C8  2F1B20     MOV #0xF1B2, W0
0077CA  07FFD2     RCALL lcdWriteString
97:                    lcdSetCursor(0,2);
0077CC  B3C021     MOV.B #0x2, W1
0077CE  EB4000     CLR.B W0
0077D0  07FFA8     RCALL lcdSetCursor
98:                    lcdWriteString("I:");
0077D2  2F1B60     MOV #0xF1B6, W0
0077D4  07FFCD     RCALL lcdWriteString
99:                    lcdSetCursor(8,2);
0077D6  B3C021     MOV.B #0x2, W1
0077D8  B3C080     MOV.B #0x8, W0
0077DA  07FFA3     RCALL lcdSetCursor
100:                   lcdWriteString("O:");
0077DC  2F1B90     MOV #0xF1B9, W0
0077DE  07FFC8     RCALL lcdWriteString
101:                   lcdSetCursor(0,3);
0077E0  B3C031     MOV.B #0x3, W1
0077E2  EB4000     CLR.B W0
0077E4  07FF9E     RCALL lcdSetCursor
102:                   lcdWriteString("B:");
0077E6  2F1BC0     MOV #0xF1BC, W0
0077E8  07FFC3     RCALL lcdWriteString
103:                   lcdSetCursor(6,3);
0077EA  B3C031     MOV.B #0x3, W1
0077EC  B3C060     MOV.B #0x6, W0
0077EE  07FF99     RCALL lcdSetCursor
104:                   lcdWriteString("Cyc:");
0077F0  2F1BF0     MOV #0xF1BF, W0
0077F2  07FFBE     RCALL lcdWriteString
105:                   lcdSetCursor(15,3);
0077F4  B3C031     MOV.B #0x3, W1
0077F6  B3C0F0     MOV.B #0xF, W0
0077F8  07FF94     RCALL lcdSetCursor
106:                   if(TEST_SIN==TRUE)lcdWriteString("SINE");
0077FA  BFD020     MOV.B TEST_SIN, WREG
0077FC  404FE1     ADD.B W0, #0x1, [W15]
0077FE  3A0003     BRA NZ, 0x7806
007800  2F1C40     MOV #0xF1C4, W0
007802  07FFB6     RCALL lcdWriteString
007804  370002     BRA 0x780A
107:                   else lcdWriteString("PASS");
007806  2F1C90     MOV #0xF1C9, W0
007808  07FFB3     RCALL lcdWriteString
108:                   
109:               }
00780A  060000     RETURN
110:               
111:               void lcdCustomSymbols(void){
112:                   int i=0;
113:                   lcdCommand(0x40);
00780C  B3C400     MOV.B #0x40, W0
00780E  07FF7B     RCALL lcdCommand
114:                   Delay_us(200);
007810  200C80     MOV #0xC8, W0
007812  07FF68     RCALL Delay_us
115:                  // for(; i<8; i++)lcdWriteString(loadingOne[i]);
116:                   //lcdWriteString(loadingTwo);
117:                   //lcdWriteString(loadingThree);
118:                   //lcdWriteString(loadingFour);
119:               }
007814  060000     RETURN
120:               
121:               void lcdInit(void){
122:                   lcdCommand(0x38);              //function set, 8 bits, 2 line disp, 5x8
007816  B3C380     MOV.B #0x38, W0
007818  07FF76     RCALL lcdCommand
123:                   Delay_us(4500);                //>4.1 mS required
00781A  211940     MOV #0x1194, W0
00781C  07FF63     RCALL Delay_us
124:                   lcdCommand(0x0C);              //display on, cursor on, blink on   (0f for blink+cursor)
00781E  B3C0C0     MOV.B #0xC, W0
007820  07FF72     RCALL lcdCommand
125:                   Delay_us(4500);
007822  211940     MOV #0x1194, W0
007824  07FF5F     RCALL Delay_us
126:                   lcdClear();                    //Display Clear  
007826  07FF77     RCALL lcdClear
127:                   Delay_us(1800);                //>1.64mS required
007828  207080     MOV #0x708, W0
00782A  07FF5C     RCALL Delay_us
128:                   lcdCommand(0x06);               // entry Mode Set
00782C  B3C060     MOV.B #0x6, W0
00782E  07FF6B     RCALL lcdCommand
129:                   Delay_us(200);
007830  200C80     MOV #0xC8, W0
007832  07FF58     RCALL Delay_us
130:                   lcdReturn();
007834  07FF73     RCALL lcdReturn
131:                   Delay_us(1500);
007836  205DC0     MOV #0x5DC, W0
007838  07FF55     RCALL Delay_us
132:                   
133:                   //lcdCustomSymbols();
134:                   Delay_us(200);
00783A  200C80     MOV #0xC8, W0
00783C  07FF53     RCALL Delay_us
135:                   lcdClear();                         //Display Clear  
00783E  07FF6B     RCALL lcdClear
136:                   Delay_us(1500);
007840  205DC0     MOV #0x5DC, W0
007842  07FF50     RCALL Delay_us
137:                   lcdReturn();
007844  07FF6B     RCALL lcdReturn
138:                   Delay_us(200);
007846  200C80     MOV #0xC8, W0
007848  07FF4D     RCALL Delay_us
139:               }
00784A  060000     RETURN
140:               
141:               void lcdWriteWord(int word){
00784C  4787E6     ADD W15, #0x6, W15
00784E  781F88     MOV W8, [W15++]
007850  781F8E     MOV W14, [W15++]
007852  780400     MOV W0, W8
00787A  200040     MOV #0x4, W0
142:                   int i;
143:                   char inchar[4];
144:                   
145:                   if(word<0) {
007854  E00008     CP0 W8
007856  3D0004     BRA GE, 0x7860
146:                       lcdWrite('-');
007858  B3C2D0     MOV.B #0x2D, W0
00785A  07FF4D     RCALL lcdWrite
147:                       word=~word+1;
00785C  EA0408     NEG W8, W8
00785E  370002     BRA 0x7864
148:                   }else lcdWrite(' ');
007860  B3C200     MOV.B #0x20, W0
007862  07FF49     RCALL lcdWrite
149:                  Delay_us(40);
007864  200280     MOV #0x28, W0
007866  07FF3E     RCALL Delay_us
150:                  
151:                  inchar[0] = word&0x000F; 
007868  64406F     AND.B W8, #0xF, W0
152:                  if (inchar[0] > 9) 
00786A  504FE9     SUB.B W0, #0x9, [W15]
00786C  340003     BRA LE, 0x7874
153:                      inchar[0]+=55;
00786E  B04370     ADD.B #0x37, W0
007870  9FFF80     MOV.B W0, [W15-8]
007872  370002     BRA 0x7878
154:                  else inchar[0]+=48;
007874  B04300     ADD.B #0x30, W0
007876  9FFF80     MOV.B W0, [W15-8]
007878  578768     SUB W15, #0x8, W14
155:                  
156:                  for(i=1; i<4; i++){ 
007894  500FF0     SUB W0, #0x10, [W15]
007896  3AFFF2     BRA NZ, 0x787C
157:                     inchar[i] = ((word>>(i*4))&0x0000F); 
00787C  DEC080     ASR W8, W0, W1
00787E  60C0EF     AND.B W1, #0xF, W1
007880  E8070E     INC W14, W14
007882  784F01     MOV.B W1, [W14]
158:                     if (inchar[i] > 9) 
007884  50CFE9     SUB.B W1, #0x9, [W15]
007886  340003     BRA LE, 0x788E
159:                         inchar[i]+=55;
007888  B3C373     MOV.B #0x37, W3
00788A  40CF03     ADD.B W1, W3, [W14]
00788C  370002     BRA 0x7892
160:                     else inchar[i]+=48;
00788E  B3C303     MOV.B #0x30, W3
007890  40CF03     ADD.B W1, W3, [W14]
007892  400064     ADD W0, #0x4, W0
161:                  } 
162:                  lcdWrite(inchar[3]);
007898  97F83F     MOV.B [W15-5], W0
00789A  07FF2D     RCALL lcdWrite
163:                  Delay_us(50);
00789C  200320     MOV #0x32, W0
00789E  07FF22     RCALL Delay_us
164:                  lcdWrite(inchar[2]);
0078A0  97F82F     MOV.B [W15-6], W0
0078A2  07FF29     RCALL lcdWrite
165:                   Delay_us(50);
0078A4  200320     MOV #0x32, W0
0078A6  07FF1E     RCALL Delay_us
166:                  lcdWrite(inchar[1]);
0078A8  97F81F     MOV.B [W15-7], W0
0078AA  07FF25     RCALL lcdWrite
167:                  Delay_us(50);
0078AC  200320     MOV #0x32, W0
0078AE  07FF1A     RCALL Delay_us
168:                  lcdWrite(inchar[0]);
0078B0  97F80F     MOV.B [W15-8], W0
0078B2  07FF21     RCALL lcdWrite
169:                  Delay_us(50);
0078B4  200320     MOV #0x32, W0
0078B6  07FF16     RCALL Delay_us
170:               }
0078B8  78074F     MOV [--W15], W14
0078BA  78044F     MOV [--W15], W8
0078BC  B1006F     SUB #0x6, W15
0078BE  060000     RETURN
171:               
172:               void lcdVUvertical(unsigned char col, unsigned char row, int data){
173:                   lcdSetCursor(col,row);
0078C0  07FF30     RCALL lcdSetCursor
174:               }
0078C2  060000     RETURN
175:               /*
176:                char loadingOne[8] = {
177:               	0b10000,
178:               	0b10000,
179:               	0b10000,
180:               	0b10000,
181:               	0b10000,
182:               	0b10000,
183:               	0b10000,
184:               	0b10000
185:               };
186:               
187:               char loadingTwo[8] = {
188:               	0b11000,
189:               	0b11000,
190:               	0b11000,
191:               	0b11000,
192:               	0b11000,
193:               	0b11000,
194:               	0b11000,
195:               	0b11000
196:               };
197:               
198:               char loadingThree[8] = {
199:               	0b11100,
200:               	0b11100,
201:               	0b11100,
202:               	0b11100,
203:               	0b11100,
204:               	0b11100,
205:               	0b11100,
206:               	0b11100
207:               };
208:               
209:               char loadingFour[8] = {
210:               	0b11110,
211:               	0b11110,
212:               	0b11110,
213:               	0b11110,
214:               	0b11110,
215:               	0b11110,
216:               	0b11110,
217:               	0b11110
218:               };
219:                */
220:               
---  /home/fbuga/Documents/ps-040/main.c  ---------------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 //#include "fatfs/src/ff.h"
9:                 
10:                #pragma config ICS = PGD1       //pgeDC 1 is used
11:                #pragma config JTAGEN = OFF     //disable jtag
12:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
13:                #pragma config FWDTEN = OFF     //disable watchdog timer 
14:                #pragma config GCP = OFF        //disable general segment code protect
15:                #pragma config PLLKEN = ON      //wait for PLL lock
16:                #pragma config POSCMD = NONE    //no external oscillator
17:                #pragma config OSCIOFNC = ON   //OSC2 is clock output
18:                #pragma config FNOSC = FRCPLL   //clock source
19:                
20:                unsigned char pad[8]={0};                                                                //CONTROL VARIABLES//
21:                fractional pots[4]={0};
22:                fractional pots_scaled[4]={0};
23:                fractional output[2][STREAMBUF];
24:                fractional stream[2][STREAMBUF];
25:                
26:                /* DMA BUFFERS */
27:                fractional txBufferA[STREAMBUF]__attribute__((space(eds)));
28:                fractional txBufferB[STREAMBUF] __attribute__((space(eds)));
29:                fractional rxBufferA[STREAMBUF] __attribute__((space(eds)));
30:                fractional rxBufferB[STREAMBUF] __attribute__((space(eds)));
31:                
32:                unsigned int bpm=0, write_ptr=0, rw=0, frameReady=0;
33:                unsigned int idle=0, cycle=0;
34:                
35:                unsigned char hard_clipped=FALSE;                                               //STATUS VARIABLES//
36:                volatile unsigned char t1flag=FALSE;
37:                volatile unsigned char t2flag=FALSE;
38:                volatile unsigned char recording=TRUE;
39:                unsigned char UART_ON = FALSE;
40:                unsigned char TEST_SIN = FALSE;
41:                
42:                volatile unsigned char tremelo=FALSE;                                           //FX FLAGS//
43:                volatile unsigned char looper=FALSE;
44:                volatile unsigned char lpf=FALSE;
45:                
46:                void initBuffer(void){
007B9E  267787     MOV #0x6778, W7
007BA0  200806     MOV #0x80, W6
007BA2  430307     ADD W6, W7, W6
007BA4  2CF7E5     MOV #0xCF7E, W5
007BA6  2CEFE4     MOV #0xCEFE, W4
007BA8  2CE7E3     MOV #0xCE7E, W3
007BAA  2CDFE2     MOV #0xCDFE, W2
007BAC  200401     MOV #0x40, W1
47:                    int i=0;
48:                    for(; i<STREAMBUF; i++){
007BBE  3AFFF8     BRA NZ, 0x7BB0
49:                        stream[0][i]=0;
007BAE  EB0000     CLR W0
007BB0  781B80     MOV W0, [W7++]
50:                        stream[1][i]=0;
007BB2  781B00     MOV W0, [W6++]
51:                        txBufferA[i]=0;
007BB4  782A80     MOV W0, [++W5]
52:                        txBufferB[i]=0;
007BB6  782A00     MOV W0, [++W4]
53:                        rxBufferA[i]=0;
007BB8  782980     MOV W0, [++W3]
54:                        rxBufferB[i]=0;
007BBA  782900     MOV W0, [++W2]
007BBC  E90081     DEC W1, W1
55:                    }
56:                }
007BC0  060000     RETURN
57:                
58:                int main(void) {
007BC2  BE9F88     MOV.D W8, [W15++]
59:                    initPorts();                    //configure io device & adc 
007BC4  07FB15     RCALL initPorts
60:                    //initUART1();                    //configure & enable UART
61:                    initBuffer();
007BC6  07FFEB     RCALL initBuffer
62:                    initADC1();                     //configure & enable internal ADC
007BC8  07FBBA     RCALL initADC1
63:                    //initSPI2_ADC();                  //configure & enable SPI ADC !!!DEFUNCT!!!
64:                    initPMP();
007BCA  07FBCC     RCALL initPMP
65:                    //||||||||----
66:                    //initDMA0();
67:                    initDCI_DAC();                  //configure & enable DAC
007BCC  07FC1A     RCALL initDCI_DAC
68:                    initT1();                       //configure & start T1 
007BCE  07FBE9     RCALL initT1
69:                    initT2();                       //configure & start T2 
007BD0  07FBF7     RCALL initT2
70:                    //initSPI3_SEG();                  //start segment display
71:                
72:                    //initCAP_BPM();                  //configure bpm capture
73:                    //initT3();                       //configure & start T3
74:                    while(1){   
75:                        unsigned int temp;
76:                        if(frameReady) {
007BD6  E21016     CP0 frameReady
007BD8  320008     BRA Z, 0x7BEA
77:                            processData(stream, output);
007BD2  266788     MOV #0x6678, W8
007BD4  267789     MOV #0x6778, W9
007BDA  780088     MOV W8, W1
007BDC  780009     MOV W9, W0
007BDE  07FD5E     RCALL processData
78:                            temp = 8*idle/STREAMBUF;
007BE0  8080C0     MOV idle, W0
007BE2  DD0043     SL W0, #3, W0
007BE4  DE0046     LSR W0, #6, W0
79:                            cycle=temp;
007BE6  8880D0     MOV W0, cycle
80:                            idle=0;
007BE8  EF3018     CLR idle
81:                        }
82:                        if(t2flag==TRUE){
007BEA  BFD01E     MOV.B t2flag, WREG
007BEC  404FE1     ADD.B W0, #0x1, [W15]
007BEE  3A0003     BRA NZ, 0x7BF6
83:                            scanMatrix();                   //read button matrix
007BF0  07FC7B     RCALL scanMatrix
84:                            readPots();                     //read control pots
007BF2  07FC98     RCALL readPots
85:                            t2flag=FALSE;
007BF4  EF701E     CLR.B t2flag
86:                        }
87:                        if(t1flag==TRUE){
007BF6  BFD01D     MOV.B t1flag, WREG
007BF8  404FE1     ADD.B W0, #0x1, [W15]
007BFA  3A0002     BRA NZ, 0x7C00
88:                            display();
007BFC  07FD12     RCALL display
89:                            t1flag=FALSE; 
007BFE  EF701D     CLR.B t1flag
90:                        }
91:                        if(idle<0xFFFF) idle++; //999
007C00  8080C0     MOV idle, W0
007C02  400FE1     ADD W0, #0x1, [W15]
007C04  32FFE8     BRA Z, 0x7BD6
007C06  E80000     INC W0, W0
007C08  8880C0     MOV W0, idle
007C0A  37FFE5     BRA 0x7BD6
92:                    }
93:                    return 0;
94:                }
95:                // example test 
---  /home/fbuga/Documents/ps-040/devInits.c  -----------------------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 
5:                 #include <xc.h>
6:                 #include <p33EP512GM310.h>
7:                 #include <libpic30.h>
8:                 #include "common.h"
9:                 #include "devInits.h"
10:                #include "utilities.h"
11:                #include "plcd.h"
12:                
13:                extern unsigned char UART_ON;
14:                extern int txBufferA[STREAMBUF], txBufferB[STREAMBUF], rxBufferA[STREAMBUF], rxBufferB[STREAMBUF];  //doesnt work as fractional
15:                 
16:                //Description: Responsible i/o, clock, & RP pin config setup
17:                //Prereq: NONE
18:                //Dependencies: NONE
19:                //*Note: This is ALWAYS the first function called in main*
20:                void initPorts(void){
21:                    //CLOCK CONFIG
22:                    CLKDIVbits.PLLPOST=0;
0071F0  2FF3F0     MOV #0xFF3F, W0
0071F2  B62744     AND CLKDIV
23:                    CLKDIVbits.PLLPRE=0;
0071F4  2FFE00     MOV #0xFFE0, W0
0071F6  B62744     AND CLKDIV
24:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
0071F8  2FE000     MOV #0xFE00, W0
0071FA  B60746     AND PLLFBD, WREG
0071FC  B30490     IOR #0x49, W0
0071FE  883A30     MOV W0, PLLFBD
25:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
007200  200201     MOV #0x20, W1
007202  803A12     MOV OSCCON, W2
007204  608002     AND W1, W2, W0
007206  32FFFD     BRA Z, 0x7202
26:                    //RP pin config
27:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
007208  803A10     MOV OSCCON, W0
00720A  A16000     BCLR W0, #6
00720C  200461     MOV #0x46, W1
00720E  200572     MOV #0x57, W2
007210  207423     MOV #0x742, W3
007212  784981     MOV.B W1, [W3]
007214  784982     MOV.B W2, [W3]
007216  784980     MOV.B W0, [W3]
28:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
29:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
30:                    RPOR2bits.RP38R = 0x1;
007218  2FFC00     MOV #0xFFC0, W0
00721A  803424     MOV RPOR2, W4
00721C  600184     AND W0, W4, W3
00721E  A00003     BSET W3, #0
007220  883423     MOV W3, RPOR2
31:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
007222  2FF803     MOV #0xFF80, W3
007224  803685     MOV RPINR24, W5
007226  618205     AND W3, W5, W4
007228  B303D4     IOR #0x3D, W4
00722A  883684     MOV W4, RPINR24
32:                    RPOR3bits.RP40R=0x0C;       //DCI clock
00722C  B60686     AND RPOR3, WREG
00722E  B300C0     IOR #0xC, W0
007230  883430     MOV W0, RPOR3
33:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
007232  2C0FF0     MOV #0xC0FF, W0
007234  803424     MOV RPOR2, W4
007236  600284     AND W0, W4, W5
007238  20D004     MOV #0xD00, W4
00723A  720205     IOR W4, W5, W4
00723C  883424     MOV W4, RPOR2
34:                    RPOR3bits.RP41R=0x0B;       //DCI output
00723E  803434     MOV RPOR3, W4
007240  600284     AND W0, W4, W5
007242  20B004     MOV #0xB00, W4
007244  720205     IOR W4, W5, W4
007246  883434     MOV W4, RPOR3
35:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
007248  803575     MOV RPINR7, W5
00724A  618185     AND W3, W5, W3
00724C  B305F3     IOR #0x5F, W3
00724E  883573     MOV W3, RPINR7
36:                    RPINR29bits.SCK3R=0x39;      //SCK3 input on pin 84
007250  280FF4     MOV #0x80FF, W4
007252  8036D3     MOV RPINR29, W3
007254  620203     AND W4, W3, W4
007256  239003     MOV #0x3900, W3
007258  718184     IOR W3, W4, W3
00725A  8836D3     MOV W3, RPINR29
37:                    RPOR7bits.RP57R=0x20;        //SCK3 output on pin 84
00725C  803474     MOV RPOR7, W4
00725E  600184     AND W0, W4, W3
007260  A0D003     BSET W3, #13
007262  883473     MOV W3, RPOR7
38:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
007264  B60690     AND RPOR8, WREG
007266  21F003     MOV #0x1F00, W3
007268  718180     IOR W3, W0, W3
00726A  883483     MOV W3, RPOR8
39:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
00726C  803A10     MOV OSCCON, W0
00726E  A06000     BSET W0, #6
007270  207423     MOV #0x742, W3
007272  784981     MOV.B W1, [W3]
007274  784982     MOV.B W2, [W3]
007276  784980     MOV.B W0, [W3]
40:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
41:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
007278  EB8000     SETM W0
00727A  883B60     MOV W0, PMD7
00727C  F8076C     PUSH PMD7
00727E  F9076A     POP PMD6
007280  F8076A     PUSH PMD6
007282  F90766     POP PMD4
007284  F80766     PUSH PMD4
007286  F90764     POP PMD3
007288  F80764     PUSH PMD3
00728A  F90762     POP PMD2
00728C  F80762     PUSH PMD2
00728E  F90760     POP PMD1
42:                    PMD1bits.AD1MD=0;
007290  A90760     BCLR PMD1, #0
43:                    PMD1bits.SPI1MD=0;
007292  A96760     BCLR PMD1, #3
44:                    PMD1bits.SPI2MD=0;
007294  A98760     BCLR PMD1, #4
45:                    PMD1bits.U1MD=0;
007296  A9A760     BCLR PMD1, #5
46:                    PMD1bits.U2MD=0;
007298  A9C760     BCLR PMD1, #6
47:                    PMD1bits.DCIMD=0;
00729A  A90761     BCLR 0x761, #0
48:                    PMD1bits.T1MD=0;
00729C  A96761     BCLR 0x761, #3
49:                    PMD1bits.T2MD=0;
00729E  A98761     BCLR 0x761, #4
50:                    PMD1bits.T3MD=0;
0072A0  A9A761     BCLR 0x761, #5
51:                    PMD1bits.T4MD=0;
0072A2  A9C761     BCLR 0x761, #6
52:                    PMD3bits.PMPMD=0;
0072A4  A90765     BCLR 0x765, #0
53:                    PMD3bits.CMPMD=0;
0072A6  A94765     BCLR 0x765, #2
54:                    PMD6bits.SPI3MD=0;
0072A8  A9076A     BCLR PMD6, #0
55:                    PMD7bits.DMA0MD=0;
0072AA  A9876C     BCLR PMD7, #4
56:                    
57:                    /* ANALOG PINS (1 = analog) */
58:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
0072AC  EF2E6E     CLR ANSELG
0072AE  F80E6E     PUSH ANSELG
0072B0  F90E5E     POP ANSELF
0072B2  F80E5E     PUSH ANSELF
0072B4  F90E4E     POP ANSELE
0072B6  F80E4E     PUSH ANSELE
0072B8  F90E3E     POP ANSELD
0072BA  F80E3E     PUSH ANSELD
0072BC  F90E2E     POP ANSELC
0072BE  F80E2E     PUSH ANSELC
0072C0  F90E1E     POP ANSELB
0072C2  F80E1E     PUSH ANSELB
0072C4  F90E0E     POP ANSELA
59:                    ANSELBbits.ANSB0 = 1; // Ensure AN0/RB0 is analog
0072C6  A80E1E     BSET ANSELB, #0
60:                    ANSELBbits.ANSB1 = 1; // Ensure AN1/RB1 is analog
0072C8  A82E1E     BSET ANSELB, #1
61:                    ANSELBbits.ANSB2 = 1; // Ensure AN2/RB2 is analog
0072CA  A84E1E     BSET ANSELB, #2
62:                    ANSELBbits.ANSB3 = 1; // Ensure AN5/RB5 is analog
0072CC  A86E1E     BSET ANSELB, #3
63:                    
64:                    /* IO DIRECTION (1 = input) */
65:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
0072CE  EF2E60     CLR TRISG
0072D0  F80E60     PUSH TRISG
0072D2  F90E50     POP TRISF
0072D4  F80E50     PUSH TRISF
0072D6  F90E40     POP TRISE
0072D8  F80E40     PUSH TRISE
0072DA  F90E30     POP TRISD
0072DC  F80E30     PUSH TRISD
0072DE  F90E20     POP TRISC
0072E0  F80E20     PUSH TRISC
0072E2  F90E10     POP TRISB
0072E4  F80E10     PUSH TRISB
0072E6  F90E00     POP TRISA
66:                    TRISA=0x0603;
0072E8  206031     MOV #0x603, W1
0072EA  887001     MOV W1, TRISA
67:                    TRISB=0x0003;
0072EC  200031     MOV #0x3, W1
0072EE  887081     MOV W1, TRISB
68:                    TRISC=0x2080;
0072F0  220801     MOV #0x2080, W1
0072F2  887101     MOV W1, TRISC
69:                    TRISE=0x7000;
0072F4  270001     MOV #0x7000, W1
0072F6  887201     MOV W1, TRISE
70:                    TRISG=0xFFFF;   //PORTG all inputs
0072F8  887300     MOV W0, TRISG
71:                    
72:                    /* DIGITAL OUTPUT LATCH */
73:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
0072FA  EF2E64     CLR LATG
0072FC  F80E64     PUSH LATG
0072FE  F90E54     POP LATF
007300  F80E54     PUSH LATF
007302  F90E44     POP LATE
007304  F80E44     PUSH LATE
007306  F90E34     POP LATD
007308  F80E34     PUSH LATD
00730A  F90E24     POP LATC
00730C  F80E24     PUSH LATC
00730E  F90E14     POP LATB
007310  F80E14     PUSH LATB
007312  F90E04     POP LATA
74:                    LATA=0x0040;
007314  200401     MOV #0x40, W1
007316  887021     MOV W1, LATA
75:                    
76:                    //weak internal pull ups
77:                    CNPUG=0xFFFF;       //weak pull ups on all of G
007318  887350     MOV W0, CNPUG
78:                }
00731A  060000     RETURN
79:                
80:                //Description: Initializes UART1 device & interrupts
81:                //Prereq: NONE
82:                //Dependencies: NONE
83:                void initUART1(void){
84:                    IFS0bits.U1TXIF = 0;        //clear flag
00731C  A98801     BCLR 0x801, #4
85:                    IFS0bits.U1RXIF = 0;        //clear flag
00731E  A96801     BCLR 0x801, #3
86:                    U1STA=0x1510;               //enable tx & rx
007320  215100     MOV #0x1510, W0
007322  881110     MOV W0, U1STA
87:                    U1BRG=BRGVAL;               //baud rate
007324  2004A0     MOV #0x4A, W0
007326  881140     MOV W0, U1BRG
88:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
007328  2FFF90     MOV #0xFFF9, W0
00732A  B60220     AND U1MODE, WREG
00732C  A01000     BSET W0, #1
00732E  881100     MOV W0, U1MODE
89:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
007330  270000     MOV #0x7000, W0
007332  B72844     IOR IPC2
90:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
007334  200070     MOV #0x7, W0
007336  B72846     IOR IPC3
91:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
92:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
93:                    U1MODEbits.UARTEN = 1;      //start uart
007338  A8E221     BSET 0x221, #7
94:                    UART_ON = TRUE;
00733A  EFF01F     SETM.B UART_ON
95:                    
96:                }
00733C  060000     RETURN
97:                
98:                //Description: Initializes onboard ADC 
99:                //Prereq: NONE
100:               //Dependencies: NONE
101:               void initADC1(void){
102:                   AD1CON1bits.ASAM = 1;       //enable simultaneous sample
00733E  A84320     BSET AD1CON1, #2
103:                   AD1CON1bits.SIMSAM = 0;     //enable simultaneous sample
007340  A96320     BCLR AD1CON1, #3
104:                   AD1CON1bits.FORM=2;         //signed fractional format
007342  2FCFF0     MOV #0xFCFF, W0
007344  801902     MOV AD1CON1, W2
007346  600082     AND W0, W2, W1
007348  A09001     BSET W1, #9
00734A  881901     MOV W1, AD1CON1
105:                   AD1CON2bits.CHPS = 0b01;    //sample channels 0-3
00734C  B60322     AND AD1CON2, WREG
00734E  A08000     BSET W0, #8
007350  881910     MOV W0, AD1CON2
106:                   AD1CON3bits.ADCS = 0x3F;    //tad ~ 1us
007352  B3C3F0     MOV.B #0x3F, W0
007354  B7E324     MOV.B WREG, AD1CON3
107:                   //AD1CHS0bits.CH0SA = 0x03;   //ch0->an3 (no use an0)
108:                   AD1CHS0bits.CH0NA = 0; // Select Vref- for CH0 -ve input
007356  A9E328     BCLR AD1CHS0, #7
109:                   AD1CHS123bits.CH123NA = 0; // Select Vref- for CH1/CH2/CH3 -ve input
007358  2FFF90     MOV #0xFFF9, W0
00735A  B62326     AND AD1CHS123
110:                   AD1CON1bits.ADON = 1;       //start ADC module
00735C  A8E321     BSET 0x321, #7
111:                   Delay_us(20);
00735E  200140     MOV #0x14, W0
007360  0701C1     RCALL Delay_us
112:               }
007362  060000     RETURN
113:               
114:               void initPMP(void){
115:                   /*
116:                    Data is clocked on falling edge of E
117:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
118:                    *  E = 81 = PMWR (pulse width 450ns MIN, data triggers from H to L) 
119:                    */
120:                   PMMODEbits.MODE=3;  //master mode 1 
007364  203000     MOV #0x300, W0
007366  B72602     IOR PMMODE
121:                   PMCONbits.PTWREN = 1;
007368  A82601     BSET 0x601, #1
122:                   PMCONbits.PTRDEN = 1;
00736A  A80601     BSET 0x601, #0
123:                   PMCONbits.WRSP=1;   //write strobe active high
00736C  A82600     BSET PMCON, #1
124:                   PMCONbits.RDSP=1;   //read strobe active high
00736E  A80600     BSET PMCON, #0
125:                   PMMODEbits.WAITB = 3;
007370  200C00     MOV #0xC0, W0
007372  B72602     IOR PMMODE
126:                   PMMODEbits.WAITM = 0x08;
007374  2FFC33     MOV #0xFFC3, W3
007376  803010     MOV PMMODE, W0
007378  618080     AND W3, W0, W1
00737A  A05001     BSET W1, #5
00737C  883011     MOV W1, PMMODE
127:                   PMMODEbits.WAITE = 3;
00737E  200030     MOV #0x3, W0
007380  B72602     IOR PMMODE
128:                   PMMODEbits.WAITB = 0;
007382  2FF3F1     MOV #0xFF3F, W1
007384  206022     MOV #0x602, W2
007386  608912     AND W1, [W2], [W2]
129:                   PMMODEbits.WAITM = 0xC;
007388  803011     MOV PMMODE, W1
00738A  618001     AND W3, W1, W0
00738C  B30300     IOR #0x30, W0
00738E  883010     MOV W0, PMMODE
130:                   PMMODEbits.WAITE = 0;
007390  2FFFC0     MOV #0xFFFC, W0
007392  B62602     AND PMMODE
131:                   LCD_RS=0;
007394  A9EE45     BCLR 0xE45, #7
132:                   PMCONbits.PMPEN = 1;
007396  A8E601     BSET 0x601, #7
133:                   
134:                   
135:                   /* INIT DEVICE */
136:                   Delay_us(40000);
007398  29C400     MOV #0x9C40, W0
00739A  0701A4     RCALL Delay_us
137:                   lcdInit();
00739C  07023C     RCALL lcdInit
138:                   
139:                   /* SETUP SCREEN */
140:                   lcdSetupPots();
00739E  0701F8     RCALL lcdSetupPots
141:               }
0073A0  060000     RETURN
142:               
143:               
144:               //Description: Initializes timer for LED's UART and display
145:               //Prereq: initUART1()
146:               //Dependencies: _T1Interrupt(void)
147:               //Frequency: 15Hz
148:               void initT1(void){          //16 bit timer
149:                   TMR1 = 0x0000;          //clear timer 4
0073A2  EF2100     CLR TMR1
150:                   T1CONbits.TCKPS = 3;    //prescale 1:256
0073A4  200300     MOV #0x30, W0
0073A6  B72104     IOR T1CON
151:                   T1CONbits.TCS = 0;      //use internal clock
0073A8  A92104     BCLR T1CON, #1
152:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
0073AA  A9C104     BCLR T1CON, #6
153:                   PR1 = Fcy/(256*Fdisp);    //period register
0073AC  223280     MOV #0x2328, W0
0073AE  880810     MOV W0, PR1
154:                   //PR1=0x7FFF;
155:                   IFS0bits.T1IF = 0;      //clear timer 1 interrupt flag
0073B0  A96800     BCLR IFS0, #3
156:                   IEC0bits.T1IE = 1;      //enable timer 1 interrupt
0073B2  A86820     BSET IEC0, #3
157:                   IPC0bits.T1IP = 2;      //interrupt priority 2 (low)
0073B4  28FFF0     MOV #0x8FFF, W0
0073B6  B60840     AND IPC0, WREG
0073B8  A0D000     BSET W0, #13
0073BA  884200     MOV W0, IPC0
158:                   T1CONbits.TON = 1;      //start timer
0073BC  A8E105     BSET 0x105, #7
159:               }
0073BE  060000     RETURN
160:               
161:               //Description:  Initializes timer handles polling button input
162:               //Prereq: initADC1() 
163:               //Dependencies: _T2Interrupt(void)
164:               //Frequency: 512Hz
165:               void initT2(void){          //16/32 bit timer
166:                   TMR2 = 0x0000;          //clear timer 4
0073C0  EF2106     CLR TMR2
167:                   T2CONbits.T32 = 0;      //16 bit mode
0073C2  A96110     BCLR T2CON, #3
168:                   T2CONbits.TCKPS = 1;    //prescale 1:8
0073C4  2FFCF0     MOV #0xFFCF, W0
0073C6  B60110     AND T2CON, WREG
0073C8  A04000     BSET W0, #4
0073CA  880880     MOV W0, T2CON
169:                   T2CONbits.TCS = 0;      //use internal clock
0073CC  A92110     BCLR T2CON, #1
170:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
0073CE  A9C110     BCLR T2CON, #6
171:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
0073D0  241EB0     MOV #0x41EB, W0
0073D2  880860     MOV W0, PR2
172:                   IFS0bits.T2IF = 0;      //clear timer 2 interrupt flag
0073D4  A9E800     BCLR IFS0, #7
173:                   IEC0bits.T2IE = 1;      //enable timer 2 interrupt
0073D6  A8E820     BSET IEC0, #7
174:                   IPC1bits.T2IP = 2;      //interrupt priority 2 (low)
0073D8  28FFF0     MOV #0x8FFF, W0
0073DA  B60842     AND IPC1, WREG
0073DC  A0D000     BSET W0, #13
0073DE  884210     MOV W0, IPC1
175:                   T2CONbits.TON = 1;      //start timer
0073E0  A8E111     BSET 0x111, #7
176:               }
0073E2  060000     RETURN
177:               
178:               //Description: Initialize timer handling ADC sampling
179:               //Prereq: initSPI_ADC()
180:               //Dependencies: _T3Interrupt(void)
181:               //Frequency: 44.1kHz
182:               //*Note: Currently unused as readDac is chained to DCI interrupt*
183:               void initT3(void){          //16/32 bit timer
184:                   TMR3 = 0x0000;          //clear timer 3
0073E4  EF210A     CLR TMR3
185:                   T3CONbits.TCKPS = 3;    //prescale 256:1
0073E6  200300     MOV #0x30, W0
0073E8  B72112     IOR T3CON
186:                   T3CONbits.TCS = 0;      //use internal clock
0073EA  A92112     BCLR T3CON, #1
187:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
0073EC  A9C112     BCLR T3CON, #6
188:                   PR3 = Fcy/(256*T3freq);           //period register
0073EE  200060     MOV #0x6, W0
0073F0  880870     MOV W0, PR3
189:                   //PR3 = 0xFFFF;
190:                   IFS0bits.T3IF = 0;      //clear timer 3 interrupt flag
0073F2  A90801     BCLR 0x801, #0
191:                   IEC0bits.T3IE = 1;      //enable timer 3 interrupt
0073F4  A80821     BSET 0x821, #0
192:                   IPC2bits.T3IP = 2;      //interrupt priority 3 (low)
0073F6  2FFF80     MOV #0xFFF8, W0
0073F8  B60844     AND IPC2, WREG
0073FA  A01000     BSET W0, #1
0073FC  884220     MOV W0, IPC2
193:                   T3CONbits.TON = 1;      //start timer
0073FE  A8E113     BSET 0x113, #7
194:               }
007400  060000     RETURN
195:               
196:               //Description: Initializes & starts 16 bit DCI I2S DAC
197:               //Prereq: initSPI_ADC(void)
198:               //Dependencies: readDAC(void)
199:               void initDCI_DAC(void){
200:                   DCICON1bits.CSCKD=0;
007402  A94281     BCLR 0x281, #2
201:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
007404  2F0000     MOV #0xF000, W0
007406  B60284     AND DCICON3, WREG
007408  B30170     IOR #0x17, W0
00740A  881420     MOV W0, DCICON3
202:                   DCICON1bits.COFSM=1;    //i2s mode
00740C  2FFFC0     MOV #0xFFFC, W0
00740E  B60280     AND DCICON1, WREG
007410  A00000     BSET W0, #0
007412  881400     MOV W0, DCICON1
203:                   DCICON1bits.CSCKE=1;    //sample on rising edge
007414  A82281     BSET 0x281, #1
204:                   DCICON2bits.WS=0xF;     //16 bit data word
007416  2000F0     MOV #0xF, W0
007418  B72282     IOR DCICON2
205:                   DCICON2bits.COFSG=0;    //data frame has 1 words
00741A  2FE1F0     MOV #0xFE1F, W0
00741C  B62282     AND DCICON2
206:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
00741E  A80288     BSET TSCON, #0
207:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
007420  A82288     BSET TSCON, #1
208:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
007422  A8028C     BSET RSCON, #0
209:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
007424  A8228C     BSET RSCON, #1
210:                   DCICON1bits.DJST=0;     //align data
007426  A9A280     BCLR DCICON1, #5
211:                   DCICON2bits.BLEN=1;     //2 words buffer btwn interrupts
007428  2F3FF0     MOV #0xF3FF, W0
00742A  B60282     AND DCICON2, WREG
00742C  A0A000     BSET W0, #10
00742E  881410     MOV W0, DCICON2
212:                   IPC15bits.DCIIP = 6;    // Interrput priority
007430  2FFF80     MOV #0xFFF8, W0
007432  B6085E     AND IPC15, WREG
007434  B30060     IOR #0x6, W0
007436  8842F0     MOV W0, IPC15
213:                   IFS3bits.DCIIF=0;
007438  A98807     BCLR 0x807, #4
214:                   IEC3bits.DCIIE=1;       //=0 to let dma handle interrupt
00743A  A88827     BSET 0x827, #4
215:                   TXBUF0=0;
00743C  EF2298     CLR TXBUF0
216:                   TXBUF1=0;   
00743E  EF229A     CLR TXBUF1
217:                   DCICON1bits.DCIEN=1;    //ENABLE
007440  A8E281     BSET 0x281, #7
218:               }
007442  060000     RETURN
219:               
220:               void initDMA0(void){
221:                   unsigned long address;
222:                   
223:                   /*
224:                   DMA0CONbits.AMODE = 2; // Configure DMA for Peripheral indirect mode
225:                   DMA0CONbits.MODE = 0; // Configure DMA for Continuous no Ping-Pong mode
226:                   DMA0PAD =  0X0608; // Point DMA to PMP
227:                   DMA0CNT = 2; //2 // 3 DMA request (3 buffers, each with 1 words)
228:                   DMA0REQ = 13; // Select ADC1 as DMA Request source
229:                   //DMA0STA = __builtin_dmaoffset(&BufferA);
230:                   //DMA0STB = __builtin_dmaoffset(&BufferB);
231:                   IFS0bits.DMA0IF = 0; //Clear the DMA interrupt flag bit
232:                   IEC0bits.DMA0IE = 1; //Set the DMA interrupt enable bit
233:                   DMA0CONbits.CHEN=1; // Enable DMA
234:                   */
235:                   
236:                   DMA0CONbits.SIZE = 0; /* Word transfers*/
007444  A9CB01     BCLR 0xB01, #6
237:                   DMA0CONbits.DIR = 1; /* From RAM to DCI*/
007446  A8AB01     BSET 0xB01, #5
238:                   DMA0CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
007448  2FFCF4     MOV #0xFFCF, W4
00744A  20B000     MOV #0xB00, W0
00744C  620810     AND W4, [W0], [W0]
239:                   DMA0CONbits.MODE = 2; /* Continuous ping pong mode enabled*/
00744E  2FFFC3     MOV #0xFFFC, W3
007450  805801     MOV DMA0CON, W1
007452  618001     AND W3, W1, W0
007454  A01000     BSET W0, #1
007456  885800     MOV W0, DMA0CON
240:                   DMA0CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
007458  A98B01     BCLR 0xB01, #4
241:                   DMA0CONbits.NULLW = 0;
00745A  A96B01     BCLR 0xB01, #3
242:                   DMA0REQbits.FORCE = 0; /* Automatic transfer*/
00745C  A9EB03     BCLR 0xB03, #7
243:                   DMA0REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
00745E  B3C3C2     MOV.B #0x3C, W2
007460  20B025     MOV #0xB02, W5
007462  784A82     MOV.B W2, [W5]
244:                   address =__builtin_edsoffset(txBufferA) & 0x7FFF;
007464  27FFF0     MOV #0x7FFF, W0
007466  2CF801     MOV #0xCF80, W1
007468  608080     AND W1, W0, W1
245:                   address +=__builtin_edspage(txBufferA) << 15;
00746A  200016     MOV #0x1, W6
00746C  DD334F     SL W6, #15, W6
00746E  EB0380     CLR W7
007470  408306     ADD W1, W6, W6
007472  4B83E0     ADDC W7, #0x0, W7
246:                   DMA0STAL = address & 0xFFFF;
007474  885826     MOV W6, DMA0STAL
247:                   DMA0STAH = address >>16;
007476  885837     MOV W7, DMA0STAH
248:                   address =__builtin_edsoffset(txBufferB) & 0x7FFF;
007478  2CF001     MOV #0xCF00, W1
00747A  608080     AND W1, W0, W1
249:                   address +=__builtin_edspage(txBufferB) << 15;
00747C  200016     MOV #0x1, W6
00747E  DD334F     SL W6, #15, W6
007480  EB0380     CLR W7
007482  408306     ADD W1, W6, W6
007484  4B83E0     ADDC W7, #0x0, W7
250:                   DMA0STBL = address & 0xFFFF;
007486  885846     MOV W6, DMA0STBL
251:                   DMA0STBH = address >>16;
007488  885857     MOV W7, DMA0STBH
252:                   DMA0PAD = (int)&TXBUF0;
00748A  202981     MOV #0x298, W1
00748C  885861     MOV W1, DMA0PAD
253:                   DMA0CNT = STREAMBUF-1;
00748E  2003F1     MOV #0x3F, W1
007490  885871     MOV W1, DMA0CNT
254:                   /* DMA 2 - DCI to DPSRAM*/
255:                   DMA2CONbits.SIZE = 0; /* Word transfers*/
007492  A9CB21     BCLR 0xB21, #6
256:                   DMA2CONbits.DIR = 0; /* From DCI to DPSRAM */
007494  A9AB21     BCLR 0xB21, #5
257:                   DMA2CONbits.HALF = 0; /* Interrupt when all the data has been moved*/
007496  A98B21     BCLR 0xB21, #4
258:                   DMA2CONbits.NULLW = 0; /* No NULL writes - Normal Operation*/
007498  A96B21     BCLR 0xB21, #3
259:                   DMA2CONbits.AMODE = 0; /* Register Indirect with post-increment mode*/
00749A  20B205     MOV #0xB20, W5
00749C  620A95     AND W4, [W5], [W5]
260:                   DMA2CONbits.MODE = 2; /* Continuous mode ping pong mode enabled*/
00749E  805904     MOV DMA2CON, W4
0074A0  618184     AND W3, W4, W3
0074A2  A01003     BSET W3, #1
0074A4  885903     MOV W3, DMA2CON
261:                   DMA2REQbits.FORCE = 0; /* Automatic transfer*/
0074A6  A9EB23     BCLR 0xB23, #7
262:                   DMA2REQbits.IRQSEL = 0x3C;/* Codec transfer done*/
0074A8  784182     MOV.B W2, W3
0074AA  20B225     MOV #0xB22, W5
0074AC  784A83     MOV.B W3, [W5]
263:                   address =__builtin_edsoffset(rxBufferA) & 0x7FFF;
0074AE  2CE804     MOV #0xCE80, W4
0074B0  620200     AND W4, W0, W4
264:                   address +=__builtin_edspage(rxBufferA) << 15;
0074B2  200012     MOV #0x1, W2
0074B4  DD114F     SL W2, #15, W2
0074B6  EB0180     CLR W3
0074B8  420102     ADD W4, W2, W2
0074BA  4981E0     ADDC W3, #0x0, W3
265:                   DMA2STAL = address & 0xFFFF;
0074BC  885922     MOV W2, DMA2STAL
266:                   DMA2STAH = address >>16;
0074BE  885933     MOV W3, DMA2STAH
267:                   address =__builtin_edsoffset(rxBufferB) & 0x7FFF;
0074C0  2CE002     MOV #0xCE00, W2
0074C2  610000     AND W2, W0, W0
268:                   address +=__builtin_edspage(rxBufferB) << 15;
0074C4  200012     MOV #0x1, W2
0074C6  DD114F     SL W2, #15, W2
0074C8  EB0180     CLR W3
0074CA  400102     ADD W0, W2, W2
0074CC  4981E0     ADDC W3, #0x0, W3
269:                   DMA2STBL = address & 0xFFFF;
0074CE  885942     MOV W2, DMA2STBL
270:                   DMA2STBH = address >>16;
0074D0  885953     MOV W3, DMA2STBH
271:                   DMA2PAD = (int)&RXBUF0;
0074D2  202900     MOV #0x290, W0
0074D4  885960     MOV W0, DMA2PAD
272:                   DMA2CNT = STREAMBUF-1;
0074D6  885971     MOV W1, DMA2CNT
273:                   _DMA2IP = 5;
0074D8  2FFF80     MOV #0xFFF8, W0
0074DA  B6084C     AND IPC6, WREG
0074DC  B30050     IOR #0x5, W0
0074DE  884260     MOV W0, IPC6
274:                   _DMA2IE = 1;
0074E0  A80823     BSET 0x823, #0
275:                   DMA0CONbits.CHEN = 1; /* Enable the channel*/
0074E2  A8EB01     BSET 0xB01, #7
276:                   DMA2CONbits.CHEN = 1;
0074E4  A8EB21     BSET 0xB21, #7
277:               }
0074E6  060000     RETURN
278:               
279:               /*
280:               void initCAP_BPM(void){
281:                   IFS0bits.IC1IF=0;
282:                   IPC0bits.IC1IP=3;
283:                   IC1CON1bits.ICTSEL=0;   //Fp is clock source (7))
284:                   IC1CON1bits.ICM=2;      //capture every falling edge
285:                   IC1CON2bits.ICTRIG=1;
286:                   IC1CON2bits.SYNCSEL=0xD;
287:                   IEC0bits.IC1IE=1;
288:               }
289:               
290:               //Description: Initializes 16 bit SPI ADC 
291:               //Prereq: NONE
292:               //Dependencies: NONE
293:               void initSPI2_ADC(void){
294:                   //ADC_CONV=1;                 //prevent shift as per errata
295:                   PORTBbits.RB10=1;           //prevent shift as per errata
296:                   IFS2bits.SPI2IF = 0;        // Clear the Interrupt flag
297:                   IEC2bits.SPI2IE = 0;        // Disable the interrupt
298:                   SPI2CON1bits.MSTEN=1;       //master mode
299:                   SPI2CON1bits.DISSCK = 0;    //Internal serial clock is enabled
300:                   SPI2CON1bits.MODE16=1;      //16 bit
301:                   SPI2CON1bits.DISSDO=1;      //no SDO 
302:                   SPI2CON1bits.SSEN=0;        //no use SS
303:                   SPI2CON2bits.FRMEN=0;       //no enable framed mode
304:                   SPI2CON2bits.SPIBEN=1;      //enhanced buffer mode
305:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
306:                   SPI2CON1bits.SMP=1;         //data sampled at end of output time
307:                   SPI2CON1bits.CKP=1;         //idle clock is high
308:                   SPI2CON1bits.CKE=1;         //data changes from H to L
309:                   SPI2CON1bits.PPRE=2;        //4:1 primary prescale
310:                   SPI2CON1bits.SPRE=0;        //8:1 secondary
311:                   SPI2STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
312:                   IPC8bits.SPI2IP = 5;        // Interrupt priority
313:                   IFS2bits.SPI2IF = 0;        // Clear the Interrupt flag
314:                   IEC2bits.SPI2IE = 1;        // Enable the interrupt
315:                   SPI2STATbits.SPIEN = 1;     //start SPI module
316:               }
317:               
318:               void initSPI3_SEG(void){
319:                   SEG_SEL = 1;
320:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
321:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
322:                   SPI3CON1bits.MSTEN=1;       //master mode
323:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
324:                   SPI3CON1bits.MODE16=1;      //16 bit
325:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
326:                   SPI3CON1bits.SSEN=0;        //use SS
327:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
328:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
329:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
330:                   SPI3CON1bits.SMP=0;         //data sampled at end of output time
331:                   SPI3CON1bits.CKP=0;         //idle clock is low
332:                   SPI3CON1bits.CKE=1;         //data changes from H to L
333:                   SPI3CON1bits.PPRE=1;        //4:1 primary prescale
334:                   SPI3CON1bits.SPRE=7;        //1:1 secondary
335:                   SPI3STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
336:                   IPC22bits.SPI3IP = 3;        // Interrupt priority
337:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
338:                   IEC5bits.SPI3IE = 0;        // Enable the interrupt
339:                   SPI3STATbits.SPIEN = 1;     //start SPI module
340:                   __delay32(40);
341:                   MAX7219_Init();
342:               }
343:               */
344:               
---  /home/fbuga/Documents/ps-040/audio.c  --------------------------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[8];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[4];
7:                 extern fractional pots_scaled[4];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                fractional mixer(fractional sample){
0078C4  F80022     PUSH ACCA
0078C6  F80024     PUSH ACCAH
0078C8  F80026     PUSH ACCAU
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    
38:                    if(pad[0]==0&&kick_playing==FALSE){                                         //kick
0078CA  266701     MOV #0x6670, W1
0078CC  784091     MOV.B [W1], W1
0078CE  E00401     CP0.B W1
0078D0  3A0006     BRA NZ, 0x78DE
0078D2  E25036     CP0.B kick_playing
0078D4  3A0004     BRA NZ, 0x78DE
39:                        kick_playing=TRUE;
0078D6  EBC100     SETM.B W2
0078D8  210363     MOV #0x1036, W3
0078DA  784982     MOV.B W2, [W3]
0078DC  370004     BRA 0x78E6
40:                    }
41:                    if(kick_playing==TRUE&&kick_ptr<kick_max){
0078DE  210362     MOV #0x1036, W2
0078E0  784112     MOV.B [W2], W2
0078E2  414FE1     ADD.B W2, #0x1, [W15]
0078E4  3A0011     BRA NZ, 0x7908
0078E6  874CD3     MOV 0xE99A, W3
0078E8  8081C5     MOV kick_ptr, W5
0078EA  528F83     SUB W5, W3, [W15]
0078EC  31000D     BRA C, 0x7908
42:                        result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
0078EE  780200     MOV W0, W4
0078F0  273325     MOV #0x7332, W5
0078F2  C00113     MPY W4*W5, A
43:                        result1 = __builtin_add(result1,kick[kick_ptr++],0);
0078F4  8081C0     MOV kick_ptr, W0
0078F6  400080     ADD W0, W0, W1
0078F8  292DA2     MOV #0x92DA, W2
0078FA  410081     ADD W2, W1, W1
0078FC  780091     MOV [W1], W1
0078FE  E80000     INC W0, W0
007900  8881C0     MOV W0, kick_ptr
007902  C90001     ADD W1, A
44:                        sample=__builtin_sac(result1, 0);
007904  CC0000     SAC A, W0
007906  37000A     BRA 0x791C
45:                    }
46:                    else if (pad[0]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
007908  50CFE1     SUB.B W1, #0x1, [W15]
00790A  3A0008     BRA NZ, 0x791C
00790C  414FE1     ADD.B W2, #0x1, [W15]
00790E  3A0006     BRA NZ, 0x791C
007910  874CD1     MOV 0xE99A, W1
007912  8081C2     MOV kick_ptr, W2
007914  510F81     SUB W2, W1, [W15]
007916  3A0002     BRA NZ, 0x791C
47:                        kick_playing=FALSE;
007918  EF7036     CLR.B kick_playing
48:                        kick_ptr=0;
00791A  EF3038     CLR kick_ptr
49:                    }
50:                    
51:                    /*
52:                    if(pad[2]==0&&hat_playing==FALSE){                                          //hat
53:                        hat_playing=TRUE;
54:                    }
55:                    if(hat_playing==TRUE&&hat_ptr<hat_max){
56:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
57:                        result1 = __builtin_add(result1,hat[hat_ptr++],0);
58:                        sample=__builtin_sac(result1, 0);
59:                    }
60:                    else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
61:                        hat_playing=FALSE;
62:                        hat_ptr=0;
63:                    }
64:                    */
65:                    if(pad[2]==0&&snare_playing==FALSE){                                        //snare
00791C  266721     MOV #0x6672, W1
00791E  784091     MOV.B [W1], W1
007920  E00401     CP0.B W1
007922  3A0006     BRA NZ, 0x7930
007924  E2503A     CP0.B snare_playing
007926  3A0004     BRA NZ, 0x7930
66:                        snare_playing=TRUE;
007928  EBC100     SETM.B W2
00792A  2103A3     MOV #0x103A, W3
00792C  784982     MOV.B W2, [W3]
00792E  370004     BRA 0x7938
67:                    }
68:                    if(snare_playing==TRUE&&snare_ptr<snare_max){
007930  2103A2     MOV #0x103A, W2
007932  784112     MOV.B [W2], W2
007934  414FE1     ADD.B W2, #0x1, [W15]
007936  3A0011     BRA NZ, 0x795A
007938  874CE3     MOV 0xE99C, W3
00793A  8081E5     MOV snare_ptr, W5
00793C  528F83     SUB W5, W3, [W15]
00793E  31000D     BRA C, 0x795A
69:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
007940  780200     MOV W0, W4
007942  26CCC5     MOV #0x6CCC, W5
007944  C00113     MPY W4*W5, A
70:                        result1 = __builtin_add(result1,snare[snare_ptr++],0);
007946  8081E0     MOV snare_ptr, W0
007948  400080     ADD W0, W0, W1
00794A  2BE3A2     MOV #0xBE3A, W2
00794C  410081     ADD W2, W1, W1
00794E  780091     MOV [W1], W1
007950  E80000     INC W0, W0
007952  8881E0     MOV W0, snare_ptr
007954  C90001     ADD W1, A
71:                        sample=__builtin_sac(result1, 0);
007956  CC0000     SAC A, W0
007958  37000A     BRA 0x796E
72:                    }
73:                    else if (pad[2]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
00795A  50CFE1     SUB.B W1, #0x1, [W15]
00795C  3A0008     BRA NZ, 0x796E
00795E  414FE1     ADD.B W2, #0x1, [W15]
007960  3A0006     BRA NZ, 0x796E
007962  874CE1     MOV 0xE99C, W1
007964  8081E2     MOV snare_ptr, W2
007966  510F81     SUB W2, W1, [W15]
007968  3A0002     BRA NZ, 0x796E
74:                        snare_playing=FALSE;
00796A  EF703A     CLR.B snare_playing
75:                        snare_ptr=0;
00796C  EF303C     CLR snare_ptr
76:                    }
77:                    
78:                    
79:                    //VOLUME CONTROL
80:                    /*
81:                    if(pots[0]==0x001F)
82:                        sample=0;
83:                    else if(pots[0]>0xFFF0);
84:                    else{
85:                        result1 =__builtin_mpy(sample,pots[0], NULL, NULL, 0, NULL, NULL, 0);
86:                        sample=__builtin_sac(result1, 0);
87:                    }
88:                    */
89:                    if (TEST_SIN==FALSE){
00796E  E25020     CP0.B TEST_SIN
007970  32000B     BRA Z, 0x7988
90:                        return sample;
91:                    }
92:                    else {
93:                        i++;
007972  EC1034     INC i, WREG
007974  8881A0     MOV W0, i
94:                        if(i==1024)
007976  204001     MOV #0x400, W1
007978  500F81     SUB W0, W1, [W15]
00797A  3A0001     BRA NZ, 0x797E
95:                            i=0;
00797C  EF3034     CLR i
96:                        return sintab[i];
00797E  8081A0     MOV i, W0
007980  400000     ADD W0, W0, W0
007982  2E99E1     MOV #0xE99E, W1
007984  408000     ADD W1, W0, W0
007986  780010     MOV [W0], W0
97:                    }
98:                }
007988  F90026     POP ACCAU
00798A  F90024     POP ACCAH
00798C  F90022     POP ACCA
00798E  060000     RETURN
99:                
100:               fractional fx(fractional sample){
007990  F80022     PUSH ACCA
007992  F80024     PUSH ACCAH
007994  F80026     PUSH ACCAU
007996  F80028     PUSH ACCB
007998  F8002A     PUSH ACCBH
00799A  F8002C     PUSH ACCBU
101:                   volatile register int result1 asm("A");
102:                   volatile register int result2 asm("B");
103:                   static fractional delayed_sample;
104:                   static fractional trem_mod;
105:                   if(tremelo==TRUE){                                                          //TREMELO//
00799C  210211     MOV #0x1021, W1
00799E  784091     MOV.B [W1], W1
0079A0  40CFE1     ADD.B W1, #0x1, [W15]
0079A2  3A0027     BRA NZ, 0x79F2
106:                       if (trem_var<=pots_scaled[1]){
0079A4  808161     MOV trem_var, W1
0079A6  808052     MOV 0x100A, W2
0079A8  510F81     SUB W2, W1, [W15]
0079AA  39000F     BRA NC, 0x79CA
107:                           trem_var++;
0079AC  E80081     INC W1, W1
0079AE  888161     MOV W1, trem_var
108:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
0079B0  808141     MOV tremelo_ptr, W1
0079B2  408081     ADD W1, W1, W1
0079B4  2E99E2     MOV #0xE99E, W2
0079B6  410081     ADD W2, W1, W1
0079B8  780291     MOV [W1], W5
0079BA  808244     MOV 0x1048, W4
0079BC  C00113     MPY W4*W5, A
109:                           trem_mod=__builtin_sac(result1, 0);
0079BE  CC0004     SAC A, W4
0079C0  888184     MOV W4, trem_mod
110:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
0079C2  780280     MOV W0, W5
0079C4  C08113     MPY W4*W5, B
111:                           sample=__builtin_sac(result2, 0);
0079C6  CC8000     SAC B, W0
0079C8  370014     BRA 0x79F2
112:                       }
113:                       else{
114:                           trem_var=0;
0079CA  EF302C     CLR trem_var
115:                           if(tremelo_ptr==1024)
0079CC  204001     MOV #0x400, W1
0079CE  808142     MOV tremelo_ptr, W2
0079D0  510F81     SUB W2, W1, [W15]
0079D2  3A0001     BRA NZ, 0x79D6
116:                               tremelo_ptr=0;
0079D4  EF3028     CLR tremelo_ptr
117:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
0079D6  808141     MOV tremelo_ptr, W1
0079D8  408101     ADD W1, W1, W2
0079DA  2E99E3     MOV #0xE99E, W3
0079DC  418102     ADD W3, W2, W2
0079DE  780292     MOV [W2], W5
0079E0  E80081     INC W1, W1
0079E2  888141     MOV W1, tremelo_ptr
0079E4  808244     MOV 0x1048, W4
0079E6  C00113     MPY W4*W5, A
118:                           trem_mod=__builtin_sac(result1, 0);
0079E8  CC0004     SAC A, W4
0079EA  888184     MOV W4, trem_mod
119:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
0079EC  780280     MOV W0, W5
0079EE  C08113     MPY W4*W5, B
120:                           sample=__builtin_sac(result2, 0);
0079F0  CC8000     SAC B, W0
121:                       }
122:                   }
123:                   
124:                   if(looper==TRUE){                                                           //LOOPER// 
0079F2  210221     MOV #0x1022, W1
0079F4  784091     MOV.B [W1], W1
0079F6  40CFE1     ADD.B W1, #0x1, [W15]
0079F8  3A0019     BRA NZ, 0x7A2C
125:                       if(loop_lim>=LOOP_BUF_SIZE)
0079FA  22B100     MOV #0x2B10, W0
0079FC  E31026     CP loop_lim
0079FE  360002     BRA LEU, 0x7A04
126:                           loop_lim=LOOP_BUF_SIZE;
007A00  E80000     INC W0, W0
007A02  888130     MOV W0, loop_lim
127:                       if(loop_ptr<loop_lim){
007A04  808130     MOV loop_lim, W0
007A06  E31024     CP loop_ptr
007A08  310008     BRA C, 0x7A1A
128:                           sample = (loop[loop_ptr++]);
007A0A  808121     MOV loop_ptr, W1
007A0C  408001     ADD W1, W1, W0
007A0E  2104E2     MOV #0x104E, W2
007A10  410000     ADD W2, W0, W0
007A12  780010     MOV [W0], W0
007A14  E80081     INC W1, W1
007A16  888121     MOV W1, loop_ptr
007A18  37001D     BRA 0x7A54
129:                       }
130:                       else {
131:                           loop_ptr=0;
007A1A  EF3024     CLR loop_ptr
132:                           sample = (loop[loop_ptr++]);
007A1C  808121     MOV loop_ptr, W1
007A1E  408001     ADD W1, W1, W0
007A20  2104E2     MOV #0x104E, W2
007A22  410000     ADD W2, W0, W0
007A24  780010     MOV [W0], W0
007A26  E80081     INC W1, W1
007A28  888121     MOV W1, loop_ptr
007A2A  370014     BRA 0x7A54
133:                       }
134:                   }                                                                           
135:                   else {                                                                      //buffer
136:                       if(loop_ptr<LOOP_BUF_SIZE)
007A2C  22B101     MOV #0x2B10, W1
007A2E  808122     MOV loop_ptr, W2
007A30  510F81     SUB W2, W1, [W15]
007A32  3E0008     BRA GTU, 0x7A44
137:                           loop[loop_ptr++]=sample;
007A34  808121     MOV loop_ptr, W1
007A36  408101     ADD W1, W1, W2
007A38  2104E3     MOV #0x104E, W3
007A3A  418102     ADD W3, W2, W2
007A3C  780900     MOV W0, [W2]
007A3E  E80081     INC W1, W1
007A40  888121     MOV W1, loop_ptr
007A42  370008     BRA 0x7A54
138:                       else {
139:                           loop_ptr=0;
007A44  EF3024     CLR loop_ptr
140:                           loop[loop_ptr++]=sample;
007A46  808121     MOV loop_ptr, W1
007A48  408101     ADD W1, W1, W2
007A4A  2104E3     MOV #0x104E, W3
007A4C  418102     ADD W3, W2, W2
007A4E  780900     MOV W0, [W2]
007A50  E80081     INC W1, W1
007A52  888121     MOV W1, loop_ptr
141:                       }
142:                   }
143:                   
144:                                                                                               //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
145:                   if(lpf==TRUE){
007A54  210231     MOV #0x1023, W1
007A56  784091     MOV.B [W1], W1
007A58  40CFE1     ADD.B W1, #0x1, [W15]
007A5A  3A0008     BRA NZ, 0x7A6C
146:                       result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
007A5C  808224     MOV 0x1044, W4
007A5E  780280     MOV W0, W5
007A60  C08113     MPY W4*W5, B
147:                       result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
007A62  808234     MOV 0x1046, W4
007A64  808195     MOV delayed_sample, W5
007A66  C08112     MAC W4*W5, B
148:                       delayed_sample=__builtin_sac(result2, 0);
007A68  CC8000     SAC B, W0
007A6A  888190     MOV W0, delayed_sample
149:                       sample=delayed_sample;
150:                   }
151:                   return sample;
152:               }
007A6C  F9002C     POP ACCBU
007A6E  F9002A     POP ACCBH
007A70  F90028     POP ACCB
007A72  F90026     POP ACCAU
007A74  F90024     POP ACCAH
007A76  F90022     POP ACCA
007A78  060000     RETURN
153:               
154:               //test
