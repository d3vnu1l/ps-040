Disassembly Listing for sampler_0.49.2
Generated From:
/home/fbuga/Documents/ps-040/dist/default/production/ps-040.production.elf
Jan 13, 2018 6:29:36 PM

---  /home/fbuga/Documents/ps-040/utilitites.c  ---------------------------------------------------------
1:                 #include "utilities.h"
2:                 #include <xc.h>
3:                 #include <p33EP512GM310.h>
4:                 #include <libpic30.h>
5:                 #include <dsp.h>
6:                 #include <stdio.h>
7:                 #include <stdlib.h>
8:                 #include <math.h>
9:                 #include "common.h"
10:                #include "sounds.h"
11:                #include "audio.h"
12:                #include "plcd.h"
13:                
14:                
15:                //CONTROL VARIABLES//
16:                extern char pad[8];
17:                extern fractional pots[4];
18:                extern fractional pots_scaled[4];
19:                extern unsigned char UART_ON;
20:                
21:                //STATUS VARIABLES//
22:                extern unsigned char hard_clipped;
23:                extern unsigned char UART_EN;
24:                
25:                extern fractional sample;
26:                
27:                //FX FLAGS & VARS
28:                extern unsigned char tremelo, looper, lpf;
29:                extern unsigned int tremelo_ptr, tremelo_length, trem_var;
30:                extern unsigned int loop_lim;
31:                extern fractional lpf_alpha, lpf_inv_alpha;
32:                extern fractional tremelo_depth;
33:                
34:                void scanMatrix(void){
35:                    static unsigned char pad_last[8] = {1,1,1,1,1,1,1,1};
36:                    
37:                    pad[0]=p0;
007418  807311     MOV PORTG, W1
00741A  DE08CE     LSR W1, #14, W1
00741C  2666A0     MOV #0x666A, W0
00741E  60C861     AND.B W1, #0x1, [W0]
38:                    pad[1]=p1;
007420  807311     MOV PORTG, W1
007422  DE08CA     LSR W1, #10, W1
007424  E80000     INC W0, W0
007426  60C861     AND.B W1, #0x1, [W0]
39:                    pad[2]=p2;
007428  807311     MOV PORTG, W1
00742A  D10081     LSR W1, W1
00742C  E80000     INC W0, W0
00742E  60C861     AND.B W1, #0x1, [W0]
40:                    pad[3]=p3;
007430  807311     MOV PORTG, W1
007432  E80000     INC W0, W0
007434  60C861     AND.B W1, #0x1, [W0]
41:                    pad[4]=p4;
007436  807311     MOV PORTG, W1
007438  DE08CC     LSR W1, #12, W1
00743A  E80000     INC W0, W0
00743C  60C861     AND.B W1, #0x1, [W0]
42:                    pad[5]=p5;
00743E  807311     MOV PORTG, W1
007440  DE08C3     LSR W1, #3, W1
007442  E80000     INC W0, W0
007444  60C861     AND.B W1, #0x1, [W0]
43:                    pad[6]=p6;
007446  807311     MOV PORTG, W1
007448  DE08CB     LSR W1, #11, W1
00744A  E80000     INC W0, W0
00744C  60C861     AND.B W1, #0x1, [W0]
44:                    pad[7]=p7;
00744E  807310     MOV PORTG, W0
007450  DE004D     LSR W0, #13, W0
007452  604061     AND.B W0, #0x1, W0
007454  266711     MOV #0x6671, W1
007456  784880     MOV.B W0, [W1]
45:                    
46:                    if(pad[7]==0&&pad_last[7]==1){                                              //TREMELO CONTROL
007458  3A0013     BRA NZ, 0x7480
00745A  26B3D1     MOV #0x6B3D, W1
00745C  B3C012     MOV.B #0x1, W2
00745E  114F91     SUBR.B W2, [W1], [W15]
007460  3A000F     BRA NZ, 0x7480
47:                        pad_last[7]=0;
007462  780001     MOV W1, W0
007464  EB4800     CLR.B [W0]
48:                        if(tremelo==FALSE)
007466  E2501D     CP0.B tremelo
007468  3A0002     BRA NZ, 0x746E
49:                            tremelo=TRUE;
00746A  EFF01D     SETM.B tremelo
00746C  370001     BRA 0x7470
50:                        else tremelo=FALSE;
00746E  EF701D     CLR.B tremelo
51:                        TREMELO_LED=tremelo;
007470  BFD01D     MOV.B tremelo, WREG
007472  DD004F     SL W0, #15, W0
007474  27FFF1     MOV #0x7FFF, W1
007476  8071A2     MOV LATD, W2
007478  608082     AND W1, W2, W1
00747A  700081     IOR W0, W1, W1
00747C  8871A1     MOV W1, LATD
00747E  370002     BRA 0x7484
52:                    }
53:                    else{
54:                        pad_last[7]=pad[7];
007480  26B3D1     MOV #0x6B3D, W1
007482  784880     MOV.B W0, [W1]
55:                    }
56:                    
57:                    if(pad[4]==0){                                                              //LOOPER CONTROL
007484  2666E0     MOV #0x666E, W0
007486  E00410     CP0.B [W0]
007488  3A0003     BRA NZ, 0x7490
58:                        looper=TRUE;
00748A  EFF01E     SETM.B looper
59:                        YLED=looper;
00748C  A82E44     BSET LATE, #1
00748E  370002     BRA 0x7494
60:                    }
61:                    else {
62:                        looper=FALSE;
007490  EF701E     CLR.B looper
63:                        YLED=looper;
007492  A92E44     BCLR LATE, #1
64:                    }
65:                   
66:                    if(pad[0]==0&&pad_last[0]==1){                                              //LPF CONTROL
007494  2666A0     MOV #0x666A, W0
007496  784010     MOV.B [W0], W0
007498  E00400     CP0.B W0
00749A  3A0013     BRA NZ, 0x74C2
00749C  26B361     MOV #0x6B36, W1
00749E  B3C012     MOV.B #0x1, W2
0074A0  114F91     SUBR.B W2, [W1], [W15]
0074A2  3A000F     BRA NZ, 0x74C2
67:                        pad_last[0]=0;
0074A4  780001     MOV W1, W0
0074A6  EB4800     CLR.B [W0]
68:                        if(lpf==FALSE)
0074A8  E2501F     CP0.B lpf
0074AA  3A0002     BRA NZ, 0x74B0
69:                            lpf=TRUE;
0074AC  EFF01F     SETM.B lpf
0074AE  370001     BRA 0x74B2
70:                        else lpf=FALSE;
0074B0  EF701F     CLR.B lpf
71:                        GLED=lpf;
0074B2  BFD01F     MOV.B lpf, WREG
0074B4  600061     AND W0, #0x1, W0
0074B6  DD0044     SL W0, #4, W0
0074B8  807121     MOV LATC, W1
0074BA  A14001     BCLR W1, #4
0074BC  700081     IOR W0, W1, W1
0074BE  887121     MOV W1, LATC
0074C0  370002     BRA 0x74C6
72:                    }
73:                    else{
74:                        pad_last[0]=pad[0];
0074C2  26B361     MOV #0x6B36, W1
0074C4  784880     MOV.B W0, [W1]
75:                    }
76:                    
77:                    //lpf=TRUE;
78:                    
79:                    
80:                }
0074C6  060000     RETURN
81:                
82:                void readPots(void){
83:                    volatile register int scaled asm("A");
84:                    
85:                    AD1CON1bits.SAMP = 0;      // start sampling
0074C8  A92320     BCLR AD1CON1, #1
86:                    while (!_AD1IF);           //wait for conversions to complete
0074CA  220001     MOV #0x2000, W1
0074CC  804002     MOV IFS0, W2
0074CE  608002     AND W1, W2, W0
0074D0  32FFFD     BRA Z, 0x74CC
87:                    _AD1IF = 0;                //clear status bit
0074D2  A9A801     BCLR 0x801, #5
88:                    pots[0]=(ADC1BUF0>>1)+0x1F;
0074D4  210000     MOV #0x1000, W0
0074D6  801801     MOV ADC1BUF0, W1
0074D8  D10081     LSR W1, W1
0074DA  40887F     ADD W1, #0x1F, [W0]
89:                    pots[1]=(ADC1BUF1>>1)+0x1F;
0074DC  801811     MOV ADC1BUF1, W1
0074DE  D10081     LSR W1, W1
0074E0  4080FF     ADD W1, #0x1F, W1
0074E2  980011     MOV W1, [W0+2]
90:                    pots[2]=(ADC1BUF2>>1)+0x1F;
0074E4  801822     MOV ADC1BUF2, W2
0074E6  D10102     LSR W2, W2
0074E8  41017F     ADD W2, #0x1F, W2
0074EA  980022     MOV W2, [W0+4]
91:                    pots[3]=(ADC1BUF3>>1)+0x1F;
0074EC  801832     MOV ADC1BUF3, W2
0074EE  D10102     LSR W2, W2
0074F0  41017F     ADD W2, #0x1F, W2
0074F2  980032     MOV W2, [W0+6]
92:                    //pot scaling 
93:                    
94:                    if(pots[1]<=2048)
0074F4  208000     MOV #0x800, W0
0074F6  508F80     SUB W1, W0, [W15]
0074F8  3C0003     BRA GT, 0x7500
95:                        pots_scaled[1]=8;
0074FA  200080     MOV #0x8, W0
0074FC  888050     MOV W0, 0x100A
0074FE  370056     BRA 0x75AC
96:                    else if(pots[1]<=4096)
007500  210000     MOV #0x1000, W0
007502  508F80     SUB W1, W0, [W15]
007504  3C0003     BRA GT, 0x750C
97:                        pots_scaled[1]=12;
007506  2000C0     MOV #0xC, W0
007508  888050     MOV W0, 0x100A
00750A  370050     BRA 0x75AC
98:                    else if(pots[1]<=6144)
00750C  218000     MOV #0x1800, W0
00750E  508F80     SUB W1, W0, [W15]
007510  3C0003     BRA GT, 0x7518
99:                        pots_scaled[1]=14;
007512  2000E0     MOV #0xE, W0
007514  888050     MOV W0, 0x100A
007516  37004A     BRA 0x75AC
100:                   else if(pots[1]<=8192)
007518  220000     MOV #0x2000, W0
00751A  508F80     SUB W1, W0, [W15]
00751C  3C0003     BRA GT, 0x7524
101:                       pots_scaled[1]=16;
00751E  200100     MOV #0x10, W0
007520  888050     MOV W0, 0x100A
007522  370044     BRA 0x75AC
102:                   else if(pots[1]<=10240)
007524  228000     MOV #0x2800, W0
007526  508F80     SUB W1, W0, [W15]
007528  3C0003     BRA GT, 0x7530
103:                       pots_scaled[1]=19;
00752A  200130     MOV #0x13, W0
00752C  888050     MOV W0, 0x100A
00752E  37003E     BRA 0x75AC
104:                   else if(pots[1]<=12288)
007530  230000     MOV #0x3000, W0
007532  508F80     SUB W1, W0, [W15]
007534  3C0003     BRA GT, 0x753C
105:                       pots_scaled[1]=23;
007536  200170     MOV #0x17, W0
007538  888050     MOV W0, 0x100A
00753A  370038     BRA 0x75AC
106:                   else if(pots[1]<=14336)
00753C  238000     MOV #0x3800, W0
00753E  508F80     SUB W1, W0, [W15]
007540  3C0003     BRA GT, 0x7548
107:                       pots_scaled[1]=28;
007542  2001C0     MOV #0x1C, W0
007544  888050     MOV W0, 0x100A
007546  370032     BRA 0x75AC
108:                   else if(pots[1]<=16384)
007548  240000     MOV #0x4000, W0
00754A  508F80     SUB W1, W0, [W15]
00754C  3C0003     BRA GT, 0x7554
109:                       pots_scaled[1]=32;
00754E  200200     MOV #0x20, W0
007550  888050     MOV W0, 0x100A
007552  37002C     BRA 0x75AC
110:                   else if(pots[1]<=18432)
007554  248000     MOV #0x4800, W0
007556  508F80     SUB W1, W0, [W15]
007558  3C0003     BRA GT, 0x7560
111:                       pots_scaled[1]=36;
00755A  200240     MOV #0x24, W0
00755C  888050     MOV W0, 0x100A
00755E  370026     BRA 0x75AC
112:                   else if(pots[1]<=20480)
007560  250000     MOV #0x5000, W0
007562  508F80     SUB W1, W0, [W15]
007564  3C0003     BRA GT, 0x756C
113:                       pots_scaled[2]=40;
007566  200280     MOV #0x28, W0
007568  888060     MOV W0, 0x100C
00756A  370020     BRA 0x75AC
114:                   else if(pots[1]<=22528)
00756C  258000     MOV #0x5800, W0
00756E  508F80     SUB W1, W0, [W15]
007570  3C0003     BRA GT, 0x7578
115:                       pots_scaled[2]=44;
007572  2002C0     MOV #0x2C, W0
007574  888060     MOV W0, 0x100C
007576  37001A     BRA 0x75AC
116:                   else if(pots[1]<=24576)
007578  260000     MOV #0x6000, W0
00757A  508F80     SUB W1, W0, [W15]
00757C  3C0003     BRA GT, 0x7584
117:                       pots_scaled[1]=48;
00757E  200300     MOV #0x30, W0
007580  888050     MOV W0, 0x100A
007582  370014     BRA 0x75AC
118:                   else if(pots[1]<=26624)
007584  268000     MOV #0x6800, W0
007586  508F80     SUB W1, W0, [W15]
007588  3C0003     BRA GT, 0x7590
119:                       pots_scaled[1]=52;
00758A  200340     MOV #0x34, W0
00758C  888050     MOV W0, 0x100A
00758E  37000E     BRA 0x75AC
120:                   else if(pots[1]<=28672)
007590  270000     MOV #0x7000, W0
007592  508F80     SUB W1, W0, [W15]
007594  3C0003     BRA GT, 0x759C
121:                       pots_scaled[1]=56;
007596  200380     MOV #0x38, W0
007598  888050     MOV W0, 0x100A
00759A  370008     BRA 0x75AC
122:                   else if(pots[1]<=30720)
00759C  278000     MOV #0x7800, W0
00759E  508F80     SUB W1, W0, [W15]
0075A0  3C0003     BRA GT, 0x75A8
123:                       pots_scaled[1]=60;
0075A2  2003C0     MOV #0x3C, W0
0075A4  888050     MOV W0, 0x100A
0075A6  370002     BRA 0x75AC
124:                   else if(pots[1]<=32768)
125:                       pots_scaled[1]=64;
0075A8  200400     MOV #0x40, W0
0075AA  888050     MOV W0, 0x100A
126:                   else if(pots[1]<=34816)
127:                       pots_scaled[1]=68;
128:                   else 
129:                       pots_scaled[1]=72;
130:                    
131:                                                                                                
132:                   loop_lim=154*pots_scaled[1];                                                //LOOPER CONTROL
0075AC  2009A0     MOV #0x9A, W0
0075AE  808051     MOV 0x100A, W1
0075B0  B98880     MULW.SS W1, W0, W0
0075B2  888110     MOV W0, loop_lim
133:                   if(pots[1]>=310){                                                           //LPF CONTROL
0075B4  808010     MOV 0x1002, W0
0075B6  201351     MOV #0x135, W1
0075B8  500F81     SUB W0, W1, [W15]
0075BA  340004     BRA LE, 0x75C4
134:                       lpf_alpha=pots[1];
0075BC  8881D0     MOV W0, 0x103A
135:                       lpf_inv_alpha=(32767-lpf_alpha); 
0075BE  27FFF1     MOV #0x7FFF, W1
0075C0  508000     SUB W1, W0, W0
0075C2  8881E0     MOV W0, 0x103C
136:                   }
137:                   //tremelo_depth=pots[4];
138:                           
139:               }
0075C4  060000     RETURN
140:               
141:               void display(void){
142:                   
143:                  //lcdWrite(0xFF);
144:                  PMDIN1=0xFF;
0075C6  200FF0     MOV #0xFF, W0
0075C8  883040     MOV W0, PMDIN1
145:                   
146:                  if(hard_clipped==TRUE){                                                     //CLIP CONTROL    
0075CA  BFD018     MOV.B hard_clipped, WREG
0075CC  404FE1     ADD.B W0, #0x1, [W15]
0075CE  3A0003     BRA NZ, 0x75D6
147:                       HARD_CLIP_LED=1;
0075D0  A82E24     BSET LATC, #1
148:                       hard_clipped=FALSE;
0075D2  EF7018     CLR.B hard_clipped
0075D4  370001     BRA 0x75D8
149:                   }  else HARD_CLIP_LED=0;
0075D6  A92E24     BCLR LATC, #1
150:                   
151:                  if(UART_ON==TRUE){
0075D8  BFD01B     MOV.B UART_ON, WREG
0075DA  404FE1     ADD.B W0, #0x1, [W15]
0075DC  3A000A     BRA NZ, 0x75F2
152:                       //IC1CON2bits.TRIGSTAT = ~pad[4]; 
153:                       //printf("b1 %d, b2 %d, b3 %d, b4 %d\r\n", pad[0], pad[1], pad[2], pad[3]);
154:                       //printf("b4 %d, b5 %d, b6 %d, b7 %d\r\n", pad[4], pad[5], pad[6], pad[7]);
155:                       //printf("P1 %x  P1 %d bpm %d\r\n", pots[0], pots[0], bpm);   //check pots
156:                       printf("P1 %d  P2 %d P3 %d\r\n", pots[0], pots[1], pots[2]);   //check pots
0075DE  210000     MOV #0x1000, W0
0075E0  9000A0     MOV [W0+4], W1
0075E2  781F81     MOV W1, [W15++]
0075E4  900090     MOV [W0+2], W1
0075E6  781F81     MOV W1, [W15++]
0075E8  781F90     MOV [W0], [W15++]
0075EA  2F1A80     MOV #0xF1A8, W0
0075EC  781F80     MOV W0, [W15++]
0075EE  07C790     RCALL __printf_cdnopuxX
0075F0  5787E8     SUB W15, #0x8, W15
157:                       //printf("%d\r\n", sample);  //check input ADC
158:                       //printf("%d, pot1 %x, pot2 %x, avg %x\r\n", sample, pots[1], pots[2], average);  //check input ADC
159:                   }
160:                  
161:                  SLED=~SLED;
0075F2  8072A0     MOV LATF, W0
0075F4  EA8000     COM W0, W0
0075F6  600061     AND W0, #0x1, W0
0075F8  8072A1     MOV LATF, W1
0075FA  A10001     BCLR W1, #0
0075FC  700081     IOR W0, W1, W1
0075FE  8872A1     MOV W1, LATF
162:               }
007600  060000     RETURN
---  /home/fbuga/Documents/ps-040/routines.c  -----------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <stdio.h>
5:                 #include "common.h"
6:                 #include "audio.h"
7:                 //#include "utilities.h"
8:                 //CONTROL VARIABLES//
9:                 extern char pad[8];
10:                extern fractional pots[4]; 
11:                extern fractional stream[2][STREAMBUF];
12:                extern fractional output;
13:                extern unsigned int write_ptr, rw;
14:                
15:                //STATUS VARIABLES
16:                extern unsigned char hard_clipped;
17:                extern unsigned char recording;
18:                extern const int sintab[1024];
19:                extern unsigned char t1flag, t2flag;
20:                
21:                //FX FLAGS
22:                extern unsigned char tremelo, looper;
23:                
24:                //misc.
25:                volatile fractional sample=0;
26:                
27:                //Description: This interrupt toggles status led, runs UART1 and handles display
28:                //Dependencies: initUART1();
29:                //Frequency: 60
30:                void __attribute__ ((interrupt, auto_psv)) _T1Interrupt(void){
000306  F80032     PUSH DSRPAG
000308  F80034     PUSH DSWPAG
00030A  781F88     MOV W8, [W15++]
00030C  200018     MOV #0x1, W8
00030E  8801A8     MOV W8, DSWPAG
000310  202008     MOV #0x200, W8
000312  880198     MOV W8, DSRPAG
000314  000000     NOP
000316  78044F     MOV [--W15], W8
31:                    t1flag=TRUE;
000318  EFF019     SETM.B t1flag
32:                    IFS0bits.T1IF = 0;              //clear interrupt flag & restart
00031A  A96800     BCLR IFS0, #3
33:                }
00031C  F90034     POP DSWPAG
00031E  F90032     POP DSRPAG
000320  064000     RETFIE
34:                
35:                //Description: This interrupt handles polling button input
36:                //Dependencies: initADC1(); 
37:                //Frequency: 512Hz
38:                void __attribute__ ((interrupt, auto_psv)) _T2Interrupt(void){
000322  F80032     PUSH DSRPAG
000324  F80034     PUSH DSWPAG
000326  781F88     MOV W8, [W15++]
000328  200018     MOV #0x1, W8
00032A  8801A8     MOV W8, DSWPAG
00032C  202008     MOV #0x200, W8
00032E  880198     MOV W8, DSRPAG
000330  000000     NOP
000332  78044F     MOV [--W15], W8
39:                    t2flag=TRUE;
000334  EFF01A     SETM.B t2flag
40:                    IFS0bits.T2IF = 0;              //clear interrupt flag & restart
000336  A9E800     BCLR IFS0, #7
41:                }
000338  F90034     POP DSWPAG
00033A  F90032     POP DSRPAG
00033C  064000     RETFIE
42:                
43:                //Description: This interrupt triggers at the completion of DCI output
44:                //Dependancies: initSPI2(); 
45:                void __attribute__ ((interrupt, auto_psv)) _DCIInterrupt(void){
00033E  F80036     PUSH RCOUNT
000340  BE9F80     MOV.D W0, [W15++]
000342  BE9F82     MOV.D W2, [W15++]
000344  BE9F84     MOV.D W4, [W15++]
000346  BE9F86     MOV.D W6, [W15++]
000348  781F88     MOV W8, [W15++]
00034A  F80032     PUSH DSRPAG
00034C  F80034     PUSH DSWPAG
00034E  200010     MOV #0x1, W0
000350  8801A0     MOV W0, DSWPAG
000352  202000     MOV #0x200, W0
000354  880190     MOV W0, DSRPAG
000356  000000     NOP
46:                    TXBUF0=output;                                    //output buffered sample to DAC
000358  808080     MOV output, W0
00035A  8814C0     MOV W0, TXBUF0
47:                    TXBUF1=output;
00035C  8814D0     MOV W0, TXBUF1
48:                    sample=RXBUF1;
00035E  F80292     PUSH RXBUF1
000360  F91044     POP sample
49:                    int trash=RXBUF0;
000362  801480     MOV RXBUF0, W0
50:                    __builtin_btg(&sample, 15);                             //convert to Q1.15 compatible format
000364  210440     MOV #0x1044, W0
000366  A2F010     BTG [W0], #15
51:                    if(sample<=-32766||sample>=32766)
000368  27FFD0     MOV #0x7FFD, W0
00036A  B41044     ADD sample, WREG
00036C  400FE6     ADD W0, #0x6, [W15]
00036E  360001     BRA LEU, 0x372
52:                        hard_clipped=TRUE;
000370  EFF018     SETM.B hard_clipped
53:                    if(write_ptr==(STREAMBUF-1)){                       //reset pointer when out of bounds
000372  8080A0     MOV write_ptr, W0
000374  200FF1     MOV #0xFF, W1
000376  500F81     SUB W0, W1, [W15]
000378  3A0003     BRA NZ, 0x380
54:                        write_ptr=0;
00037A  EF3014     CLR write_ptr
55:                        __builtin_btg(&rw,0);
00037C  AA1016     BTG rw, #0
00037E  370002     BRA 0x384
56:                    }
57:                    else write_ptr++;
000380  E80000     INC W0, W0
000382  8880A0     MOV W0, write_ptr
58:                    if(recording==TRUE){
000384  BFD042     MOV.B 0x1042, WREG
000386  404FE1     ADD.B W0, #0x1, [W15]
000388  3A0009     BRA NZ, 0x39C
59:                        stream[rw][write_ptr]=sample;                 //get output
00038A  8080B0     MOV rw, W0
00038C  DD0048     SL W0, #8, W0
00038E  8080A1     MOV write_ptr, W1
000390  400001     ADD W0, W1, W0
000392  400000     ADD W0, W0, W0
000394  266721     MOV #0x6672, W1
000396  408000     ADD W1, W0, W0
000398  808221     MOV sample, W1
00039A  780801     MOV W1, [W0]
60:                    }
61:                    stream[rw][write_ptr]=fx(stream[rw][write_ptr]);    //run fx on latest sample
00039C  8080B8     MOV rw, W8
00039E  DD4448     SL W8, #8, W8
0003A0  8080A0     MOV write_ptr, W0
0003A2  440400     ADD W8, W0, W8
0003A4  440408     ADD W8, W8, W8
0003A6  266720     MOV #0x6672, W0
0003A8  400408     ADD W0, W8, W8
0003AA  780018     MOV [W8], W0
0003AC  073990     RCALL fx
0003AE  780C00     MOV W0, [W8]
62:                    if(rw==0)
0003B0  E21016     CP0 rw
0003B2  3A0009     BRA NZ, 0x3C6
63:                        output=mixer(stream[1][write_ptr]);             //mix  new output
0003B4  8080A0     MOV write_ptr, W0
0003B6  B01000     ADD #0x100, W0
0003B8  400000     ADD W0, W0, W0
0003BA  266721     MOV #0x6672, W1
0003BC  408000     ADD W1, W0, W0
0003BE  780010     MOV [W0], W0
0003C0  073920     RCALL mixer
0003C2  888080     MOV W0, output
0003C4  370007     BRA 0x3D4
64:                    else output = mixer(stream[0][write_ptr]);
0003C6  8080A0     MOV write_ptr, W0
0003C8  400000     ADD W0, W0, W0
0003CA  266721     MOV #0x6672, W1
0003CC  408000     ADD W1, W0, W0
0003CE  780010     MOV [W0], W0
0003D0  073918     RCALL mixer
0003D2  888080     MOV W0, output
65:                    IFS3bits.DCIIF=0;
0003D4  A98807     BCLR 0x807, #4
66:                }
0003D6  F90034     POP DSWPAG
0003D8  F90032     POP DSRPAG
0003DA  78044F     MOV [--W15], W8
0003DC  BE034F     MOV.D [--W15], W6
0003DE  BE024F     MOV.D [--W15], W4
0003E0  BE014F     MOV.D [--W15], W2
0003E2  BE004F     MOV.D [--W15], W0
0003E4  F90036     POP RCOUNT
0003E6  064000     RETFIE
67:                
68:                void __attribute__ ((interrupt, auto_psv)) _IC1Interrupt(void){
0003E8  BE9F80     MOV.D W0, [W15++]
0003EA  F80032     PUSH DSRPAG
0003EC  F80034     PUSH DSWPAG
0003EE  200010     MOV #0x1, W0
0003F0  8801A0     MOV W0, DSWPAG
0003F2  202000     MOV #0x200, W0
0003F4  880190     MOV W0, DSRPAG
0003F6  000000     NOP
69:                    IFS0bits.IC1IF=0;   
0003F8  A92800     BCLR IFS0, #1
70:                    //bpm=IC1BUF;
71:                    RLED=~RLED;
0003FA  807120     MOV LATC, W0
0003FC  EA8000     COM W0, W0
0003FE  600061     AND W0, #0x1, W0
000400  807121     MOV LATC, W1
000402  A10001     BCLR W1, #0
000404  700081     IOR W0, W1, W1
000406  887121     MOV W1, LATC
72:                }
000408  F90034     POP DSWPAG
00040A  F90032     POP DSRPAG
00040C  BE004F     MOV.D [--W15], W0
00040E  064000     RETFIE
73:                
74:                void __attribute__ ((interrupt, auto_psv)) _SPI3Interrupt(void){
000410  781F80     MOV W0, [W15++]
000412  F80032     PUSH DSRPAG
000414  F80034     PUSH DSWPAG
000416  200010     MOV #0x1, W0
000418  8801A0     MOV W0, DSWPAG
00041A  202000     MOV #0x200, W0
00041C  880190     MOV W0, DSRPAG
00041E  000000     NOP
75:                    //SEG_SEL=1;
76:                    int trash=SPI3BUF;
000420  801540     MOV SPI3BUF, W0
77:                    SPI3STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
000422  A9C2A0     BCLR SPI3STAT, #6
78:                    IFS5bits.SPI3IF=0;
000424  A9680B     BCLR 0x80B, #3
79:                    
80:                }
000426  F90034     POP DSWPAG
000428  F90032     POP DSRPAG
00042A  78004F     MOV [--W15], W0
00042C  064000     RETFIE
81:                
82:                /*
83:                //Description: This interrupt handles polling button input
84:                //Dependencies: initADC1(); 
85:                //Frequency: 44.1kHz
86:                void __attribute__ ((interrupt, auto_psv)) _T3Interrupt(void){
87:                    SEG_SEL=0;
88:                    SPI3BUF=0x0100;
89:                    //SEG_SEL=1;
90:                    IFS0bits.T3IF = 0;              //clear flag, restart
91:                }
92:                
93:                void __attribute__ ((interrupt, auto_psv)) _SPI2Interrupt(void){
94:                    //GLED=~GLED;                                             //check half freq w/ RLED                                        //returns SS2 to idle state
95:                    SPI2STATbits.SPIROV = 0;                                //Clear SPI1 receive overflow flag if set
96:                    IFS2bits.SPI2IF = 0;                                    //reset flag & restart
97:                }
98:                //Description: This interrupt handles UART reception
99:                //Dependencies: initUART1();
100:               void __attribute__ ((interrupt, auto_psv)) _U1RXInterrupt(void){
101:                   unsigned char trash;
102:                   GLED=~GLED;
103:                   trash=U1RXREG;
104:                   printf("RECIEVED: %d\r\n", trash);
105:                   IFS0bits.U1RXIF = 0;            //clear flag, restart
106:               }
107:               
108:               //Description: This interrupt handles UART transmission
109:               //Dependencies: initUART1();
110:               void __attribute__ ((interrupt, auto_psv)) _U1TXInterrupt(void){
111:                   YLED=~YLED;
112:                   IFS0bits.U1TXIF = 0;            //clear flag, restart
113:               } 
114:                */
---  /home/fbuga/Documents/ps-040/plcd.c  ---------------------------------------------------------------
1:                 /*
2:                  * File:   plcd.c
3:                  * Author: root
4:                  *
5:                  * Created on January 10, 2018, 4:48 PM
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                unsigned int statusReg = 0x0C;  //internal copy of pwr reg
11:                                                // 0b_0 0 0 0_1 D C B (display, cursor, blink)
12:                
13:                void lcdWrite(unsigned int data){
14:                    if(!PMMODEbits.BUSY) PMDIN1=data; //(!skips if busy!)
0078C4  E20602     CP0 PMMODE
0078C6  350001     BRA LT, 0x78CA
0078C8  883040     MOV W0, PMDIN1
15:                }
0078CA  060000     RETURN
16:                
17:                void lcdClear(void){
18:                    lcdWrite(0x01);
0078CC  200010     MOV #0x1, W0
0078CE  07FFFA     RCALL lcdWrite
19:                }
0078D0  060000     RETURN
20:                
21:                void lcdReturn(void){
22:                    lcdWrite(0x02);
0078D2  200020     MOV #0x2, W0
0078D4  07FFF7     RCALL lcdWrite
23:                }
0078D6  060000     RETURN
24:                
25:                
26:                void lcdPwr(signed int pwr){
27:                    //lcd soft power on/off, does not reset device
28:                    if(pwr)
0078D8  E00000     CP0 W0
0078DA  320003     BRA Z, 0x78E2
29:                        statusReg&=0x04;
0078DC  200040     MOV #0x4, W0
0078DE  B63046     AND 0x1046
0078E0  370001     BRA 0x78E4
30:                    else __builtin_btg(&statusReg, 2);
0078E2  AA5046     BTG 0x1046, #2
31:                    
32:                    lcdWrite(statusReg);
0078E4  808230     MOV 0x1046, W0
0078E6  07FFEE     RCALL lcdWrite
33:                }
0078E8  060000     RETURN
34:                
35:                void lcdCursorEn(signed int pwr){
36:                    //cursor on / off
37:                    if(pwr)
0078EA  E00000     CP0 W0
0078EC  320003     BRA Z, 0x78F4
38:                        statusReg&=0x0A;
0078EE  2000A0     MOV #0xA, W0
0078F0  B63046     AND 0x1046
0078F2  370001     BRA 0x78F6
39:                    else __builtin_btg(&statusReg, 1);
0078F4  AA3046     BTG 0x1046, #1
40:                    
41:                    lcdWrite(statusReg);
0078F6  808230     MOV 0x1046, W0
0078F8  07FFE5     RCALL lcdWrite
42:                }
0078FA  060000     RETURN
43:                
44:                void lcdCursorBlink(signed int pwr){
45:                    if(pwr)
0078FC  E00000     CP0 W0
0078FE  320003     BRA Z, 0x7906
46:                        statusReg&=0x09;
007900  200090     MOV #0x9, W0
007902  B63046     AND 0x1046
007904  370001     BRA 0x7908
47:                    else __builtin_btg(&statusReg, 0);
007906  AA1046     BTG 0x1046, #0
48:                    
49:                    lcdWrite(statusReg);
007908  808230     MOV 0x1046, W0
00790A  07FFDC     RCALL lcdWrite
50:                }
00790C  060000     RETURN
---  /home/fbuga/Documents/ps-040/main.c  ---------------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <p33EP512GM310.h>
3:                 #include <dsp.h>
4:                 #include <libpic30.h>
5:                 #include "common.h"
6:                 #include "devInits.h"
7:                 #include "utilities.h"
8:                 //#include "fatfs/src/ff.h"
9:                 
10:                #pragma config ICS = PGD1       //pgeDC 1 is used
11:                #pragma config JTAGEN = OFF     //disable jtag
12:                #pragma config BOREN = OFF      //disable brown out (FYI possible erratta case in 33eMU810)
13:                #pragma config FWDTEN = OFF     //disable watchdog timer 
14:                #pragma config GCP = OFF        //disable general segment code protect
15:                #pragma config PLLKEN = ON      //wait for PLL lock
16:                #pragma config POSCMD = NONE    //no external oscillator
17:                #pragma config OSCIOFNC = ON   //OSC2 is clock output
18:                #pragma config FNOSC = FRCPLL   //clock source
19:                
20:                char pad[8]={0};                                                                //CONTROL VARIABLES//
21:                fractional pots[4]={0};
22:                fractional pots_scaled[4]={0};
23:                fractional output=0;
24:                fractional stream[2][STREAMBUF];
25:                unsigned int bpm=0, write_ptr=0, rw=0;
26:                
27:                unsigned char hard_clipped=FALSE;                                               //STATUS VARIABLES//
28:                volatile unsigned char t1flag=FALSE;
29:                volatile unsigned char t2flag=FALSE;
30:                volatile unsigned char recording=TRUE;
31:                unsigned char UART_ON = FALSE;
32:                unsigned char TEST_SIN = FALSE;
33:                
34:                volatile unsigned char tremelo=FALSE;                                           //FX FLAGS//
35:                volatile unsigned char looper=FALSE;
36:                volatile unsigned char lpf=FALSE;
37:                
38:                void initBuffer(void){
00790E  266720     MOV #0x6672, W0
007910  202001     MOV #0x200, W1
007912  408080     ADD W1, W0, W1
007914  780181     MOV W1, W3
39:                    int i=0;
40:                    for(; i<STREAMBUF; i++){
00791C  500F83     SUB W0, W3, [W15]
00791E  3AFFFC     BRA NZ, 0x7918
41:                        stream[0][i]=0;
007916  EB0100     CLR W2
007918  781802     MOV W2, [W0++]
42:                        stream[1][i]=0;
00791A  781882     MOV W2, [W1++]
43:                    }
44:                }
007920  060000     RETURN
45:                
46:                int main(void) {
007922  781F88     MOV W8, [W15++]
47:                    initPorts();                    //configure io device & adc 
007924  07FC4C     RCALL initPorts
48:                    //initUART1();                    //configure & enable UART
49:                    initBuffer();
007926  07FFF3     RCALL initBuffer
50:                    initADC1();                     //configure & enable internal ADC
007928  07FD64     RCALL initADC1
51:                    //initSPI2_ADC();                  //configure & enable SPI ADC !!!DEFUNCT!!!
52:                    initDCI_DAC();                  //configure & enable DAC
00792A  07FD32     RCALL initDCI_DAC
53:                    initT1();                       //configure & start T1 
00792C  07FD01     RCALL initT1
54:                    initT2();                       //configure & start T2 
00792E  07FD0F     RCALL initT2
55:                    //initSPI3_SEG();                  //start segment display
56:                    initPMP();
007930  07FCED     RCALL initPMP
57:                    //initCAP_BPM();                  //configure bpm capture
58:                    //initT3();                       //configure & start T3
59:                    while(1){   
60:                        if(t2flag==TRUE){
007934  BFD01A     MOV.B t2flag, WREG
007936  404FE1     ADD.B W0, #0x1, [W15]
007938  3A0004     BRA NZ, 0x7942
61:                            scanMatrix();                   //read button matrix
00793A  07FD6E     RCALL scanMatrix
62:                            readPots();                     //read control pots
00793C  07FDC5     RCALL readPots
63:                            t2flag=FALSE;
007932  EB4400     CLR.B W8
00793E  2101A0     MOV #0x101A, W0
007940  784808     MOV.B W8, [W0]
64:                        }
65:                        if(t1flag==TRUE){
007942  BFD019     MOV.B t1flag, WREG
007944  404FE1     ADD.B W0, #0x1, [W15]
007946  3AFFF6     BRA NZ, 0x7934
66:                            display();
007948  07FE3E     RCALL display
67:                            t1flag=FALSE; 
00794A  210190     MOV #0x1019, W0
00794C  784808     MOV.B W8, [W0]
00794E  37FFF2     BRA 0x7934
68:                            
69:                        }
70:                    }
71:                    return 0;
72:                }
73:                // example test 
---  /home/fbuga/Documents/ps-040/devInits.c  -----------------------------------------------------------
1:                 /*
2:                  ** This file contains functions to initialize various peripheral devices
3:                  */
4:                 
5:                 #include <xc.h>
6:                 #include <p33EP512GM310.h>
7:                 #include <libpic30.h>
8:                 #include "common.h"
9:                 #include "devInits.h"
10:                #include "plcd.h"
11:                
12:                extern unsigned char UART_ON;
13:                
14:                //Description: Responsible i/o, clock, & RP pin config setup
15:                //Prereq: NONE
16:                //Dependencies: NONE
17:                //*Note: This is ALWAYS the first function called in main*
18:                void initPorts(void){
19:                    //CLOCK CONFIG
20:                    CLKDIVbits.PLLPOST=0;
0071BE  2FF3F0     MOV #0xFF3F, W0
0071C0  B62744     AND CLKDIV
21:                    CLKDIVbits.PLLPRE=0;
0071C2  2FFE00     MOV #0xFFE0, W0
0071C4  B62744     AND CLKDIV
22:                    PLLFBDbits.PLLDIV = 0x49;       //d_73 for ~140Mhz
0071C6  2FE000     MOV #0xFE00, W0
0071C8  B60746     AND PLLFBD, WREG
0071CA  B30490     IOR #0x49, W0
0071CC  883A30     MOV W0, PLLFBD
23:                    while(OSCCONbits.LOCK!=1) {};   //wait for PLL to lock
0071CE  200201     MOV #0x20, W1
0071D0  803A12     MOV OSCCON, W2
0071D2  608002     AND W1, W2, W0
0071D4  32FFFD     BRA Z, 0x71D0
24:                    //RP pin config
25:                	__builtin_write_OSCCONL(OSCCON & ~(1<<6));      // Unlock Registers
0071D6  803A10     MOV OSCCON, W0
0071D8  A16000     BCLR W0, #6
0071DA  200461     MOV #0x46, W1
0071DC  200572     MOV #0x57, W2
0071DE  207423     MOV #0x742, W3
0071E0  784981     MOV.B W1, [W3]
0071E2  784982     MOV.B W2, [W3]
0071E4  784980     MOV.B W0, [W3]
26:                    //RPINR18bits.U1RXR = 0x37; //U1 rx on RP55
27:                    //RPOR6bits.RP54R=0x1;          //U1 tx on RP54
28:                    RPOR2bits.RP38R = 0x1;
0071E6  2FFC00     MOV #0xFFC0, W0
0071E8  803424     MOV RPOR2, W4
0071EA  600184     AND W0, W4, W3
0071EC  A00003     BSET W3, #0
0071EE  883423     MOV W3, RPOR2
29:                    RPINR24bits.CSDIR=0x3D;     //DCI IN on RPI61           
0071F0  2FF803     MOV #0xFF80, W3
0071F2  803685     MOV RPINR24, W5
0071F4  618205     AND W3, W5, W4
0071F6  B303D4     IOR #0x3D, W4
0071F8  883684     MOV W4, RPINR24
30:                    RPOR3bits.RP40R=0x0C;       //DCI clock
0071FA  B60686     AND RPOR3, WREG
0071FC  B300C0     IOR #0xC, W0
0071FE  883430     MOV W0, RPOR3
31:                    RPOR2bits.RP39R=0x0D;       //DCI frame sync
007200  2C0FF0     MOV #0xC0FF, W0
007202  803424     MOV RPOR2, W4
007204  600284     AND W0, W4, W5
007206  20D004     MOV #0xD00, W4
007208  720205     IOR W4, W5, W4
00720A  883424     MOV W4, RPOR2
32:                    RPOR3bits.RP41R=0x0B;       //DCI output
00720C  803434     MOV RPOR3, W4
00720E  600284     AND W0, W4, W5
007210  20B004     MOV #0xB00, W4
007212  720205     IOR W4, W5, W4
007214  883434     MOV W4, RPOR3
33:                    RPINR7bits.IC1R=0x5F;       //Capture input on pin 95 re15
007216  803575     MOV RPINR7, W5
007218  618185     AND W3, W5, W3
00721A  B305F3     IOR #0x5F, W3
00721C  883573     MOV W3, RPINR7
34:                    RPINR29bits.SCK3R=0x39;      //SCK3 input on pin 84
00721E  280FF4     MOV #0x80FF, W4
007220  8036D3     MOV RPINR29, W3
007222  620203     AND W4, W3, W4
007224  239003     MOV #0x3900, W3
007226  718184     IOR W3, W4, W3
007228  8836D3     MOV W3, RPINR29
35:                    RPOR7bits.RP57R=0x20;        //SCK3 output on pin 84
00722A  803474     MOV RPOR7, W4
00722C  600184     AND W0, W4, W3
00722E  A0D003     BSET W3, #13
007230  883473     MOV W3, RPOR7
36:                    RPOR8bits.RP70R=0x1F;       //SDO3 on pin 83
007232  B60690     AND RPOR8, WREG
007234  21F003     MOV #0x1F00, W3
007236  718180     IOR W3, W0, W3
007238  883483     MOV W3, RPOR8
37:                	__builtin_write_OSCCONL(OSCCON | (1<<6));       // Lock Registers
00723A  803A10     MOV OSCCON, W0
00723C  A06000     BSET W0, #6
00723E  207423     MOV #0x742, W3
007240  784981     MOV.B W1, [W3]
007242  784982     MOV.B W2, [W3]
007244  784980     MOV.B W0, [W3]
38:                    /*PERIPHERAL ENABLE (0) - DISABLE (1)*/
39:                    PMD1=PMD2=PMD3=PMD4=PMD6=PMD7=0xFFFF;
007246  EB8000     SETM W0
007248  883B60     MOV W0, PMD7
00724A  F8076C     PUSH PMD7
00724C  F9076A     POP PMD6
00724E  F8076A     PUSH PMD6
007250  F90766     POP PMD4
007252  F80766     PUSH PMD4
007254  F90764     POP PMD3
007256  F80764     PUSH PMD3
007258  F90762     POP PMD2
00725A  F80762     PUSH PMD2
00725C  F90760     POP PMD1
40:                    PMD1bits.AD1MD=0;
00725E  A90760     BCLR PMD1, #0
41:                    PMD1bits.SPI1MD=0;
007260  A96760     BCLR PMD1, #3
42:                    PMD1bits.SPI2MD=0;
007262  A98760     BCLR PMD1, #4
43:                    PMD1bits.U1MD=0;
007264  A9A760     BCLR PMD1, #5
44:                    PMD1bits.U2MD=0;
007266  A9C760     BCLR PMD1, #6
45:                    PMD1bits.DCIMD=0;
007268  A90761     BCLR 0x761, #0
46:                    PMD1bits.T1MD=0;
00726A  A96761     BCLR 0x761, #3
47:                    PMD1bits.T2MD=0;
00726C  A98761     BCLR 0x761, #4
48:                    PMD1bits.T3MD=0;
00726E  A9A761     BCLR 0x761, #5
49:                    PMD1bits.T4MD=0;
007270  A9C761     BCLR 0x761, #6
50:                    PMD3bits.PMPMD=0;
007272  A90765     BCLR 0x765, #0
51:                    PMD3bits.CMPMD=0;
007274  A94765     BCLR 0x765, #2
52:                    PMD6bits.SPI3MD=0;
007276  A9076A     BCLR PMD6, #0
53:                    PMD7bits.DMA0MD=0;
007278  A9876C     BCLR PMD7, #4
54:                    
55:                    /* ANALOG PINS (1 = analog) */
56:                    ANSELA=ANSELB=ANSELC=ANSELD=ANSELE=ANSELF=ANSELG=0x0000;
00727A  EF2E6E     CLR ANSELG
00727C  F80E6E     PUSH ANSELG
00727E  F90E5E     POP ANSELF
007280  F80E5E     PUSH ANSELF
007282  F90E4E     POP ANSELE
007284  F80E4E     PUSH ANSELE
007286  F90E3E     POP ANSELD
007288  F80E3E     PUSH ANSELD
00728A  F90E2E     POP ANSELC
00728C  F80E2E     PUSH ANSELC
00728E  F90E1E     POP ANSELB
007290  F80E1E     PUSH ANSELB
007292  F90E0E     POP ANSELA
57:                    ANSELBbits.ANSB0 = 1; // Ensure AN0/RB0 is analog
007294  A80E1E     BSET ANSELB, #0
58:                    ANSELBbits.ANSB1 = 1; // Ensure AN1/RB1 is analog
007296  A82E1E     BSET ANSELB, #1
59:                    ANSELBbits.ANSB2 = 1; // Ensure AN2/RB2 is analog
007298  A84E1E     BSET ANSELB, #2
60:                    ANSELBbits.ANSB3 = 1; // Ensure AN5/RB5 is analog
00729A  A86E1E     BSET ANSELB, #3
61:                    
62:                    /* IO DIRECTION (1 = input) */
63:                    TRISA=TRISB=TRISC=TRISD=TRISE=TRISF=TRISG=0x0000;
00729C  EF2E60     CLR TRISG
00729E  F80E60     PUSH TRISG
0072A0  F90E50     POP TRISF
0072A2  F80E50     PUSH TRISF
0072A4  F90E40     POP TRISE
0072A6  F80E40     PUSH TRISE
0072A8  F90E30     POP TRISD
0072AA  F80E30     PUSH TRISD
0072AC  F90E20     POP TRISC
0072AE  F80E20     PUSH TRISC
0072B0  F90E10     POP TRISB
0072B2  F80E10     PUSH TRISB
0072B4  F90E00     POP TRISA
64:                    TRISA=0x0603;
0072B6  206031     MOV #0x603, W1
0072B8  887001     MOV W1, TRISA
65:                    TRISB=0x0003;
0072BA  200031     MOV #0x3, W1
0072BC  887081     MOV W1, TRISB
66:                    TRISC=0x2080;
0072BE  220801     MOV #0x2080, W1
0072C0  887101     MOV W1, TRISC
67:                    TRISE=0x7000;
0072C2  270001     MOV #0x7000, W1
0072C4  887201     MOV W1, TRISE
68:                    TRISG=0xFFFF;   //PORTG all inputs
0072C6  887300     MOV W0, TRISG
69:                    
70:                    /* DIGITAL OUTPUT LATCH */
71:                    LATA=LATB=LATC=LATD=LATE=LATF=LATG=0x0000;
0072C8  EF2E64     CLR LATG
0072CA  F80E64     PUSH LATG
0072CC  F90E54     POP LATF
0072CE  F80E54     PUSH LATF
0072D0  F90E44     POP LATE
0072D2  F80E44     PUSH LATE
0072D4  F90E34     POP LATD
0072D6  F80E34     PUSH LATD
0072D8  F90E24     POP LATC
0072DA  F80E24     PUSH LATC
0072DC  F90E14     POP LATB
0072DE  F80E14     PUSH LATB
0072E0  F90E04     POP LATA
72:                    LATA=0x0040;
0072E2  200401     MOV #0x40, W1
0072E4  887021     MOV W1, LATA
73:                    
74:                    //weak internal pull ups
75:                    CNPUG=0xFFFF;       //weak pull ups on all of G
0072E6  887350     MOV W0, CNPUG
76:                }
0072E8  060000     RETURN
77:                
78:                //Description: Initializes UART1 device & interrupts
79:                //Prereq: NONE
80:                //Dependencies: NONE
81:                void initUART1(void){
82:                    IFS0bits.U1TXIF = 0;        //clear flag
0072EA  A98801     BCLR 0x801, #4
83:                    IFS0bits.U1RXIF = 0;        //clear flag
0072EC  A96801     BCLR 0x801, #3
84:                    U1STA=0x1510;               //enable tx & rx
0072EE  215100     MOV #0x1510, W0
0072F0  881110     MOV W0, U1STA
85:                    U1BRG=BRGVAL;               //baud rate
0072F2  2004A0     MOV #0x4A, W0
0072F4  881140     MOV W0, U1BRG
86:                    U1MODEbits.PDSEL=1;         //8 bit data, even parity
0072F6  2FFF90     MOV #0xFFF9, W0
0072F8  B60220     AND U1MODE, WREG
0072FA  A01000     BSET W0, #1
0072FC  881100     MOV W0, U1MODE
87:                    IPC2bits.U1RXIP = 7;        //interrupt priority 3 (low)
0072FE  270000     MOV #0x7000, W0
007300  B72844     IOR IPC2
88:                    IPC3bits.U1TXIP = 7;        //interrupt priority 3 (low)
007302  200070     MOV #0x7, W0
007304  B72846     IOR IPC3
89:                    //IEC0bits.U1TXIE = 1;        //enable tx interrupt
90:                    //IEC0bits.U1RXIE = 1;        //enable rx interrupt
91:                    U1MODEbits.UARTEN = 1;      //start uart
007306  A8E221     BSET 0x221, #7
92:                    UART_ON = TRUE;
007308  EFF01B     SETM.B UART_ON
93:                    
94:                }
00730A  060000     RETURN
95:                
96:                //Description: Initializes onboard ADC 
97:                //Prereq: NONE
98:                //Dependencies: NONE
99:                void initADC1(void){
100:                   AD1CON1bits.ASAM = 1;       //enable simultaneous sample
0073F2  A84320     BSET AD1CON1, #2
101:                   AD1CON1bits.SIMSAM = 0;     //enable simultaneous sample
0073F4  A96320     BCLR AD1CON1, #3
102:                   AD1CON1bits.FORM=2;         //signed fractional format
0073F6  2FCFF0     MOV #0xFCFF, W0
0073F8  801902     MOV AD1CON1, W2
0073FA  600082     AND W0, W2, W1
0073FC  A09001     BSET W1, #9
0073FE  881901     MOV W1, AD1CON1
103:                   AD1CON2bits.CHPS = 0b01;    //sample channels 0-3
007400  B60322     AND AD1CON2, WREG
007402  A08000     BSET W0, #8
007404  881910     MOV W0, AD1CON2
104:                   AD1CON3bits.ADCS = 0x3F;    //tad ~ 1us
007406  B3C3F0     MOV.B #0x3F, W0
007408  B7E324     MOV.B WREG, AD1CON3
105:                   //AD1CHS0bits.CH0SA = 0x03;   //ch0->an3 (no use an0)
106:                   AD1CHS0bits.CH0NA = 0; // Select Vref- for CH0 -ve input
00740A  A9E328     BCLR AD1CHS0, #7
107:                   AD1CHS123bits.CH123NA = 0; // Select Vref- for CH1/CH2/CH3 -ve input
00740C  2FFF90     MOV #0xFFF9, W0
00740E  B62326     AND AD1CHS123
108:                   AD1CON1bits.ADON = 1;       //start ADC module
007410  A8E321     BSET 0x321, #7
109:                   Delay_us(20);
007412  200140     MOV #0x14, W0
007414  07FFE5     RCALL Delay_us
110:               }
007416  060000     RETURN
111:               
112:               void initPMP(void){
113:                   /*
114:                    Data is clocked on falling edge of E
115:                    *  RS = 44 = PMAO (H = display data, L = display instruction)
116:                    *  E = 72 = CS1 (pulse width 450ns MIN, data triggers from H to L) 
117:                    */
118:                   PMMODEbits.MODE=3;  //master mode 1 
00730C  203000     MOV #0x300, W0
00730E  B72602     IOR PMMODE
119:                   PMCONbits.PTWREN = 1;
007310  A82601     BSET 0x601, #1
120:                   PMCONbits.PTRDEN = 1;
007312  A80601     BSET 0x601, #0
121:                   PMCONbits.WRSP=1;   //write strobe active high
007314  A82600     BSET PMCON, #1
122:                   PMCONbits.RDSP=1;   //read strobe active high
007316  A80600     BSET PMCON, #0
123:                   //PMCONbits.CS1P = 1; //active high CS1
124:                   PMMODEbits.WAITB = 3;
007318  200C00     MOV #0xC0, W0
00731A  B72602     IOR PMMODE
125:                   PMMODEbits.WAITM = 0x08;
00731C  2FFC30     MOV #0xFFC3, W0
00731E  B60602     AND PMMODE, WREG
007320  A05000     BSET W0, #5
007322  883010     MOV W0, PMMODE
126:                   PMMODEbits.WAITE = 3;
007324  200030     MOV #0x3, W0
007326  B72602     IOR PMMODE
127:                   PMAEN=1;
007328  200010     MOV #0x1, W0
00732A  883060     MOV W0, PMAEN
128:                   //PMCONbits.CSF=2;     //pmcs1 & pmcs2 as CS
129:               
130:                   PMCONbits.PMPEN = 1;
00732C  A8E601     BSET 0x601, #7
131:                   
132:                   /* INIT DEVICE */
133:                   /*
134:                   Delay_us(100);
135:                   lcdWrite(0x30);   //function set, 8 bits, 1 line disp, 5x8
136:                   Delay_us(400);    //39 uS required
137:                   lcdWrite(0x30);   //entry mode
138:                   Delay_us(400);     //39 uS required
139:                   lcdWrite(0x30);   //entry mode
140:                   Delay_us(400);     //39 uS required
141:                   lcdClear();  
142:                   Delay_us(1640);     //1.64mS required
143:                   lcdPwr(1);
144:                   Delay_us(400);
145:                   */
146:               }
00732E  060000     RETURN
147:               
148:               
149:               //Description: Initializes timer for LED's UART and display
150:               //Prereq: initUART1()
151:               //Dependencies: _T1Interrupt(void)
152:               //Frequency: 15Hz
153:               void initT1(void){          //16 bit timer
154:                   TMR1 = 0x0000;          //clear timer 4
007330  EF2100     CLR TMR1
155:                   T1CONbits.TCKPS = 3;    //prescale 1:256
007332  200300     MOV #0x30, W0
007334  B72104     IOR T1CON
156:                   T1CONbits.TCS = 0;      //use internal clock
007336  A92104     BCLR T1CON, #1
157:                   T1CONbits.TGATE = 0;    //gate accumulation disabled
007338  A9C104     BCLR T1CON, #6
158:                   PR1 = Fcy/(256*Fdisp);    //period register
00733A  223280     MOV #0x2328, W0
00733C  880810     MOV W0, PR1
159:                   //PR1=0x7FFF;
160:                   IFS0bits.T1IF = 0;      //clear timer 1 interrupt flag
00733E  A96800     BCLR IFS0, #3
161:                   IEC0bits.T1IE = 1;      //enable timer 1 interrupt
007340  A86820     BSET IEC0, #3
162:                   IPC0bits.T1IP = 2;      //interrupt priority 2 (low)
007342  28FFF0     MOV #0x8FFF, W0
007344  B60840     AND IPC0, WREG
007346  A0D000     BSET W0, #13
007348  884200     MOV W0, IPC0
163:                   T1CONbits.TON = 1;      //start timer
00734A  A8E105     BSET 0x105, #7
164:               }
00734C  060000     RETURN
165:               
166:               //Description:  Initializes timer handles polling button input
167:               //Prereq: initADC1() 
168:               //Dependencies: _T2Interrupt(void)
169:               //Frequency: 512Hz
170:               void initT2(void){          //16/32 bit timer
171:                   TMR2 = 0x0000;          //clear timer 4
00734E  EF2106     CLR TMR2
172:                   T2CONbits.T32 = 0;      //16 bit mode
007350  A96110     BCLR T2CON, #3
173:                   T2CONbits.TCKPS = 1;    //prescale 1:8
007352  2FFCF0     MOV #0xFFCF, W0
007354  B60110     AND T2CON, WREG
007356  A04000     BSET W0, #4
007358  880880     MOV W0, T2CON
174:                   T2CONbits.TCS = 0;      //use internal clock
00735A  A92110     BCLR T2CON, #1
175:                   T2CONbits.TGATE = 0;    //gate accumulation disabled
00735C  A9C110     BCLR T2CON, #6
176:                   PR2 = Fcy/(8*Fscan);      //period register about 512hz, PR2 = 0x3938 
00735E  241EB0     MOV #0x41EB, W0
007360  880860     MOV W0, PR2
177:                   IFS0bits.T2IF = 0;      //clear timer 2 interrupt flag
007362  A9E800     BCLR IFS0, #7
178:                   IEC0bits.T2IE = 1;      //enable timer 2 interrupt
007364  A8E820     BSET IEC0, #7
179:                   IPC1bits.T2IP = 2;      //interrupt priority 2 (low)
007366  28FFF0     MOV #0x8FFF, W0
007368  B60842     AND IPC1, WREG
00736A  A0D000     BSET W0, #13
00736C  884210     MOV W0, IPC1
180:                   T2CONbits.TON = 1;      //start timer
00736E  A8E111     BSET 0x111, #7
181:               }
007370  060000     RETURN
182:               
183:               //Description: Initialize timer handling ADC sampling
184:               //Prereq: initSPI_ADC()
185:               //Dependencies: _T3Interrupt(void)
186:               //Frequency: 44.1kHz
187:               //*Note: Currently unused as readDac is chained to DCI interrupt*
188:               void initT3(void){          //16/32 bit timer
189:                   TMR3 = 0x0000;          //clear timer 3
007372  EF210A     CLR TMR3
190:                   T3CONbits.TCKPS = 3;    //prescale 256:1
007374  200300     MOV #0x30, W0
007376  B72112     IOR T3CON
191:                   T3CONbits.TCS = 0;      //use internal clock
007378  A92112     BCLR T3CON, #1
192:                   T3CONbits.TGATE = 0;    //gate accumulation disabled
00737A  A9C112     BCLR T3CON, #6
193:                   PR3 = Fcy/(256*T3freq);           //period register
00737C  200060     MOV #0x6, W0
00737E  880870     MOV W0, PR3
194:                   //PR3 = 0xFFFF;
195:                   IFS0bits.T3IF = 0;      //clear timer 3 interrupt flag
007380  A90801     BCLR 0x801, #0
196:                   IEC0bits.T3IE = 1;      //enable timer 3 interrupt
007382  A80821     BSET 0x821, #0
197:                   IPC2bits.T3IP = 2;      //interrupt priority 3 (low)
007384  2FFF80     MOV #0xFFF8, W0
007386  B60844     AND IPC2, WREG
007388  A01000     BSET W0, #1
00738A  884220     MOV W0, IPC2
198:                   T3CONbits.TON = 1;      //start timer
00738C  A8E113     BSET 0x113, #7
199:               }
00738E  060000     RETURN
200:               
201:               //Description: Initializes & starts 16 bit DCI I2S DAC
202:               //Prereq: initSPI_ADC(void)
203:               //Dependencies: readDAC(void)
204:               void initDCI_DAC(void){
205:                   DCICON1bits.CSCKD=0;
007390  A94281     BCLR 0x281, #2
206:                   DCICON3bits.BCG=(Fcy/(64*Fout)-1);  //calculate baud rate (WILL TRUNCATE)
007392  2F0000     MOV #0xF000, W0
007394  B60284     AND DCICON3, WREG
007396  B30170     IOR #0x17, W0
007398  881420     MOV W0, DCICON3
207:                   DCICON1bits.COFSM=1;    //i2s mode
00739A  2FFFC0     MOV #0xFFFC, W0
00739C  B60280     AND DCICON1, WREG
00739E  A00000     BSET W0, #0
0073A0  881400     MOV W0, DCICON1
208:                   DCICON1bits.CSCKE=1;    //sample on rising edge
0073A2  A82281     BSET 0x281, #1
209:                   DCICON2bits.WS=0xF;     //16 bit data word
0073A4  2000F0     MOV #0xF, W0
0073A6  B72282     IOR DCICON2
210:                   DCICON2bits.COFSG=0;    //data frame has 1 words
0073A8  2FE1F0     MOV #0xFE1F, W0
0073AA  B62282     AND DCICON2
211:                   TSCONbits.TSE0 = 1;     // Transmit on Time Slot 0     
0073AC  A80288     BSET TSCON, #0
212:                   TSCONbits.TSE1 = 1;     // Transmit on Time Slot 1   
0073AE  A82288     BSET TSCON, #1
213:                   RSCONbits.RSE0 = 1;     // rcv on Time Slot 0     
0073B0  A8028C     BSET RSCON, #0
214:                   RSCONbits.RSE1 = 1;     // rcv on Time Slot 1 
0073B2  A8228C     BSET RSCON, #1
215:                   DCICON1bits.DJST=0;     //align data
0073B4  A9A280     BCLR DCICON1, #5
216:                   DCICON2bits.BLEN=1;     //2 words buffer btwn interrupts
0073B6  2F3FF0     MOV #0xF3FF, W0
0073B8  B60282     AND DCICON2, WREG
0073BA  A0A000     BSET W0, #10
0073BC  881410     MOV W0, DCICON2
217:                   IPC15bits.DCIIP = 6;    // Interrput priority
0073BE  2FFF80     MOV #0xFFF8, W0
0073C0  B6085E     AND IPC15, WREG
0073C2  B30060     IOR #0x6, W0
0073C4  8842F0     MOV W0, IPC15
218:                   IFS3bits.DCIIF=0;
0073C6  A98807     BCLR 0x807, #4
219:                   IEC3bits.DCIIE=1; 
0073C8  A88827     BSET 0x827, #4
220:                   TXBUF0=0;
0073CA  EF2298     CLR TXBUF0
221:                   TXBUF1=0;   
0073CC  EF229A     CLR TXBUF1
222:                   DCICON1bits.DCIEN=1;    //ENABLE
0073CE  A8E281     BSET 0x281, #7
223:                   
224:                   
225:                       static int ij=0;
226:                   if (ij<8)
0073D0  808200     MOV ij, W0
0073D2  500FE7     SUB W0, #0x7, [W15]
0073D4  3C0003     BRA GT, 0x73DC
227:                       ij++;
0073D6  E80000     INC W0, W0
0073D8  888200     MOV W0, ij
0073DA  370001     BRA 0x73DE
228:                   else ij=0;
0073DC  EF3040     CLR ij
229:                   //seg_display(ij);
230:               }
0073DE  060000     RETURN
231:               
232:               /*
233:               void initCAP_BPM(void){
234:                   IFS0bits.IC1IF=0;
235:                   IPC0bits.IC1IP=3;
236:                   IC1CON1bits.ICTSEL=0;   //Fp is clock source (7))
237:                   IC1CON1bits.ICM=2;      //capture every falling edge
238:                   IC1CON2bits.ICTRIG=1;
239:                   IC1CON2bits.SYNCSEL=0xD;
240:                   IEC0bits.IC1IE=1;
241:               }
242:               
243:               //Description: Initializes 16 bit SPI ADC 
244:               //Prereq: NONE
245:               //Dependencies: NONE
246:               void initSPI2_ADC(void){
247:                   //ADC_CONV=1;                 //prevent shift as per errata
248:                   PORTBbits.RB10=1;           //prevent shift as per errata
249:                   IFS2bits.SPI2IF = 0;        // Clear the Interrupt flag
250:                   IEC2bits.SPI2IE = 0;        // Disable the interrupt
251:                   SPI2CON1bits.MSTEN=1;       //master mode
252:                   SPI2CON1bits.DISSCK = 0;    //Internal serial clock is enabled
253:                   SPI2CON1bits.MODE16=1;      //16 bit
254:                   SPI2CON1bits.DISSDO=1;      //no SDO 
255:                   SPI2CON1bits.SSEN=0;        //no use SS
256:                   SPI2CON2bits.FRMEN=0;       //no enable framed mode
257:                   SPI2CON2bits.SPIBEN=1;      //enhanced buffer mode
258:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
259:                   SPI2CON1bits.SMP=1;         //data sampled at end of output time
260:                   SPI2CON1bits.CKP=1;         //idle clock is high
261:                   SPI2CON1bits.CKE=1;         //data changes from H to L
262:                   SPI2CON1bits.PPRE=2;        //4:1 primary prescale
263:                   SPI2CON1bits.SPRE=0;        //8:1 secondary
264:                   SPI2STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
265:                   IPC8bits.SPI2IP = 5;        // Interrupt priority
266:                   IFS2bits.SPI2IF = 0;        // Clear the Interrupt flag
267:                   IEC2bits.SPI2IE = 1;        // Enable the interrupt
268:                   SPI2STATbits.SPIEN = 1;     //start SPI module
269:               }
270:               
271:               void initSPI3_SEG(void){
272:                   SEG_SEL = 1;
273:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
274:                   IEC5bits.SPI3IE = 0;        // Disable the interrupt
275:                   SPI3CON1bits.MSTEN=1;       //master mode
276:                   SPI3CON1bits.DISSCK = 0;    //Internal serial clock is enabled
277:                   SPI3CON1bits.MODE16=1;      //16 bit
278:                   SPI3CON1bits.DISSDO=0;      //enable SDO 
279:                   SPI3CON1bits.SSEN=0;        //use SS
280:                   SPI3CON2bits.FRMEN=0;       //no enable framed mode
281:                   SPI3CON2bits.SPIBEN=0;      //enhanced buffer mode
282:                   SPI2STATbits.SISEL=5;       //interrupt when done sending
283:                   SPI3CON1bits.SMP=0;         //data sampled at end of output time
284:                   SPI3CON1bits.CKP=0;         //idle clock is low
285:                   SPI3CON1bits.CKE=1;         //data changes from H to L
286:                   SPI3CON1bits.PPRE=1;        //4:1 primary prescale
287:                   SPI3CON1bits.SPRE=7;        //1:1 secondary
288:                   SPI3STATbits.SPIROV = 0;    // Clear SPI1 receive overflow flag if set
289:                   IPC22bits.SPI3IP = 3;        // Interrupt priority
290:                   IFS5bits.SPI3IF = 0;        // Clear the Interrupt flag
291:                   IEC5bits.SPI3IE = 0;        // Enable the interrupt
292:                   SPI3STATbits.SPIEN = 1;     //start SPI module
293:                   __delay32(40);
294:                   MAX7219_Init();
295:               }
296:               */
297:               
298:               void Delay_us(unsigned int delay)
299:               {
300:                   int i;
301:                   for (i = 0; i < delay; i++)
0073E0  E00000     CP0 W0
0073E2  320006     BRA Z, 0x73F0
0073E4  EB0080     CLR W1
0073EA  E80081     INC W1, W1
0073EC  500F81     SUB W0, W1, [W15]
0073EE  3EFFFB     BRA GTU, 0x73E6
302:                   {
303:                       __asm__ volatile ("repeat #39");
0073E6  090027     REPEAT #0x27
304:                       __asm__ volatile ("nop");
0073E8  000000     NOP
305:                   }
306:               }
0073F0  060000     RETURN
---  /home/fbuga/Documents/ps-040/audio.c  --------------------------------------------------------------
1:                 #include "xc.h"
2:                 #include "common.h"
3:                 #include <dsp.h>
4:                 
5:                 extern char pad[8];                                                             //CONTROL VARIABLES//
6:                 extern fractional pots[4];
7:                 extern fractional pots_scaled[4];
8:                 
9:                 volatile unsigned int loop_ptr = 0;                                             //FX FLAGS & VARS//
10:                unsigned int loop_lim=0;
11:                unsigned int tremelo_ptr=0, tremelo_length=0, trem_var=0;
12:                extern unsigned char hard_clipped, tremelo, looper, lpf;
13:                volatile fractional loop[LOOP_BUF_SIZE]={0};
14:                unsigned int delay_samples=0;
15:                fractional lpf_alpha=Q15(0.5), lpf_inv_alpha=Q15(0.5);
16:                fractional tremelo_depth=Q15(1.0);
17:                
18:                extern fractional sintab[1024];     //misc//
19:                extern unsigned char TEST_SIN;
20:                
21:                extern unsigned char kick_playing;                                              //SAMPLES//
22:                extern unsigned int kick_max, kick_ptr;
23:                extern fractional kick[5552];
24:                //extern unsigned char kick_mode;
25:                /*
26:                extern unsigned char hat_playing;
27:                extern unsigned int hat_max, hat_ptr;
28:                extern fractional hat[5552];
29:                 */
30:                extern unsigned char snare_playing;
31:                extern unsigned int snare_max, snare_ptr;
32:                extern fractional snare[5552];
33:                
34:                fractional mixer(fractional sample){
007602  F80022     PUSH ACCA
007604  F80024     PUSH ACCAH
007606  F80026     PUSH ACCAU
35:                    volatile register int result1 asm("A");
36:                    static int i=0;
37:                    
38:                    if(pad[3]==0&&kick_playing==FALSE){                                         //kick
007608  2666D1     MOV #0x666D, W1
00760A  784091     MOV.B [W1], W1
00760C  E00401     CP0.B W1
00760E  3A0006     BRA NZ, 0x761C
007610  E25032     CP0.B kick_playing
007612  3A0004     BRA NZ, 0x761C
39:                        kick_playing=TRUE;
007614  EBC100     SETM.B W2
007616  210323     MOV #0x1032, W3
007618  784982     MOV.B W2, [W3]
00761A  370004     BRA 0x7624
40:                    }
41:                    if(kick_playing==TRUE&&kick_ptr<kick_max){
00761C  210322     MOV #0x1032, W2
00761E  784112     MOV.B [W2], W2
007620  414FE1     ADD.B W2, #0x1, [W15]
007622  3A0011     BRA NZ, 0x7646
007624  874D23     MOV 0xE9A4, W3
007626  8081A5     MOV kick_ptr, W5
007628  528F83     SUB W5, W3, [W15]
00762A  31000D     BRA C, 0x7646
42:                        result1 =__builtin_mpy(sample,Q15(0.90), NULL, NULL, 0, NULL, NULL, 0);
00762C  780200     MOV W0, W4
00762E  273325     MOV #0x7332, W5
007630  C00113     MPY W4*W5, A
43:                        result1 = __builtin_add(result1,kick[kick_ptr++],0);
007632  8081A0     MOV kick_ptr, W0
007634  400080     ADD W0, W0, W1
007636  292E42     MOV #0x92E4, W2
007638  410081     ADD W2, W1, W1
00763A  780091     MOV [W1], W1
00763C  E80000     INC W0, W0
00763E  8881A0     MOV W0, kick_ptr
007640  C90001     ADD W1, A
44:                        sample=__builtin_sac(result1, 0);
007642  CC0000     SAC A, W0
007644  37000A     BRA 0x765A
45:                    }
46:                    else if (pad[3]==1&&kick_playing==TRUE&&kick_ptr==kick_max){
007646  50CFE1     SUB.B W1, #0x1, [W15]
007648  3A0008     BRA NZ, 0x765A
00764A  414FE1     ADD.B W2, #0x1, [W15]
00764C  3A0006     BRA NZ, 0x765A
00764E  874D21     MOV 0xE9A4, W1
007650  8081A2     MOV kick_ptr, W2
007652  510F81     SUB W2, W1, [W15]
007654  3A0002     BRA NZ, 0x765A
47:                        kick_playing=FALSE;
007656  EF7032     CLR.B kick_playing
48:                        kick_ptr=0;
007658  EF3034     CLR kick_ptr
49:                    }
50:                    
51:                    /*
52:                    if(pad[2]==0&&hat_playing==FALSE){                                          //hat
53:                        hat_playing=TRUE;
54:                    }
55:                    if(hat_playing==TRUE&&hat_ptr<hat_max){
56:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
57:                        result1 = __builtin_add(result1,hat[hat_ptr++],0);
58:                        sample=__builtin_sac(result1, 0);
59:                    }
60:                    else if (pad[2]==1&&hat_playing==TRUE&&hat_ptr==hat_max){
61:                        hat_playing=FALSE;
62:                        hat_ptr=0;
63:                    }
64:                    */
65:                    if(pad[2]==0&&snare_playing==FALSE){                                        //snare
00765A  2666C1     MOV #0x666C, W1
00765C  784091     MOV.B [W1], W1
00765E  E00401     CP0.B W1
007660  3A0006     BRA NZ, 0x766E
007662  E25036     CP0.B snare_playing
007664  3A0004     BRA NZ, 0x766E
66:                        snare_playing=TRUE;
007666  EBC100     SETM.B W2
007668  210363     MOV #0x1036, W3
00766A  784982     MOV.B W2, [W3]
00766C  370004     BRA 0x7676
67:                    }
68:                    if(snare_playing==TRUE&&snare_ptr<snare_max){
00766E  210362     MOV #0x1036, W2
007670  784112     MOV.B [W2], W2
007672  414FE1     ADD.B W2, #0x1, [W15]
007674  3A0011     BRA NZ, 0x7698
007676  874D33     MOV 0xE9A6, W3
007678  8081C5     MOV snare_ptr, W5
00767A  528F83     SUB W5, W3, [W15]
00767C  31000D     BRA C, 0x7698
69:                        result1 =__builtin_mpy(sample,Q15(0.85), NULL, NULL, 0, NULL, NULL, 0);
00767E  780200     MOV W0, W4
007680  26CCC5     MOV #0x6CCC, W5
007682  C00113     MPY W4*W5, A
70:                        result1 = __builtin_add(result1,snare[snare_ptr++],0);
007684  8081C0     MOV snare_ptr, W0
007686  400080     ADD W0, W0, W1
007688  2BE442     MOV #0xBE44, W2
00768A  410081     ADD W2, W1, W1
00768C  780091     MOV [W1], W1
00768E  E80000     INC W0, W0
007690  8881C0     MOV W0, snare_ptr
007692  C90001     ADD W1, A
71:                        sample=__builtin_sac(result1, 0);
007694  CC0000     SAC A, W0
007696  37000A     BRA 0x76AC
72:                    }
73:                    else if (pad[2]==1&&snare_playing==TRUE&&snare_ptr==snare_max){
007698  50CFE1     SUB.B W1, #0x1, [W15]
00769A  3A0008     BRA NZ, 0x76AC
00769C  414FE1     ADD.B W2, #0x1, [W15]
00769E  3A0006     BRA NZ, 0x76AC
0076A0  874D31     MOV 0xE9A6, W1
0076A2  8081C2     MOV snare_ptr, W2
0076A4  510F81     SUB W2, W1, [W15]
0076A6  3A0002     BRA NZ, 0x76AC
74:                        snare_playing=FALSE;
0076A8  EF7036     CLR.B snare_playing
75:                        snare_ptr=0;
0076AA  EF3038     CLR snare_ptr
76:                    }
77:                    
78:                    
79:                    //VOLUME CONTROL
80:                    /*
81:                    if(pots[0]==0x001F)
82:                        sample=0;
83:                    else if(pots[0]>0xFFF0);
84:                    else{
85:                        result1 =__builtin_mpy(sample,pots[0], NULL, NULL, 0, NULL, NULL, 0);
86:                        sample=__builtin_sac(result1, 0);
87:                    }
88:                    */
89:                    if (TEST_SIN==FALSE){
0076AC  E2501C     CP0.B TEST_SIN
0076AE  32000B     BRA Z, 0x76C6
90:                        return sample;
91:                    }
92:                    else {
93:                        i++;
0076B0  EC1030     INC i, WREG
0076B2  888180     MOV W0, i
94:                        if(i==1024)
0076B4  204001     MOV #0x400, W1
0076B6  500F81     SUB W0, W1, [W15]
0076B8  3A0001     BRA NZ, 0x76BC
95:                            i=0;
0076BA  EF3030     CLR i
96:                        return sintab[i];
0076BC  808180     MOV i, W0
0076BE  400000     ADD W0, W0, W0
0076C0  2E9A81     MOV #0xE9A8, W1
0076C2  408000     ADD W1, W0, W0
0076C4  780010     MOV [W0], W0
97:                    }
98:                }
0076C6  F90026     POP ACCAU
0076C8  F90024     POP ACCAH
0076CA  F90022     POP ACCA
0076CC  060000     RETURN
99:                
100:               fractional fx(fractional sample){
0076CE  F80022     PUSH ACCA
0076D0  F80024     PUSH ACCAH
0076D2  F80026     PUSH ACCAU
0076D4  F80028     PUSH ACCB
0076D6  F8002A     PUSH ACCBH
0076D8  F8002C     PUSH ACCBU
101:                   volatile register int result1 asm("A");
102:                   volatile register int result2 asm("B");
103:                   static fractional delayed_sample;
104:                   static fractional trem_mod;
105:                   if(tremelo==TRUE){                                                          //TREMELO//
0076DA  2101D1     MOV #0x101D, W1
0076DC  784091     MOV.B [W1], W1
0076DE  40CFE1     ADD.B W1, #0x1, [W15]
0076E0  3A0027     BRA NZ, 0x7730
106:                       if (trem_var<=pots_scaled[1]){
0076E2  808141     MOV trem_var, W1
0076E4  808052     MOV 0x100A, W2
0076E6  510F81     SUB W2, W1, [W15]
0076E8  39000F     BRA NC, 0x7708
107:                           trem_var++;
0076EA  E80081     INC W1, W1
0076EC  888141     MOV W1, trem_var
108:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr], NULL, NULL, 0, NULL, NULL, 0);
0076EE  808121     MOV tremelo_ptr, W1
0076F0  408081     ADD W1, W1, W1
0076F2  2E9A82     MOV #0xE9A8, W2
0076F4  410081     ADD W2, W1, W1
0076F6  780291     MOV [W1], W5
0076F8  8081F4     MOV 0x103E, W4
0076FA  C00113     MPY W4*W5, A
109:                           trem_mod=__builtin_sac(result1, 0);
0076FC  CC0004     SAC A, W4
0076FE  888164     MOV W4, trem_mod
110:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
007700  780280     MOV W0, W5
007702  C08113     MPY W4*W5, B
111:                           sample=__builtin_sac(result2, 0);
007704  CC8000     SAC B, W0
007706  370014     BRA 0x7730
112:                       }
113:                       else{
114:                           trem_var=0;
007708  EF3028     CLR trem_var
115:                           if(tremelo_ptr==1024)
00770A  204001     MOV #0x400, W1
00770C  808122     MOV tremelo_ptr, W2
00770E  510F81     SUB W2, W1, [W15]
007710  3A0001     BRA NZ, 0x7714
116:                               tremelo_ptr=0;
007712  EF3024     CLR tremelo_ptr
117:                           result1 =__builtin_mpy(tremelo_depth,sintab[tremelo_ptr++], NULL, NULL, 0, NULL, NULL, 0);
007714  808121     MOV tremelo_ptr, W1
007716  408101     ADD W1, W1, W2
007718  2E9A83     MOV #0xE9A8, W3
00771A  418102     ADD W3, W2, W2
00771C  780292     MOV [W2], W5
00771E  E80081     INC W1, W1
007720  888121     MOV W1, tremelo_ptr
007722  8081F4     MOV 0x103E, W4
007724  C00113     MPY W4*W5, A
118:                           trem_mod=__builtin_sac(result1, 0);
007726  CC0004     SAC A, W4
007728  888164     MOV W4, trem_mod
119:                           result2 =__builtin_mpy(trem_mod,sample, NULL, NULL, 0, NULL, NULL, 0);
00772A  780280     MOV W0, W5
00772C  C08113     MPY W4*W5, B
120:                           sample=__builtin_sac(result2, 0);
00772E  CC8000     SAC B, W0
121:                       }
122:                   }
123:                   
124:                   if(looper==TRUE){                                                           //LOOPER// 
007730  2101E1     MOV #0x101E, W1
007732  784091     MOV.B [W1], W1
007734  40CFE1     ADD.B W1, #0x1, [W15]
007736  3A0019     BRA NZ, 0x776A
125:                       if(loop_lim>=LOOP_BUF_SIZE)
007738  22B100     MOV #0x2B10, W0
00773A  E31022     CP loop_lim
00773C  360002     BRA LEU, 0x7742
126:                           loop_lim=LOOP_BUF_SIZE;
00773E  E80000     INC W0, W0
007740  888110     MOV W0, loop_lim
127:                       if(loop_ptr<loop_lim){
007742  808110     MOV loop_lim, W0
007744  E31020     CP loop_ptr
007746  310008     BRA C, 0x7758
128:                           sample = (loop[loop_ptr++]);
007748  808101     MOV loop_ptr, W1
00774A  408001     ADD W1, W1, W0
00774C  210482     MOV #0x1048, W2
00774E  410000     ADD W2, W0, W0
007750  780010     MOV [W0], W0
007752  E80081     INC W1, W1
007754  888101     MOV W1, loop_ptr
007756  37001D     BRA 0x7792
129:                       }
130:                       else {
131:                           loop_ptr=0;
007758  EF3020     CLR loop_ptr
132:                           sample = (loop[loop_ptr++]);
00775A  808101     MOV loop_ptr, W1
00775C  408001     ADD W1, W1, W0
00775E  210482     MOV #0x1048, W2
007760  410000     ADD W2, W0, W0
007762  780010     MOV [W0], W0
007764  E80081     INC W1, W1
007766  888101     MOV W1, loop_ptr
007768  370014     BRA 0x7792
133:                       }
134:                   }                                                                           
135:                   else {                                                                      //buffer
136:                       if(loop_ptr<LOOP_BUF_SIZE)
00776A  22B101     MOV #0x2B10, W1
00776C  808102     MOV loop_ptr, W2
00776E  510F81     SUB W2, W1, [W15]
007770  3E0008     BRA GTU, 0x7782
137:                           loop[loop_ptr++]=sample;
007772  808101     MOV loop_ptr, W1
007774  408101     ADD W1, W1, W2
007776  210483     MOV #0x1048, W3
007778  418102     ADD W3, W2, W2
00777A  780900     MOV W0, [W2]
00777C  E80081     INC W1, W1
00777E  888101     MOV W1, loop_ptr
007780  370008     BRA 0x7792
138:                       else {
139:                           loop_ptr=0;
007782  EF3020     CLR loop_ptr
140:                           loop[loop_ptr++]=sample;
007784  808101     MOV loop_ptr, W1
007786  408101     ADD W1, W1, W2
007788  210483     MOV #0x1048, W3
00778A  418102     ADD W3, W2, W2
00778C  780900     MOV W0, [W2]
00778E  E80081     INC W1, W1
007790  888101     MOV W1, loop_ptr
141:                       }
142:                   }
143:                   
144:                                                                                               //LPF-EMA//   y(i)= ??x(i)+(1-?)?y(i-1)
145:                   if(lpf==TRUE){
007792  2101F1     MOV #0x101F, W1
007794  784091     MOV.B [W1], W1
007796  40CFE1     ADD.B W1, #0x1, [W15]
007798  3A0008     BRA NZ, 0x77AA
146:                       result2 =__builtin_mpy(sample,lpf_alpha, NULL, NULL, 0, NULL, NULL, 0);
00779A  8081D4     MOV 0x103A, W4
00779C  780280     MOV W0, W5
00779E  C08113     MPY W4*W5, B
147:                       result2 =__builtin_mac(result2, delayed_sample, lpf_inv_alpha, NULL, NULL, 0, NULL, NULL, 0, 0, result2);
0077A0  8081E4     MOV 0x103C, W4
0077A2  808175     MOV delayed_sample, W5
0077A4  C08112     MAC W4*W5, B
148:                       delayed_sample=__builtin_sac(result2, 0);
0077A6  CC8000     SAC B, W0
0077A8  888170     MOV W0, delayed_sample
149:                       sample=delayed_sample;
150:                   }
151:                   return sample;
152:               }
0077AA  F9002C     POP ACCBU
0077AC  F9002A     POP ACCBH
0077AE  F90028     POP ACCB
0077B0  F90026     POP ACCAU
0077B2  F90024     POP ACCAH
0077B4  F90022     POP ACCA
0077B6  060000     RETURN
153:               
154:               //test
